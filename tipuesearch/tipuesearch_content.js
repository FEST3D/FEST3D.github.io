var tipuesearch = {"pages":[{"text":"FEST-3D FEST-3D (Finite-volume Explicit STructured 3-Dimensional) is computational fluid dynamic solver written in Fortran 90 for solving the Navier-Stokes equations on structured grids using state-of-the-art finite-volume  methods. It is a modular, multiblock, finite-volume code developed to solve flow problems  in the field of aerodynamics. Installation For installation instructions check out the Documentation guide. Steps to run FEST-3D For detailed documentation on steps to run the FEST-3D after downlaod and installation, check out \" How to run FEST-3D \" page. Tutorials For tutorials check out the test_case descriptions. Note There are two separate GitHub repositories: 1. FEST-3D directory, which contains the source code 2. Run directory, which contains the tutorials The run directory is a submodule of the FEST-3D code. Modules and Subroutines Although most of modules and subroutines are named such that its purpose is clear from its name, still more information is provided in source File and Modules pages. Documentation of FEST-3D uses Ford documentation generator which generates documentation using the special comments written for each subroutine and module. License FEST-3D is an open-source software available under GNU General Public License v3.0 Reference and Citation Details about the governing equations used in the FEST-3D code can be found in the publication by Jatinder Pal Singh Sandhu et al. ( Singh Sandhu, J. P., Girdhar, A., Ramakrishnan, R., Teja, R. D., & Ghosh, S., A convergence study of solutions using two two-equation RANS turbulence models on a finite volume solver for structured grids , AIAA 2018-3859 ). User are requested to cite this reference for any research publications made using the FEST-3D solver. Bug Halt/Stop condition does not work on MPI Can not run turbulent flow simulation on Windows Subsystem for Linux (WSL) due to outdated OS and libraries used by WSL. Todo Add HLLC and Roe flux difference Schemes FEST-3D Team Group of students from the Department of Aerospace Engineering at Indian Institute of Technology Madras (IITM), Chennai (600036), India. Developers Jatinder Pal Singh Sandhu R. D. Teja Rakesh Ramakrishnan Anant Girdhar Advisor Dr. Santanu Ghosh","tags":"home","loc":"index.html","title":" FEST-3D "},{"text":"This module handles the MPI Communication calls for interface boundary conditions This file depends on sourcefile~~interface1.f90~~EfferentGraph sourcefile~interface1.f90 interface1.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~utils.f90 utils.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~interface1.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~interface1.f90~~AfferentGraph sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules interface1 Source Code interface1.f90 Source Code !< This module handles the MPI Communication calls for interface boundary conditions module interface1 !< This module handles the MPI Communication calls for interface boundary conditions use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : n_var use global_vars , only : qp use global_vars , only : imin_id use global_vars , only : jmin_id use global_vars , only : kmin_id use global_vars , only : imax_id use global_vars , only : jmax_id use global_vars , only : kmax_id use global_vars , only : layers use global_vars , only : process_id use global_vars , only : dir_switch use global_vars , only : PbcId use mapping , only : PiDir use mapping , only : PjDir use mapping , only : PkDir use mapping , only : Pilo use mapping , only : Pjlo use mapping , only : Pklo use mapping , only : Pihi use mapping , only : Pjhi use mapping , only : Pkhi use mapping , only : mpi_class use mapping , only : read_interface_map use utils , only : alloc use utils , only : dealloc use utils , only : dmsg #include \"error.inc\" #include \"mpi.inc\" private integer :: ibuf_size !< Size of the buffer for I face interface integer :: jbuf_size !< Size of the buffer for J face interface integer :: kbuf_size !< Size of the buffer for K face interface real , dimension (:), allocatable :: imin_send_buf !< Array to store data to send data for Imin face real , dimension (:), allocatable :: jmin_send_buf !< Array to store data to send data for Jmin face real , dimension (:), allocatable :: kmin_send_buf !< Array to store data to send data for Kmin face real , dimension (:), allocatable :: imin_recv_buf !< Array to store data to receive data for Imin face real , dimension (:), allocatable :: jmin_recv_buf !< Array to store data to receive data for Jmin face real , dimension (:), allocatable :: kmin_recv_buf !< Array to store data to receive data for Kmin face real , dimension (:), allocatable :: imax_send_buf !< Array to store data to send data for Imax face real , dimension (:), allocatable :: jmax_send_buf !< Array to store data to send data for Jmax face real , dimension (:), allocatable :: kmax_send_buf !< Array to store data to send data for Kmax face real , dimension (:), allocatable :: imax_recv_buf !< Array to store data to receive data for Imax face real , dimension (:), allocatable :: jmax_recv_buf !< Array to store data to receive data for Jmax face real , dimension (:), allocatable :: kmax_recv_buf !< Array to store data to receive data for Kmax face public :: setup_interface public :: destroy_interface public :: apply_interface contains subroutine setup_interface () !< Allocate memory for the data communication between processors implicit none character ( len =* ), parameter :: & errmsg = \"module: interface, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * layers jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * layers kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * layers call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) end subroutine setup_interface subroutine destroy_interface () !< Deallocate all the memory being used  for data communication between processors implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) end subroutine destroy_interface subroutine apply_interface () !< MPISEND_RECV call to exchange interface infromation between !< connected blocks. implicit none integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !---------------------------------------------------------- ! call pattern is change for first block = 0 ! to avoid O-Grid infinite loop for mpi communication call !----------------------------------------------------------- if ( mod ( process_id , 2 ) == 0 ) then !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(2)==0)then !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(2)==1)then !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(1)==0)then !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(1)==1)then !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if else !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(1)==0)then !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(1)==1)then !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(2)==0)then !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(2)==1)then !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(3)==0)then !          call MPI_SEND(jmin_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(jmin_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(3)==1)then !          call MPI_RECV(jmin_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(jmin_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(4)==0)then !          call MPI_SEND(jmax_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(jmax_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(4)==1)then !          call MPI_RECV(jmax_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(jmax_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(5)==0)then !          call MPI_SEND(kmin_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(kmin_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(5)==1)then !          call MPI_RECV(kmin_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(kmin_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(6)==0)then !          call MPI_SEND(kmax_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(kmax_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(6)==1)then !          call MPI_RECV(kmax_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(kmax_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc () end subroutine apply_interface subroutine apply_periodic_bc () !<If a block is connected to another block in perodic !<fashion, this subroutine will take care of that boundary condition. implicit none integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc end module interface1","tags":"","loc":"sourcefile/interface1.f90.html","title":"interface1.f90 – FEST-3D"},{"text":"Preconditioned LU-SGS scheme\n  maxtrix-free implicit time-integration method\n  for low speed flows This file depends on sourcefile~~plusgs.f90~~EfferentGraph sourcefile~plusgs.f90 plusgs.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~plusgs.f90->sourcefile~geometry.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~plusgs.f90->sourcefile~mapping.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~plusgs.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~plusgs.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~plusgs.f90~~AfferentGraph sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules plusgs Source Code plusgs.f90 Source Code !< Preconditioned LU-SGS scheme !<  maxtrix-free implicit time-integration method !<  for low speed flows module plusgs !< !< Reference: Kitamura, K., Shima, E., Fujimoto, K. and Wang, Z.J., !< Performance of low-dissipation Euler fluxes and preconditioned LU-SGS !< at low speeds, Communications in Computational Physics, vol. 10 no. 1, pp.90-119, 2011 !----------------------------------------------- use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : sigma_sa use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : R_gas use global_vars , only : gm use global_vars , only : Pr use global_vars , only : tPr use global_vars , only : DCCVnX use global_vars , only : DCCVnY use global_vars , only : DCCVnZ use global_vars , only : CCnormalX use global_vars , only : CCnormalY use global_vars , only : CCnormalZ use global_vars , only : volume use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : n_var use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gm use global_vars , only : sst_n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : dist use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : tk_inf use global_vars , only : tkl_inf use global_vars , only : free_stream_tu use global_vars , only : tk use global_vars , only : tw use global_vars , only : vel_mag use global_vars , only : Minf use global_vars , only : delta_t use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : Reynolds_number use global_vars , only : process_id use global_vars , only : F_p use global_vars , only : G_p use global_vars , only : H_p use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : omega_residue use global_vars , only : kl_residue use global_vars , only : residue use global_vars , only : mu_ref use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use geometry , only : CellCenter use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use utils , only : DEBUG_LEVEL use string !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi !-------mapping --------------! use mapping , only : PiDir use mapping , only : PjDir use mapping , only : PkDir use mapping , only : Pilo use mapping , only : Pjlo use mapping , only : Pklo use mapping , only : Pihi use mapping , only : Pjhi use mapping , only : Pkhi use mapping , only : mpi_class use global_vars , only : imin_id use global_vars , only : jmin_id use global_vars , only : kmin_id use global_vars , only : imax_id use global_vars , only : jmax_id use global_vars , only : kmax_id use global_vars , only : dir_switch use global_vars , only : PbcId #include \"error.inc\" #include \"mpi.inc\" real , dimension (:,:,:,:), allocatable :: delQ !< Change of state variable (solution) over one time-step real , dimension (:,:,:,:), allocatable :: delQstar !< Intermediate change of state variable over one time-step real , dimension (:,:,:), allocatable , target :: dummy !< Dummy variable real , dimension (:,:,:), pointer :: tmu !< Pointer to turbulent viscosity real , dimension (:,:,:), pointer :: mmu !< Pointer to molecular viscosity !parallel communication integer :: ibuf_size !< Size of the buffer for I face interface integer :: jbuf_size !< Size of the buffer for J face interface integer :: kbuf_size !< Size of the buffer for K face interface real , dimension (:), allocatable :: imin_send_buf !< Array to store data to send data for Imin face real , dimension (:), allocatable :: jmin_send_buf !< Array to store data to send data for Jmin face real , dimension (:), allocatable :: kmin_send_buf !< Array to store data to send data for Kmin face real , dimension (:), allocatable :: imin_recv_buf !< Array to store data to receive data for Imin face real , dimension (:), allocatable :: jmin_recv_buf !< Array to store data to receive data for Jmin face real , dimension (:), allocatable :: kmin_recv_buf !< Array to store data to receive data for Kmin face real , dimension (:), allocatable :: imax_send_buf !< Array to store data to send data for Imax face real , dimension (:), allocatable :: jmax_send_buf !< Array to store data to send data for Jmax face real , dimension (:), allocatable :: kmax_send_buf !< Array to store data to send data for Kmax face real , dimension (:), allocatable :: imax_recv_buf !< Array to store data to receive data for Imax face real , dimension (:), allocatable :: jmax_recv_buf !< Array to store data to receive data for Jmax face real , dimension (:), allocatable :: kmax_recv_buf !< Array to store data to receive data for Kmax face public :: update_with_plusgs public :: setup_plusgs public :: destroy_plusgs contains subroutine setup_plusgs () !< Allocate array memory for data communication implicit none character ( len =* ), parameter :: & errmsg = \"module: LUSGS, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * 1 jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * 1 kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * 1 call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_plusgs subroutine destroy_plusgs () !< Unallocate the memory required by LU-SGS module implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) call dealloc ( delQ ) call dealloc ( delQstar ) call dealloc ( dummy ) end subroutine destroy_plusgs subroutine update_with_plusgs () !< Time-integrate with LU_SGS method implicit none select case ( trim ( turbulence )) case ( 'none' ) call update_laminar_variables () case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' , 'bc' ) call update_SST_variables () case ( 'lctm2015' ) call update_lctm2015 () case DEFAULT Fatal_error end select case ( 'kkl' ) !          call update_KKL_variables() case ( 'sa' , 'saBC' ) call update_SA_variables () case Default Fatal_error end select end subroutine update_with_plusgs subroutine update_laminar_variables () !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k real , dimension ( 1 : 5 ) :: deltaU real :: D real , dimension ( 1 : 5 ) :: conservativeQ real , dimension ( 1 : 5 ) :: OldIminusFlux real , dimension ( 1 : 5 ) :: OldJminusFlux real , dimension ( 1 : 5 ) :: OldKminusFlux real , dimension ( 1 : 5 ) :: NewIminusFlux real , dimension ( 1 : 5 ) :: NewJminusFlux real , dimension ( 1 : 5 ) :: NewKminusFlux real , dimension ( 1 : 5 ) :: DelIminusFlux real , dimension ( 1 : 5 ) :: DelJminusFlux real , dimension ( 1 : 5 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 5 ) :: Q0 ! state at cell real , dimension ( 1 : 5 ) :: Q1 ! state at neighbours real , dimension ( 1 : 5 ) :: Q2 real , dimension ( 1 : 5 ) :: Q3 real , dimension ( 1 : 5 ) :: Q4 real , dimension ( 1 : 5 ) :: Q5 real , dimension ( 1 : 5 ) :: Q6 real , dimension ( 1 : 5 ) :: DQ0 ! change in state real , dimension ( 1 : 5 ) :: DQ1 real , dimension ( 1 : 5 ) :: DQ2 real , dimension ( 1 : 5 ) :: DQ3 real , dimension ( 1 : 5 ) :: DQ4 real , dimension ( 1 : 5 ) :: DQ5 real , dimension ( 1 : 5 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , H real :: factor real , dimension ( 1 : 5 , 1 : 5 ) :: PrecondInv !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) !deltaU(1:5) = -residue(i,j,k,1:5) & deltaU ( 1 : 5 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 5 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables function Flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for laminar flow. !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux function SpectralRadius ( ql , qr , inputs , c1 , c2 , eps ) !< Calculated spectral radius implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql real , dimension ( 1 : n_var ), intent ( in ) :: qr real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : 3 ) , intent ( in ) :: c1 real , dimension ( 1 : 3 ) , intent ( in ) :: c2 real , intent ( in ) :: eps ! local variables real :: SpectralRadius real :: NormalSpeed real :: SpeedOfSound real :: vis real :: mu real :: rho real :: distance !extract inputs real :: Area real :: nx real :: ny real :: nz real :: volume real :: mm real :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = 2.0 * gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( 0.5 * (( 1.0 + eps ) * NormalSpeed & + sqrt ((( eps - 1.0 ) ** 2 ) * ( NormalSpeed ** 2 ) & + 4 * eps * ( SpeedOfSound ** 2 ))) + vis ) * Area end function SpectralRadius subroutine update_SST_variables () !< Update the RANS (SST) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , kk , ww , H real :: factor real , dimension ( 1 : 7 , 1 : 7 ) :: PrecondInv ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: De , Dp real :: Fpg real :: dvdy real :: lamd real :: intermittency De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 7 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables function SSTFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SST) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SSTFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux subroutine update_SA_variables () !< Update the RANS (SA) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 6 ) :: deltaU real , dimension ( 1 : 6 ) :: D real , dimension ( 1 : 6 ) :: conservativeQ real , dimension ( 1 : 6 ) :: OldIminusFlux real , dimension ( 1 : 6 ) :: OldJminusFlux real , dimension ( 1 : 6 ) :: OldKminusFlux real , dimension ( 1 : 6 ) :: NewIminusFlux real , dimension ( 1 : 6 ) :: NewJminusFlux real , dimension ( 1 : 6 ) :: NewKminusFlux real , dimension ( 1 : 6 ) :: DelIminusFlux real , dimension ( 1 : 6 ) :: DelJminusFlux real , dimension ( 1 : 6 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 6 ) :: Q0 ! state at cell real , dimension ( 1 : 6 ) :: Q1 ! state at neighbours real , dimension ( 1 : 6 ) :: Q2 real , dimension ( 1 : 6 ) :: Q3 real , dimension ( 1 : 6 ) :: Q4 real , dimension ( 1 : 6 ) :: Q5 real , dimension ( 1 : 6 ) :: Q6 real , dimension ( 1 : 6 ) :: DQ0 ! change in state real , dimension ( 1 : 6 ) :: DQ1 real , dimension ( 1 : 6 ) :: DQ2 real , dimension ( 1 : 6 ) :: DQ3 real , dimension ( 1 : 6 ) :: DQ4 real , dimension ( 1 : 6 ) :: DQ5 real , dimension ( 1 : 6 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , p , H , tv !r real :: factor real , dimension ( 1 : 6 , 1 : 6 ) :: PrecondInv real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: nu_t real :: glim real :: g_6 real :: gamma_BC real :: dfv1 real :: dfv2 real :: dfw real :: dShat real :: dr real :: dg !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! deltaU ( 1 : 6 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 6 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do !call apply_interface(delQstar, 1) delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables function SAFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SA) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SAFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtvdx real :: dtvdy real :: dtvdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux subroutine update_lctm2015 () !< Update the RANS/transition (LCTM2015) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 8 ) :: deltaU real , dimension ( 1 : 8 ) :: D real , dimension ( 1 : 8 ) :: conservativeQ real , dimension ( 1 : 8 ) :: OldIminusFlux real , dimension ( 1 : 8 ) :: OldJminusFlux real , dimension ( 1 : 8 ) :: OldKminusFlux real , dimension ( 1 : 8 ) :: NewIminusFlux real , dimension ( 1 : 8 ) :: NewJminusFlux real , dimension ( 1 : 8 ) :: NewKminusFlux real , dimension ( 1 : 8 ) :: DelIminusFlux real , dimension ( 1 : 8 ) :: DelJminusFlux real , dimension ( 1 : 8 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 8 ) :: Q0 ! state at cell real , dimension ( 1 : 8 ) :: Q1 ! state at neighbours real , dimension ( 1 : 8 ) :: Q2 real , dimension ( 1 : 8 ) :: Q3 real , dimension ( 1 : 8 ) :: Q4 real , dimension ( 1 : 8 ) :: Q5 real , dimension ( 1 : 8 ) :: Q6 real , dimension ( 1 : 8 ) :: DQ0 ! change in state real , dimension ( 1 : 8 ) :: DQ1 real , dimension ( 1 : 8 ) :: DQ2 real , dimension ( 1 : 8 ) :: DQ3 real , dimension ( 1 : 8 ) :: DQ4 real , dimension ( 1 : 8 ) :: DQ5 real , dimension ( 1 : 8 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , kk , ww , H , im real :: factor real , dimension ( 1 : 8 , 1 : 8 ) :: PrecondInv real , dimension ( 1 : 8 , 1 : 8 ) :: Identity ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: Dp , De real :: Fpg real :: dvdy real :: lamd Dp = 0.0 De = 0.0 !Identity matrix Identity = 0.0 do i = 1 , 8 Identity ( i , i ) = 1.0 end do !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 8 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015 function lctm2015flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent/transition flow (LCTM2015) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: lctm2015flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: dtgmdx real :: dtgmdy real :: dtgmdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux subroutine apply_interface ( qp , layers ) !< Apply inter-block interface boundary condition implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( delQstar , 1 ) end subroutine apply_interface subroutine apply_periodic_bc ( qp , layers ) !< Apply periodic boundary condition implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc end module plusgs","tags":"","loc":"sourcefile/plusgs.f90.html","title":"plusgs.f90 – FEST-3D"},{"text":"The viscous module contains the viscous fluxes calculations This file depends on sourcefile~~viscous2.f90~~EfferentGraph sourcefile~viscous2.f90 viscous2.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~global.f90 global.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~viscous2.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~viscous2.f90~~AfferentGraph sourcefile~viscous2.f90 viscous2.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules viscous Source Code viscous2.f90 Source Code !< The viscous module contains the viscous fluxes calculations module viscous !< The viscous module contains the viscous fluxes calculations !----------------------------------------------------------------- #include \"error.inc\" use global , only : FILE_NAME_LENGTH use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : vol => volume use geometry , only : CellCenter use global_vars , only : process_id use global_vars , only : gm use global_vars , only : n_var use global_vars , only : R_gas use global_vars , only : mu_ref use global_vars , only : T_ref use global_vars , only : Pr use global_vars , only : tPr use global_vars , only : Sutherland_temp use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : gradtkl_x use global_vars , only : gradtkl_y use global_vars , only : gradtkl_z use global_vars , only : gradtv_x use global_vars , only : gradtv_y use global_vars , only : gradtv_z use global_vars , only : gradtgm_x use global_vars , only : gradtgm_y use global_vars , only : gradtgm_z use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : kkl_mu use global_vars , only : sst_mu use global_vars , only : turbulence use global_vars , only : transition use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi use global_sa , only : sigma_sa use global_sa , only : cb2 use utils , only : alloc , dealloc , dmsg use string implicit none private public :: compute_viscous_fluxes contains subroutine compute_viscous_fluxes ( F , G , H ) !< Call to all viscous flux subroutine based on !< the drection and turbulence/transition model being !< used implicit none real , dimension (:, :, :, :), pointer :: F , G , H call compute_viscous_fluxes_laminar ( F , 'x' ) call compute_viscous_fluxes_laminar ( G , 'y' ) !if(kmx==2)then !  continue !else call compute_viscous_fluxes_laminar ( H , 'z' ) !end if select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_viscous_fluxes_sa ( F , 'x' ) call compute_viscous_fluxes_sa ( G , 'y' ) call compute_viscous_fluxes_sa ( H , 'z' ) case ( 'sst' , 'sst2003' ) call compute_viscous_fluxes_sst ( F , 'x' ) call compute_viscous_fluxes_sst ( G , 'y' ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_sst ( H , 'z' ) end if case ( 'kkl' ) call compute_viscous_fluxes_kkl ( F , 'x' ) call compute_viscous_fluxes_kkl ( G , 'y' ) !if(kmx==2)then !  continue !else call compute_viscous_fluxes_kkl ( H , 'z' ) !end if case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call compute_viscous_fluxes_lctm2015 ( F , 'x' ) call compute_viscous_fluxes_lctm2015 ( G , 'y' ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_lctm2015 ( H , 'z' ) end if case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end select if ( any ( isnan ( G ))) then Fatal_error end if if ( any ( isnan ( F ))) then Fatal_error end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_viscous_fluxes subroutine compute_viscous_fluxes_laminar ( F , direction ) !< Compute viscous fluxes for first five Navier-Stokes equation implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: dudx , dudy , dudz real :: dvdx , dvdy , dvdz real :: dwdx , dwdy , dwdz real :: dTdx , dTdy , dTdz real :: normal_comp real :: d_LR real :: T_RE real :: T_LE real :: K_heat , Qx , Qy , Qz real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: delu real :: delv real :: delw real :: delT real :: Tau_xx real :: Tau_xy real :: Tau_xz real :: Tau_yx real :: Tau_yy real :: Tau_yz real :: Tau_zx real :: Tau_zy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real :: uface real :: vface real :: wface real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dudx = 0.5 * ( gradu_x ( i - ii , j - jj , k - kk ) + gradu_x ( i , j , k )) dudy = 0.5 * ( gradu_y ( i - ii , j - jj , k - kk ) + gradu_y ( i , j , k )) dudz = 0.5 * ( gradu_z ( i - ii , j - jj , k - kk ) + gradu_z ( i , j , k )) dvdx = 0.5 * ( gradv_x ( i - ii , j - jj , k - kk ) + gradv_x ( i , j , k )) dvdy = 0.5 * ( gradv_y ( i - ii , j - jj , k - kk ) + gradv_y ( i , j , k )) dvdz = 0.5 * ( gradv_z ( i - ii , j - jj , k - kk ) + gradv_z ( i , j , k )) dwdx = 0.5 * ( gradw_x ( i - ii , j - jj , k - kk ) + gradw_x ( i , j , k )) dwdy = 0.5 * ( gradw_y ( i - ii , j - jj , k - kk ) + gradw_y ( i , j , k )) dwdz = 0.5 * ( gradw_z ( i - ii , j - jj , k - kk ) + gradw_z ( i , j , k )) dTdx = 0.5 * ( gradT_x ( i - ii , j - jj , k - kk ) + gradT_x ( i , j , k )) dTdy = 0.5 * ( gradT_y ( i - ii , j - jj , k - kk ) + gradT_y ( i , j , k )) dTdz = 0.5 * ( gradT_z ( i - ii , j - jj , k - kk ) + gradT_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! Finding the temperature of left and right element to the face i,j,k T_LE = pressure ( i - ii , j - jj , k - kk ) / ( density ( i - ii , j - jj , k - kk ) * R_gas ) T_RE = pressure ( i , j , k ) / ( density ( i , j , k ) * R_gas ) ! difference in state across face delu = x_speed ( i , j , k ) - x_speed ( i - ii , j - jj , k - kk ) delv = y_speed ( i , j , k ) - y_speed ( i - ii , j - jj , k - kk ) delw = z_speed ( i , j , k ) - z_speed ( i - ii , j - jj , k - kk ) delT = T_RE - T_LE !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( delu - ( dudx * delx + dudy * dely + dudz * delz )) / d_LR dudx = dudx + ( normal_comp * delx / d_LR ) dudy = dudy + ( normal_comp * dely / d_LR ) dudz = dudz + ( normal_comp * delz / d_LR ) normal_comp = ( delv - ( dvdx * delx + dvdy * dely + dvdz * delz )) / d_LR dvdx = dvdx + ( normal_comp * delx / d_LR ) dvdy = dvdy + ( normal_comp * dely / d_LR ) dvdz = dvdz + ( normal_comp * delz / d_LR ) normal_comp = ( delw - ( dwdx * delx + dwdy * dely + dwdz * delz )) / d_LR dwdx = dwdx + ( normal_comp * delx / d_LR ) dwdy = dwdy + ( normal_comp * dely / d_LR ) dwdz = dwdz + ( normal_comp * delz / d_LR ) normal_comp = ( delT - ( dTdx * delx + dTdy * dely + dTdz * delz )) / d_LR dTdx = dTdx + ( normal_comp * delx / d_LR ) dTdy = dTdy + ( normal_comp * dely / d_LR ) dTdz = dTdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) if ( trim ( turbulence ) /= 'none' ) then mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) else mut_f = 0.0 end if ! effective viscosity total_mu = mu_f + mut_f ! Using lambda = -2 * mu / 3 ! diagonal terms of stress tensor Tau_xx = 2. * total_mu * ( dudx - (( dudx + dvdy + dwdz ) / 3. )) Tau_yy = 2. * total_mu * ( dvdy - (( dudx + dvdy + dwdz ) / 3. )) Tau_zz = 2. * total_mu * ( dwdz - (( dudx + dvdy + dwdz ) / 3. )) ! off diagonal symmetrical part of stress tensor Tau_xy = total_mu * ( dvdx + dudy ) Tau_xz = total_mu * ( dwdx + dudz ) Tau_yz = total_mu * ( dwdy + dvdz ) Tau_yx = Tau_xy Tau_zx = Tau_xz Tau_zy = Tau_yz ! Pr: Prandtl Number and tPr: Turbulent Prandtl number ! Qx, Qy, Qz: Conduction fluxes K_heat = ( mu_f / Pr + mut_f / tPr ) * gm * R_gas / ( gm - 1 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) uface = 0.5 * ( x_speed ( i - ii , j - jj , k - kk ) + x_speed ( i , j , k )) vface = 0.5 * ( y_speed ( i - ii , j - jj , k - kk ) + y_speed ( i , j , k )) wface = 0.5 * ( z_speed ( i - ii , j - jj , k - kk ) + z_speed ( i , j , k )) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - (( Tau_xx * nx + Tau_xy * ny + Tau_xz * nz ) * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - (( Tau_yx * nx + Tau_yy * ny + Tau_yz * nz ) * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - (( Tau_zx * nx + Tau_zy * ny + Tau_zz * nz ) * area ) ! Energy flux ! (TijVj + Qi)ni F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * ( & (( Tau_xx * uface + Tau_xy * vface + Tau_xz * wface + Qx ) * nx ) + & (( Tau_yx * uface + Tau_yy * vface + Tau_yz * wface + Qy ) * ny ) + & (( Tau_zx * uface + Tau_zy * vface + Tau_zz * wface + Qz ) * nz ) ) ) end do end do end do end subroutine compute_viscous_fluxes_laminar subroutine compute_viscous_fluxes_sst ( F , direction ) !< Compute viscous fluxes for additianal equations due to SST turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< flux array ! local variables real :: tkface real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: deltk real :: deltw real :: Tau_xx real :: Tau_yy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sst variable requirement ---! real :: dtkdx , dtkdy , dtkdz , dtwdx , dtwdy , dtwdz real :: F1 real :: sigma_kf real :: sigma_wf !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtwdx = 0.5 * ( gradtw_x ( i - ii , j - jj , k - kk ) + gradtw_x ( i , j , k )) dtwdy = 0.5 * ( gradtw_y ( i - ii , j - jj , k - kk ) + gradtw_y ( i , j , k )) dtwdz = 0.5 * ( gradtw_z ( i - ii , j - jj , k - kk ) + gradtw_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = tk ( i , j , k ) - tk ( i - ii , j - jj , k - kk ) deltw = tw ( i , j , k ) - tw ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltw - ( dtwdx * delx + dtwdy * dely + dtwdz * delz )) / d_LR dtwdx = dtwdx + ( normal_comp * delx / d_LR ) dtwdy = dtwdy + ( normal_comp * dely / d_LR ) dtwdz = dtwdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( sst_mu ( i - ii , j - jj , k - kk ) + sst_mu ( i , j , k )) F1 = 0.5 * ( sst_F1 ( i - ii , j - jj , k - kk ) + sst_F1 ( i , j , k )) sigma_kf = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_wf = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) total_mu = mu_f + mut_f rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) tkface = 0.5 * ( tk ( i - ii , j - jj , k - kk ) + tk ( i , j , k )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_wf * mut_f ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_sst subroutine compute_viscous_fluxes_kkl ( F , direction ) !< Compute viscous fluxes for additianal equations due to k-kL turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: tkface real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: deltk real :: deltkl real :: Tau_xx real :: Tau_yy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- kkl variable requirement  ---! real :: dtkdx , dtkdy , dtkdz real :: dtkldx , dtkldy , dtkldz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtkldx = 0.5 * ( gradtkl_x ( i - ii , j - jj , k - kk ) + gradtkl_x ( i , j , k )) dtkldy = 0.5 * ( gradtkl_y ( i - ii , j - jj , k - kk ) + gradtkl_y ( i , j , k )) dtkldz = 0.5 * ( gradtkl_z ( i - ii , j - jj , k - kk ) + gradtkl_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = tk ( i , j , k ) - tk ( i - ii , j - jj , k - kk ) deltkl = tkl ( i , j , k ) - tkl ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltkl - ( dtkldx * delx + dtkldy * dely + dtkldz * delz )) / d_LR dtkldx = dtkldx + ( normal_comp * delx / d_LR ) dtkldy = dtkldy + ( normal_comp * dely / d_LR ) dtkldz = dtkldz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( kkl_mu ( i - ii , j - jj , k - kk ) + kkl_mu ( i , j , k )) total_mu = mu_f + mut_f rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) tkface = 0.5 * ( tk ( i - ii , j - jj , k - kk ) + tk ( i , j , k )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_phi * mut_f ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_kkl subroutine compute_viscous_fluxes_sa ( F , direction ) !< Compute viscous fluxes for additianal equations due to SA turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: delx real :: dely real :: delz real :: deltv real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real :: dtvdx , dtvdy , dtvdz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtvdx = 0.5 * ( gradtv_x ( i - ii , j - jj , k - kk ) + gradtv_x ( i , j , k )) dtvdy = 0.5 * ( gradtv_y ( i - ii , j - jj , k - kk ) + gradtv_y ( i , j , k )) dtvdz = 0.5 * ( gradtv_z ( i - ii , j - jj , k - kk ) + gradtv_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltv = tv ( i , j , k ) - tv ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltv - ( dtvdx * delx + dtvdy * dely + dtvdz * delz )) / d_LR dtvdx = dtvdx + ( normal_comp * delx / d_LR ) dtvdy = dtvdy + ( normal_comp * dely / d_LR ) dtvdz = dtvdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( tv ( i - ii , j - jj , k - kk ) + tv ( i , j , k )) * rhoface ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + mut_f ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ))) / sigma_sa end do end do end do end subroutine compute_viscous_fluxes_sa subroutine compute_viscous_fluxes_lctm2015 ( F , direction ) !< Compute viscous fluxes for additianal equations due to LCTM2015 transition model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: delx real :: dely real :: delz real :: deltgm real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real :: dtgmdx , dtgmdy , dtgmdz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtgmdx = 0.5 * ( gradtgm_x ( i - ii , j - jj , k - kk ) + gradtgm_x ( i , j , k )) dtgmdy = 0.5 * ( gradtgm_y ( i - ii , j - jj , k - kk ) + gradtgm_y ( i , j , k )) dtgmdz = 0.5 * ( gradtgm_z ( i - ii , j - jj , k - kk ) + gradtgm_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltgm = tgm ( i , j , k ) - tgm ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltgm - ( dtgmdx * delx + dtgmdy * dely + dtgmdz * delz )) / d_LR dtgmdx = dtgmdx + ( normal_comp * delx / d_LR ) dtgmdy = dtgmdy + ( normal_comp * dely / d_LR ) dtgmdz = dtgmdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , n_var ) = F ( i , j , k , n_var ) - ( area * (( mu_f + mut_f ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_lctm2015 end module viscous","tags":"","loc":"sourcefile/viscous2.f90.html","title":"viscous2.f90 – FEST-3D"},{"text":"Calculate the time step for the current iteration This file depends on sourcefile~~time.f90~~EfferentGraph sourcefile~time.f90 time.f90 sourcefile~string.f90 string.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~read.f90 read.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~time.f90~~AfferentGraph sourcefile~time.f90 time.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules time Source Code time.f90 Source Code !< Calculate the time step for the current iteration module time !< Calculate the time step for the current iteration use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : volume use global_vars , only : n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : gm use global_vars , only : Pr use global_vars , only : tPr use global_vars , only : R_gas use global_vars , only : mu_ref use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : CFL use global_vars , only : total_process use global_vars , only : process_id use global_vars , only : time_stepping_method use global_vars , only : time_step_accuracy use global_vars , only : global_time_step use global_vars , only : delta_t use global_vars , only : sim_clock use global_vars , only : turbulence use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use utils , only : DEBUG_LEVEL use face_interpolant , only : interpolant , & x_qp_left , x_qp_right , & y_qp_left , y_qp_right , & z_qp_left , z_qp_right , compute_face_interpolant , & extrapolate_cell_averages_to_faces use string use read , only : read_input_and_controls use geometry , only : CellCenter #include \"mpi.inc\" private INTEGER :: & nb_ticks_initial , & !< Initial value of the clock tick counter nb_ticks_final , & !< Final value of the clock tick counter nb_ticks_max , & !< Maximum value of the clock counter nb_ticks_sec , & !< Number of clock ticks per second nb_ticks !< Number of clock ticks of the code REAL :: elapsed_time !< Real time in seconds REAL :: t1 !< Start clock time REAL :: t2 !< Finish clock time real :: cpu_time_elapsed ! Public methods public :: setup_time public :: destroy_time public :: compute_time_step public :: update_simulation_clock contains subroutine setup_time () !< Allocate memeroy and setup initial clock implicit none call dmsg ( 1 , 'time' , 'initmisc' ) call alloc ( delta_t , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , & errmsg = 'Error: Unable to allocate memory for delta_t.' ) CALL SYSTEM_CLOCK ( COUNT_RATE = nb_ticks_sec , COUNT_MAX = nb_ticks_max ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_initial ) CALL CPU_TIME ( t1 ) end subroutine setup_time subroutine destroy_time () !< Deallocate memory and find simulation time. implicit none real , dimension (:), allocatable :: total_time integer :: ierr call dmsg ( 1 , 'solver' , 'deallocate_misc' ) !simlulation clock data if ( process_id == 0 ) write ( * , '(A)' ) '>> TIME <<' if ( process_id == 0 ) write ( * , '(A)' ) \"Simulation Clock : \" // trim ( write_time ( sim_clock )) call alloc ( total_time , 1 , total_process ) CALL CPU_TIME ( t2 ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_final ) call dealloc ( delta_t ) nb_ticks = nb_ticks_final - nb_ticks_initial IF ( nb_ticks_final < nb_ticks_initial ) & nb_ticks = nb_ticks + nb_ticks_max elapsed_time = REAL ( nb_ticks ) / nb_ticks_sec cpu_time_elapsed = t2 - t1 write ( * , '(A,I0,A)' ) 'process: ' , process_id ,& \" > SYSTEM clock <: \" // trim ( write_time ( elapsed_time )) // & \" /-\\ CPU time <: \" // trim ( write_time ( cpu_time_elapsed )) !total time including all blocks call MPI_GATHER ( elapsed_time , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( process_id == 0 ) print * , \"Total SYSTEM clock: \" , trim ( write_time ( sum ( total_time ))) call MPI_GATHER ( cpu_time_elapsed , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( process_id == 0 ) print * , \"Total CPU time    : \" , trim ( write_time ( sum ( total_time ))) call dealloc ( total_time ) end subroutine destroy_time function write_time ( time_in_seconds ) result ( string ) !< Particular format to write time in output log file implicit none real , intent ( in ) :: time_in_seconds !< Time to output character ( len = 64 ) :: string !< Time as string in particlar format if ( time_in_seconds > 86400 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 8640 0. , \"days\" elseif ( time_in_seconds > 3600 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 360 0. , \"Hr.\" elseif ( time_in_seconds > 60 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 6 0. , \"Min.\" elseif ( time_in_seconds > 0 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds , \"Sec.\" else write ( string , '(A)' ) \"Not Valid\" end if end function write_time subroutine compute_local_time_step () !< Compute the time step to be used at each cell center !< !< Local time stepping can be used to get the solution !< advance towards steady state faster. If only the steady !< state solution is required, i.e., transients are !< irrelevant, use local time stepping. !----------------------------------------------------------- implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum real :: x_sound_speed_avg , y_sound_speed_avg , z_sound_speed_avg integer :: i , j , k call dmsg ( 1 , 'solver' , 'compute_local_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! For orientation, refer to the report. The standard i,j,k ! direction are marked. All orientation notations are w.r.t ! to the perspective shown in the image. ! Faces with lower index x_sound_speed_avg = 0.5 * ( sqrt ( gm * x_qp_left ( i , j , k , 5 ) / & x_qp_left ( i , j , k , 1 )) + & sqrt ( gm * x_qp_right ( i , j , k , 5 ) / & x_qp_right ( i , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( gm * y_qp_left ( i , j , k , 5 ) / & y_qp_left ( i , j , k , 1 )) + & sqrt ( gm * y_qp_right ( i , j , k , 5 ) / & y_qp_right ( i , j , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( gm * z_qp_left ( i , j , k , 5 ) / & z_qp_left ( i , j , k , 1 )) + & sqrt ( gm * z_qp_right ( i , j , k , 5 ) / & z_qp_right ( i , j , k , 1 )) ) ! For left face: i.e., lower index face along xi direction lmx1 = abs ( & ( x_speed ( i , j , k ) * xnx ( i , j , k )) + & ( y_speed ( i , j , k ) * xny ( i , j , k )) + & ( z_speed ( i , j , k ) * xnz ( i , j , k ))) + & x_sound_speed_avg ! For front face, i.e., lower index face along eta direction lmx2 = abs ( & ( x_speed ( i , j , k ) * ynx ( i , j , k )) + & ( y_speed ( i , j , k ) * yny ( i , j , k )) + & ( z_speed ( i , j , k ) * ynz ( i , j , k ))) + & y_sound_speed_avg ! For bottom face, i.e., lower index face along zeta direction lmx3 = abs ( & ( x_speed ( i , j , k ) * znx ( i , j , k )) + & ( y_speed ( i , j , k ) * zny ( i , j , k )) + & ( z_speed ( i , j , k ) * znz ( i , j , k ))) + & z_sound_speed_avg ! Faces with higher index x_sound_speed_avg = 0.5 * ( sqrt ( gm * x_qp_left ( i + 1 , j , k , 5 ) / x_qp_left ( i + 1 , j , k , 1 )) + & sqrt ( gm * x_qp_right ( i + 1 , j , k , 5 ) / x_qp_right ( i + 1 , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( gm * y_qp_left ( i , j + 1 , k , 5 ) / y_qp_left ( i , j + 1 , k , 1 )) + & sqrt ( gm * y_qp_right ( i , j + 1 , k , 5 ) / y_qp_right ( i , j + 1 , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( gm * z_qp_left ( i , j , k + 1 , 5 ) / z_qp_left ( i , j , k + 1 , 1 )) + & sqrt ( gm * z_qp_right ( i , j , k + 1 , 5 ) / z_qp_right ( i , j , k + 1 , 1 )) ) ! For right face, i.e., higher index face along xi direction lmx4 = abs ( & ( x_speed ( i + 1 , j , k ) * xnx ( i + 1 , j , k )) + & ( y_speed ( i + 1 , j , k ) * xny ( i + 1 , j , k )) + & ( z_speed ( i + 1 , j , k ) * xnz ( i + 1 , j , k ))) + & x_sound_speed_avg ! For back face, i.e., higher index face along eta direction lmx5 = abs ( & ( x_speed ( i , j + 1 , k ) * ynx ( i , j + 1 , k )) + & ( y_speed ( i , j + 1 , k ) * yny ( i , j + 1 , k )) + & ( z_speed ( i , j + 1 , k ) * ynz ( i , j + 1 , k ))) + & y_sound_speed_avg ! For top face, i.e., higher index face along zeta direction lmx6 = abs ( & ( x_speed ( i , j , k + 1 ) * znx ( i , j , k + 1 )) + & ( y_speed ( i , j , k + 1 ) * zny ( i , j , k + 1 )) + & ( z_speed ( i , j , k + 1 ) * znz ( i , j , k + 1 ))) + & z_sound_speed_avg lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) delta_t ( i , j , k ) = 1. / lmxsum delta_t ( i , j , k ) = delta_t ( i , j , k ) * volume ( i , j , k ) * CFL end do end do end do if ( mu_ref /= 0.0 ) then call add_viscous_time () end if if ( mu_ref /= 0 . and . trim ( turbulence ) /= 'none' ) then call add_turbulent_time () end if end subroutine compute_local_time_step subroutine compute_global_time_step () !< Compute a common time step to be used at all cell centers !< !< Global time stepping is generally used to get time !< accurate solutions; transients can be studied by !< employing this strategy. !<----------------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'compute_global_time_step' ) if ( global_time_step > 0 ) then delta_t = global_time_step else call compute_local_time_step () ! The global time step is the minimum of all the local time ! steps. delta_t = minval ( delta_t ) end if end subroutine compute_global_time_step subroutine compute_time_step () !< Compute the time step to be used !< !< This calls either compute_global_time_step() or !< compute_local_time_step() based on what !< time_stepping_method is set to. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'compute_time_step' ) if ( time_stepping_method . eq . 'g' ) then call compute_global_time_step () else if ( time_stepping_method . eq . 'l' ) then call compute_local_time_step () else call dmsg ( 5 , 'solver' , 'compute_time_step' , & msg = 'Value for time_stepping_method (' // & time_stepping_method // ') not recognized.' ) stop end if !update_simulation clock call update_simulation_clock () end subroutine compute_time_step subroutine update_simulation_clock !<  Update the simulation clock !< !<  It is sometimes useful to know what the simulation time is !<  at every iteration so that a comparison with an analytical !<  solution is possible. Since, the global timesteps used may !<  not be uniform, we need to track this explicitly. !< !<  Of course, it makes sense to track this only if the time !<  stepping is global and not local. If the time stepping is !<  local, the simulation clock is set to -1. If it is global !<  it is incremented according to the time step found. !----------------------------------------------------------- implicit none if ( time_stepping_method . eq . 'g' . and . sim_clock >= 0. ) then sim_clock = sim_clock + minval ( delta_t ) else if ( time_stepping_method . eq . 'l' ) then sim_clock = - 1 end if end subroutine update_simulation_clock subroutine add_viscous_time () !< Addition to local time step due to viscous effects implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k call dmsg ( 1 , 'time' , 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i - 1 , j , k , 1 ) - CellCenter ( i , j , k , 1 )) * xnx ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 2 ) - CellCenter ( i , j , k , 2 )) * xny ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 3 ) - CellCenter ( i , j , k , 3 )) * xnz ( i , j , k )))) ! For front face, i.e., lower index face along eta direction lmx2 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j - 1 , k , 1 ) - CellCenter ( i , j , k , 1 )) * ynx ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 2 ) - CellCenter ( i , j , k , 2 )) * yny ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 3 ) - CellCenter ( i , j , k , 3 )) * ynz ( i , j , k )))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j , k - 1 , 1 ) - CellCenter ( i , j , k , 1 )) * znx ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 2 ) - CellCenter ( i , j , k , 2 )) * zny ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 3 ) - CellCenter ( i , j , k , 3 )) * znz ( i , j , k )))) ! For right face, i.e., higher index face along xi direction lmx4 = mu ( i + 1 , j , k ) / ( density ( i + 1 , j , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i + 1 , j , k , 1 )) * xnx ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i + 1 , j , k , 2 )) * xny ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i + 1 , j , k , 3 )) * xnz ( i + 1 , j , k )))) ! For back face, i.e., higher index face along eta direction lmx5 = mu ( i , j + 1 , k ) / ( density ( i , j + 1 , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j + 1 , k , 1 )) * ynx ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j + 1 , k , 2 )) * yny ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j + 1 , k , 3 )) * ynz ( i , j + 1 , k )))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu ( i , j , k + 1 ) / ( density ( i , j , k + 1 ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j , k + 1 , 1 )) * znx ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j , k + 1 , 2 )) * zny ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j , k + 1 , 3 )) * znz ( i , j , k + 1 )))) lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) lmxsum = gm * lmxsum / Pr lmxsum = 2. / ( lmxsum + ( 2. * CFL * volume ( i , j , k ) / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * volume ( i , j , k )) end do end do end do end subroutine add_viscous_time subroutine add_turbulent_time () !< Addition to local time step due to turbulence implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k call dmsg ( 1 , 'time' , 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i - 1 , j , k , 1 ) - CellCenter ( i , j , k , 1 )) * xnx ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 2 ) - CellCenter ( i , j , k , 2 )) * xny ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 3 ) - CellCenter ( i , j , k , 3 )) * xnz ( i , j , k )))) ! For front face, i.e., lower index face along eta direction lmx2 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j - 1 , k , 1 ) - CellCenter ( i , j , k , 1 )) * ynx ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 2 ) - CellCenter ( i , j , k , 2 )) * yny ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 3 ) - CellCenter ( i , j , k , 3 )) * ynz ( i , j , k )))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j , k - 1 , 1 ) - CellCenter ( i , j , k , 1 )) * znx ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 2 ) - CellCenter ( i , j , k , 2 )) * zny ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 3 ) - CellCenter ( i , j , k , 3 )) * znz ( i , j , k )))) ! For right face, i.e., higher index face along xi direction lmx4 = mu_t ( i + 1 , j , k ) / ( density ( i + 1 , j , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i + 1 , j , k , 1 )) * xnx ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i + 1 , j , k , 2 )) * xny ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i + 1 , j , k , 3 )) * xnz ( i + 1 , j , k )))) ! For back face, i.e., higher index face along eta direction lmx5 = mu_t ( i , j + 1 , k ) / ( density ( i , j + 1 , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j + 1 , k , 1 )) * ynx ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j + 1 , k , 2 )) * yny ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j + 1 , k , 3 )) * ynz ( i , j + 1 , k )))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu_t ( i , j , k + 1 ) / ( density ( i , j , k + 1 ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j , k + 1 , 1 )) * znx ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j , k + 1 , 2 )) * zny ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j , k + 1 , 3 )) * znz ( i , j , k + 1 )))) lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) lmxsum = gm * lmxsum / tPr lmxsum = 2. / ( lmxsum + ( 2. * CFL * volume ( i , j , k ) / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * volume ( i , j , k )) end do end do end do end subroutine add_turbulent_time end module time","tags":"","loc":"sourcefile/time.f90.html","title":"time.f90 – FEST-3D"},{"text":"Calculate Cell-center and normal through them for transition model This file depends on sourcefile~~cc.f90~~EfferentGraph sourcefile~cc.f90 CC.f90 sourcefile~utils.f90 utils.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~cc.f90~~AfferentGraph sourcefile~cc.f90 CC.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules CC Source Code CC.f90 Source Code !< Calculate Cell-center and normal through them for transition model module CC !< In order to calculate pressure gradient in the transition model, two !< quantities are required: the distance of the cell-center from the wall !< andn the normal made by the distance vector field (from wall to cell-center). !< This module calucate both with gradient of V.n also. #include \"debug.h\" #include \"error.h\" use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : process_id use global_vars , only : xn use global_vars , only : yn use global_vars , only : zn use global_vars , only : xA use global_vars , only : yA use global_vars , only : zA use global_vars , only : volume use global_vars , only : CCnormalX use global_vars , only : CCnormalY use global_vars , only : CCnormalZ use global_vars , only : CCVn use global_vars , only : DCCVnX use global_vars , only : DCCVnY use global_vars , only : DCCVnZ use global_vars , only : dist use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : transition use global_vars , only : turbulence use utils , only : alloc use utils , only : dealloc implicit none private public :: find_DCCVn public :: setupCC public :: destroyCC contains subroutine setupCC () !< Allocate memory for the cell center variable only in case of transition model implicit none DebugCall ( \"Setup CC\" ) if (( transition == 'lctm2015' ) . and . turbulence /= 'none' ) then call alloc ( CCnormalX , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalX\" )) call alloc ( CCnormalY , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalY\" )) call alloc ( CCnormalZ , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalZ\" )) call alloc ( CCVn , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCVn\" )) call alloc ( DCCVnX , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call alloc ( DCCVnY , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnY\" )) call alloc ( DCCVnZ , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call find_CCnormal () end if end subroutine setupCC subroutine destroyCC () !< Deallocate memory from the cell-center variables implicit none DebugCall ( \"Destroy CC\" ) call dealloc ( CCnormalX ) call dealloc ( CCnormalY ) call dealloc ( CCnormalZ ) call dealloc ( CCVn ) call dealloc ( DCCVnX ) call dealloc ( DCCVnY ) call dealloc ( DCCVnZ ) end subroutine destroyCC subroutine find_CCnormal () !< Find the cell-center unit normal implicit none call compute_gradient ( CCnormalX , dist , 'x' ) call compute_gradient ( CCnormalY , dist , 'y' ) call compute_gradient ( CCnormalZ , dist , 'z' ) !using already allocated memeory for storing magnitude CCVn = sqrt ( CCnormalX ** 2 + CCnormalY ** 2 + CCnormalZ ** 2 ) !CCVn hold the magnitude of CCnormal temporaraly and can be !overwritten after next three lines of code. CCnormalX = CCnormalX / ( CCVn + 1 e - 12 ) CCnormalY = CCnormalY / ( CCVn + 1 e - 12 ) CCnormalZ = CCnormalZ / ( CCVn + 1 e - 12 ) end subroutine find_CCnormal subroutine find_CCVn () !< Taking a dot product between Cell-center velocity and unit normal implicit none CCVn = CCnormalX * x_speed + CCnormalY * y_speed + CCnormalZ * z_speed end subroutine find_CCVn subroutine find_DCCVn () !< Find gradient of the dot product between cell velocity and unit normal implicit none call find_CCVn () call compute_gradient ( DCCVnX , dist , 'x' ) call compute_gradient ( DCCVnY , dist , 'y' ) call compute_gradient ( DCCVnZ , dist , 'z' ) end subroutine find_DCCVn subroutine compute_gradient ( grad , var , dir ) !< Generalized subroutine to calculate gradients implicit none real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: grad real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: var character ( len =* ) , intent ( in ) :: dir real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k ! initialize grad = 0.0 select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * nx ( i , j , k ) * xA ( i , j , k ) & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * ny ( i , j , k ) * yA ( i , j , k ) & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * nz ( i , j , k ) * zA ( i , j , k ) & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient end module CC","tags":"","loc":"sourcefile/cc.f90.html","title":"CC.f90 – FEST-3D"},{"text":"Calculate gradients of any primitive variables and temperature This file depends on sourcefile~~summon_grad_evaluation.f90~~EfferentGraph sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~string.f90 string.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~global_vars.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~ghost_gradient.f90->sourcefile~utils.f90 sourcefile~ghost_gradient.f90->sourcefile~global_vars.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~summon_grad_evaluation.f90~~AfferentGraph sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules summon_grad_evaluation Source Code summon_grad_evaluation.f90 Source Code !< Calculate gradients of any primitive variables and temperature module summon_grad_evaluation !< Calculate gradients of any primitive variables and temperature !---------------------------------------------------------- !170608  -Jatinder Pal Singh Sandhu ! Aim : call is made to all the required gradients !                         based on input conditions !---------------------------------------------------------- #include \"error.inc\" use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : tk use global_vars , only : tw use global_vars , only : tv use global_vars , only : te use global_vars , only : tkl use global_vars , only : tgm use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : gradtv_x use global_vars , only : gradtv_y use global_vars , only : gradtv_z use global_vars , only : gradte_x use global_vars , only : gradte_y use global_vars , only : gradte_z use global_vars , only : gradtkl_x use global_vars , only : gradtkl_y use global_vars , only : gradtkl_z use global_vars , only : gradtgm_x use global_vars , only : gradtgm_y use global_vars , only : gradtgm_z use global_vars , only : gradqp_z use global_vars , only : process_id use global_vars , only : xn use global_vars , only : yn use global_vars , only : zn use global_vars , only : xnx use global_vars , only : xny use global_vars , only : xnz use global_vars , only : ynx use global_vars , only : yny use global_vars , only : ynz use global_vars , only : znx use global_vars , only : zny use global_vars , only : znz use global_vars , only : xA use global_vars , only : yA use global_vars , only : zA use global_vars , only : volume use global_vars , only : density use global_vars , only : pressure use global_vars , only : R_gas use global_vars , only : gm use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use utils , only : turbulence_read_error use string use ghost_gradients , only : apply_gradient_bc implicit none private real , dimension ( 6 ) :: T !< Temperaure array for six neighbours real :: cell_T !< Temperature at cell center integer :: i , j , k !< integer for DO loop public :: evaluate_all_gradients contains subroutine evaluate_all_gradients () !< Call to all the required gradients and !< apply boundary condition for ghost cell !< gradients implicit none call dmsg ( 1 , 'summon_grad_evaluation' , 'evaluate_all_gradients' ) call compute_gradient_G ( gradu_x , x_speed , 'x' ) call compute_gradient_G ( gradv_x , y_speed , 'x' ) call compute_gradient_G ( gradw_x , z_speed , 'x' ) call compute_gradient_T ( gradT_x , 'x' ) call compute_gradient_G ( gradu_y , x_speed , 'y' ) call compute_gradient_G ( gradv_y , y_speed , 'y' ) call compute_gradient_G ( gradw_y , z_speed , 'y' ) call compute_gradient_T ( gradT_y , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradu_z , x_speed , 'z' ) call compute_gradient_G ( gradv_z , y_speed , 'z' ) call compute_gradient_G ( gradw_z , z_speed , 'z' ) call compute_gradient_T ( gradT_z , 'z' ) else gradqp_z = 0.0 end if !      include \"compute_gradu_x.inc\" !      include \"compute_gradu_y.inc\" !      include \"compute_gradv_x.inc\" !      include \"compute_gradv_y.inc\" !      include \"compute_gradw_x.inc\" !      include \"compute_gradw_y.inc\" !      include \"compute_gradT_x.inc\" !      include \"compute_gradT_y.inc\" !      if(kmx>2) then !      include \"compute_gradu_z.inc\" !      include \"compute_gradv_z.inc\" !      include \"compute_gradw_z.inc\" !      include \"compute_gradT_z.inc\" !      else !      gradqp_z=0.0 !      end if select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_gradient_G ( gradtv_x , tv , 'x' ) call compute_gradient_G ( gradtv_y , tv , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtv_z , tv , 'z' ) end if case ( 'sst' , 'sst2003' ) call compute_gradient_G ( gradtk_x , tk , 'x' ) call compute_gradient_G ( gradtw_x , tw , 'x' ) call compute_gradient_G ( gradtk_y , tk , 'y' ) call compute_gradient_G ( gradtw_y , tw , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , 'z' ) call compute_gradient_G ( gradtw_z , tw , 'z' ) end if case ( 'kkl' ) call compute_gradient_G ( gradtk_x , tk , 'x' ) call compute_gradient_G ( gradtkl_x , tkl , 'x' ) call compute_gradient_G ( gradtk_y , tk , 'y' ) call compute_gradient_G ( gradtkl_y , tkl , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , 'z' ) call compute_gradient_G ( gradtkl_z , tkl , 'z' ) end if case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call compute_gradient_G ( gradtgm_x , tgm , 'x' ) call compute_gradient_G ( gradtgm_y , tgm , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtgm_z , tgm , 'z' ) end if case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select !gradqp_z=0.0 !applying boundary condition to gradients call apply_gradient_bc () end subroutine evaluate_all_gradients subroutine compute_gradient_G ( grad , var , dir ) !<  Compute gradient of any input scalar implicit none real , dimension ( 0 : imx , 0 : jmx , 0 : kmx ), intent ( out ) :: grad !< Output variable storing the graident of var real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: var !< Input variable of which graident is required character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * nx ( i , j , k ) * xA ( i , j , k ) & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * ny ( i , j , k ) * yA ( i , j , k ) & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * nz ( i , j , k ) * zA ( i , j , k ) & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_G subroutine compute_gradient_T ( grad , dir ) !< Calculate gradient of temperature implicit none real , dimension ( 0 : imx , 0 : jmx , 0 : kmx ), intent ( out ) :: grad !< Output gradient of termperature character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated real , dimension ( 6 ) :: T real :: cell_T real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx cell_T = ( pressure ( i , j , k ) / density ( i , j , k )) / R_gas T ( 1 ) = ( pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) / R_gas + cell_T T ( 2 ) = ( pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) / R_gas + cell_T T ( 3 ) = ( pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) / R_gas + cell_T T ( 4 ) = ( pressure ( i + 1 , j , k ) / density ( i + 1 , j , k )) / R_gas + cell_T T ( 5 ) = ( pressure ( i , j + 1 , k ) / density ( i , j + 1 , k )) / R_gas + cell_T T ( 6 ) = ( pressure ( i , j , k + 1 ) / density ( i , j , k + 1 )) / R_gas + cell_T grad ( i , j , k ) = ( - T ( 1 ) * nx ( i , j , k ) * xA ( i , j , k ) & - T ( 2 ) * ny ( i , j , k ) * yA ( i , j , k ) & - T ( 3 ) * nz ( i , j , k ) * zA ( i , j , k ) & + T ( 4 ) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + T ( 5 ) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + T ( 6 ) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_T end module summon_grad_evaluation","tags":"","loc":"sourcefile/summon_grad_evaluation.f90.html","title":"summon_grad_evaluation.f90 – FEST-3D"},{"text":"Add source's contribution to the residual This file depends on sourcefile~~source.f90~~EfferentGraph sourcefile~source.f90 source.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~string.f90 string.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~layout.f90 layout.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~global.f90 global.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output.f90->sourcefile~global_vars.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 var pansourcefilesourcef90EfferentGraph = svgPanZoom('#sourcefilesourcef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~source.f90~~AfferentGraph sourcefile~source.f90 source.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules source Source Code source.f90 Source Code !< Add source's contribution to the residual module source !< Add source's contribution to the residual !----------------------------------------------------------------- !170609  - jatinder Pal Singh Sandhu ! AIM: to add source term residue to already calculate residuals !      if requires !----------------------------------------------------------------- #include \"debug.h\" #include \"error.h\" use dump_solution , only : checkpoint use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : process_id use utils , only : dmsg use utils , only : turbulence_read_error !--- variable required for sst source calculation ---! use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : a1 use global_sst , only : gama1 use global_sst , only : gama2 use global_sst , only : beta use global_sst , only : sigma_w use global_sst , only : sigma_k use global_sst , only : gama use global_sst , only : sst_F1 use global_vars , only : free_stream_tu use global_vars , only : Reynolds_number use global_vars , only : intermittency use global_vars , only : vel_mag use global_vars , only : qp use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : n_var use global_vars , only : volume use global_vars , only : density use global_vars , only : x_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tk_inf use global_vars , only : tw_inf use global_vars , only : free_stream_tu use global_vars , only : mu use global_vars , only : sst_mu use global_vars , only : dist use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : gradtgm_x use global_vars , only : gradtgm_y use global_vars , only : gradtgm_z use global_vars , only : residue use global_vars , only : TKE_residue use global_vars , only : omega_residue use global_vars , only : xn use global_vars , only : yn use global_vars , only : zn !--- variables required for kkl source calculation ---! use global_kkl , only : zeta1 use global_kkl , only : zeta2 use global_kkl , only : zeta3 use global_kkl , only : sigma_phi use global_kkl , only : cmu use global_kkl , only : kappa use global_kkl , only : c11 use global_kkl , only : c12 use global_kkl , only : cd1 use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta !variables required by sa source term calculation use global_vars , only : tv use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use global_vars , only : gradtv_x use global_vars , only : gradtv_y use global_vars , only : gradtv_z use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : tkl use global_vars , only : mu_t use global_vars , only : KL_residue use global_vars , only : tv_residue use global_vars , only : DCCVnX use global_vars , only : DCCVnY use global_vars , only : DCCVnZ use global_vars , only : CCnormalX use global_vars , only : CCnormalY use global_vars , only : CCnormalZ use CC , only : find_DCCVn use utils , only : alloc , dealloc , dmsg use layout , only : process_id use string implicit none private public :: add_source_term_residue public :: Setup_source public :: destroy_source contains subroutine add_source_term_residue () !< Call to add different source terms to the residual of different equations. implicit none call dmsg ( 1 , 'source' , 'add_source_term_residue' ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' ) select case ( trim ( transition )) case ( 'none' ) call add_sa_source () case ( 'bc' ) call add_saBC_source () case DEFAULT Fatal_error end select case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' ) call add_sst_source () case ( 'lctm2015' ) call add_sst_source_lctm2015 () case ( 'bc' ) call add_sst_bc_source () case DEFAULT Fatal_error end select case ( 'kkl' ) call add_kkl_source () case DEFAULT Fatal_error end select end subroutine add_source_term_residue subroutine Setup_source () !< Allcoate memory to the required by the variable implicit none !nothing end subroutine Setup_source subroutine destroy_source () !< deallocate memory before stoping the solver implicit none !nothing end subroutine destroy_source subroutine add_sst_source () !< Add residual due to source terms of the SST turbulence model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_k real :: S_w real :: D_k real :: D_w real :: P_k real :: P_w real :: lamda integer :: limiter real :: divergence if ( trim ( turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = sst_mu ( i , j , k ) * ( vort ** 2 ) - (( 2.0 / 3.0 ) * density ( i , j , k ) * tk ( i , j , k ) * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w end do end do end do end subroutine add_sst_source subroutine add_sst_source_lctm2015 () !< Add residual due to source terms of the LCTM2015 transition model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_K real :: S_w real :: S_gm real :: D_k real :: D_w real :: D_gm real :: P_k real :: P_w real :: P_gm real :: lamda real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: intermittency real :: Pk_lim real :: Fon_lim real :: dudx real :: dudy real :: dudz real :: duds real :: velmag real :: u , v , w real :: lamd real :: Fpg real :: divergence real :: dvdy integer :: limiter if ( trim ( turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if !for pressure gradient calculation call find_DCCVn () do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 intermittency = qp ( i , j , k , n_var ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( ((( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 ) & + (( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 ) & + (( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 ) & + 2 * ( gradu_x ( i , j , k ) ** 2 ) & + 2 * ( gradv_y ( i , j , k ) ** 2 ) & + 2 * ( gradw_z ( i , j , k ) ** 2 ) & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = sst_mu ( i , j , k ) * ( vort * strain ) - (( 2.0 / 3.0 ) * density ( i , j , k ) * tk ( i , j , k ) * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ ! --pressure gradient !            u = qp(i,j,k,2) !            v = qp(i,j,k,3) !            w = qp(i,j,k,4) !            velmag = sqrt((u**2) + (v**2) + (w**2)) !            dudx = 0.5*((2.0*u*gradu_x(i,j,k)) + (2.0*v*gradv_x(i,j,k)) + (2.0*w*gradw_x(i,j,k)))/velmag !            dudy = 0.5*((2.0*u*gradu_y(i,j,k)) + (2.0*v*gradv_y(i,j,k)) + (2.0*w*gradw_y(i,j,k)))/velmag !            dudz = 0.5*((2.0*u*gradu_z(i,j,k)) + (2.0*v*gradv_z(i,j,k)) + (2.0*w*gradw_z(i,j,k)))/velmag !            duds = (((u/velmag)*dudx) + ((v/velmag)*dudy) + ((w/velmag)*dudz)) !            !lamd =(-7.57e-3)*(duds*dist(i,j,k)*dist(i,j,k)*density(i,j,k)/mu(i,j,k)) + 0.0128 !            lamd =(+7.57e-3)*(duds*dist(i,j,k)*dist(i,j,k)*density(i,j,k)/mu(i,j,k)) + 0.0128 dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) ! --gradient TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) !Re_theta = 100.0 + 1000.0*exp(-TuL) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) P_gm = 100 * density ( i , j , k ) * strain * intermittency * ( 1.0 - intermittency ) * Fonset D_gm = 0.06 * density ( i , j , k ) * vort * intermittency * Fturb * (( 5 0.0 * intermittency ) - 1.0 ) Fon_lim = min ( max (( Rev / ( 2.2 * 110 0.0 )) - 1.0 , 0.0 ), 3.0 ) Pk_lim = 5 * max ( intermittency - 0.2 , 0.0 ) * ( 1.0 - intermittency ) * Fon_lim * max ( 3 * mu ( i , j , k ) - mu_t ( i , j , k ), 0.0 ) * strain * vort S_k = intermittency * P_k - max ( intermittency , 0.1 ) * D_k + Pk_lim !Source term gm S_W = P_w - D_w + lamda !Source term gm S_gm = P_gm - D_gm !Source term gm S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) S_gm = S_gm * Volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w residue ( i , j , k , n_var ) = residue ( i , j , k , n_var ) - S_gm end do end do end do end subroutine add_sst_source_lctm2015 ! SST-BC model subroutine add_sst_bc_source () !< Add residual due to source terms of the SST-BC transition model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_k real :: S_w real :: D_k real :: D_w real :: P_k real :: P_w real :: lamda real :: TuL !--------BC model ----- real :: chi_1 = 0.002 real :: chi_2 = 5.0 real :: nu_BC real :: nu_cr real :: nu_t real :: re_v real :: re_theta real :: re_theta_t real :: term1 real :: term2 real :: term_exponential real :: gamma_BC real :: vmag do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) !CD = max(CD, 1e-20) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ P_k = sst_mu ( i , j , k ) * ( vort ** 2 ) P_k = min ( P_k , 2 0.0 * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ !------ BC model --- vmag = sqrt ( SUM ( qp ( i , j , k , 2 : 4 ) ** 2 )) chi_1 = 0.002 chi_2 = 5.0 nu_t = mu_t ( i , j , k ) / density ( i , j , k ) nu_cr = chi_2 / Reynolds_number nu_bc = nu_t / ( vmag * dist ( i , j , k )) !TuL = min(100.0*sqrt(2.0*tk(i,j,k)/3.0)/(tw(i,j,k)*dist(i,j,k)),100.0) TuL = free_stream_tu !local turbulence intensity might not work for BC model re_v = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * vort / mu ( i , j , k ) re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( TuL + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 100.0 + 1000.0*exp(-TuL) !re_theta_t = 163.0 + exp(6.91 - TuL) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) P_k = gamma_BC * P_k S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w end do end do end do end subroutine add_sst_bc_source subroutine add_kkl_source () !< Add residual due to source terms of the k-kL turbulence model implicit none integer :: i , j , k real :: Tau11 real :: Tau12 real :: Tau13 real :: Tau21 real :: Tau22 real :: Tau23 real :: Tau31 real :: Tau32 real :: Tau33 real :: S11 real :: S12 real :: S13 real :: S21 real :: S22 real :: S23 real :: S31 real :: S32 real :: S33 real :: delv real :: d2udx2 real :: d2udy2 real :: d2udz2 real :: d2vdx2 real :: d2vdy2 real :: d2vdz2 real :: d2wdx2 real :: d2wdy2 real :: d2wdz2 real :: Lvk real :: fp real :: ud real :: udd real :: S_k real :: S_kl real :: D_k real :: D_kl real :: P_k real :: P_kl !change for transition modeling real :: vort real :: Rev real :: Rev1 real :: ReThc real :: Tu real :: term1 do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 S11 = 0.5 * ( gradu_x ( i , j , k ) + gradu_x ( i , j , k )) S12 = 0.5 * ( gradu_y ( i , j , k ) + gradv_x ( i , j , k )) S13 = 0.5 * ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) S21 = 0.5 * ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) S22 = 0.5 * ( gradv_y ( i , j , k ) + gradv_y ( i , j , k )) S23 = 0.5 * ( gradv_z ( i , j , k ) + gradw_y ( i , j , k )) S31 = 0.5 * ( gradw_x ( i , j , k ) + gradu_z ( i , j , k )) S32 = 0.5 * ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) S33 = 0.5 * ( gradw_z ( i , j , k ) + gradw_z ( i , j , k )) delv = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) Tau11 = mu_t ( i , j , k ) * ( 2 * S11 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) Tau12 = mu_t ( i , j , k ) * ( 2 * S12 ) Tau13 = mu_t ( i , j , k ) * ( 2 * S13 ) Tau21 = mu_t ( i , j , k ) * ( 2 * S21 ) Tau22 = mu_t ( i , j , k ) * ( 2 * S22 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) Tau23 = mu_t ( i , j , k ) * ( 2 * S23 ) Tau31 = mu_t ( i , j , k ) * ( 2 * S31 ) Tau32 = mu_t ( i , j , k ) * ( 2 * S32 ) Tau33 = mu_t ( i , j , k ) * ( 2 * S33 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) P_k = 0. P_k = P_k + Tau11 * gradu_x ( i , j , k ) + Tau12 * gradu_y ( i , j , k ) + Tau13 * gradu_z ( i , j , k ) P_k = P_k + Tau21 * gradv_x ( i , j , k ) + Tau22 * gradv_y ( i , j , k ) + Tau23 * gradv_z ( i , j , k ) P_k = P_k + Tau31 * gradw_x ( i , j , k ) + Tau32 * gradw_y ( i , j , k ) + Tau33 * gradw_z ( i , j , k ) D_k = ( cmu ** 0.75 ) * density ( i , j , k ) * ( tk ( i , j , k ) ** 2.5 ) / max ( tkl ( i , j , k ), 1.e-20 ) P_k = min ( P_k , 20 * D_k ) ! calculation of Lvk ! first get second order gradients d2udx2 = ( - ( gradu_x ( i - 1 , j , k ) + gradu_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradu_x ( i , j - 1 , k ) + gradu_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradu_x ( i , j , k - 1 ) + gradu_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradu_x ( i + 1 , j , k ) + gradu_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_x ( i , j + 1 , k ) + gradu_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_x ( i , j , k + 1 ) + gradu_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2udy2 = ( - ( gradu_y ( i - 1 , j , k ) + gradu_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradu_y ( i , j - 1 , k ) + gradu_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradu_y ( i , j , k - 1 ) + gradu_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradu_y ( i + 1 , j , k ) + gradu_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_y ( i , j + 1 , k ) + gradu_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_y ( i , j , k + 1 ) + gradu_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2udz2 = ( - ( gradu_z ( i - 1 , j , k ) + gradu_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradu_z ( i , j - 1 , k ) + gradu_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradu_z ( i , j , k - 1 ) + gradu_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradu_z ( i + 1 , j , k ) + gradu_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_z ( i , j + 1 , k ) + gradu_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_z ( i , j , k + 1 ) + gradu_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) ! gradient of v component d2vdx2 = ( - ( gradv_x ( i - 1 , j , k ) + gradv_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradv_x ( i , j - 1 , k ) + gradv_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradv_x ( i , j , k - 1 ) + gradv_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradv_x ( i + 1 , j , k ) + gradv_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_x ( i , j + 1 , k ) + gradv_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_x ( i , j , k + 1 ) + gradv_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2vdy2 = ( - ( gradv_y ( i - 1 , j , k ) + gradv_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradv_y ( i , j - 1 , k ) + gradv_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradv_y ( i , j , k - 1 ) + gradv_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradv_y ( i + 1 , j , k ) + gradv_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_y ( i , j + 1 , k ) + gradv_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_y ( i , j , k + 1 ) + gradv_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2vdz2 = ( - ( gradv_z ( i - 1 , j , k ) + gradv_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradv_z ( i , j - 1 , k ) + gradv_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradv_z ( i , j , k - 1 ) + gradv_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradv_z ( i + 1 , j , k ) + gradv_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_z ( i , j + 1 , k ) + gradv_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_z ( i , j , k + 1 ) + gradv_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) !gradients of w components d2wdx2 = ( - ( gradw_x ( i - 1 , j , k ) + gradw_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradw_x ( i , j - 1 , k ) + gradw_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradw_x ( i , j , k - 1 ) + gradw_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradw_x ( i + 1 , j , k ) + gradw_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_x ( i , j + 1 , k ) + gradw_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_x ( i , j , k + 1 ) + gradw_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2wdy2 = ( - ( gradw_y ( i - 1 , j , k ) + gradw_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradw_y ( i , j - 1 , k ) + gradw_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradw_y ( i , j , k - 1 ) + gradw_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradw_y ( i + 1 , j , k ) + gradw_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_y ( i , j + 1 , k ) + gradw_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_y ( i , j , k + 1 ) + gradw_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2wdz2 = ( - ( gradw_z ( i - 1 , j , k ) + gradw_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradw_z ( i , j - 1 , k ) + gradw_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradw_z ( i , j , k - 1 ) + gradw_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradw_z ( i + 1 , j , k ) + gradw_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_z ( i , j + 1 , k ) + gradw_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_z ( i , j , k + 1 ) + gradw_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) udd = sqrt ( ( d2udx2 + d2udy2 + d2udz2 ) ** 2 & + ( d2vdx2 + d2vdy2 + d2vdz2 ) ** 2 & + ( d2wdx2 + d2wdy2 + d2wdz2 ) ** 2 ) ud = sqrt ( 2 * ( s11 ** 2 + s12 ** 2 + s13 ** 2 & + s21 ** 2 + s22 ** 2 + s23 ** 2 & + s31 ** 2 + s32 ** 2 + s33 ** 2 )) Lvk = kappa * abs ( ud / max ( udd , 1.e-20 )) fp = min ( max ( P_k / D_k , 0.5 ), 1.0 ) ! Lvk limiter Lvk = max ( Lvk , tkl ( i , j , k ) / max (( tk ( i , j , k ) * c11 ), 1.e-20 )) Lvk = min ( Lvk , c12 * kappa * dist ( i , j , k ) * fp ) eta = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( 0.3 * tk ( i , j , k )) / ( 20 * mu ( i , j , k )) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) cphi2 = zeta3 cphi1 = ( zeta1 - zeta2 * (( tkl ( i , j , k ) / max ( tk ( i , j , k ) * Lvk , 1.e-20 )) ** 2 )) P_kl = cphi1 * tkl ( i , j , k ) * P_k / max ( tk ( i , j , k ), 1.e-20 ) D_kl = cphi2 * density ( i , j , k ) * ( tk ( i , j , k ) ** 1.5 ) S_k = P_k - D_k - 2 * mu ( i , j , k ) * tk ( i , j , k ) / ( dist ( i , j , k ) ** 2 ) !Source term TKE S_kl = P_kl - D_kl - 6 * mu ( i , j , k ) * tkl ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 ) !source term KL S_k = S_k * volume ( i , j , k ) S_kl = S_kl * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k KL_residue ( i , j , k ) = KL_residue ( i , j , k ) - S_kl end do end do end do end subroutine add_kkl_source subroutine add_sa_source () !< Add residual due to source terms of SA turbulence model implicit none integer :: i , j , k real :: CD1 real :: CD2 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: vort real :: S_v real :: D_v real :: P_v real :: lamda real :: kd2 real :: xi real :: nu real :: gradrho_x real :: gradrho_y real :: gradrho_z real , dimension ( 6 ) :: RhoFace real , dimension ( 6 ) :: Area real , dimension ( 6 , 3 ) :: Normal do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 RhoFace ( 1 ) = density ( i - 1 , j , k ) + density ( i , j , k ) RhoFace ( 2 ) = density ( i , j - 1 , k ) + density ( i , j , k ) RhoFace ( 3 ) = density ( i , j , k - 1 ) + density ( i , j , k ) RhoFace ( 4 ) = density ( i + 1 , j , k ) + density ( i , j , k ) RhoFace ( 5 ) = density ( i , j + 1 , k ) + density ( i , j , k ) RhoFace ( 6 ) = density ( i , j , k + 1 ) + density ( i , j , k ) Area ( 1 ) = xA ( i , j , k ) Area ( 2 ) = yA ( i , j , k ) Area ( 3 ) = zA ( i , j , k ) Area ( 4 ) = xA ( i + 1 , j , k ) Area ( 5 ) = yA ( i , j + 1 , k ) Area ( 6 ) = zA ( i , j , k + 1 ) Normal ( 1 , 1 : 3 ) = xn ( i , j , k ,:) Normal ( 2 , 1 : 3 ) = yn ( i , j , k ,:) Normal ( 3 , 1 : 3 ) = zn ( i , j , k ,:) Normal ( 4 , 1 : 3 ) = xn ( i + 1 , j , k ,:) Normal ( 5 , 1 : 3 ) = yn ( i , j + 1 , k ,:) Normal ( 6 , 1 : 3 ) = zn ( i , j , k + 1 ,:) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 nu = mu ( i , j , k ) / density ( i , j , k ) xi = tv ( i , j , k ) / nu ! ___ functions ___ fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) fv2 = 1.0 - xi / ( 1.0 + ( xi * fv1 )) ! ___ Shear stress for production ___ scap = max ( vort + ( tv ( i , j , k ) * fv2 / ( kd2 )), 0.3 * vort ) ! ___ wall function ___ r = min ( tv ( i , j , k ) / ( Scap * kd2 ), 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) fw = g * ( ( 1.0 + ( cw3 ** 6 )) / (( g ** 6 ) + ( cw3 ** 6 )) ) ** ( 1.0 / 6.0 ) ! ____ Dissipation term ___ D_v = density ( i , j , k ) * cw1 * fw * (( tv ( i , j , k ) / dist ( i , j , k )) ** 2 ) ! ____ PRODUCTION term____ P_v = density ( i , j , k ) * cb1 * Scap * tv ( i , j , k ) ! ____ cross diffusion term ___ lamda = density ( i , j , k ) * CD1 / sigma_sa - CD2 * ( nu + tv ( i , j , k )) / sigma_sa S_v = ( P_v - D_v + lamda ) * volume ( i , j , k ) tv_residue ( i , j , k ) = tv_residue ( i , j , k ) - S_v end do end do end do end subroutine add_sa_source subroutine add_saBC_source () !< Add residual due to source terms of SABC transition model implicit none integer :: i , j , k real :: CD1 real :: CD2 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: gradrho_x real :: gradrho_y real :: gradrho_z real , dimension ( 6 ) :: RhoFace real , dimension ( 6 ) :: Area real , dimension ( 6 , 3 ) :: Normal ! transition modeling variables real :: chi_1 = 0.002 real :: chi_2 = 5.0 real :: nu_BC real :: nu_cr real :: nu_t real :: u , v , w real :: glim real :: g_6 real :: vmag real :: Production real :: Destruction real :: re_v real :: re_theta real :: re_theta_t real :: term1 real :: term2 real :: term_exponential real :: gamma_BC real :: tu tu = free_stream_tu do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 !Local_vel_mag u = qp ( i , j , k , 2 ) v = qp ( i , j , k , 3 ) w = qp ( i , j , k , 4 ) vmag = sqrt ( u * u + v * v + w * w ) RhoFace ( 1 ) = density ( i - 1 , j , k ) + density ( i , j , k ) RhoFace ( 2 ) = density ( i , j - 1 , k ) + density ( i , j , k ) RhoFace ( 3 ) = density ( i , j , k - 1 ) + density ( i , j , k ) RhoFace ( 4 ) = density ( i + 1 , j , k ) + density ( i , j , k ) RhoFace ( 5 ) = density ( i , j + 1 , k ) + density ( i , j , k ) RhoFace ( 6 ) = density ( i , j , k + 1 ) + density ( i , j , k ) Area ( 1 ) = xA ( i , j , k ) Area ( 2 ) = yA ( i , j , k ) Area ( 3 ) = zA ( i , j , k ) Area ( 4 ) = xA ( i + 1 , j , k ) Area ( 5 ) = yA ( i , j + 1 , k ) Area ( 6 ) = zA ( i , j , k + 1 ) Normal ( 1 , 1 : 3 ) = xn ( i , j , k ,:) Normal ( 2 , 1 : 3 ) = yn ( i , j , k ,:) Normal ( 3 , 1 : 3 ) = zn ( i , j , k ,:) Normal ( 4 , 1 : 3 ) = xn ( i + 1 , j , k ,:) Normal ( 5 , 1 : 3 ) = yn ( i , j + 1 , k ,:) Normal ( 6 , 1 : 3 ) = zn ( i , j , k + 1 ,:) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) ! __ vorticity __ Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = tv ( i , j , k ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + tv ( i , j , k ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat ! ____ PRODUCTION term____ chi_1 = 0.002 chi_2 = 5.0 nu_t = tv ( i , j , k ) * fv1 nu_cr = chi_2 / Reynolds_number nu_bc = nu_t / ( vmag * dist_i ) re_v = dist_i_2 * Omega / nu re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( tu + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 163.0 + exp(6.91-0.18) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) !            intermittency(i,j,k) = gamma_BC Production = gamma_BC * cb1 * Shat * tv ( i , j , k ) * volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( tv ( i , j , k ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim Destruction = ( cw1 * fw * tv ( i , j , k ) * tv ( i , j , k ) / dist_i_2 ) * ( volume ( i , j , k )) ! ____ cross diffusion term ___ lamda = ( density ( i , j , k ) * CD1 / sigma_sa - CD2 * ( nu + tv ( i , j , k )) / sigma_sa ) * volume ( i , j , k ) S_v = ( Production - Destruction + lamda ) tv_residue ( i , j , k ) = tv_residue ( i , j , k ) - S_v end do end do end do end subroutine add_saBC_source end module source","tags":"","loc":"sourcefile/source.f90.html","title":"source.f90 – FEST-3D"},{"text":"The grid module read grid file and allocate memory to storing variables This file depends on sourcefile~~grid.f90~~EfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~utils.f90 utils.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~grid.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~grid.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~string.f90 string.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~grid.f90~~AfferentGraph sourcefile~grid.f90 grid.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~grid.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules grid Source Code grid.f90 Source Code !< The grid module read grid file and allocate memory to storing variables module grid !< The grid module contains the grid definition (locations of the !< grid points) as well as procedures to load these from a file. !------------------------------------------------------------------- use global , only : STRING_BUFFER_LENGTH , GRID_FILE_UNIT use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : imin_id use global_vars , only : jmin_id use global_vars , only : kmin_id use global_vars , only : imax_id use global_vars , only : jmax_id use global_vars , only : kmax_id use mapping , only : Gilo use mapping , only : Gjlo use mapping , only : Gklo use mapping , only : Gihi use mapping , only : Gjhi use mapping , only : Gkhi use mapping , only : mpi_class use mapping , only : read_interface_map use global_vars , only : dir_switch use global_vars , only : layers use global_vars , only : process_id use utils , only : alloc , dealloc , dmsg #include \"error.inc\" #include \"mpi.inc\" private ! Public methods public :: setup_grid public :: destroy_grid contains subroutine allocate_memory () !< Allocate memory to store the grid !----------------------------------------------------------- implicit none call dmsg ( 1 , 'grid' , 'allocate_memory' ) call alloc ( grid_x , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_x.' ) call alloc ( grid_y , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_y.' ) call alloc ( grid_z , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_z.' ) ! The alloc function earlier allocates only real arrays. ! A new function has been written to allocate for integers ! as well !           call alloc(sphere_indices, 1, 3, 1, n_sph_ind, & !                   errmsg='Error: Unable to allocate memory for sphere_indices.') end subroutine allocate_memory subroutine destroy_grid () !< Deallocate the memory allocated for the grid. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'grid' , 'destroy_memory' ) call dealloc ( grid_x ) call dealloc ( grid_y ) call dealloc ( grid_z ) !           call dealloc(sphere_indices) end subroutine destroy_grid subroutine setup_grid ( gridfile ) !< Read the grid file and initialize the grid !----------------------------------------------------------- implicit none character ( len = 64 ), intent ( in ) :: gridfile !        character(len=32) :: sphindfile call dmsg ( 1 , 'grid' , 'setup_grid' ) !           sphindfile = 'sphere-indices.txt' open ( GRID_FILE_UNIT , file = gridfile ) !           open(SPHERE_INDICES_FILE_UNIT, file=sphindfile) call extract_grid_size () !           call extract_sphere_indices_size() call allocate_memory () !read interface mapping call read_interface_map () ! ghost grid exchange call populate_grid_points () !           call populate_sphere_indices() close ( GRID_FILE_UNIT ) !           close(SPHERE_INDICES_FILE_UNIT) ! populate ghost grid points call ghost_grid () end subroutine setup_grid subroutine extract_grid_size () !< Extract the grid size from the grid file header ! ! We assume that the grid could be in 1 or 2 dimensions. If ! the grid is in 1 dimension, jmx will be set to 1. ! We assume that at least one number is specified in the ! header, i.e., the grid has atleast one dimension. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: header integer :: ios ! io operation status call dmsg ( 1 , 'grid' , 'extract_grid_size' ) read ( GRID_FILE_UNIT , '(A)' , iostat = ios ) header if ( ios /= 0 ) then print * , 'Error while reading grid file header.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if ! Try to read constants corresponding to two dimensions. read ( header , * , iostat = ios ) imx , jmx , kmx if ( ios /= 0 ) then ! An io error means it was not possible to read kmx ! This means the file does not have kmx  and so, set ! the extent of this direction to 1. Read the remaining ! dimension from the header. read ( header , * , iostat = ios ) imx , jmx if ( ios /= 0 ) then ! This means that jmx does not exist. Repeat again read ( header , * , iostat = ios ) imx if ( ios /= 0 ) then ! Error while reading print * , 'Unable to read grid extent.' stop end if jmx = 1 end if kmx = 1 end if end subroutine extract_grid_size subroutine extract_grid_point ( line , i , j , k ) !< Extract a grid point from a line of the grid file. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ), intent ( in ) :: line integer , intent ( in ) :: i , j , k call dmsg ( 0 , 'grid' , 'extract_grid_point' ) if ( kmx > 1 ) then read ( line , * ) grid_x ( i , j , k ), grid_y ( i , j , k ), grid_z ( i , j , k ) else if ( jmx > 1 ) then read ( line , * ) grid_x ( i , j , k ), grid_y ( i , j , k ) else read ( line , * ) grid_x ( i , j , k ) grid_y ( i , j , k ) = 0. end if grid_z ( i , j , k ) = 0. end if end subroutine extract_grid_point subroutine populate_grid_points () !< Use the grid file to populate the grid points. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: line integer :: i , j , k integer :: ios ! io status call dmsg ( 1 , 'grid' , 'populate_grid_point' ) !  print *, imx, jmx, kmx ! Read grid points from the grid file do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( GRID_FILE_UNIT , '(A)' , iostat = ios ) line if ( ios /= 0 ) then print * , 'Error while reading grid line.' print * , 'Current grid point: ' , i , j , k print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH print * , 'Exiting program.' stop end if call extract_grid_point ( line , i , j , k ) end do end do end do end subroutine populate_grid_points subroutine ghost_grid () !< generate ghost grid for the various operations later. implicit none integer :: count = 0 integer :: i , j , k , l integer :: ierr integer :: status ( MPI_STATUS_SIZE ) real , dimension (:), allocatable :: imin_send_buffer real , dimension (:), allocatable :: jmin_send_buffer real , dimension (:), allocatable :: kmin_send_buffer real , dimension (:), allocatable :: imin_recv_buffer real , dimension (:), allocatable :: jmin_recv_buffer real , dimension (:), allocatable :: kmin_recv_buffer real , dimension (:), allocatable :: imax_send_buffer real , dimension (:), allocatable :: jmax_send_buffer real , dimension (:), allocatable :: kmax_send_buffer real , dimension (:), allocatable :: imax_recv_buffer real , dimension (:), allocatable :: jmax_recv_buffer real , dimension (:), allocatable :: kmax_recv_buffer !          real, dimension(3) :: delI !          real, dimension(3) :: N !          real  :: dot !          real  :: magnitude !          real :: d1x, d2x, d1y, d2y, d1z, d2z !          integer :: ii,jj,kk ! !          call dmsg(1, 'grid', 'ghost_grid_extrapolate') !          !---IMIN---! !          do k = 1, kmx !           do j = 1, jmx !             ! finding face normal !              ii=1 !              jj=j !              kk=k !              if(j==jmx) jj=j-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii, jj+1, kk+1) - grid_x(ii, jj  , kk) !              d1y = grid_y(ii, jj+1, kk+1) - grid_y(ii, jj  , kk) !              d1z = grid_z(ii, jj+1, kk+1) - grid_z(ii, jj  , kk) !              d2x = grid_x(ii, jj  , kk+1) - grid_x(ii, jj+1, kk) !              d2y = grid_y(ii, jj  , kk+1) - grid_y(ii, jj+1, kk) !              d2z = grid_z(ii, jj  , kk+1) - grid_z(ii, jj+1, kk) !              N(1) = -0.5 * (d1y*d2z - d1z*d2y) !              N(2) = -0.5 * (d1z*d2x - d1x*d2z) !              N(3) = -0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii+1, jj  , kk) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii+1, jj  , kk) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii+1, jj  , kk) !                d2x = grid_x(ii+1, jj  , kk+1) - grid_x(ii+1, jj+1, kk) !                d2y = grid_y(ii+1, jj  , kk+1) - grid_y(ii+1, jj+1, kk) !                d2z = grid_z(ii+1, jj  , kk+1) - grid_z(ii+1, jj+1, kk) !                N(1) = -0.5 * (d1y*d2z - d1z*d2y) !                N(2) = -0.5 * (d1z*d2x - d1x*d2z) !                N(3) = -0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(ii+1,j,k)-grid_x(ii,j,k) !                delI(2) = grid_y(ii+1,j,k)-grid_y(ii,j,k) !                delI(3) = grid_z(ii+1,j,k)-grid_z(ii,j,k) !                dot=SUM(N*delI)/magnitude !                grid_x(ii-l,j,k)= grid_x(ii,j,k) + delI(1) + (l+1)*dot*N(1) !                grid_y(ii-l,j,k)= grid_y(ii,j,k) + delI(2) + (l+1)*dot*N(2) !                grid_z(ii-l,j,k)= grid_z(ii,j,k) + delI(3) + (l+1)*dot*N(3) !             end do !            end do !           end do ! ! !           !--- IMAX ---! !          do k = 1, kmx !           do j = 1, jmx !             ! finding face normal !              ii=imx !              jj=j !              kk=k !              if(j==jmx) jj=j-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii, jj+1, kk+1) - grid_x(ii, jj  , kk) !              d1y = grid_y(ii, jj+1, kk+1) - grid_y(ii, jj  , kk) !              d1z = grid_z(ii, jj+1, kk+1) - grid_z(ii, jj  , kk) !              d2x = grid_x(ii, jj  , kk+1) - grid_x(ii, jj+1, kk) !              d2y = grid_y(ii, jj  , kk+1) - grid_y(ii, jj+1, kk) !              d2z = grid_z(ii, jj  , kk+1) - grid_z(ii, jj+1, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii-1, jj+1, kk+1) - grid_x(ii-1, jj  , kk) !                d1y = grid_y(ii-1, jj+1, kk+1) - grid_y(ii-1, jj  , kk) !                d1z = grid_z(ii-1, jj+1, kk+1) - grid_z(ii-1, jj  , kk) !                d2x = grid_x(ii-1, jj  , kk+1) - grid_x(ii-1, jj+1, kk) !                d2y = grid_y(ii-1, jj  , kk+1) - grid_y(ii-1, jj+1, kk) !                d2z = grid_z(ii-1, jj  , kk+1) - grid_z(ii-1, jj+1, kk) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(ii-1,j,k)-grid_x(ii,j,k) !                delI(2) = grid_y(ii-1,j,k)-grid_y(ii,j,k) !                delI(3) = grid_z(ii-1,j,k)-grid_z(ii,j,k) !                dot=SUM(N*delI)/magnitude !                grid_x(ii+l,j,k)= grid_x(ii,j,k) + delI(1) + (l+1)*dot*N(1) !                grid_y(ii+l,j,k)= grid_y(ii,j,k) + delI(2) + (l+1)*dot*N(2) !                grid_z(ii+l,j,k)= grid_z(ii,j,k) + delI(3) + (l+1)*dot*N(3) !            end do !           end do !          end do ! !          !--- JMIN ---! !          do k = 1, kmx !           do i = -2, imx+3 !             ! finding face normal !              ii=i !              jj=1 !              kk=k !              if(i==imx+3) ii=i-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii+1, jj, kk+1) - grid_x(ii, jj, kk) !              d1y = grid_y(ii+1, jj, kk+1) - grid_y(ii, jj, kk) !              d1z = grid_z(ii+1, jj, kk+1) - grid_z(ii, jj, kk) !              d2x = grid_x(ii+1, jj, kk)   - grid_x(ii, jj, kk+1) !              d2y = grid_y(ii+1, jj, kk)   - grid_y(ii, jj, kk+1) !              d2z = grid_z(ii+1, jj, kk)   - grid_z(ii, jj, kk+1) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii, jj+1, kk) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii, jj+1, kk) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii, jj+1, kk) !                d2x = grid_x(ii+1, jj+1, kk)   - grid_x(ii, jj+1, kk+1) !                d2y = grid_y(ii+1, jj+1, kk)   - grid_y(ii, jj+1, kk+1) !                d2z = grid_z(ii+1, jj+1, kk)   - grid_z(ii, jj+1, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,jj+1,k)-grid_x(i,jj,k) !                delI(2) = grid_y(i,jj+1,k)-grid_y(i,jj,k) !                delI(3) = grid_z(i,jj+1,k)-grid_z(i,jj,k) !                dot=SUM(N*delI)/magnitude !                grid_x(i,jj-l,k)= grid_x(i,jj,k) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,jj-l,k)= grid_y(i,jj,k) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,jj-l,k)= grid_z(i,jj,k) + delI(3) - (l+1)*dot*N(3) !              end do !            end do !          end do ! ! !          !--- JMAX ---! !          do k = 1, kmx !           do i = -2, imx+3 !             ! finding face normal !              ii=i !              jj=jmx !              kk=k !              if(i==imx+3) ii=i-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii+1, jj, kk+1) - grid_x(ii, jj, kk) !              d1y = grid_y(ii+1, jj, kk+1) - grid_y(ii, jj, kk) !              d1z = grid_z(ii+1, jj, kk+1) - grid_z(ii, jj, kk) !              d2x = grid_x(ii+1, jj, kk  ) - grid_x(ii, jj, kk+1) !              d2y = grid_y(ii+1, jj, kk  ) - grid_y(ii, jj, kk+1) !              d2z = grid_z(ii+1, jj, kk  ) - grid_z(ii, jj, kk+1) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj-1, kk+1) - grid_x(ii, jj-1, kk) !                d1y = grid_y(ii+1, jj-1, kk+1) - grid_y(ii, jj-1, kk) !                d1z = grid_z(ii+1, jj-1, kk+1) - grid_z(ii, jj-1, kk) !                d2x = grid_x(ii+1, jj-1, kk  ) - grid_x(ii, jj-1, kk+1) !                d2y = grid_y(ii+1, jj-1, kk  ) - grid_y(ii, jj-1, kk+1) !                d2z = grid_z(ii+1, jj-1, kk  ) - grid_z(ii, jj-1, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,jj-1,k)-grid_x(i,jj,k) !                delI(2) = grid_y(i,jj-1,k)-grid_y(i,jj,k) !                delI(3) = grid_z(i,jj-1,k)-grid_z(i,jj,k) !                dot=SUM(N*delI)/magnitude !                grid_x(i,jj+l,k)= grid_x(i,jj,k) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,jj+l,k)= grid_y(i,jj,k) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,jj+l,k)= grid_z(i,jj,k) + delI(3) - (l+1)*dot*N(3) !              end do !            end do !          end do ! !          !--- KMIN ---! !          do j = -2, jmx+3 !           do i = -2, imx+3 !              ii=i !              jj=j !              kk=1 !              if(i==imx+3) ii=i-1 !              if(j==jmx+3) jj=j-1 !              d1x = grid_x(ii+1, jj+1, kk) - grid_x(ii  , jj, kk) !              d1y = grid_y(ii+1, jj+1, kk) - grid_y(ii  , jj, kk) !              d1z = grid_z(ii+1, jj+1, kk) - grid_z(ii  , jj, kk) !              d2x = grid_x(ii  , jj+1, kk) - grid_x(ii+1, jj, kk) !              d2y = grid_y(ii  , jj+1, kk) - grid_y(ii+1, jj, kk) !              d2z = grid_z(ii  , jj+1, kk) - grid_z(ii+1, jj, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii  , jj, kk+1) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii  , jj, kk+1) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii  , jj, kk+1) !                d2x = grid_x(ii  , jj+1, kk+1) - grid_x(ii+1, jj, kk+1) !                d2y = grid_y(ii  , jj+1, kk+1) - grid_y(ii+1, jj, kk+1) !                d2z = grid_z(ii  , jj+1, kk+1) - grid_z(ii+1, jj, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,j,kk+1)-grid_x(i,j,kk) !                delI(2) = grid_y(i,j,kk+1)-grid_y(i,j,kk) !                delI(3) = grid_z(i,j,kk+1)-grid_z(i,j,kk) !                dot=SUM(N*delI)/magnitude !                grid_x(i,j,kk-l)= grid_x(i,j,kk) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,j,kk-l)= grid_y(i,j,kk) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,j,kk-l)= grid_z(i,j,kk) + delI(3) - (l+1)*dot*N(3) !            end do !           end do !          end do ! !          !--- KMAX ---! !          do j = -2, jmx+3 !           do i = -2, imx+3 !              ii=i !              jj=j !              kk=kmx !              if(i==imx+3) ii=i-1 !              if(j==jmx+3) jj=j-1 !              d1x = grid_x(ii+1, jj+1, kk) - grid_x(ii  , jj, kk) !              d1y = grid_y(ii+1, jj+1, kk) - grid_y(ii  , jj, kk) !              d1z = grid_z(ii+1, jj+1, kk) - grid_z(ii  , jj, kk) !              d2x = grid_x(ii  , jj+1, kk) - grid_x(ii+1, jj, kk) !              d2y = grid_y(ii  , jj+1, kk) - grid_y(ii+1, jj, kk) !              d2z = grid_z(ii  , jj+1, kk) - grid_z(ii+1, jj, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk-1) - grid_x(ii  , jj, kk-1) !                d1y = grid_y(ii+1, jj+1, kk-1) - grid_y(ii  , jj, kk-1) !                d1z = grid_z(ii+1, jj+1, kk-1) - grid_z(ii  , jj, kk-1) !                d2x = grid_x(ii  , jj+1, kk-1) - grid_x(ii+1, jj, kk-1) !                d2y = grid_y(ii  , jj+1, kk-1) - grid_y(ii+1, jj, kk-1) !                d2z = grid_z(ii  , jj+1, kk-1) - grid_z(ii+1, jj, kk-1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,j,kk-1)-grid_x(i,j,kk) !                delI(2) = grid_y(i,j,kk-1)-grid_y(i,j,kk) !                delI(3) = grid_z(i,j,kk-1)-grid_z(i,j,kk) !                dot=SUM(N*delI)/magnitude !                grid_x(i,j,kk+l)= grid_x(i,j,kk) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,j,kk+l)= grid_y(i,j,kk) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,j,kk+l)= grid_z(i,j,kk) + delI(3) - (l+1)*dot*N(3) !                print*, grid_x(ii+l,j,k), grid_y(ii+l,j,k), grid_z(ii+l,j,k) !            end do !           end do !          end do !          !------------------------------------------------------------------- !          !getting ghost cell for all faces even if it is a interface cell !          ! <algorithm> !          ! Point_ghost = 2*Point_first_inner_cell - Point_second_inner_cell !          ! </algorithm> !          !------------------------------------------------------------------- ! !--- I faces ---! !imin face -> 0 grid point grid_x ( 0 ,:,:) = 2 * grid_x ( 1 ,:,:) - grid_x ( 2 ,:,:) grid_y ( 0 ,:,:) = 2 * grid_y ( 1 ,:,:) - grid_y ( 2 ,:,:) grid_z ( 0 ,:,:) = 2 * grid_z ( 1 ,:,:) - grid_z ( 2 ,:,:) !imin face -> -1 grid point grid_x ( - 1 ,:,:) = 2 * grid_x ( 0 ,:,:) - grid_x ( 1 ,:,:) grid_y ( - 1 ,:,:) = 2 * grid_y ( 0 ,:,:) - grid_y ( 1 ,:,:) grid_z ( - 1 ,:,:) = 2 * grid_z ( 0 ,:,:) - grid_z ( 1 ,:,:) !imin face -> -2 grid point grid_x ( - 2 ,:,:) = 2 * grid_x ( - 1 ,:,:) - grid_x ( 0 ,:,:) grid_y ( - 2 ,:,:) = 2 * grid_y ( - 1 ,:,:) - grid_y ( 0 ,:,:) grid_z ( - 2 ,:,:) = 2 * grid_z ( - 1 ,:,:) - grid_z ( 0 ,:,:) !imax face -> imx+1 grid point grid_x ( imx + 1 ,:,:) = 2 * grid_x ( imx + 0 ,:,:) - grid_x ( imx - 1 ,:,:) grid_y ( imx + 1 ,:,:) = 2 * grid_y ( imx + 0 ,:,:) - grid_y ( imx - 1 ,:,:) grid_z ( imx + 1 ,:,:) = 2 * grid_z ( imx + 0 ,:,:) - grid_z ( imx - 1 ,:,:) !imax face -> imx+2 grid point grid_x ( imx + 2 ,:,:) = 2 * grid_x ( imx + 1 ,:,:) - grid_x ( imx - 0 ,:,:) grid_y ( imx + 2 ,:,:) = 2 * grid_y ( imx + 1 ,:,:) - grid_y ( imx - 0 ,:,:) grid_z ( imx + 2 ,:,:) = 2 * grid_z ( imx + 1 ,:,:) - grid_z ( imx - 0 ,:,:) !imax face -> imx+3 grid point grid_x ( imx + 3 ,:,:) = 2 * grid_x ( imx + 2 ,:,:) - grid_x ( imx + 1 ,:,:) grid_y ( imx + 3 ,:,:) = 2 * grid_y ( imx + 2 ,:,:) - grid_y ( imx + 1 ,:,:) grid_z ( imx + 3 ,:,:) = 2 * grid_z ( imx + 2 ,:,:) - grid_z ( imx + 1 ,:,:) !--- Jmin faces ---! !jmin faces -> 0 grid point grid_x (:, 0 ,:) = 2 * grid_x (:, 1 ,:) - grid_x (:, 2 ,:) grid_y (:, 0 ,:) = 2 * grid_y (:, 1 ,:) - grid_y (:, 2 ,:) grid_z (:, 0 ,:) = 2 * grid_z (:, 1 ,:) - grid_z (:, 2 ,:) !jmin face -> -1 grid point grid_x (:, - 1 ,:) = 2 * grid_x (:, 0 ,:) - grid_x (:, 1 ,:) grid_y (:, - 1 ,:) = 2 * grid_y (:, 0 ,:) - grid_y (:, 1 ,:) grid_z (:, - 1 ,:) = 2 * grid_z (:, 0 ,:) - grid_z (:, 1 ,:) !jmin face -> -2 grid point grid_x (:, - 2 ,:) = 2 * grid_x (:, - 1 ,:) - grid_x (:, 0 ,:) grid_y (:, - 2 ,:) = 2 * grid_y (:, - 1 ,:) - grid_y (:, 0 ,:) grid_z (:, - 2 ,:) = 2 * grid_z (:, - 1 ,:) - grid_z (:, 0 ,:) !jmax face -> imx+1 grid point grid_x (:, jmx + 1 ,:) = 2 * grid_x (:, jmx + 0 ,:) - grid_x (:, jmx - 1 ,:) grid_y (:, jmx + 1 ,:) = 2 * grid_y (:, jmx + 0 ,:) - grid_y (:, jmx - 1 ,:) grid_z (:, jmx + 1 ,:) = 2 * grid_z (:, jmx + 0 ,:) - grid_z (:, jmx - 1 ,:) !jmax face -> imx+2 grid point grid_x (:, jmx + 2 ,:) = 2 * grid_x (:, jmx + 1 ,:) - grid_x (:, jmx - 0 ,:) grid_y (:, jmx + 2 ,:) = 2 * grid_y (:, jmx + 1 ,:) - grid_y (:, jmx - 0 ,:) grid_z (:, jmx + 2 ,:) = 2 * grid_z (:, jmx + 1 ,:) - grid_z (:, jmx - 0 ,:) !jmax face -> imx+3 grid point grid_x (:, jmx + 3 ,:) = 2 * grid_x (:, jmx + 2 ,:) - grid_x (:, jmx + 1 ,:) grid_y (:, jmx + 3 ,:) = 2 * grid_y (:, jmx + 2 ,:) - grid_y (:, jmx + 1 ,:) grid_z (:, jmx + 3 ,:) = 2 * grid_z (:, jmx + 2 ,:) - grid_z (:, jmx + 1 ,:) !--- Kmax faces ---! !kmin faces -> 0 grid point grid_x (:,:, 0 ) = 2 * grid_x (:,:, 1 ) - grid_x (:,:, 2 ) grid_y (:,:, 0 ) = 2 * grid_y (:,:, 1 ) - grid_y (:,:, 2 ) grid_z (:,:, 0 ) = 2 * grid_z (:,:, 1 ) - grid_z (:,:, 2 ) !kmin face -> -1 grid point grid_x (:,:, - 1 ) = 2 * grid_x (:,:, 0 ) - grid_x (:,:, 1 ) grid_y (:,:, - 1 ) = 2 * grid_y (:,:, 0 ) - grid_y (:,:, 1 ) grid_z (:,:, - 1 ) = 2 * grid_z (:,:, 0 ) - grid_z (:,:, 1 ) !kmin face -> -2 grid point grid_x (:,:, - 2 ) = 2 * grid_x (:,:, - 1 ) - grid_x (:,:, 0 ) grid_y (:,:, - 2 ) = 2 * grid_y (:,:, - 1 ) - grid_y (:,:, 0 ) grid_z (:,:, - 2 ) = 2 * grid_z (:,:, - 1 ) - grid_z (:,:, 0 ) !kmax face -> imx+1 grid point grid_x (:,:, kmx + 1 ) = 2 * grid_x (:,:, kmx + 0 ) - grid_x (:,:, kmx - 1 ) grid_y (:,:, kmx + 1 ) = 2 * grid_y (:,:, kmx + 0 ) - grid_y (:,:, kmx - 1 ) grid_z (:,:, kmx + 1 ) = 2 * grid_z (:,:, kmx + 0 ) - grid_z (:,:, kmx - 1 ) !kmax face -> imx+2 grid point grid_x (:,:, kmx + 2 ) = 2 * grid_x (:,:, kmx + 1 ) - grid_x (:,:, kmx - 0 ) grid_y (:,:, kmx + 2 ) = 2 * grid_y (:,:, kmx + 1 ) - grid_y (:,:, kmx - 0 ) grid_z (:,:, kmx + 2 ) = 2 * grid_z (:,:, kmx + 1 ) - grid_z (:,:, kmx - 0 ) !kmax face -> imx+3 grid point grid_x (:,:, kmx + 3 ) = 2 * grid_x (:,:, kmx + 2 ) - grid_x (:,:, kmx + 1 ) grid_y (:,:, kmx + 3 ) = 2 * grid_y (:,:, kmx + 2 ) - grid_y (:,:, kmx + 1 ) grid_z (:,:, kmx + 3 ) = 2 * grid_z (:,:, kmx + 2 ) - grid_z (:,:, kmx + 1 ) !print*, grid_x(:,:,kmx) !print*, grid_y(:,:,kmx) !print*, grid_z(:,:,kmx) call dmsg ( 1 , 'grid' , 'ghost_grid_interface' ) !---  MPI transfer of grid point across interface  ---! !--- imin face ---! allocate ( imin_send_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmin_send_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmin_send_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imin_recv_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmin_recv_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmin_recv_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imax_send_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmax_send_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmax_send_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imax_recv_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmax_recv_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmax_recv_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) !          if(imin_id>=0)then !            !collect grid point in 1d array !            count=0 !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_x(l+1,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_y(l+1,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_z(l+1,j,k) !                end do !              end do !            end do ! !        call MPI_SENDRECV(imin_send_buffer,count, MPI_DOUBLE_PRECISION, imin_id,1,& !                          imin_recv_buffer,count, MPI_DOUBLE_PRECISION, imin_id,1,& !                          MPI_COMM_WORLD,status,ierr) !        !    if(mpi_class(1)==0)then !        !      print*, Process_id, \"imin master\" !        !      call MPI_SEND(imin_send_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD, ierr) !        !      call MPI_RECV(imin_recv_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD,status,ierr) !        !    else !        !      print*, Process_id, \"imin slave\" !        !      call MPI_RECV(imin_recv_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD,status,ierr) !        !      call MPI_SEND(imin_send_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD, ierr) !        !    end if !             ! distribute grid points !            if(dir_switch(1)==0)then !              count=0 !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_x(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_y(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_z(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do !            else !              count=0 !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_x(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_y(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_z(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do !            end if !          end if ! !          !--- IMAX ---! !          if(imax_id>=0)then !            !collect grid point in 1d array !            count=0 !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_x(imx-l,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_y(imx-l,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_z(imx-l,j,k) !                end do !              end do !            end do ! !        call MPI_SENDRECV(imax_send_buffer,count, MPI_DOUBLE_PRECISION, imax_id,1,& !                          imax_recv_buffer,count, MPI_DOUBLE_PRECISION, imax_id,1,& !                          MPI_COMM_WORLD,status,ierr) !        !    if(mpi_class(2)==0)then !        !      print*, Process_id, \"imax master\" !        !      call MPI_SEND(imax_send_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD, ierr) !        !      call MPI_RECV(imax_recv_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD,status,ierr) !        !    else !        !      print*, Process_id, \"imax slave\" !        !      call MPI_RECV(imax_recv_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD,status,ierr) !        !      call MPI_SEND(imax_send_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD, ierr) !        !    end if !             ! distribute grid points !            if(dir_switch(2)==0)then !              count=0 !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_x(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_y(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_z(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do !            else !              count=0 !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_x(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_y(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_z(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do !            end if !          end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_x ( i , l + 1 , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_y ( i , l + 1 , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_z ( i , l + 1 , k ) end do end do end do if ( mpi_class ( 3 ) == 0 ) then call MPI_SEND ( jmin_send_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( jmin_recv_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( jmin_recv_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( jmin_send_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 3 ) == 0 ) then count = 0 do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_x ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_y ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_z ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_x ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_y ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_z ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_x ( i , jmx - l , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_y ( i , jmx - l , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_z ( i , jmx - l , k ) end do end do end do if ( mpi_class ( 4 ) == 0 ) then call MPI_SEND ( jmax_send_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( jmax_recv_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( jmax_recv_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( jmax_send_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 4 ) == 0 ) then count = 0 do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_x ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_y ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_z ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_x ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_y ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_z ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_x ( i , j , 1 + l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_y ( i , j , 1 + l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_z ( i , j , 1 + l ) end do end do end do if ( mpi_class ( 5 ) == 0 ) then call MPI_SEND ( kmin_send_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( kmin_recv_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( kmin_recv_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( kmin_send_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 5 ) == 0 ) then count = 0 do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_x ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_y ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_z ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_x ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_y ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_z ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_x ( i , j , kmx - l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_y ( i , j , kmx - l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_z ( i , j , kmx - l ) end do end do end do if ( mpi_class ( 6 ) == 0 ) then call MPI_SEND ( kmax_send_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( kmax_recv_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( kmax_recv_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( kmax_send_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 6 ) == 0 ) then count = 0 do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_x ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_y ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_z ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_x ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_y ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_z ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do end if end if deallocate ( imin_send_buffer ) deallocate ( jmin_send_buffer ) deallocate ( kmin_send_buffer ) deallocate ( imin_recv_buffer ) deallocate ( jmin_recv_buffer ) deallocate ( kmin_recv_buffer ) deallocate ( imax_send_buffer ) deallocate ( jmax_send_buffer ) deallocate ( kmax_send_buffer ) deallocate ( imax_recv_buffer ) deallocate ( jmax_recv_buffer ) deallocate ( kmax_recv_buffer ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) call dmsg ( 1 , 'grid' , 'done with ghost_grid' ) end subroutine ghost_grid end module grid","tags":"","loc":"sourcefile/grid.f90.html","title":"grid.f90 – FEST-3D"},{"text":"Create and destroy the solver setup This file depends on sourcefile~~create_and_erase.f90~~EfferentGraph sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~bc.f90 bc.f90 sourcefile~create_and_erase.f90->sourcefile~bc.f90 sourcefile~read.f90 read.f90 sourcefile~create_and_erase.f90->sourcefile~read.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~time.f90 time.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~create_and_erase.f90->sourcefile~wall_dist.f90 sourcefile~wall.f90 wall.f90 sourcefile~create_and_erase.f90->sourcefile~wall.f90 sourcefile~global.f90 global.f90 sourcefile~create_and_erase.f90->sourcefile~global.f90 sourcefile~string.f90 string.f90 sourcefile~create_and_erase.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~create_and_erase.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~create_and_erase.f90->sourcefile~global_vars.f90 sourcefile~grid.f90 grid.f90 sourcefile~create_and_erase.f90->sourcefile~grid.f90 sourcefile~source.f90 source.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~layout.f90 layout.f90 sourcefile~create_and_erase.f90->sourcefile~layout.f90 sourcefile~state.f90 state.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~create_and_erase.f90->sourcefile~geometry.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~bc.f90->sourcefile~global_vars.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~gradients.f90->sourcefile~global_vars.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~global_vars.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~wall.f90->sourcefile~global_vars.f90 sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~grid.f90->sourcefile~global.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~state.f90->sourcefile~global_vars.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~read_bc.f90->sourcefile~global_vars.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~laminar_gradients.f90->sourcefile~utils.f90 sourcefile~laminar_gradients.f90->sourcefile~global_vars.f90 sourcefile~read_output.f90->sourcefile~global.f90 sourcefile~read_output.f90->sourcefile~string.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~read_output.f90->sourcefile~global_vars.f90 sourcefile~read_output.f90->sourcefile~check_outout_control.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~sst_gradients.f90->sourcefile~utils.f90 sourcefile~sst_gradients.f90->sourcefile~global_vars.f90 sourcefile~check_outout_control.f90->sourcefile~global_vars.f90 sourcefile~str_case.f90 str_case.f90 sourcefile~check_outout_control.f90->sourcefile~str_case.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~kkl_gradients.f90->sourcefile~utils.f90 sourcefile~kkl_gradients.f90->sourcefile~global_vars.f90 sourcefile~sa_gradients.f90->sourcefile~utils.f90 sourcefile~sa_gradients.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~lctm2015_gradients.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90->sourcefile~global_vars.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~read_output_tec.f90->sourcefile~global.f90 sourcefile~read_output_tec.f90->sourcefile~string.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90->sourcefile~global_vars.f90 sourcefile~read_output_tec.f90->sourcefile~global_sst.f90 sourcefile~str_case.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~string.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 var pansourcefilecreate_and_erasef90EfferentGraph = svgPanZoom('#sourcefilecreate_and_erasef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules create_and_erase Source Code create_and_erase.f90 Source Code !< Create and destroy the solver setup module create_and_erase !< Create and destroy the solver setup !----------------------------------------------------------- ! 170609  -Jatinder Pal Singh Sandhu ! AIM : 1)to setup, create, allocate memory, link pointer !         (everything that is required before first iteration !       2)free memory and free pointers !------------------------------------------------------------ use global , only : STOP_FILE_UNIT use global , only : stop_file use global_vars , only : n_var use global_vars , only : sst_n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : qp_n use global_vars , only : dEdx_1 use global_vars , only : dEdx_2 use global_vars , only : dEdx_3 use global_vars , only : resnorm , resnorm_0 use global_vars , only : cont_resnorm , cont_resnorm_0 use global_vars , only : x_mom_resnorm , x_mom_resnorm_0 use global_vars , only : y_mom_resnorm , y_mom_resnorm_0 use global_vars , only : z_mom_resnorm , z_mom_resnorm_0 use global_vars , only : energy_resnorm , energy_resnorm_0 use global_vars , only : write_percision use global_vars , only : CFL use global_vars , only : tolerance use global_vars , only : min_iter use global_vars , only : max_iters use global_vars , only : current_iter use global_vars , only : checkpoint_iter use global_vars , only : checkpoint_iter_count use global_vars , only : time_stepping_method use global_vars , only : time_step_accuracy use global_vars , only : global_time_step use global_vars , only : delta_t use global_vars , only : sim_clock use global_vars , only : turbulence use global_vars , only : supersonic_flag use global_vars , only : r_list use global_vars , only : w_list use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use string use read , only : read_input_and_controls use grid , only : setup_grid use grid , only : destroy_grid use geometry , only : setup_geometry use geometry , only : destroy_geometry use state , only : setup_state use state , only : destroy_state use gradients , only : setup_gradients use gradients , only : destroy_gradients use scheme , only : setup_scheme use scheme , only : destroy_scheme use source , only : add_source_term_residue use wall_dist , only : setup_wall_dist use wall_dist , only : destroy_wall_dist use wall_dist , only : find_wall_dist use layout , only : process_id use layout , only : grid_file_buf use layout , only : bc_file use layout , only : get_process_data use layout , only : read_layout_file use layout , only : total_process use parallel , only : allocate_buffer_cells use resnorm_ , only : destroy_resnorm use resnorm_ , only : setup_resnorm use transport , only : setup_transport use transport , only : destroy_transport use bc , only : setup_bc use blending_function , only : setup_sst_F1 use blending_function , only : destroy_sst_F1 use wall , only : write_surfnode use time , only : setup_time use time , only : destroy_time private public :: setup_all public :: destroy_all contains subroutine setup_all () !< To setup, create, allocate memory, link pointer !<    (everything that is required before first iteration implicit none call dmsg ( 1 , 'create_erase' , 'setup_all' ) call get_process_data () ! parallel calls call read_layout_file ( process_id ) ! reads layout file calls call read_input_and_controls () ! all input config file are read call setup_grid ( grid_file_buf ) ! read grid call setup_geometry () ! calculate geometric quantities (area, normal and volume) call setup_state () ! allocate memroy and initialize state variable call setup_transport () ! allocate memroy to viscosity call setup_gradients () ! allocate memroy to gradients call setup_bc () ! set id and face_names array call allocate_memory () call allocate_buffer_cells ( 3 ) ! parallel buffers (MPI interafce communication) call setup_scheme () ! face convective flux: memory and scheme if ( turbulence /= 'none' ) then call write_surfnode () call setup_wall_dist () call find_wall_dist () end if call setup_sst_F1 () call link_aliases_solver () call setup_resnorm () call initmisc () checkpoint_iter_count = 0 call checkpoint () ! Create an initial dump file call setup_time () call dmsg ( 5 , 'create_erase' , 'setup_all' , 'Setup complete' ) end subroutine setup_all subroutine destroy_all () !< Free memory and free pointers implicit none call dmsg ( 1 , 'create_erase' , 'destroy_all' ) call destroy_time () call destroy_transport () call destroy_gradients () call destroy_wall_dist () call destroy_scheme () call deallocate_misc () call unlink_aliases_solver () call destroy_state () call destroy_geometry () call destroy_grid () call destroy_resnorm () call destroy_sst_F1 () if ( allocated ( r_list )) deallocate ( r_list ) if ( allocated ( w_list )) deallocate ( w_list ) call dmsg ( 5 , 'create_erase' , 'destroy_all' , 'Memory_freed' ) end subroutine destroy_all end module create_and_erase","tags":"","loc":"sourcefile/create_and_erase.f90.html","title":"create_and_erase.f90 – FEST-3D"},{"text":"Matix-free time integration: LU-SGS This file depends on sourcefile~~lusgs.f90~~EfferentGraph sourcefile~lusgs.f90 lusgs.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~lusgs.f90->sourcefile~geometry.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~lusgs.f90->sourcefile~mapping.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~lusgs.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~lusgs.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~lusgs.f90~~AfferentGraph sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules lusgs Source Code lusgs.f90 Source Code !< Matix-free time integration: LU-SGS module lusgs !< !< Reference: Sharov, D., Luo, H., Baum, J., and Loehner, R., !< “Implementation of unstructured grid GMRES+LU-SGS method on !< shared-memory, cache-based parallel computers,” !< 38th Aerospace Sciences Meeting and Exhibit, vol. 927, 2000, p. 2000. use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : sigma_sa use global_sa , only : cb1 use global_sa , only : cb2 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : sigma_sa use global_sa , only : kappa_sa use global_sa , only : cv1_3 use global_sa , only : cw3_6 use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : R_gas use global_vars , only : Pr use global_vars , only : tPr use global_vars , only : DCCVnX use global_vars , only : DCCVnY use global_vars , only : DCCVnZ use global_vars , only : CCnormalX use global_vars , only : CCnormalY use global_vars , only : CCnormalZ use global_vars , only : volume use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : n_var use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gm use global_vars , only : sst_n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : dist use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : tk_inf use global_vars , only : tkl_inf use global_vars , only : free_stream_tu use global_vars , only : tk use global_vars , only : tw use global_vars , only : delta_t use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : Reynolds_number use global_vars , only : process_id use global_vars , only : F_p use global_vars , only : G_p use global_vars , only : H_p use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : omega_residue use global_vars , only : kl_residue use global_vars , only : residue use global_vars , only : mu_ref use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use geometry , only : CellCenter use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use utils , only : DEBUG_LEVEL use string !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use global_kkl , only : sigma_k use global_kkl , only : sigma_phi !-------mapping --------------! use mapping , only : PiDir use mapping , only : PjDir use mapping , only : PkDir use mapping , only : Pilo use mapping , only : Pjlo use mapping , only : Pklo use mapping , only : Pihi use mapping , only : Pjhi use mapping , only : Pkhi use mapping , only : mpi_class use global_vars , only : imin_id use global_vars , only : jmin_id use global_vars , only : kmin_id use global_vars , only : imax_id use global_vars , only : jmax_id use global_vars , only : kmax_id use global_vars , only : dir_switch use global_vars , only : PbcId #include \"error.inc\" #include \"mpi.inc\" real , dimension (:,:,:,:), allocatable :: delQ !< change of state variable (solution) over one time-step real , dimension (:,:,:,:), allocatable :: delQstar !< Intermediate change of state variable over one time-step real , dimension (:,:,:), allocatable , target :: dummy !< dummy variable real , dimension (:,:,:), pointer :: tmu !< Pionter to turbulent viscosity real , dimension (:,:,:), pointer :: mmu !< Pointer to molecular viscosity !parallel communication integer :: ibuf_size !< size of the buffer for I face interface integer :: jbuf_size !< size of the buffer for J face interface integer :: kbuf_size !< size of the buffer for K face interface real , dimension (:), allocatable :: imin_send_buf !< Array to store data to send data for Imin face real , dimension (:), allocatable :: jmin_send_buf !< Array to store data to send data for Jmin face real , dimension (:), allocatable :: kmin_send_buf !< Array to store data to send data for Kmin face real , dimension (:), allocatable :: imin_recv_buf !< Array to store data to receive data for Imin face real , dimension (:), allocatable :: jmin_recv_buf !< Array to store data to receive data for Jmin face real , dimension (:), allocatable :: kmin_recv_buf !< Array to store data to receive data for Kmin face real , dimension (:), allocatable :: imax_send_buf !< Array to store data to send data for Imax face real , dimension (:), allocatable :: jmax_send_buf !< Array to store data to send data for Jmax face real , dimension (:), allocatable :: kmax_send_buf !< Array to store data to send data for Kmax face real , dimension (:), allocatable :: imax_recv_buf !< Array to store data to receive data for Imax face real , dimension (:), allocatable :: jmax_recv_buf !< Array to store data to receive data for Jmax face real , dimension (:), allocatable :: kmax_recv_buf !< Array to store data to receive data for Kmax face public :: update_with_lusgs public :: setup_lusgs public :: destroy_lusgs contains subroutine setup_lusgs () !< allocate array memory for data communication implicit none character ( len =* ), parameter :: & errmsg = \"module: LUSGS, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * 1 jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * 1 kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * 1 call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_lusgs subroutine destroy_lusgs () !< unallocate the memory required by LU-SGS module implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) call dealloc ( delQ ) call dealloc ( delQstar ) call dealloc ( dummy ) end subroutine destroy_lusgs subroutine update_with_lusgs () !< Time-integrate with LU_SGS method implicit none select case ( trim ( turbulence )) case ( 'none' ) call update_laminar_variables () case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' , 'bc' ) call update_SST_variables () case ( 'lctm2015' ) call update_lctm2015 () case DEFAULT Fatal_error end select case ( 'kkl' ) call update_KKL_variables () case ( 'sa' , 'saBC' ) call update_SA_variables () case Default Fatal_error end select end subroutine update_with_lusgs subroutine update_laminar_variables () !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k real , dimension ( 1 : 5 ) :: deltaU real :: D real , dimension ( 1 : 5 ) :: conservativeQ real , dimension ( 1 : 5 ) :: OldIminusFlux real , dimension ( 1 : 5 ) :: OldJminusFlux real , dimension ( 1 : 5 ) :: OldKminusFlux real , dimension ( 1 : 5 ) :: NewIminusFlux real , dimension ( 1 : 5 ) :: NewJminusFlux real , dimension ( 1 : 5 ) :: NewKminusFlux real , dimension ( 1 : 5 ) :: DelIminusFlux real , dimension ( 1 : 5 ) :: DelJminusFlux real , dimension ( 1 : 5 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 5 ) :: Q0 ! state at cell real , dimension ( 1 : 5 ) :: Q1 ! state at neighbours real , dimension ( 1 : 5 ) :: Q2 real , dimension ( 1 : 5 ) :: Q3 real , dimension ( 1 : 5 ) :: Q4 real , dimension ( 1 : 5 ) :: Q5 real , dimension ( 1 : 5 ) :: Q6 real , dimension ( 1 : 5 ) :: DQ0 ! change in state real , dimension ( 1 : 5 ) :: DQ1 real , dimension ( 1 : 5 ) :: DQ2 real , dimension ( 1 : 5 ) :: DQ3 real , dimension ( 1 : 5 ) :: DQ4 real , dimension ( 1 : 5 ) :: DQ5 real , dimension ( 1 : 5 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 5 ) = - residue ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables function Flux ( ql , qr , du , inputs ) !< calculate the total flux through face for laminar flow. !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux function SpectralRadius ( ql , qr , inputs , c1 , c2 ) !< Calculate the spectral radius implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql real , dimension ( 1 : n_var ), intent ( in ) :: qr real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : 3 ) , intent ( in ) :: c1 real , dimension ( 1 : 3 ) , intent ( in ) :: c2 ! local variables real :: SpectralRadius real :: NormalSpeed real :: SpeedOfSound real :: vis real :: mu real :: rho real :: distance !extract inputs real :: Area real :: nx real :: ny real :: nz real :: volume real :: mm real :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( NormalSpeed + SpeedOfSound + vis ) * Area end function SpectralRadius subroutine update_SST_variables () !< Update the RANS (SST) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: De , Dp real :: Fpg real :: dvdy real :: lamd real :: intermittency De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - ( residue ( i , j , k , 1 : 7 )) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables function SSTFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SST) implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SSTFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux subroutine update_KKL_variables () !< Update the RANS (k-kL) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = KKLFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = KKLFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = KKLFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = KKLFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = KKLFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * volume ( i , j , k ) / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - residue ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = KKLFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = KKLFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = KKLFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = KKLFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = KKLFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * volume ( i , j , k ) / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) qp ( i , j , k , 7 ) = max ( qp ( i , j , k , 7 ), 1.e-8 ) end do end do end do end subroutine update_KKL_variables function KKLFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (k-kL) implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: KKLFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtkldx real :: dtkldy real :: dtkldz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) W ( 7 ) = max ( W ( 7 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtkldx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtkldy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtkldz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_phi * tmu ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ) Flux = Flux * Area KKLFlux = Flux end function KKLFlux subroutine update_SA_variables () !< Update the RANS (SA) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 6 ) :: deltaU real , dimension ( 1 : 6 ) :: D real , dimension ( 1 : 6 ) :: conservativeQ real , dimension ( 1 : 6 ) :: OldIminusFlux real , dimension ( 1 : 6 ) :: OldJminusFlux real , dimension ( 1 : 6 ) :: OldKminusFlux real , dimension ( 1 : 6 ) :: NewIminusFlux real , dimension ( 1 : 6 ) :: NewJminusFlux real , dimension ( 1 : 6 ) :: NewKminusFlux real , dimension ( 1 : 6 ) :: DelIminusFlux real , dimension ( 1 : 6 ) :: DelJminusFlux real , dimension ( 1 : 6 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 6 ) :: Q0 ! state at cell real , dimension ( 1 : 6 ) :: Q1 ! state at neighbours real , dimension ( 1 : 6 ) :: Q2 real , dimension ( 1 : 6 ) :: Q3 real , dimension ( 1 : 6 ) :: Q4 real , dimension ( 1 : 6 ) :: Q5 real , dimension ( 1 : 6 ) :: Q6 real , dimension ( 1 : 6 ) :: DQ0 ! change in state real , dimension ( 1 : 6 ) :: DQ1 real , dimension ( 1 : 6 ) :: DQ2 real , dimension ( 1 : 6 ) :: DQ3 real , dimension ( 1 : 6 ) :: DQ4 real , dimension ( 1 : 6 ) :: DQ5 real , dimension ( 1 : 6 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: nu_t real :: glim real :: g_6 real :: gamma_BC real :: dfv1 real :: dfv2 real :: dfw real :: dShat real :: dr real :: dg !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! deltaU ( 1 : 6 ) = - residue ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do !call apply_interface(delQstar, 1) delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables function SAFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SA) !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SAFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtvdx real :: dtvdy real :: dtvdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux subroutine update_lctm2015 () !< Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 8 ) :: deltaU real , dimension ( 1 : 8 ) :: D real , dimension ( 1 : 8 ) :: conservativeQ real , dimension ( 1 : 8 ) :: OldIminusFlux real , dimension ( 1 : 8 ) :: OldJminusFlux real , dimension ( 1 : 8 ) :: OldKminusFlux real , dimension ( 1 : 8 ) :: NewIminusFlux real , dimension ( 1 : 8 ) :: NewJminusFlux real , dimension ( 1 : 8 ) :: NewKminusFlux real , dimension ( 1 : 8 ) :: DelIminusFlux real , dimension ( 1 : 8 ) :: DelJminusFlux real , dimension ( 1 : 8 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 8 ) :: Q0 ! state at cell real , dimension ( 1 : 8 ) :: Q1 ! state at neighbours real , dimension ( 1 : 8 ) :: Q2 real , dimension ( 1 : 8 ) :: Q3 real , dimension ( 1 : 8 ) :: Q4 real , dimension ( 1 : 8 ) :: Q5 real , dimension ( 1 : 8 ) :: Q6 real , dimension ( 1 : 8 ) :: DQ0 ! change in state real , dimension ( 1 : 8 ) :: DQ1 real , dimension ( 1 : 8 ) :: DQ2 real , dimension ( 1 : 8 ) :: DQ3 real , dimension ( 1 : 8 ) :: DQ4 real , dimension ( 1 : 8 ) :: DQ5 real , dimension ( 1 : 8 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: Dp , De Dp = 0.0 De = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - residue ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) !              qp(i,j,k,6) = conservativeQ(6) / conservativeQ(1) !              qp(i,j,k,7) = conservativeQ(7) / conservativeQ(1) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015 function lctm2015flux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent/transition flow (LCTM2015) !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: lctm2015flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: dtgmdx real :: dtgmdy real :: dtgmdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux subroutine apply_interface ( qp , layers ) implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( delQstar , 1 ) end subroutine apply_interface subroutine apply_periodic_bc ( qp , layers ) implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc end module lusgs","tags":"","loc":"sourcefile/lusgs.f90.html","title":"lusgs.f90 – FEST-3D"},{"text":"This module contains subroutine that \n 1. check if time for resnorm dump is arrived\n 2. calculate resnorm\n 3. send those resnorm to processor number 0\n 4. Recalulate resnorm based on information \n    availble from all processors\n 5. Append the data to resnorm file This file depends on sourcefile~~resnorm.f90~~EfferentGraph sourcefile~resnorm.f90 resnorm.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~resnorm.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~resnorm.f90->sourcefile~global.f90 sourcefile~utils.f90 utils.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~resnorm.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~resnorm.f90->sourcefile~string.f90 sourcefile~layout.f90 layout.f90 sourcefile~resnorm.f90->sourcefile~layout.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~resnorm.f90~~AfferentGraph sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules resnorm Source Code resnorm.f90 Source Code !< This module contains subroutine that !< 1. check if time for resnorm dump is arrived !< 2. calculate resnorm !< 3. send those resnorm to processor number 0 !< 4. Recalulate resnorm based on information !<    availble from all processors !< 5. Append the data to resnorm file module resnorm !< This module contains subroutine that !< 1. check if time for resnorm dump is arrived !< 2. calculate resnorm !< 3. send those resnorm to processor number 0 !< 4. Recalulate resnorm based on information !<    availble from all processors !< 5. Append the data to resnorm file !---------------------------------------------------- use global , only : RESNORM_FILE_UNIT use global , only : resnorm_file use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gm use global_vars , only : n_var use global_vars , only : density_inf use global_vars , only : vel_mag use global_vars , only : pressure_inf use global_vars , only : tk_inf use global_vars , only : tw_inf use global_vars , only : tkl_inf use global_vars , only : te_inf use global_vars , only : tv_inf use global_vars , only : current_iter use global_vars , only : res_write_interval use global_vars , only : write_percision use global_vars , only : Res_abs use global_vars , only : Res_rel use global_vars , only : Res_save use global_vars , only : Res_scale use global_vars , only : Res_count use global_vars , only : Res_list use global_vars , only : Res_itr use global_vars , only : turbulence use global_vars , only : residue use global_vars , only : start_from use global_vars , only : last_iter use global_vars , only : F_p use global_vars , only : G_p use global_vars , only : H_p use utils , only : dmsg use utils , only : dealloc use utils , only : alloc use layout , only : process_id use layout , only : total_process use string use fclose , only : close_file #include \"error.inc\" #include \"mpi.inc\" private real :: merror real , dimension (:), allocatable :: buffer public :: setup_resnorm public :: destroy_resnorm public :: find_resnorm contains subroutine setup_resnorm () !< Allocate memory, setup scale and file to write implicit none call allocate_memory () call setup_scale () call setup_file () end subroutine setup_resnorm subroutine find_resnorm () !< Find the normalized residual for each processor implicit none call get_absolute_resnorm () call collect_resnorm_from_all_blocks () call assemble_resnom_at_each_process () call get_relative_resnorm () if (( mod ( current_iter , res_write_interval ) == 0 . or . & current_iter == Res_itr . or . & current_iter == 1 ) . and . & process_id == 0 ) then call write_resnorm () end if end subroutine find_resnorm subroutine destroy_resnorm () !< Deallocate memory and close residual file implicit none call deallocate_memory () call close_file ( RESNORM_FILE_UNIT ) end subroutine destroy_resnorm subroutine setup_file () !< Open the residual file to write implicit none integer :: i if ( process_id == 0 ) then if ( start_from == 0 ) then open ( RESNORM_FILE_UNIT , file = resnorm_file ) else open ( RESNORM_FILE_UNIT , file = resnorm_file , status = 'old' , position = 'append' , action = 'write' ) end if write ( RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) \"Iteration\" do i = 1 , Res_count write ( RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) trim ( Res_list ( i )) end do write ( RESNORM_FILE_UNIT , * ) end if end subroutine setup_file subroutine allocate_memory () !< Allocate memory to MPI Communication implicit none call alloc ( Res_abs , 0 , n_var ) call alloc ( Res_rel , 0 , n_var ) call alloc ( Res_scale , 0 , n_var ) call alloc ( Res_save , 0 , n_var ) call alloc ( buffer , 1 ,( n_var + 1 ) * total_process ) end subroutine allocate_memory subroutine deallocate_memory () !< Deallocate memory required for MPI Communication implicit none call dealloc ( Res_abs ) call dealloc ( Res_rel ) call dealloc ( Res_scale ) call dealloc ( Res_save ) call dealloc ( buffer ) if ( allocated ( Res_list )) deallocate ( Res_list ) end subroutine deallocate_memory subroutine setup_scale () !< Setup scale required for relative and absolute !< residual for writing in the file. implicit none Res_scale ( 0 ) = 1. Res_scale ( 1 ) = density_inf * vel_mag Res_scale ( 2 ) = density_inf * vel_mag * vel_mag Res_scale ( 3 ) = density_inf * vel_mag * vel_mag Res_scale ( 4 ) = density_inf * vel_mag * vel_mag Res_scale ( 5 ) = ( 0.5 * density_inf * vel_mag ** 3 + & (( gm / ( gm - 1. )) * pressure_inf )) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'kkl' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tkl_inf case ( 'des' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'sa' , 'saBC' ) Res_scale ( 6 ) = density_inf * vel_mag * tv_inf case ( 'kw' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'ke' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * te_inf case DEFAULT Fatal_error end select end subroutine setup_scale subroutine get_absolute_resnorm () !< Get absolute residual for current process implicit none integer :: i do i = 1 , n_var Res_abs ( i ) = ( sum ( Residue (:,:,:, i ) ** 2 ) / Res_scale ( i ) ** 2 ) end do merror = ( & sum ( F_p ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 )) & - sum ( F_p ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 )) & + sum ( G_p ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 )) & - sum ( G_p ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 )) & + sum ( H_p ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 )) & - sum ( H_p ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 )) & ) Res_abs ( 0 ) = ( merror / Res_scale ( 0 )) end subroutine get_absolute_resnorm subroutine collect_resnorm_from_all_blocks () !< MPI Communication to gather residual from all processes implicit none integer :: ierr call MPI_ALLGATHER ( Res_abs , n_var + 1 , MPI_DOUBLE_PRECISION , & buffer , n_var + 1 , MPI_DOUBLE_PRECISION , MPI_COMM_WORLD , ierr ) end subroutine collect_resnorm_from_all_blocks subroutine assemble_resnom_at_each_process () !< Sum residual obtained from all the processes after MPI_Communication implicit none integer :: i , j Res_abs = 0. do i = 0 , total_process - 1 do j = 0 , n_var Res_abs ( j ) = Res_abs ( j ) + buffer (( j + 1 ) + ( n_var + 1 ) * i ) end do end do Res_abs ( 1 :) = sqrt ( Res_abs ( 1 :)) Res_abs ( 0 ) = abs ( Res_abs ( 0 )) end subroutine assemble_resnom_at_each_process subroutine get_relative_resnorm () !< Get relative residual with respect to first iteration residual implicit none if ( current_iter <= Res_itr ) Res_save = Res_abs Res_rel = Res_abs / Res_save end subroutine get_relative_resnorm subroutine write_resnorm () !< Writing the residual in the file to save. implicit none integer :: i integer :: n = 6 character ( len = 20 ) :: frm n = write_percision write ( frm , '(A,I0,A,I0,A)' ) \"(e\" , n + 8 , \".\" , n , \"E2, 4x)\" write ( RESNORM_FILE_UNIT , '(I0,4x)' , advance = 'no' ) current_iter + last_iter do i = 1 , Res_count select case ( trim ( Res_list ( i ))) !include \"resnorm_write_cases.inc\" case ( 'Mass_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 0 ) case ( 'Resnorm_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) if ( trim ( turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 6 :) ** 2 )) end if case ( 'Continuity_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 1 ) case ( 'X_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 2 ) case ( 'Y_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 3 ) case ( 'Z_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 4 ) case ( 'Energy_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 5 ) case ( 'Mass_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 0 ) case ( 'Resnorm_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) if ( trim ( turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 6 :) ** 2 )) end if case ( 'Continuity_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 1 ) case ( 'X-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 2 ) case ( 'Y-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 3 ) case ( 'Z-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 4 ) case ( 'Energy_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 5 ) case ( 'TKE_abs' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'kkl' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Tv_abs' ) if ( trim ( turbulence ) == 'sa' . or . trim ( turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Dissipation_abs' ) if ( trim ( turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Omega_abs' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Kl_abs' ) if ( trim ( turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'TKE_rel' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'kkl' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Tv_rel' ) if ( trim ( turbulence ) == 'sa' . or . trim ( turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Dissipation_rel' ) if ( trim ( turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Omega_rel' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Kl_rel' ) if ( trim ( turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case DEFAULT ! making absolute resnorm default write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select end do write ( RESNORM_FILE_UNIT , * ) end subroutine write_resnorm end module resnorm","tags":"","loc":"sourcefile/resnorm.f90.html","title":"resnorm.f90 – FEST-3D"},{"text":"This file depends on sourcefile~~solver.f90~~EfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~solver.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~solver.f90->sourcefile~global_vars.f90 sourcefile~layout.f90 layout.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~source.f90 source.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~utils.f90 utils.f90 sourcefile~solver.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~string.f90 string.f90 sourcefile~solver.f90->sourcefile~string.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~global.f90 global.f90 sourcefile~solver.f90->sourcefile~global.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~wall.f90->sourcefile~global_vars.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~global_vars.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~global_vars.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~global_vars.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~viscous2.f90->sourcefile~global_vars.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~state.f90->sourcefile~global_vars.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~gradients.f90->sourcefile~global_vars.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~wall_dist.f90->sourcefile~global_vars.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~resnorm.f90->sourcefile~global_vars.f90 sourcefile~resnorm.f90->sourcefile~layout.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~resnorm.f90->sourcefile~string.f90 sourcefile~resnorm.f90->sourcefile~global.f90 sourcefile~resnorm.f90->sourcefile~fclose.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~bc.f90->sourcefile~global_vars.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_vars.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~bc_primitive.f90->sourcefile~global_vars.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~update.f90->sourcefile~global_vars.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~geometry.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~string.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global_vars.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global.f90 var pansourcefilesolverf90EfferentGraph = svgPanZoom('#sourcefilesolverf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~solver.f90~~AfferentGraph sourcefile~solver.f90 solver.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules solver Source Code solver.f90 Source Code module solver !< Setup, run, and destroy the solver !< allocate/deallcoate memory, initialize, iterate !------------------------------------------------- use global , only : STOP_FILE_UNIT use global , only : stop_file use global_vars , only : want_to_stop use global_vars , only : Halt use global_vars , only : max_iters use global_vars , only : current_iter use global_vars , only : checkpoint_iter use global_vars , only : checkpoint_iter_count use global_vars , only : sim_clock use global_vars , only : turbulence use global_vars , only : supersonic_flag use global_vars , only : res_write_interval use global_vars , only : r_list use global_vars , only : w_list use global_vars , only : Res_itr use utils , only : dmsg use CC , only : setupCC use CC , only : destroyCC use string use read , only : read_input_and_controls use grid , only : setup_grid , destroy_grid use geometry , only : setup_geometry , destroy_geometry use state , only : setup_state , destroy_state use gradients , only : setup_gradients use gradients , only : destroy_gradients use Scheme , only : setup_scheme , destroy_scheme use source , only : add_source_term_residue , setup_source , destroy_source use wall_dist , only : setup_wall_dist , destroy_wall_dist , find_wall_dist use viscous , only : compute_viscous_fluxes use layout , only : process_id , grid_file_buf , bc_file , & get_process_data , read_layout_file , total_process use interface1 , only : setup_interface use interface1 , only : destroy_interface use resnorm , only : find_resnorm , setup_resnorm , destroy_resnorm use dump_solution , only : checkpoint use viscosity , only : setup_viscosity use viscosity , only : destroy_viscosity use viscosity , only : calculate_viscosity use wall , only : write_surfnode use bc , only : setup_bc use bc , only : destroy_bc use time , only : setup_time use time , only : destroy_time use time , only : compute_time_step use update , only : get_next_solution use update , only : setup_update use update , only : destroy_update use mapping , only : read_interface_map use bc_primitive , only : populate_ghost_primitive use summon_grad_evaluation , only : evaluate_all_gradients use boundary_state_reconstruction , only : reconstruct_boundary_state #include \"error.inc\" #include \"mpi.inc\" private ! Public methods public :: setup_solver public :: destroy_solver public :: iterate_one_more_time_step contains subroutine setup_solver () !< Call to allocate memoery and initialize domain !-------------------------------------------------- implicit none integer :: ierr call dmsg ( 1 , 'solver' , 'setup_solver' ) call get_process_data () ! parallel calls call read_layout_file ( process_id ) ! reads layout file calls call read_input_and_controls () call setup_grid ( grid_file_buf ) call setup_geometry () call setup_viscosity () call setup_state () call setup_gradients () call setup_source call setup_bc () call setup_time () call setup_update () call setup_interface () call setup_scheme () if ( turbulence /= 'none' ) then call write_surfnode () call setup_wall_dist () call mpi_barrier ( MPI_COMM_WORLD , ierr ) call find_wall_dist () end if call setupCC () call setup_resnorm () call initmisc () checkpoint_iter_count = 0 call checkpoint () ! Create an initial dump file current_iter = 1 call dmsg ( 1 , 'solver' , 'setup_solver' , 'checkpoint' ) if ( process_id == 0 ) then open ( STOP_FILE_UNIT , file = stop_file ) end if call dmsg ( 1 , 'solver' , 'setup_solver' , 'Setup solver complete' ) end subroutine setup_solver subroutine destroy_solver () !< Call to different modules to deallocate memory !-------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'destroy_solver' ) if ( process_id == 0 ) then close ( STOP_FILE_UNIT ) end if call destroy_update () call destroy_viscosity () call destroy_gradients () call destroyCC () if ( turbulence /= 'none' ) then call destroy_wall_dist () end if call destroy_scheme () call destroy_source () call destroy_state () call destroy_geometry () call destroy_grid () call destroy_resnorm () call destroy_interface () call destroy_time () call destroy_bc () if ( allocated ( r_list )) deallocate ( r_list ) if ( allocated ( w_list )) deallocate ( w_list ) end subroutine destroy_solver subroutine initmisc () !< Initilize miscellaneous variables !---------------------------------- implicit none call dmsg ( 1 , 'solver' , 'initmisc' ) sim_clock = 0. current_iter = 0 end subroutine initmisc subroutine iterate_one_more_time_step () !< Perform one time step iteration !  This subroutine performs one iteration by stepping through !  time once. !----------------------------------------------------------- implicit none integer :: ierr call dmsg ( 1 , 'solver' , 'iterate_one_more_time_step' ) if ( process_id == 0 ) then print * , current_iter end if call get_next_solution () if (( mod ( current_iter , res_write_interval ) == 0 . or . & current_iter == Res_itr . or . & current_iter == 1 )) then call find_resnorm () end if call checkpoint () current_iter = current_iter + 1 if ( process_id == 0 ) then REWIND ( STOP_FILE_UNIT ) read ( STOP_FILE_UNIT , * ) want_to_stop end if call MPI_BCAST ( want_to_stop , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) !if (want_to_stop==1) max_iters=current_iter-1 if ( want_to_stop == 1 ) Halt = . TRUE . end subroutine iterate_one_more_time_step end module solver","tags":"","loc":"sourcefile/solver.f90.html","title":"solver.f90 – FEST-3D"},{"text":"Setup the indicies map at interface between two blocks This file depends on sourcefile~~mapping.f90~~EfferentGraph sourcefile~mapping.f90 mapping.f90 sourcefile~string.f90 string.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~mapping.f90~~AfferentGraph sourcefile~mapping.f90 mapping.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~mapping.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~grid.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~lusgs.f90 var pansourcefilemappingf90AfferentGraph = svgPanZoom('#sourcefilemappingf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules mapping Source Code mapping.f90 Source Code !< Setup the indicies map at interface between two blocks module mapping !< Setup the indicies map at interface between two blocks use global , only : MAP_FILE_UNIT use global , only : mapfile use global , only : PERIODIC_FILE_UNIT use global , only : periodicfile use global_vars , only : total_process use global_vars , only : process_id use global_vars , only : PbcId use utils , only : DEBUG_LEVEL use utils , only : dmsg use string use fclose , only : close_file !map variablews use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : otherface use global_vars , only : dir_switch use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id implicit none private integer , dimension ( 6 ), private :: ilo !< Read Lowest index of I direction integer , dimension ( 6 ), private :: jlo !< Read Lowest index of J direction integer , dimension ( 6 ), private :: klo !< Read Lowest index of K direction integer , dimension ( 6 ), private :: ihi !< Read Highest index of I direction integer , dimension ( 6 ), private :: jhi !< Read Highest index of J direction integer , dimension ( 6 ), private :: khi !< Read Highest index of K direction integer , dimension ( 6 ), public :: Pilo !< Modified lowest index of I direction integer , dimension ( 6 ), public :: Pjlo !< Modified lowest index of J direction integer , dimension ( 6 ), public :: Pklo !< Modified lowest index of K direction integer , dimension ( 6 ), public :: Pihi !< Modified Highest index of I direction integer , dimension ( 6 ), public :: Pjhi !< Modified Highest index of J direction integer , dimension ( 6 ), public :: Pkhi !< Modified Highest index of K direction integer , dimension ( 6 ), public :: PiDir !< Switch for communication direction from !< (low-high) to (hight-low) for I direction integer , dimension ( 6 ), public :: PjDir !< Switch for communication direction from !< (low-high) to (hight-low) for J direction integer , dimension ( 6 ), public :: PkDir !< Switch for communication direction from !< (low-high) to (hight-low) for K direction integer , dimension ( 6 ), public :: Gilo !< Modified lowest index of I direction for Grid data exchange integer , dimension ( 6 ), public :: Gjlo !< Modified lowest index of J direction for Grid data exchange integer , dimension ( 6 ), public :: Gklo !< Modified lowest index of K direction for Grid data exchange integer , dimension ( 6 ), public :: Gihi !< Modified highest index of I direction for Grid data exchange integer , dimension ( 6 ), public :: Gjhi !< Modified highest index of J direction for Grid data exchange integer , dimension ( 6 ), public :: Gkhi !< Modified highest index of K direction for Grid data exchange integer , dimension ( 6 ), public :: mpi_class =- 1 !< Class flag for master or slave public :: read_interface_map contains subroutine read_interface_map () !< Read mapping file in the system/mesh/layout/mapping.txt implicit none integer :: ios integer :: max_call integer :: i integer :: b1 , b2 , f1 , f2 integer :: s11 , s12 , s21 , s22 integer :: e11 , e12 , e21 , e22 integer :: switch integer :: class !--- initialize indicies --! max_call = total_process * 6 ilo ( 1 ) = 1 ; ihi ( 1 ) = 1 ilo ( 2 ) = imx ; ihi ( 2 ) = imx ilo ( 3 ) = 1 ; ihi ( 3 ) = imx ilo ( 4 ) = 1 ; ihi ( 4 ) = imx ilo ( 5 ) = 1 ; ihi ( 5 ) = imx ilo ( 6 ) = 1 ; ihi ( 6 ) = imx jlo ( 1 ) = 1 ; jhi ( 1 ) = jmx jlo ( 2 ) = 1 ; jhi ( 2 ) = jmx jlo ( 3 ) = 1 ; jhi ( 3 ) = 1 jlo ( 4 ) = jmx ; jhi ( 4 ) = jmx jlo ( 5 ) = 1 ; jhi ( 5 ) = jmx jlo ( 6 ) = 1 ; jhi ( 6 ) = jmx klo ( 1 ) = 1 ; khi ( 1 ) = kmx klo ( 2 ) = 1 ; khi ( 2 ) = kmx klo ( 3 ) = 1 ; khi ( 3 ) = kmx klo ( 4 ) = 1 ; khi ( 4 ) = kmx klo ( 5 ) = 1 ; khi ( 5 ) = 1 klo ( 6 ) = kmx ; khi ( 6 ) = kmx otherface ( 1 ) = 2 otherface ( 2 ) = 1 otherface ( 3 ) = 4 otherface ( 4 ) = 3 otherface ( 5 ) = 6 otherface ( 6 ) = 5 dir_switch = 0 !--- end of variable intializaiton --! !--- reading map file  ---! open ( MAP_FILE_UNIT , file = mapfile , status = 'old' , action = 'read' ) read ( MAP_FILE_UNIT , * ) ! ignore header do i = 1 , max_call read ( MAP_FILE_UNIT , * , iostat = ios ) b1 , f1 , s11 , e11 , s12 , e12 ,& b2 , f2 , s21 , e21 , s22 , e22 , switch , class if ( is_iostat_end ( ios )) EXIT if ( b1 == process_id ) then if ( f1 == 1 ) then otherface ( 1 ) = f2 jlo ( 1 ) = s21 jhi ( 1 ) = e21 klo ( 1 ) = s22 khi ( 1 ) = e22 dir_switch ( 1 ) = switch mpi_class ( 1 ) = class elseif ( f1 == 2 ) then otherface ( 2 ) = f2 jlo ( 2 ) = s21 jhi ( 2 ) = e21 klo ( 2 ) = s22 khi ( 2 ) = e22 dir_switch ( 2 ) = switch mpi_class ( 2 ) = class elseif ( f1 == 3 ) then otherface ( 3 ) = f2 ilo ( 3 ) = s21 ihi ( 3 ) = e21 klo ( 3 ) = s22 khi ( 3 ) = e22 dir_switch ( 3 ) = switch mpi_class ( 3 ) = class elseif ( f1 == 4 ) then otherface ( 4 ) = f2 ilo ( 4 ) = s21 ihi ( 4 ) = e21 klo ( 4 ) = s22 khi ( 4 ) = e22 dir_switch ( 4 ) = switch mpi_class ( 4 ) = class elseif ( f1 == 5 ) then otherface ( 5 ) = f2 ilo ( 5 ) = s21 ihi ( 5 ) = e21 jlo ( 5 ) = s22 jhi ( 5 ) = e22 dir_switch ( 5 ) = switch mpi_class ( 5 ) = class elseif ( f1 == 6 ) then otherface ( 6 ) = f2 ilo ( 6 ) = s21 ihi ( 6 ) = e21 jlo ( 6 ) = s22 jhi ( 6 ) = e22 dir_switch ( 6 ) = switch mpi_class ( 6 ) = class end if else continue end if end do call close_file ( MAP_FILE_UNIT ) call change_map_to_particular_range () call read_periodic_bc_file () end subroutine read_interface_map subroutine change_map_to_particular_range () !< Modified the indicies for MPI communication !------------------------------------- !eg: 1-kmx to 0 to kmx for data transfer !-------------------------------------- implicit none integer :: i Pilo = ilo Pjlo = jlo Pklo = klo Pihi = ihi Pjhi = jhi Pkhi = khi PiDir = 1 PjDir = 1 PkDir = 1 do i = 1 , 6 if ( ilo ( i ) == 1 . and . i > 2 ) then Pilo ( i ) = 1 Gilo ( i ) =- 2 end if if ( jlo ( i ) == 1 . and . ( i > 4 . or . i < 3 ) ) then Pjlo ( i ) = 1 Gjlo ( i ) =- 2 end if if ( klo ( i ) == 1 . and . i < 5 ) then Pklo ( i ) = 1 Gklo ( i ) =- 2 end if if ( ihi ( i ) == 1 . and . i > 2 ) then Pihi ( i ) = 1 Gihi ( i ) =- 2 PiDir ( i ) =- 1 end if if ( jhi ( i ) == 1 . and . ( i > 4 . or . i < 3 )) then Pjhi ( i ) = 1 Gjhi ( i ) =- 2 PjDir ( i ) =- 1 end if if ( khi ( i ) == 1 . and . i < 5 ) then Pkhi ( i ) = 1 Gkhi ( i ) =- 2 PkDir ( i ) =- 1 end if if ( ilo ( i ) > 1 . and . i > 2 ) then Gilo ( i ) = ilo ( i ) + 3 Pilo ( i ) = ilo ( i ) - 1 PiDir ( i ) =- 1 end if if ( jlo ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjlo ( i ) = jlo ( i ) + 3 Pjlo ( i ) = jlo ( i ) - 1 PjDir ( i ) =- 1 end if if ( klo ( i ) > 1 . and . i < 5 ) then Gklo ( i ) = klo ( i ) + 3 Pklo ( i ) = klo ( i ) - 1 PkDir ( i ) =- 1 end if if ( ihi ( i ) > 1 . and . i > 2 ) then Gihi ( i ) = ihi ( i ) + 3 Pihi ( i ) = ihi ( i ) - 1 end if if ( jhi ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjhi ( i ) = jhi ( i ) + 3 Pjhi ( i ) = jhi ( i ) - 1 end if if ( khi ( i ) > 1 . and . i < 5 ) then Gkhi ( i ) = khi ( i ) + 3 Pkhi ( i ) = khi ( i ) - 1 end if end do end subroutine change_map_to_particular_range subroutine read_periodic_bc_file () !< Read periodic.md file in the system/mesh/layout/periodic.md implicit none integer :: ios integer :: max_call integer :: i integer :: b1 , b2 integer :: f1 , f2 integer :: class open ( PERIODIC_FILE_UNIT , file = periodicfile , status = 'old' , action = 'read' ) read ( PERIODIC_FILE_UNIT , * ) !ignore first line (header) max_call = total_process * 6 do i = 1 , max_call read ( PERIODIC_FILE_UNIT , * , iostat = ios ) b1 , b2 , f1 , f2 , class if ( is_iostat_end ( ios )) EXIT if ( b1 == process_id ) then PbcId ( f1 ) = b2 end if end do close ( PERIODIC_FILE_UNIT ) end subroutine read_periodic_bc_file end module mapping","tags":"","loc":"sourcefile/mapping.f90.html","title":"mapping.f90 – FEST-3D"},{"text":"Contains routine to load layout file and sets the layout variables\n and gets process id and total process This file depends on sourcefile~~layout.f90~~EfferentGraph sourcefile~layout.f90 layout.f90 sourcefile~utils.f90 utils.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~layout.f90~~AfferentGraph sourcefile~layout.f90 layout.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~source.f90 source.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~layout.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~create_and_erase.f90->sourcefile~bc.f90 sourcefile~resnorm.f90->sourcefile~layout.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 var pansourcefilelayoutf90AfferentGraph = svgPanZoom('#sourcefilelayoutf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules layout Source Code layout.f90 Source Code !< Contains routine to load layout file and sets the layout variables !< and gets process id and total process module layout !< Contains routine to load layout file and sets the layout variables !< and gets process id and total process !------------------------------ use global , only : CONFIG_FILE_UNIT , RESNORM_FILE_UNIT , FILE_NAME_LENGTH , & STRING_BUFFER_LENGTH , INTERPOLANT_NAME_LENGTH use global , only : layout_file use global_vars , only : total_process use global_vars , only : total_entries use global_vars , only : process_id use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id use utils , only : dmsg , DEBUG_LEVEL #include \"error.inc\" #include \"mpi.inc\" ! process layout character ( len = FILE_NAME_LENGTH ) :: grid_file_buf !< Name of the gridfile to load character ( len = FILE_NAME_LENGTH ) :: bc_file !< Name of the boundary condition file to load. public :: get_next_token_parallel public :: read_layout_file public :: get_process_data contains subroutine get_process_data () !<Get Processor Id and total number of processors implicit none ! Finds and sets process data integer :: ierr call MPI_COMM_RANK ( MPI_COMM_WORLD , process_id , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , total_process , ierr ) end subroutine get_process_data subroutine get_next_token_parallel ( buf ) !< Extract the next token from the layout file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( CONFIG_FILE_UNIT , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do call dmsg ( 0 , 'solver' , 'get_next_token' , 'Returning: ' // trim ( buf )) end subroutine get_next_token_parallel subroutine read_layout_file ( process_id ) !< Read the layout file for particular processor implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf integer , intent ( in ) :: process_id !< Processor id for current block integer :: i , buf_id call dmsg ( 1 , 'layout' , 'read_layout_file' ) open ( CONFIG_FILE_UNIT , file = layout_file ) ! Read the parameters from the file call get_next_token_parallel ( buf ) read ( buf , * ) total_process call get_next_token_parallel ( buf ) read ( buf , * ) total_entries i = 0 !print *, process_id call get_next_token_parallel ( buf ) do while ( i < process_id ) call get_next_token_parallel ( buf ) i = i + 1 end do read ( buf , * ) buf_id , grid_file_buf , bc_file , imin_id , imax_id , jmin_id , jmax_id , kmin_id , kmax_id write ( grid_file_buf , '(A)' ) 'system/mesh/gridfiles/' // trim ( grid_file_buf ) write ( bc_file , '(A)' ) 'system/mesh/bc/' // trim ( bc_file ) end subroutine read_layout_file end module layout","tags":"","loc":"sourcefile/layout.f90.html","title":"layout.f90 – FEST-3D"},{"text":"Setup, destroy, calculate molecular and turbulence viscosity This file depends on sourcefile~~viscosity.f90~~EfferentGraph sourcefile~viscosity.f90 viscosity.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~utils.f90 utils.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~viscosity.f90->sourcefile~global_vars.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~viscosity.f90~~AfferentGraph sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules viscosity Source Code viscosity.f90 Source Code !< Setup, destroy, calculate molecular and turbulence viscosity module viscosity !< Setup, destroy, calculate molecular and turbulence viscosity !---------------------------------------------------- ! author   - Jatinder Pal Singh Sandhu ! obective - setup     , !            destroy   , and !            calculate ! molecular and turbulence viscosity based on switch !----------------------------------------------------- use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : mu use global_vars , only : mu_ref use global_vars , only : Sutherland_temp use global_vars , only : T_ref use global_vars , only : R_gas use global_vars , only : mu_variation use global_vars , only : process_id use global_vars , only : pressure use global_vars , only : density use global_vars , only : sst_mu use global_vars , only : kkl_mu use global_vars , only : sa_mu use global_vars , only : mu_t use global_vars , only : tw use global_vars , only : tk use global_vars , only : tkl use global_vars , only : tv use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : id use global_vars , only : face_names use global_vars , only : dist use global_kkl , only : cmu use global_sst , only : bstar use global_sst , only : a1 use global_sst , only : sst_F1 use global_sst , only : sigma_w2 use global_sa , only : cv1 ! gradients use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use copy_bc , only : copy1 use utils , only : dmsg use utils , only : alloc use utils , only : dealloc #include \"error.inc\" implicit none private public :: setup_viscosity public :: destroy_viscosity public :: calculate_viscosity contains subroutine calculate_viscosity () !< Calculate molecular and turbulent viscosity implicit none integer :: i , j , k real :: T ! molecular viscosity real :: c ! kkl eddy viscosity !- sst varibales -! real :: F real :: arg2 real :: vort real :: NUM real :: DENOM ! for arg2 real :: var1 real :: var2 !for vorticity real :: wijwij real :: wx real :: wy real :: wz !for strain calculation real :: SijSij real :: Sxx , Syy , Szz real :: Sxy , Szx , Syz real :: strain !for arg1 real :: arg1 real :: CD real :: right real :: left ! sa variables real :: fv1 real :: xi !--- calculate_molecular_viscosity ---! if ( mu_ref /= 0. ) then select case ( trim ( mu_variation )) case ( 'sutherland_law' ) ! apply_sutherland_law do k = 0 , kmx do j = 0 , jmx do i = 0 , imx T = pressure ( i , j , k ) / ( density ( i , j , k ) * R_gas ) mu ( i , j , k ) = mu_ref * (( T / T_ref ) ** ( 1.5 )) & * (( T_ref + Sutherland_temp )& / ( T + Sutherland_temp )) end do end do end do case ( 'constant' ) !do nothing !mu will be equal to mu_ref continue case DEFAULT print * , \"mu_variation not recognized:\" print * , \"   found '\" , trim ( mu_variation ), \"'\" print * , \"accepted values: 1) sutherland_law\" print * , \"                 2) constant\" Fatal_error end select end if !--- end molecular viscosity calculation---! !--- calculate_turbulent_viscosity  ---! if ( turbulence /= 'none' ) then select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call calculate_sa_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! xsi xi = tv ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k ) !calculation fo fv1 function fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) sa_mu ( i , j , k ) = density ( i , j , k ) * tv ( i , j , k ) * fv1 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sa_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sa_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sa_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sa_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sa_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sa_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sa_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sa_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sa_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sa_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sa_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sa_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sa_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sa_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sa_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sa_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sa_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sa_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sa eddy viscosity  ---! case ( 'sst2003' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! calculate_arg2() var1 = sqrt ( tk ( i , j , k )) / ( bstar * tw ( i , j , k ) * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ( i , j , k )) / (( dist ( i , j , k ) ** 2 ) * tw ( i , j , k )) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( sxx = ( gradu_x ( i , j , k )) syy = ( gradv_y ( i , j , k )) szz = ( gradw_z ( i , j , k )) syz = ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) szx = ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) sxy = ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) SijSij = ( 2.0 * ( sxx ** 2 )) + ( 2.0 * ( syy ** 2 )) + ( 2.0 * ( szz ** 2 )) + syz ** 2 + szx ** 2 + sxy ** 2 strain = sqrt ( SijSij ) NUM = density ( i , j , k ) * a1 * tk ( i , j , k ) DENOM = max ( max (( a1 * tw ( i , j , k )), strain * F ), 1.0e-10 ) sst_mu ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density ( i , j , k ) * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ), & 1.0e-10 ) right = 4 * ( density ( i , j , k ) * sigma_w2 * tk ( i , j , k )) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( tk ( i , j , k )) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst2003 eddy viscosity  and blending fucntion calculation ---! case ( 'sst' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! calculate_arg2() var1 = sqrt ( tk ( i , j , k )) / ( bstar * tw ( i , j , k ) * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ( i , j , k )) / (( dist ( i , j , k ) ** 2 ) * tw ( i , j , k )) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( wx = ( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) wy = ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) wz = ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) wijwij = wx ** 2 + wy ** 2 + wz ** 2 vort = sqrt ( wijwij ) NUM = density ( i , j , k ) * a1 * tk ( i , j , k ) DENOM = max ( max (( a1 * tw ( i , j , k )), vort * F ), 1.e-20 ) sst_mu ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density ( i , j , k ) * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ), & 1 e - 20 ) right = 4 * ( density ( i , j , k ) * sigma_w2 * tk ( i , j , k )) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( tk ( i , j , k )) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst eddy viscosity  and blending fucntion calculation ---! case ( 'kkl' ) !--- calculate_kkl_mu() c = cmu ** 0.25 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx kkl_mu ( i , j , k ) = c * density ( i , j , k ) * tkl ( i , j , k )& / ( max ( sqrt ( tk ( i , j , k )), 1.e-20 )) if ( tkl ( i , j , k ) < 1.e-14 . or . tk ( i , j , k ) < 1.e-14 ) & kkl_mu ( i , j , k ) = 0.0 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 4 : - 1 , - 6 , - 8 , - 9 ) !call copy1(kkl_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) kkl_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = kkl_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) kkl_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = kkl_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) kkl_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = kkl_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) kkl_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = kkl_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(kkl_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) kkl_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - kkl_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) kkl_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - kkl_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) kkl_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - kkl_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) kkl_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - kkl_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of kkl eddy viscosity calculation ---! case DEFAULT !call turbulence_read_error() Fatal_error end select end if !--- end turbulent viscosity calculation---! !--- check on viscosity ---! if ( any ( isnan ( mu ))) then Fatal_error end if end subroutine calculate_viscosity subroutine setup_viscosity () !< Allocate and pointer for molecular and turbulent viscosity !setup_molecular_viscosity() if ( mu_ref /= 0. ) then call alloc ( mu , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) mu = mu_ref !intialize end if !--- setup_turbulent_viscosity ---! if ( turbulence /= 'none' ) then call alloc ( mu_t , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) sa_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) case ( 'sst' , 'sst2003' ) sst_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) !-- sst blending funciton F1 --! call alloc ( sst_F1 , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) sst_F1 = 0. !-- sst blnding function setup compete--! case ( 'kkl' ) kkl_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) case DEFAULT !call turbulence_read_error() Fatal_error end select end if ! --- end turbulent viscosity setup ---! end subroutine setup_viscosity subroutine destroy_viscosity () !< Deallocate and nullify viscosity (turbulent/molecular) ! destroy_molecular_viscosity ---! if ( mu_ref /= 0. ) then call dealloc ( mu ) end if !--- destroy_turbulent_viscosity ---! if ( turbulence /= 'none' ) then select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) nullify ( sa_mu ) case ( 'sst' , 'sst2003' ) nullify ( sst_mu ) !-- blending funciton F1 --! call dealloc ( sst_F1 ) !--- sst blending funciton destoryed--! case ( 'kkl' ) nullify ( kkl_mu ) case DEFAULT !call turbulence_read_error() Fatal_error end select call dealloc ( mu_t ) end if !--- end of turublent viscosity destruction ---! end subroutine destroy_viscosity end module viscosity","tags":"","loc":"sourcefile/viscosity.f90.html","title":"viscosity.f90 – FEST-3D"},{"text":"Time integration module This file depends on sourcefile~~update.f90~~EfferentGraph sourcefile~update.f90 update.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~update.f90->sourcefile~geometry.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~time.f90 time.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~string.f90 string.f90 sourcefile~update.f90->sourcefile~string.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~utils.f90 utils.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~update.f90->sourcefile~global_vars.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_vars.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~read.f90 read.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~global_vars.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90->sourcefile~geometry.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~plusgs.f90->sourcefile~string.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~plusgs.f90->sourcefile~global_vars.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~plusgs.f90->sourcefile~mapping.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~global_vars.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90->sourcefile~global_vars.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~cc.f90 CC.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~layout.f90 layout.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~viscous2.f90->sourcefile~global_vars.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~lusgs.f90->sourcefile~geometry.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~lusgs.f90->sourcefile~string.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~lusgs.f90->sourcefile~global_vars.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90->sourcefile~mapping.f90 sourcefile~read_bc.f90->sourcefile~global_vars.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~ft_bc.f90->sourcefile~global_vars.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~copy_bc.f90->sourcefile~global_vars.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~ghost_gradient.f90->sourcefile~utils.f90 sourcefile~ghost_gradient.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output.f90->sourcefile~global_vars.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 var pansourcefileupdatef90EfferentGraph = svgPanZoom('#sourcefileupdatef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~update.f90~~AfferentGraph sourcefile~update.f90 update.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules update Source Code update.f90 Source Code !< Time integration module module update !< This module march the solution is time. use global_kkl , only : cphi1 use global_kkl , only : cphi2 use global_kkl , only : fphi use global_kkl , only : eta use global_kkl , only : cd1 use global_kkl , only : cmu use global_sst , only : beta1 use global_sst , only : beta2 use global_sst , only : bstar use global_sst , only : sst_F1 use global_sa , only : cb1 use global_sa , only : cw1 use global_sa , only : cw2 use global_sa , only : cw3 use global_sa , only : cv1 use global_sa , only : kappa_sa use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : R_gas use global_vars , only : Pr use global_vars , only : tPr use global_vars , only : volume use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : n_var use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gm use global_vars , only : sst_n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : dist use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : tk_inf use global_vars , only : tkl_inf use global_vars , only : time_stepping_method use global_vars , only : time_step_accuracy use global_vars , only : global_time_step use global_vars , only : delta_t use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : F_p use global_vars , only : G_p use global_vars , only : H_p use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : omega_residue use global_vars , only : kl_residue use global_vars , only : residue use global_vars , only : mu_ref use geometry , only : CellCenter use utils , only : alloc use utils , only : dealloc use utils , only : dmsg use utils , only : DEBUG_LEVEL use string !subroutine for residual calculation use face_interpolant , only : interpolant use global_vars , only : mu_ref use interface1 , only : apply_interface use bc_primitive , only : populate_ghost_primitive use face_interpolant , only : compute_face_interpolant use boundary_state_reconstruction , only : reconstruct_boundary_state use scheme , only : compute_fluxes use summon_grad_evaluation , only : evaluate_all_gradients use viscosity , only : calculate_viscosity use viscous , only : compute_viscous_fluxes !  use turbulent_fluxes,               only: compute_turbulent_fluxes use scheme , only : compute_residue use source , only : add_source_term_residue use time , only : compute_time_step !--- sst implicit update ---! use global_sst , only : sst_F1 use global_sst , only : sigma_k1 use global_sst , only : sigma_k2 use global_sst , only : sigma_w1 use global_sst , only : sigma_w2 use plusgs , only : update_with_plusgs use plusgs , only : setup_plusgs use plusgs , only : destroy_plusgs use lusgs , only : update_with_lusgs use lusgs , only : setup_lusgs use lusgs , only : destroy_lusgs #include \"error.inc\" #include \"mpi.inc\" private real , dimension (:,:,:,:), allocatable :: U_store !< Array to store the intermediate solution real , dimension (:,:,:,:), allocatable :: R_store !< Array to store the intermediate Residue real , dimension (:,:,:,:), allocatable , target :: aux !< Array to store some auxilary intermediate variables real , dimension (:) , allocatable :: u1 !< Variable array old for each cell center real , dimension (:) , allocatable :: u2 !< Variable array new for each cell center real , dimension (:) , allocatable :: R !< Residue array for each cell center ! Public methods public :: setup_update public :: destroy_update public :: get_next_solution contains subroutine setup_update () !< Allocate memory to variables required based !< on the time-integration scheme. implicit none call alloc ( u1 , 1 , n_var ) call alloc ( u2 , 1 , n_var ) call alloc ( R , 1 , n_var ) call alloc ( aux , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) select case ( time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) call alloc ( R_store , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var ) case ( \"TVDRK2\" , \"TVDRK3\" , \"TVDRK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) case ( \"implicit\" ) call setup_lusgs () case ( \"plusgs\" ) call setup_plusgs () case default Fatal_error end select end subroutine setup_update subroutine destroy_update () !< Dellocate memory from all variables implicit none select case ( time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call dealloc ( U_store ) call dealloc ( R_store ) case ( \"TVDRK2\" , \"TVDRK3\" , \"TVDRK4\" ) call dealloc ( U_store ) case ( \"implicit\" ) call destroy_lusgs () case ( \"plusgs\" ) call destroy_plusgs () case default Fatal_error end select call dealloc ( u1 ) call dealloc ( u2 ) call dealloc ( R ) call dealloc ( aux ) end subroutine destroy_update subroutine get_next_solution () !< Get solution at next time-step using scheme !< given in the input file. implicit none select case ( trim ( time_step_accuracy )) case ( \"none\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with ( \"conservative\" , 1. , 1. , . FALSE .) !call update_with(\"primitive\", 1. ,1., .FALSE.) !call update_laminar_variables_primitive(1. ,1., .FALSE.) !if(turbulence/='none')then !  call update_turbulent_variables_primitive(1. ,1., .FALSE.) !end if case ( \"RK4\" ) R_store = 0. U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(0.5, 1., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(0.5, 1., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 0.5 , 2. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(0.5, 2., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(0.5, 2., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 2. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(1.0, 2., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(1.0, 2., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1. / 6. , 1. , . TRUE . , R_store , U_store ) !call update_laminar_variables_primitive(1./6., 1., .TRUE., .FALSE., R_store, U_store) !call update_turbulent_variables_primitive(1./6., 1., .TRUE., .FALSE., R_store, U_store) case ( \"RK2\" ) R_store = 0. U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 0.5 , 1. , . TRUE ., R_store , U_store ) case ( \"TVDRK3\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = 0.75 * U_store + 0.25 * qp call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = ( 1. / 3. ) * U_store + ( 2. / 3. ) * qp case ( \"TVDRK2\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = 0.5 * U_store + 0.5 * qp case ( \"TVDRK4\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_laminar_variables_conservative ( 0.25 , un = U_store ) if ( turbulence /= 'none' ) then call update_turbulent_variables_conservative ( 1.0 , un = U_store ) end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 0.333333 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(0.333333, un=U_store) !end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 0.5 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(0.5, un=U_store) !end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 1.00 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(1.00, un=U_store) !end if case ( \"implicit\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with_lusgs () case ( \"plusgs\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with_plusgs () case default Fatal_error end select end subroutine get_next_solution subroutine update_with ( type , time_factor , store_factor , use , Rn , un ) !< A generalized scheme to updat the solution explicitly using !< any RK method and even first order euler explicit. implicit none character ( len =* ), intent ( in ) :: type real , intent ( in ), optional :: time_factor ! time factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ), optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional :: Rn real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor Logical :: TU = . FALSE . !to use or not real , dimension (:,:,:,:), pointer :: Quse integer :: i , j , k real :: KE = 0. real :: beta !sa variables real :: vort real :: fv1 real :: fv2 real :: fw real :: g real :: scap real :: rsa real :: kd2 real :: xi if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if select case ( type ) case ( 'primitive' ) !include \"update_primitive.inc\" !update primitive variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : n_var ) = Quse ( i , j , k , 1 : n_var ) ! finding primitive residue R ( 1 ) = mass_residue ( i , j , k ) R ( 2 ) = - 1 * ( u1 ( 2 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + x_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 3 ) = - 1 * ( u1 ( 3 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + y_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 4 ) = - 1 * ( u1 ( 4 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + z_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 5 ) = 0.5 * ( gm - 1. ) * ( sum ( u1 ( 2 : 4 ) ** 2 ) * mass_residue ( i , j , k )) & - ( gm - 1. ) * u1 ( 2 ) * x_mom_residue ( i , j , k ) & - ( gm - 1. ) * u1 ( 3 ) * y_mom_residue ( i , j , k ) & - ( gm - 1. ) * u1 ( 4 ) * z_mom_residue ( i , j , k ) & + ( gm - 1. ) * energy_residue ( i , j , k ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 5 ) = R ( 5 ) - ( gm - 1. ) * TKE_residue ( i , j , k ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue ( i , j , k ) / u1 ( 1 ) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 5 ) = R ( 5 ) - ( gm - 1. ) * TKE_residue ( i , j , k ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue ( i , j , k ) / u1 ( 1 ) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 (:) = u1 (:) - R (:) * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. ) then Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) case DEFAULT ! do nothing continue end select end if end do end do end do case ( 'conservative' ) !include \"update_conservative.inc\" !update conservative variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) select case ( turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u1(6) case ( 'sa' , 'saBC' ) KE = 0.0 case DEFAULT KE = 0. end select u1 ( 5 ) = ( u1 ( 5 ) / ( gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) + KE ! get R R ( 1 : n_var ) = residue ( i , j , k , 1 : n_var ) ! point implicit destruction term select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) case ( 'sa' , 'saBC' ) vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 xi = U1 ( 6 ) * density ( i , j , k ) / mu ( i , j , k ) fv1 = xi ** 3 / ( xi ** 3 + cv1 ** 3 ) fv2 = 1.0 - xi / ( 1 + xi * fv1 ) scap = vort + U1 ( 6 ) * fv2 / ( kd2 ) rsa = min ( U1 ( 6 ) / ( Scap * kd2 ), 1 0.0 ) g = rsa + cw2 * ( rsa ** 6 - rsa ) fw = g * ( ( 1.0 + cw3 ** 6 ) / ( g ** 6 + cw3 ** 6 ) ) ** ( 1.0 / 6.0 ) R ( 6 ) = R ( 6 ) / ( 1. + (( - 1.0 * u1 ( 1 ) * cb1 * scap ) + ( 2.0 * u1 ( 1 ) * cw1 * fw * u1 ( 6 ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k )) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 ( 1 : n_var ) = u1 ( 1 : n_var ) - R ( 1 : n_var ) * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) select case ( turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u2(6) case ( 'sa' , 'saBC' ) !u2(6) = u2(6)*u2(1) KE = 0.0 case DEFAULT KE = 0. end select u2 ( 5 ) = ( gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) - KE ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. . or . any ( isnan ( u2 ))) then print * , u2 (:) print * , \"R: \" , R print * , \"old \" , U1 Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) >= 0. ) then qp ( i , j , k , 6 ) = u2 ( 6 ) else !  qp(i,j,k,6) = tk_inf !  qp(i,j,k,6) = (max(qp(i-1,j,k,6),0.) + max(qp(i+1,j,k,6),0.) & !                +max(qp(i,j-1,k,6),0.) + max(qp(i,j+1,k,6),0.) & !                )/4 !  qp(i,j,k,6) = 1.e-3*maxval(qp(i-1:i+1,j-1:j+1,k-1:k+1,6)) end if if ( u2 ( 7 ) >= 0. ) then qp ( i , j , k , 7 ) = u2 ( 7 ) else !  qp(i,j,k,7) = tkl_inf !  qp(i,j,k,7) = (max(qp(i-1,j,k,7),0.) + max(qp(i+1,j,k,7),0.) & !                +max(qp(i,j-1,k,7),0.) + max(qp(i,j+1,k,7),0.) & !                )/4 end if case ( 'sa' , 'saBC' ) qp ( i , j , k , 6 ) = max ( u2 ( 6 ), 1.e-12 ) case DEFAULT ! do nothing continue end select end if !print*, i,j, R(1:n_var) end do end do end do case DEFAULT Fatal_error end select end subroutine update_with subroutine get_total_conservative_Residue () !< Main loop of whole code. Find residual !< !< For each iteration it apply boundary conditions, !< use higher order method to reconstruct state at !< face, evalute fluxes at each face, calculate !< inviscid residual, and introuduce additional !< residual due to  viscosity, turbulence and source !< terms. implicit none !        call send_recv(3) ! parallel call-argument:no of layers call apply_interface () call populate_ghost_primitive () call compute_face_interpolant () call reconstruct_boundary_state ( interpolant ) call compute_fluxes () if ( mu_ref /= 0.0 ) then call evaluate_all_gradients () call calculate_viscosity () call compute_viscous_fluxes ( F_p , G_p , H_p ) !          call compute_turbulent_fluxes(F_p, G_p, H_p) end if call compute_residue () call add_source_term_residue () end subroutine get_total_conservative_Residue subroutine update_laminar_variables_primitive ( time_factor , store_factor , use , tostore , Rn , un ) !< Update first five primitive variables in time implicit none real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore real , dimension ( 5 ) :: Res real :: t1 !temp variable 1/density integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : 5 ) = Quse ( i , j , k , 1 : 5 ) t1 = 1.0 / u1 ( 1 ) Res ( 1 : 5 ) = Residue ( i , j , k , 1 : 5 ) ! finding primitive residue R ( 1 ) = Res ( 1 ) R ( 2 ) = ( - 1 * ( u1 ( 2 ) * Res ( 1 )) + Res ( 2 )) * t1 R ( 3 ) = ( - 1 * ( u1 ( 3 ) * Res ( 1 )) + Res ( 3 )) * t1 R ( 4 ) = ( - 1 * ( u1 ( 4 ) * Res ( 1 )) + Res ( 4 )) * t1 R ( 5 ) = 0.5 * ( gm - 1. ) * ( u1 ( 2 ) * u1 ( 2 ) + u1 ( 3 ) * u1 ( 3 ) + u1 ( 4 ) * u1 ( 4 )) * Res ( 1 ) & - ( gm - 1. ) * u1 ( 2 ) * Res ( 2 ) & - ( gm - 1. ) * u1 ( 3 ) * Res ( 3 ) & - ( gm - 1. ) * u1 ( 4 ) * Res ( 4 ) & + ( gm - 1. ) * Res ( 5 ) !store residue aux ( i , j , k , 1 : 5 ) = R ( 1 : 5 ) !update u2 ( 1 : 5 ) = u1 ( 1 : 5 ) - ( SFU * R ( 1 : 5 ) + R_switch * Rstore ( i , j , k , 1 : 5 ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) end do end do end do if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) end if if ( any ( qp (:,:,:, 1 ) < 0. ) . and . any ( qp (:,:,:, 5 ) < 0 )) then Fatal_error end if nullify ( Rstore ) nullify ( Quse ) end subroutine update_laminar_variables_primitive subroutine update_laminar_variables_conservative ( time_factor , store_factor , use , tostore , Rn , un ) !< Update first five conservative variables in time implicit none real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) u1 ( 5 ) = ( u1 ( 5 ) / ( gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) ! get R R ( 1 : 5 ) = residue ( i , j , k , 1 : 5 ) !store conservative variables aux ( i , j , k , 1 : n_var ) = u1 ( 1 : n_var ) !update u2 ( 1 : 5 ) = u1 ( 1 : 5 ) - ( SFU * R ( 1 : 5 ) + R_switch * Rstore ( i , j , k , 1 : 5 ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) u2 ( 5 ) = ( gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) ) qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) end do end do end do if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) end if if ( any ( qp (:,:,:, 1 ) < 0. ) . and . any ( qp (:,:,:, 5 ) < 0 )) then Fatal_error end if nullify ( Rstore ) nullify ( Quse ) end subroutine update_laminar_variables_conservative subroutine update_turbulent_variables_primitive ( time_factor , store_factor , use , tostore , Rn , un ) !< Update primitive turbulence variables in time implicit none !arguments real , intent ( in ), optional :: time_factor ! time factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use in ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore integer :: i , j , k real :: beta if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 !update primitive variable u1 ( 6 : n_var ) = Quse ( i , j , k , 6 : n_var ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue ( i , j , k ) / u1 ( 1 ) !store residue aux ( i , j , k , 6 : n_var ) = R ( 6 : n_var ) !update qp ( i , j , k , 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var ) + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) end do end do end do case ( 'kkl' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 6 : n_var ) = Quse ( i , j , k , 6 : n_var ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue ( i , j , k ) / u1 ( 1 ) !store residue aux ( i , j , k , 6 : n_var ) = R ( 6 : n_var ) !update qp ( i , j , k , 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var ) + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 6 : n_var ) = max ( 1 e - 10 , qp ( i , j , k , 6 : n_var )) end do end do end do case DEFAULT Fatal_error end select !--- end update ---! if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) end if !if(any(qp(:,:,:,6)<0.) .and. any(qp(:,:,:,n_var)<0))then !  Fatal_error !end if nullify ( Rstore ) end subroutine update_turbulent_variables_primitive subroutine update_turbulent_variables_conservative ( time_factor , store_factor , use , tostore , Rn , un ) !< Update conservative turbulence variables in time implicit none !arguments real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore real :: beta integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : n_var ) = aux ( i , j , k , 1 : n_var ) !get R R ( 6 : n_var ) = residue ( i , j , k , 6 : n_var ) !point implicit beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) !update u2 ( 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var )& + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) / aux ( i , j , k , 1 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) / aux ( i , j , k , 1 ) end do end do end do case ( 'kkl' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 6 : n_var ) = aux ( i , j , k , 6 : n_var ) !get R R ( 6 : n_var ) = residue ( i , j , k , 6 : n_var ) !point implicit eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) !update u2 ( 6 : n_var ) = u1 ( 6 : n_var ) - ( R ( 6 : n_var ) + ( R_switch * SF * Rstore ( i , j , k , 6 : n_var )))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 6 : n_var ) = max ( 1.e-10 , u2 ( 6 : n_var ) / aux ( i , j , k , 1 )) end do end do end do case DEFAULT Fatal_error end select !--- end update ---! if ( present ( Rn )) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) & + SF * residue ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) end if if ( any ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) < 0. )) then Fatal_error end if nullify ( Rstore ) end subroutine update_turbulent_variables_conservative end module update","tags":"","loc":"sourcefile/update.f90.html","title":"update.f90 – FEST-3D"},{"text":"The geometry module calculates various geometrical quantities like \n face-normals, face-areas and cell-volumes to be used in computations. This file depends on sourcefile~~geometry.f90~~EfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~utils.f90 utils.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~geometry.f90~~AfferentGraph sourcefile~geometry.f90 geometry.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~geometry.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~geometry.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~plusgs.f90->sourcefile~geometry.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~lusgs.f90->sourcefile~geometry.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefilegeometryf90AfferentGraph = svgPanZoom('#sourcefilegeometryf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules geometry Source Code geometry.f90 Source Code !< The geometry module calculates various geometrical quantities like !< face-normals, face-areas and cell-volumes to be used in computations. module geometry !< The geometry module calculates various geometrical quantities like !< face-normals, face-areas and cell-volumes to be used in computations. !------------------------------------------------------------------- #include \"error.inc\" use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : xn !face unit norm x use global_vars , only : yn !face unit norm y use global_vars , only : zn !face unit norm z use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : volume use global_vars , only : left_ghost_centroid use global_vars , only : right_ghost_centroid use global_vars , only : front_ghost_centroid use global_vars , only : back_ghost_centroid use global_vars , only : top_ghost_centroid use global_vars , only : bottom_ghost_centroid use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id use global_vars , only : process_id use utils , only : alloc , dealloc , dmsg implicit none private real , dimension (:,:,:,:), allocatable , public :: CellCenter !< Store Cell-center location ! Public methods public :: setup_geometry public :: destroy_geometry contains subroutine allocate_memory_volumes () !< Allocate memory for the volume variables. !----------------------------------------------------------- implicit none call alloc ( volume , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for volume.' ) end subroutine allocate_memory_volumes subroutine allocate_memory_areas () !< Allocate memory for the area variables. !----------------------------------------------------------- implicit none call alloc ( xA , - 2 , imx + 3 , - 2 , jmx + 2 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for xA.' ) call alloc ( yA , - 2 , imx + 2 , - 2 , jmx + 3 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for yA.' ) call alloc ( zA , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for yA.' ) end subroutine allocate_memory_areas subroutine allocate_memory_normals () !< Allocate memory for the normal variables. !----------------------------------------------------------- implicit none call alloc ( xn , - 2 , imx + 3 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for xnx.' ) call alloc ( yn , - 2 , imx + 2 , - 2 , jmx + 3 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for ynx.' ) call alloc ( zn , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 3 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for ynx.' ) xnx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) xny ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) xnz ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ynx ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) yny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) ynz ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) znx ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) zny ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) znz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) end subroutine allocate_memory_normals subroutine allocate_memory_ghost_centroids () !< Allocate memory for centroids of ghost cells !----------------------------------------------------------- implicit none call alloc ( CellCenter , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for volume.' ) ! !            call alloc(left_ghost_centroid, 1, jmx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for left_ghost_centroid') !            call alloc(right_ghost_centroid, 1, jmx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for right_ghost_centroid') !            call alloc(front_ghost_centroid, 1, imx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for front_ghost_centroid') !            call alloc(back_ghost_centroid, 1, imx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for back_ghost_centroid') !            call alloc(top_ghost_centroid, 1, imx-1, 1, jmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for top_ghost_centroid') !            call alloc(bottom_ghost_centroid, 1, imx-1, 1, jmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for bottom_ghost_centroid') end subroutine allocate_memory_ghost_centroids subroutine allocate_memory () !< Allocate memory for the required variables. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'allocate_memory' ) call allocate_memory_normals () call allocate_memory_areas () call allocate_memory_volumes () call allocate_memory_ghost_centroids () end subroutine allocate_memory subroutine deallocate_memory () !< Deallocate the memoery used by the geometry variables implicit none call dmsg ( 1 , 'geometry' , 'deallocate_memory' ) call dealloc ( xn ) call dealloc ( yn ) call dealloc ( zn ) call dealloc ( xA ) call dealloc ( yA ) call dealloc ( zA ) call dealloc ( volume ) call dealloc ( CellCenter ) !            call dealloc(left_ghost_centroid) !            call dealloc(right_ghost_centroid) !            call dealloc(front_ghost_centroid) !            call dealloc(back_ghost_centroid) !            call dealloc(top_ghost_centroid) !            call dealloc(bottom_ghost_centroid) end subroutine deallocate_memory subroutine normalize_face_normals () !< Normalize the face normal vectors computed to get unit !< vectors !----------------------------------------------------------- implicit none integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 if ( xA ( i , j , k ) /= 0. ) then xnx ( i , j , k ) = xnx ( i , j , k ) / xA ( i , j , k ) xny ( i , j , k ) = xny ( i , j , k ) / xA ( i , j , k ) xnz ( i , j , k ) = xnz ( i , j , k ) / xA ( i , j , k ) end if end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 if ( yA ( i , j , k ) /= 0. ) then ynx ( i , j , k ) = ynx ( i , j , k ) / yA ( i , j , k ) yny ( i , j , k ) = yny ( i , j , k ) / yA ( i , j , k ) ynz ( i , j , k ) = ynz ( i , j , k ) / yA ( i , j , k ) end if end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 if ( zA ( i , j , k ) /= 0. ) then znx ( i , j , k ) = znx ( i , j , k ) / zA ( i , j , k ) zny ( i , j , k ) = zny ( i , j , k ) / zA ( i , j , k ) znz ( i , j , k ) = znz ( i , j , k ) / zA ( i , j , k ) end if end do end do end do ! pole boundary condition if ( imin_id ==- 7 ) then xn ( 1 ,:,:,:) = xn ( 2 ,:,:,:) xn ( 0 ,:,:,:) = xn ( 2 ,:,:,:) xn ( - 1 ,:,:,:) = xn ( 2 ,:,:,:) xn ( - 2 ,:,:,:) = xn ( 2 ,:,:,:) end if if ( imax_id ==- 7 ) then xn ( imx + 0 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 1 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 2 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 3 ,:,:,:) = xn ( imx - 1 ,:,:,:) end if if ( jmin_id ==- 7 ) then yn (:, 1 ,:,:) = yn (:, 2 ,:,:) yn (:, 0 ,:,:) = yn (:, 2 ,:,:) yn (:, - 1 ,:,:) = yn (:, 2 ,:,:) yn (:, - 2 ,:,:) = yn (:, 2 ,:,:) end if if ( jmax_id ==- 7 ) then yn (:, jmx + 0 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 1 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 2 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 3 ,:,:) = yn (:, jmx - 1 ,:,:) end if if ( kmin_id ==- 7 ) then zn (:,:, 1 ,:) = zn (:,:, 2 ,:) zn (:,:, 0 ,:) = zn (:,:, 2 ,:) zn (:,:, - 1 ,:) = zn (:,:, 2 ,:) zn (:,:, - 2 ,:) = zn (:,:, 2 ,:) end if if ( kmax_id ==- 7 ) then zn (:,:, kmx + 0 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 1 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 2 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 3 ,:) = zn (:,:, kmx - 1 ,:) end if end subroutine normalize_face_normals subroutine compute_face_areas () !< Compute face areas based on area vectors !< !< The face areas are computed using the face area vectors. !< Prior to using this subroutine, the face area vectors must !< computed and placed in the face normal variables. !< !< Since the area is given by abs(d1 x d2), the areas are !< calculated using the normal vectors calculated in !< compute_face_area_vectors, but before normalising them !----------------------------------------------------------- implicit none xA (:, :, :) = sqrt (( xnx (:, :, :)) ** 2. + ( xny (:, :, :)) ** 2. + & ( xnz (:, :, :)) ** 2. ) yA (:, :, :) = sqrt (( ynx (:, :, :)) ** 2. + ( yny (:, :, :)) ** 2. + & ( ynz (:, :, :)) ** 2. ) zA (:, :, :) = sqrt (( znx (:, :, :)) ** 2. + ( zny (:, :, :)) ** 2. + & ( znz (:, :, :)) ** 2. ) ! Pole boundary conditions ! making sure face area is exactly equal zero if ( imin_id ==- 7 ) xA ( - 2 : 1 , :, :) = 0. if ( imax_id ==- 7 ) xA ( imx : imx + 3 , :, :) = 0. if ( jmin_id ==- 7 ) yA ( :, - 2 : 1 , :) = 0. if ( jmax_id ==- 7 ) yA ( :, jmx : jmx + 3 , :) = 0. if ( kmin_id ==- 7 ) zA ( :, :, - 2 : 1 ) = 0. if ( kmax_id ==- 7 ) zA ( :, :, kmx : kmx + 3 ) = 0. end subroutine compute_face_areas subroutine compute_face_area_vectors () !< Compute face area vectors !< !< The face area vectors denote the face area both in !< magnitude and direction. They are placed in the face !< normal variables for further calculation. !< !< The face normal is given by d1 x d2, where d1 and d2 are !< the diagonals of a face !----------------------------------------------------------- implicit none real :: d1x , d2x , d1y , d2y , d1z , d2z integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 d1x = grid_x ( i , j + 1 , k + 1 ) - grid_x ( i , j , k ) d1y = grid_y ( i , j + 1 , k + 1 ) - grid_y ( i , j , k ) d1z = grid_z ( i , j + 1 , k + 1 ) - grid_z ( i , j , k ) d2x = grid_x ( i , j , k + 1 ) - grid_x ( i , j + 1 , k ) d2y = grid_y ( i , j , k + 1 ) - grid_y ( i , j + 1 , k ) d2z = grid_z ( i , j , k + 1 ) - grid_z ( i , j + 1 , k ) xnx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) xny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) xnz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 d1x = grid_x ( i + 1 , j , k + 1 ) - grid_x ( i , j , k ) d1y = grid_y ( i + 1 , j , k + 1 ) - grid_y ( i , j , k ) d1z = grid_z ( i + 1 , j , k + 1 ) - grid_z ( i , j , k ) d2x = grid_x ( i + 1 , j , k ) - grid_x ( i , j , k + 1 ) d2y = grid_y ( i + 1 , j , k ) - grid_y ( i , j , k + 1 ) d2z = grid_z ( i + 1 , j , k ) - grid_z ( i , j , k + 1 ) ynx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) yny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) ynz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 d1x = grid_x ( i + 1 , j + 1 , k ) - grid_x ( i , j , k ) d1y = grid_y ( i + 1 , j + 1 , k ) - grid_y ( i , j , k ) d1z = grid_z ( i + 1 , j + 1 , k ) - grid_z ( i , j , k ) d2x = grid_x ( i , j + 1 , k ) - grid_x ( i + 1 , j , k ) d2y = grid_y ( i , j + 1 , k ) - grid_y ( i + 1 , j , k ) d2z = grid_z ( i , j + 1 , k ) - grid_z ( i + 1 , j , k ) znx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) zny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) znz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do end subroutine compute_face_area_vectors subroutine compute_face_areas_and_normals () !< Compute the face areas and normals !< !< This is the 2-dimensional version. In this case, the face !< areas default to edge lengths. !----------------------------------------------------------- implicit none call compute_face_area_vectors () call compute_face_areas () call normalize_face_normals () end subroutine compute_face_areas_and_normals function vol_tetrahedron ( p1 , p2 , p3 , p4 ) !< Compute the volume of a tetrahedron, given 4 points which !< are 1-D arrays !< Since we know that the determinant is to be evaluated of !< a 3x3 matrix, we write the expression itself !----------------------------------------------------------- implicit none real , dimension (:), intent ( in ) :: p1 , p2 , p3 , p4 real , dimension ( 1 : 3 , 1 : 3 ) :: A real :: vol_tetrahedron A (:, 1 ) = p1 - p4 A (:, 2 ) = p2 - p4 A (:, 3 ) = p3 - p4 !vol_tetrahedron = A(1,1) * (A(2,2)*A(3,3) - A(2,3)*A(3,2)) + & !                  A(1,2) * (A(2,3)*A(3,1) - A(2,1)*A(3,3)) + & !                  A(1,3) * (A(2,1)*A(3,2) - A(2,2)*A(3,1)) vol_tetrahedron = ( p4 ( 1 ) - p1 ( 1 )) * (( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 3 ) - p1 ( 3 )) - ( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 2 ) - p1 ( 2 ))) & + ( p4 ( 2 ) - p1 ( 2 )) * (( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 1 ) - p1 ( 1 )) - ( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 3 ) - p1 ( 3 ))) & + ( p4 ( 3 ) - p1 ( 3 )) * (( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 2 ) - p1 ( 2 )) - ( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 1 ) - p1 ( 1 ))) vol_tetrahedron = - vol_tetrahedron / 6. end function vol_tetrahedron function vol_hexahedron ( p_list ) !< Compute the volume of a hexahedron, given a list of points ! The points are arranged in a specific order. For the ! element i,j,k, the order of nodes required are: ! i,j,k ! i+1, j, k ! i+1, j+1, k ! i, j+1, k ! i, j, k+1 ! i+1, j, k+1 ! i+1, j+1, k+1 ! i, j+1, k+1 ! ! The hexahedron is to be split into 5 tetrahedrons. ! Source: Split hex into 5 tetrahedron: ! No assumptions about planarity seem to be made. All cuts ! were made with a plane containing only 3 vertices at a time. ! https://ieeexplore.ieee.org/ieee_pilot/articles/06/ttg2009061587/assets/img/article_1/fig_6/large.gif ! ! The indices of the 5 split tetrahedra can be visualised from ! the above link. But since the volume of each tetrahedron ! depends on the determinant calculated, it is IMPERATIVE to ! ensure that a \"correct\" order is followed for the 4 points. ! ! The logic to get the \"correct\" order is explained as ! follows (Refer wiki article on parallelepiped): ! The determinant is taken of a matrix of pi - p4, i = 1, 2, 3. ! Graphically it denotes the sides with p4 as common vertex, ! with direction outward from p4, i.e., directed from ! p4 to pi, i = 1, 2, 3 ! Hence, if you ensure that  cross(p1-p4, p2-p4) is along ! p3-p4, then the determinant will be positive. ! ! From the above link, a set of 5 tetrahedra was obtained. ! Each tetrahedra has 4 points, and in the function calls ! below, care was taken to ensure that the order is observed ! while passing parameters into the vol_tetrahedron function !----------------------------------------------------------- implicit none real , dimension ( 1 : 3 , 1 : 8 ), intent ( in ) :: p_list real :: vol_hexahedron real :: vol_hexahedron1 vol_hexahedron1 = 0. vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 5 ), & p_list (:, 8 ), p_list (:, 6 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 8 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 4 ), & p_list (:, 1 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 6 ), p_list (:, 1 ), & p_list (:, 3 ), p_list (:, 8 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 2 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron = 0. vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 6 ), & p_list (:, 5 ), p_list (:, 7 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 5 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 5 ), p_list (:, 1 ), & p_list (:, 2 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 2 ), & p_list (:, 4 ), p_list (:, 5 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 3 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = max ( vol_hexahedron , vol_hexahedron1 ) end function vol_hexahedron subroutine compute_volumes () !< Compute the grid cell volumes !< Each grid is a hexahedron, whose volume is calculated by !< splitting it into 5 tetrahedrons, whose volume is known !----------------------------------------------------------- implicit none integer :: i , j , k real , dimension ( 1 : 3 , 1 : 8 ) :: p_list volume = 1. do k = 0 , kmx + 0 do j = 0 , jmx + 0 do i = 0 , imx + 0 p_list (:, :) = 0. p_list (:, 1 ) = ( / grid_x ( i , j , k ), grid_y ( i , j , k ), grid_z ( i , j , k ) / ) p_list (:, 2 ) = ( / grid_x ( i + 1 , j , k ), grid_y ( i + 1 , j , k ), grid_z ( i + 1 , j , k ) / ) p_list (:, 3 ) = ( / grid_x ( i + 1 , j + 1 , k ), grid_y ( i + 1 , j + 1 , k ), grid_z ( i + 1 , j + 1 , k ) / ) p_list (:, 4 ) = ( / grid_x ( i , j + 1 , k ), grid_y ( i , j + 1 , k ), grid_z ( i , j + 1 , k ) / ) p_list (:, 5 ) = ( / grid_x ( i , j , k + 1 ), grid_y ( i , j , k + 1 ), grid_z ( i , j , k + 1 ) / ) p_list (:, 6 ) = ( / grid_x ( i + 1 , j , k + 1 ), grid_y ( i + 1 , j , k + 1 ), grid_z ( i + 1 , j , k + 1 ) / ) p_list (:, 7 ) = ( / grid_x ( i + 1 , j + 1 , k + 1 ), grid_y ( i + 1 , j + 1 , k + 1 ), grid_z ( i + 1 , j + 1 , k + 1 ) / ) p_list (:, 8 ) = ( / grid_x ( i , j + 1 , k + 1 ), grid_y ( i , j + 1 , k + 1 ), grid_z ( i , j + 1 , k + 1 ) / ) volume ( i , j , k ) = ( vol_hexahedron ( p_list )) if ( volume ( i , j , k ) <= 0.0 ) then if ( i == 0 . or . i == imx . or . j == 0 . or . j == jmx . or . k == 0 . or . k == kmx ) then !print*, \"Ghost Cell volume negative\" volume ( i , j , k ) = abs ( vol_hexahedron ( p_list )) else print * , process_id , i , j , k print * , \"negative volume :\" , ( vol_hexahedron ( p_list )) STOP end if end if end do end do end do if ( any ( volume == 0.0 )) then Fatal_error end if if ( any (( volume ) < 0.0 )) then Fatal_error end if end subroutine compute_volumes subroutine compute_geometric_parameters () !< Compute the geometric parameters based on the grid points !< !< The geometric parameters include the face normals and !< areas and the cell volumes. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'compute_geometric_parameters' ) call compute_face_areas_and_normals () call compute_volumes () end subroutine compute_geometric_parameters subroutine compute_ghost_cell_centroid () !< Compute cell center of all cell including ghost cells implicit none integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 CellCenter ( i , j , k , 1 ) = 0.125 * ( grid_x ( i , j , k ) & + grid_x ( i + 1 , j , k ) & + grid_x ( i + 1 , j + 1 , k ) & + grid_x ( i + 1 , j + 1 , k + 1 ) & + grid_x ( i + 1 , j , k + 1 ) & + grid_x ( i , j + 1 , k ) & + grid_x ( i , j + 1 , k + 1 ) & + grid_x ( i , j , k + 1 ) & ) CellCenter ( i , j , k , 2 ) = 0.125 * ( grid_y ( i , j , k ) & + grid_y ( i + 1 , j , k ) & + grid_y ( i + 1 , j + 1 , k ) & + grid_y ( i + 1 , j + 1 , k + 1 ) & + grid_y ( i + 1 , j , k + 1 ) & + grid_y ( i , j + 1 , k ) & + grid_y ( i , j + 1 , k + 1 ) & + grid_y ( i , j , k + 1 ) & ) CellCenter ( i , j , k , 3 ) = 0.125 * ( grid_z ( i , j , k ) & + grid_z ( i + 1 , j , k ) & + grid_z ( i + 1 , j + 1 , k ) & + grid_z ( i + 1 , j + 1 , k + 1 ) & + grid_z ( i + 1 , j , k + 1 ) & + grid_z ( i , j + 1 , k ) & + grid_z ( i , j + 1 , k + 1 ) & + grid_z ( i , j , k + 1 ) & ) end do end do end do end subroutine compute_ghost_cell_centroid subroutine setup_geometry () !< Make the geometry module useful !< !< Allocates memory to the variables and initializes them. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'setup_geometry' ) call allocate_memory () call compute_geometric_parameters () call compute_ghost_cell_centroid () end subroutine setup_geometry subroutine destroy_geometry () !< Nullify all the face normal pionter implicit none call dmsg ( 1 , 'geometry' , 'destroy_geometry' ) nullify ( xnx ) nullify ( xny ) nullify ( xnz ) nullify ( ynx ) nullify ( yny ) nullify ( ynz ) nullify ( znx ) nullify ( zny ) nullify ( znz ) call deallocate_memory () end subroutine destroy_geometry end module geometry","tags":"","loc":"sourcefile/geometry.f90.html","title":"geometry.f90 – FEST-3D"},{"text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~convergence.f90 convergence.f90 sourcefile~main.f90->sourcefile~convergence.f90 sourcefile~solver.f90 solver.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~main.f90->sourcefile~global_vars.f90 sourcefile~convergence.f90->sourcefile~global_vars.f90 sourcefile~solver.f90->sourcefile~global_vars.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~solver.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~layout.f90 layout.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~source.f90 source.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~utils.f90 utils.f90 sourcefile~solver.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~string.f90 string.f90 sourcefile~solver.f90->sourcefile~string.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~global.f90 global.f90 sourcefile~solver.f90->sourcefile~global.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~start_finish.f90->sourcefile~fclose.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~wall.f90->sourcefile~global_vars.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~global_vars.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~global_vars.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~global_vars.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~viscous2.f90->sourcefile~global_vars.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~state.f90->sourcefile~global_vars.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~gradients.f90->sourcefile~global_vars.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~wall_dist.f90->sourcefile~global_vars.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~resnorm.f90->sourcefile~global_vars.f90 sourcefile~resnorm.f90->sourcefile~layout.f90 sourcefile~resnorm.f90->sourcefile~fclose.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~resnorm.f90->sourcefile~string.f90 sourcefile~resnorm.f90->sourcefile~global.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~bc.f90->sourcefile~global_vars.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_vars.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~bc_primitive.f90->sourcefile~global_vars.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~update.f90->sourcefile~global_vars.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~geometry.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~string.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global_vars.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global.f90 var pansourcefilemainf90EfferentGraph = svgPanZoom('#sourcefilemainf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Programs main Source Code main.f90 Source Code program main !< Main program !------------------------------------------------- ! 170801 - Jatinder Pal Singh Sandhu ! change : - explicit call with use module instead of using whole module !          - include error and mpi file ! 170803 - jatinder Pal Singh Sandhu ! change : - new name to step -> iterate_one_more_time_step !------------------------------------------------ use global_vars , only : max_iters use global_vars , only : current_iter use global_vars , only : Halt use solver , only : iterate_one_more_time_step use convergence , only : converged use start_finish , only : start_run use start_finish , only : finish_run #include \"error.inc\" #include \"mpi.inc\" !--------Start---------! call start_run () do while (( current_iter <= max_iters ) . and . (. not . converged ()) . and . (. not . Halt )) call iterate_one_more_time_step () end do call finish_run () !--------Stop---------! end program main","tags":"","loc":"sourcefile/main.f90.html","title":"main.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+ This file depends on sourcefile~~van_leer.f90~~EfferentGraph sourcefile~van_leer.f90 van_leer.f90 sourcefile~utils.f90 utils.f90 sourcefile~van_leer.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~van_leer.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules van_leer Source Code van_leer.f90 Source Code !< Flux splitting scheme: AUSM+ module van_leer !< !< Reference: Van Leer, B., Flux-vector splitting for the Euler equation. !< In Upwind and High-Resolution Schemes, Springer, Berlin, Heidelberg, pp. 80-89, 1997 !------------------------------------------------------------------- use utils , only : alloc , dealloc , dmsg use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : n_var use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F , G , H , residue !< Array to store the flux through I, J, and K direction face and residue in the cell real , dimension (:, :, :, :), pointer :: flux_p !< A general flux pointer ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'van_leer' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - van_leer.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - van_leer.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - van_leer.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - van_leer.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'van_leer' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds call dmsg ( 1 , 'van_leer' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'van_leer' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! First construct the F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! First construct the F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'van_leer' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if call compute_flux ( 'z' ) if ( any ( isnan ( H ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue using the Van-Leer scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'van_leer' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = F ( i + 1 , j , k , l ) - F ( i , j , k , l ) & + G ( i , j + 1 , k , l ) - G ( i , j , k , l ) & + H ( i , j , k + 1 , l ) - H ( i , j , k , l ) end do end do end do end do end subroutine get_residue end module van_leer","tags":"","loc":"sourcefile/van_leer.f90.html","title":"van_leer.f90 – FEST-3D"},{"text":"Flux splitting scheme: SLAU This file depends on sourcefile~~slau.f90~~EfferentGraph sourcefile~slau.f90 slau.f90 sourcefile~utils.f90 utils.f90 sourcefile~slau.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~slau.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules slau Source Code slau.f90 Source Code !< Flux splitting scheme: SLAU module slau !< Shima, E., and Kitamura, K., “Parameter-Free Simple !< Low-Dissipation AUSM-Family Scheme for All Speeds,” !< AIAA Journal, vol. 49, pp. 1693–1709, 2011 !------------------------------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : n_var use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real , public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real , public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real , public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real , dimension (:, :, :, :), pointer :: flux_p !< Pointer/alias for the either F, G, or H ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'slau' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - slau.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - slau.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - slau.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - slau.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'slau' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: xi real :: vnabs real :: delp real :: delrho real :: fnG real :: pbar real :: Mcap real :: vtface real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: VnabsL , VnabsR call dmsg ( 1 , 'slau' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'slau' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- speed of sound ---- cL = sqrt ( gm * pL / rL ) cR = sqrt ( gm * pR / rR ) C = 0.5 * ( cL + cR ) ! ---- delta quantities ---- delp = pR - pL !pL - pR delrho = rR - rL !rL - rR ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0.0 , 1.0 - floor ( abs ( ML ))) alphaR = max ( 0.0 , 1.0 - floor ( abs ( MR ))) !Above two line of code is eqvivalent to following code !if(abs(ML)>=1.0) then !  alphaL = 0.0 !else !  alphaL=1.0 !end if !if(abs(MR)>=1.0) then !  alphaR=0.0 !else !  alphaR=1.0 !end if ! -- pressure factor -- betaL = ( 1.0 - alphaL ) * 0.5 * ( 1.0 + sign ( 1.0 , ML )) + ( alphaL ) * 0.25 * ( 2.0 - ML ) * (( ML + 1.0 ) ** 2 ) betaR = ( 1.0 - alphaR ) * 0.5 * ( 1.0 - sign ( 1.0 , MR )) + ( alphaR ) * 0.25 * ( 2.0 + MR ) * (( MR - 1.0 ) ** 2 ) ! -- xi calculation -- vtface = sqrt ( 0.5 * (( uL * uL ) + ( vL * vL ) + ( wL * wL ) + ( uR * uR ) + ( vR * vR ) + ( wR * wR ))) Mcap = min ( 1.0 , vtface / C ) Xi = ( 1.0 - Mcap ) ** 2 ! -- |Vn| -- Vnabs = ( rL * abs ( VnL ) + rR * abs ( VnR )) / ( rL + rR ) ! -- function G -- fnG = - 1.0 * max ( min ( ML , 0.0 ), - 1.0 ) * min ( max ( MR , 0.0 ), 1.0 ) ! -- Pressure -- pbar = 0.5 * (( pL + pR ) + ( betaL - betaR ) * ( pL - pR ) + ( 1.0 - xi ) * ( betaL + betaR - 1.0 ) * ( pL + pR )) ! -- mass -- !mass = 0.5*((rL*VnL + rR*VnR - Vnabs*delrho)*(1.0-fnG) - (Xi*delp/C)) VnabsL = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnL ) VnabsR = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnR ) mass = 0.5 * (( rL * ( VnL + VnabsL ) + rR * ( VnR - VnabsR )) - ( Xi * delp / C )) mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) ! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_P ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'slau' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue for the slau scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'slau' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue end module slau","tags":"","loc":"sourcefile/slau.f90.html","title":"slau.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+-UP This file depends on sourcefile~~ausmup.f90~~EfferentGraph sourcefile~ausmup.f90 ausmUP.f90 sourcefile~utils.f90 utils.f90 sourcefile~ausmup.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ausmup.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausmUP Source Code ausmUP.f90 Source Code !< Flux splitting scheme: AUSM+-UP module ausmUP !< !< Reference: Liou, M. S., “A sequel to AUSM, Part II: !< AUSM+-up for all speeds,” Journal of Computational Physics, !< vol. 214, 2006, pp. 137–170 !------------------------------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : MInf use global_vars , only : n_var use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real , public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real , public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real , public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real , dimension (:, :, :, :), pointer :: flux_p !< Pointer/alias for the either F, G, or H ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'AUSM+-UP' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - AUSM+-UP.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - AUSM+-UP.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - AUSM+-UP.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - AUSM+-UP.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'AUSM+-UP' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: pbar real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: FmL , FmR real :: Mface real :: Cs real :: Mb real :: Mo real :: fna real :: Pu real :: Mp real :: alfa real , parameter :: Kp = 0.25 real , parameter :: Ku = 0.75 real , parameter :: sigma = 1.0 call dmsg ( 1 , 'ausm+-UP' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'AUSM+-UP' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( gm + 1.0 )) cL = cs * cs / ( max ( cs , VnL )) cR = cs * cs / ( max ( cs , - VnR )) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C Mb = sqrt ( 0.5 * (( VnL * VnL ) + ( VnR * VnR )) / ( C * C )) ! ---- function at face ---- Mo = sqrt ( min ( 1.0 , max ( Mb * Mb , MInf * MInf ))) fna = Mo * ( 2.0 - Mo ) alfa = 3.0 * ( - 4.0 + ( 5.0 * fna * fna )) / 1 6.0 ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.125 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * alfa * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.125 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * alfa * (( MR ** 2 - 1.0 ) ** 2 ) * MR !AUSM+- modification Pu = - Ku * betaL * betaR * ( rL + rR ) * fna * C * ( VnR - VnL ) Mp = - 2.0 * Kp * max ( 1.0 - ( sigma * Mb * Mb ), 0.0 ) * ( pR - pL ) / ( fna * ( rL + rR ) * C * C ) if ( isnan ( Pu )) then print * , \"Nan:\" , f_qp_left ( i , j , k ,:), f_qp_right ( i , j , k ,:) end if ! mass coefficient Mface = FmL + FmR + Mp ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR + Pu ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_p ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'AUSM+-UP' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue for the ausm+-UP scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'AUSM+-UP' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue end module ausmUP","tags":"","loc":"sourcefile/ausmup.f90.html","title":"ausmUP.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM+ This file depends on sourcefile~~ausmp.f90~~EfferentGraph sourcefile~ausmp.f90 ausmP.f90 sourcefile~utils.f90 utils.f90 sourcefile~ausmp.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ausmp.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausmP Source Code ausmP.f90 Source Code !< Flux splitting scheme: AUSM+ module ausmP !< !< Reference: Liou, M. S., “A sequel to AUSM: AUSM+,” !< Journal of Computational Physics, vol. 129, pp. 364–382, 1996 !------------------------------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : n_var use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real , public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real , public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real , public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real , dimension (:, :, :, :), pointer :: flux_p !< Pointer/alias for the either F, G, or H ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'AUSM+' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - AUSM+.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - AUSM+.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - AUSM+.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - AUSM+.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'AUSM+' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: pbar real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: FmL , FmR real :: Mface real :: Cs call dmsg ( 1 , 'AUSM+' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'AUSM+' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( gm + 1.0 )) cL = cs * cs / ( max ( cs , abs ( VnL ))) cR = cs * cs / ( max ( cs , abs ( VnR ))) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.1250 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * 0.1875 * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.1250 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * 0.1875 * (( MR ** 2 - 1.0 ) ** 2 ) * MR ! mass coefficient Mface = FmL + FmR ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_p ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'AUSM+' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue for the AUSM+ scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'AUSM+' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue end module ausmP","tags":"","loc":"sourcefile/ausmp.f90.html","title":"ausmP.f90 – FEST-3D"},{"text":"Flux splitting scheme: AUSM This file depends on sourcefile~~ausm.f90~~EfferentGraph sourcefile~ausm.f90 ausm.f90 sourcefile~utils.f90 utils.f90 sourcefile~ausm.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ausm.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ausm Source Code ausm.f90 Source Code !< Flux splitting scheme: AUSM module ausm !< !< Reference: Liou, M.S. and Steffen Jr, C.J., A new flux splitting scheme, !< Journal of Computational physics, vol. 107, no. 1, pp.23-39, 1993 !------------------------------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : n_var use global_vars , only : density use global_vars , only : turbulence use global_vars , only : process_id use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real , public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real , public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real , public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real , dimension (:, :, :, :), pointer :: flux_p !< Pointer/alias for the either F, G, or H ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'ausm' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - ausm.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - ausm.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - ausm.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - ausm.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'ausm' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds real :: temp_c call dmsg ( 1 , 'ausm' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ausm' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! AUSM modification temp_c = c_plus + c_minus c_plus = max ( 0. , temp_c ) c_minus = min ( 0. , temp_c ) ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'ausm' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if !if(kmx==2) then !  H = 0. !else call compute_flux ( 'z' ) !end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue for the AUSM scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'ausm' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) !print*, i, j, l, F(i+1, j,k,l), F(i,j,k,l), G(i,j+1,k,l)& !       , G(i,j,k,l), H(i,j,k+1,l), H(i,j,k,l) end do end do end do end do end subroutine get_residue end module ausm","tags":"","loc":"sourcefile/ausm.f90.html","title":"ausm.f90 – FEST-3D"},{"text":"Flux-splitting scheme: LDFSS This file depends on sourcefile~~ldfss0.f90~~EfferentGraph sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~utils.f90 utils.f90 sourcefile~ldfss0.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ldfss0.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ldfss0 Source Code ldfss0.f90 Source Code !< Flux-splitting scheme: LDFSS module ldfss0 !< !< Reference: Edwards, J.R., A low-diffusion flux-splitting scheme !< for Navier-Stokes calculations, Computers & Fluids, vol. 26, !< no. 6, pp.635-659, 1997 !------------------------------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : xA , yA , zA !face area use global_vars , only : gm use global_vars , only : n_var use global_vars , only : turbulence use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use utils , only : alloc , dealloc , dmsg use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private real , public , dimension (:, :, :, :), allocatable , target :: F !< Store fluxes throught the I faces real , public , dimension (:, :, :, :), allocatable , target :: G !< Store fluxes throught the J faces real , public , dimension (:, :, :, :), allocatable , target :: H !< Store fluxes throught the K faces real , public , dimension (:, :, :, :), allocatable , target :: residue !< Store residue at each cell-center real , dimension (:, :, :, :), pointer :: flux_p !< Pointer/alias for the either F, G, or H ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_fluxes public :: get_residue contains subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'ldfss0' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - ldfss0.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - ldfss0.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - ldfss0.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - ldfss0.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'ldfss0' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds real :: M_ldfss , M_plus_ldfss , M_minus_ldfss call dmsg ( 1 , 'ldfss0' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ldfss0' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! LDFSS0 modification M_ldfss = 0.25 * beta_left * beta_right * & ( sqrt (( M_perp_left ** 2 + M_perp_right ** 2 ) * 0.5 ) & - 1 ) ** 2 M_plus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_left ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) M_minus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_right ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) c_plus = c_plus - M_plus_ldfss c_minus = c_minus + M_minus_ldfss ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'ldfss0' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if call compute_flux ( 'z' ) if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes subroutine get_residue () !< Compute the residue for the ldfss0 scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'ldfss0' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = F ( i + 1 , j , k , l ) - F ( i , j , k , l ) & + G ( i , j + 1 , k , l ) - G ( i , j , k , l ) & + H ( i , j , k + 1 , l ) - H ( i , j , k , l ) end do end do end do end do end subroutine get_residue end module ldfss0","tags":"","loc":"sourcefile/ldfss0.f90.html","title":"ldfss0.f90 – FEST-3D"},{"text":"Higher order face state reconstruction method: MUSCL. This file depends on sourcefile~~muscl.f90~~EfferentGraph sourcefile~muscl.f90 muscl.f90 sourcefile~utils.f90 utils.f90 sourcefile~muscl.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~muscl.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules muscl Source Code muscl.f90 Source Code !< Higher order face state reconstruction method: MUSCL. module muscl !< !<Reference:Hirsch, C., Numerical computation of internal !<and external flows: The fundamentals of computational fluid !<dynamics, Elsevier, 2007 !< !< MUSCL (Monotone Upwing Schemes for Scalar Conservation Laws is !< a scheme which replaces the piecewise constant approximation by !< reconstructing the states at the left and right side of each face. !< This is a one parameter upwind scheme which results in at most 3rd !< order accuracy. ! ! The MUSCL scheme alone creates non-physical oscillations near ! discontinuities like shocks. Hence, MUSCL is combined with ! some TVD (Total Variation Diminishing) to reduce such oscillations. ! TVD schemes also ensure that no new extrema of the state variables ! is created at the faces. !----------------------------------------------------------------- use utils , only : alloc , dealloc , dmsg use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : qp use global_vars , only : n_var use global_vars , only : pressure use global_vars , only : pressure_inf use global_vars , only : ilimiter_switch use global_vars , only : jlimiter_switch use global_vars , only : klimiter_switch use global_vars , only : itlimiter_switch use global_vars , only : jtlimiter_switch use global_vars , only : ktlimiter_switch use global_vars , only : iPB_switch use global_vars , only : jPB_switch use global_vars , only : kPB_switch implicit none private ! Private variables real , dimension (:, :, :, :), allocatable , target :: x_qp_left !< Store primitive state at the I-face left side real , dimension (:, :, :, :), allocatable , target :: x_qp_right !< Store primitive state at the I-face right side real , dimension (:, :, :, :), allocatable , target :: y_qp_left !< Store primitive state at the J-face left side real , dimension (:, :, :, :), allocatable , target :: y_qp_right !< Store primitive state at the J-face right side real , dimension (:, :, :, :), allocatable , target :: z_qp_left !< Store primitive state at the K-face left side real , dimension (:, :, :, :), allocatable , target :: z_qp_right !< Store primitive state at the K-face right side real :: phi , kappa real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right real , dimension (:, :, :), allocatable :: pdif !< Used for pressure based witch integer :: switch_L = 1 !< Limiter switch ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_muscl_states public :: x_qp_left , x_qp_right public :: y_qp_left , y_qp_right public :: z_qp_left , z_qp_right !  TVD_scheme = trim('koren') contains subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'muscl' , 'setup_muscl' ) phi = 1.0 kappa = 1. / 3. call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) call alloc ( pdif , 0 , imx , 0 , jmx , 0 , kmx , & errmsg = 'Error: Unable to allocate memory for' // & 'pdif' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'muscl' , 'destroy_muscl' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) call dealloc ( pdif ) end subroutine destroy_scheme subroutine pressure_based_switching ( f_dir ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none character , intent ( in ) :: f_dir !< Character can be x or y or z integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real :: pd2 call dmsg ( 1 , 'muscl' , 'pressure_based_switching' ) select case ( f_dir ) case ( 'x' ) f_qp_left => x_qp_left f_qp_right => x_qp_right i_f = 1 j_f = 0 k_f = 0 i_end = imx j_end = jmx - 1 k_end = kmx - 1 case ( 'y' ) f_qp_left => y_qp_left f_qp_right => y_qp_right i_f = 0 j_f = 1 k_f = 0 i_end = imx - 1 j_end = jmx k_end = kmx - 1 case ( 'z' ) f_qp_left => z_qp_left f_qp_right => z_qp_right i_f = 0 j_f = 0 k_f = 1 i_end = imx - 1 j_end = jmx - 1 k_end = kmx case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 pd2 = abs ( pressure ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 ) - & pressure ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( kmx - 1 )) = & pdif ( 1 : imx - 1 - i_f * ( imx - 2 ), 1 : jmx - 1 - j_f * ( jmx - 2 ), & 1 : kmx - 1 - k_f * ( kmx - 2 )) pdif (( 1 - i_f * ( - imx + 1 )):( i_f ) + ( imx - 1 ), ( 1 - j_f * ( - jmx + 1 )):( j_f ) + ( jmx - 1 ), & ( 1 - k_f * ( - kmx + 1 )):( k_f ) + ( kmx - 1 )) = & pdif ( 1 + i_f * ( imx - 2 ): imx - 1 , 1 + j_f * ( jmx - 2 ): jmx - 1 , & 1 + k_f * ( kmx - 2 ): kmx - 1 ) ! Loop over faces do k = 1 , kmx - ( 1 - k_f ) do j = 1 , jmx - ( 1 - j_f ) do i = 1 , imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching subroutine compute_face_state ( f_dir , lam_switch , turb_switch ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none ! Character can be x or y or z character , intent ( in ) :: f_dir !< Input direction x,y,or, z for which subroutine is called integer , intent ( in ) :: lam_switch !< Limiter switch for laminar variables integer , intent ( in ) :: turb_switch !< Limiter switch for turbulent variables integer :: i , j , k , l !< integer used for DO loop integer :: ii , jj , kk !< Variable for ALFA family limiter real :: alpha !< Flags to determine face direction real :: psi1 , psi2 !< limiters real :: fd !< forward difference real :: bd !< backward difference real :: r !< ratio of differences real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right call dmsg ( 1 , 'muscl' , 'compute_face_state' ) select case ( f_dir ) case ( 'x' ) f_qp_left ( 0 : imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) => x_qp_left f_qp_right ( 0 : imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) => x_qp_right ii = 1 jj = 0 kk = 0 case ( 'y' ) f_qp_left ( 1 : imx - 1 , 0 : jmx + 1 , 1 : kmx - 1 , 1 : n_var ) => y_qp_left f_qp_right ( 1 : imx - 1 , 0 : jmx + 1 , 1 : kmx - 1 , 1 : n_var ) => y_qp_right ii = 0 jj = 1 kk = 0 case ( 'z' ) f_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 0 : kmx + 1 , 1 : n_var ) => z_qp_left f_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 0 : kmx + 1 , 1 : n_var ) => z_qp_right ii = 0 jj = 0 kk = 1 case default call dmsg ( 5 , 'muscl' , 'compute_face_state' , & 'Direction not recognised' ) stop end select alpha = 2. / 3. !Koren limiter phi = 1.0 kappa = 1. / 3. switch_L = lam_switch do l = 1 , n_var if ( l >= 6 ) then switch_L = turb_switch end if do k = 1 - kk , kmx - 1 + kk do j = 1 - jj , jmx - 1 + jj do i = 1 - ii , imx - 1 + ii ! Cell based ! Koren limiter for now ! From paper: delta: forward difference 'fd' !             nabla: backward difference 'bd' fd = qp ( i + ii , j + jj , k + kk , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - ii , j - jj , k - kk , l ) r = fd / max ( bd , 1 e - 10 ) psi1 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !alpha limiter !                psi1 = max(0., min(2*r,1.), min(r,2.))    ! superbee !                psi1 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi1 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer r = bd / max ( fd , 1 e - 10 ) psi2 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !                psi2 = max(0., min(2*r,1.), min(r,2.)) !                psi2 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi2 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) f_qp_left ( i + ii , j + jj , k + kk , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end subroutine compute_face_state subroutine compute_muscl_states () !< Implement MUSCL scheme to get left and right states at !< each face. The computation is done through all cells !< and first level ghost cells !--------------------------------------------------------- !call compute_xi_face_states() call compute_face_state ( 'x' , ilimiter_switch , itlimiter_switch ) if ( iPB_switch == 1 ) then call pressure_based_switching ( 'x' ) end if !call compute_eta_face_states() call compute_face_state ( 'y' , jlimiter_switch , jtlimiter_switch ) if ( jPB_switch == 1 ) then call pressure_based_switching ( 'y' ) end if !call compute_zeta_face_states() call compute_face_state ( 'z' , klimiter_switch , ktlimiter_switch ) if ( kPB_switch == 1 ) then call pressure_based_switching ( 'z' ) end if end subroutine compute_muscl_states end module muscl","tags":"","loc":"sourcefile/muscl.f90.html","title":"muscl.f90 – FEST-3D"},{"text":"Higher face state reconstuction method: WENO This file depends on sourcefile~~weno.f90~~EfferentGraph sourcefile~weno.f90 weno.f90 sourcefile~utils.f90 utils.f90 sourcefile~weno.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~weno.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules weno Source Code weno.f90 Source Code !< Higher face state reconstuction method: WENO module weno !< !< Reference: 1 Shu, C.-W., “High-order Finite Difference and Finite Volume !< WENO Schemes and Discontinuous Galerkin Methods for CFD,” !< International Journal of Computational Fluid Dynamics, vol. 17, 2003, pp. 107–118. !< Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., !<“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” !<Acta Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. !----------------------------------------------------------------- use utils , only : alloc , dealloc , dmsg use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : qp use global_vars , only : n_var use global_vars , only : pressure use global_vars , only : pressure_inf use global_vars , only : ilimiter_switch use global_vars , only : process_id implicit none private ! Private variables real , dimension (:, :, :, :), allocatable , target :: x_qp_left !< Store primitive state at the I-face left side real , dimension (:, :, :, :), allocatable , target :: x_qp_right !< Store primitive state at the I-face right side real , dimension (:, :, :, :), allocatable , target :: y_qp_left !< Store primitive state at the J-face left side real , dimension (:, :, :, :), allocatable , target :: y_qp_right !< Store primitive state at the J-face right side real , dimension (:, :, :, :), allocatable , target :: z_qp_left !< Store primitive state at the K-face left side real , dimension (:, :, :, :), allocatable , target :: z_qp_right !< Store primitive state at the K-face right side real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_weno_states public :: x_qp_left , x_qp_right public :: y_qp_left , y_qp_right public :: z_qp_left , z_qp_right contains subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'weno' , 'setup_weno' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'weno' , 'destroy_weno' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) end subroutine destroy_scheme subroutine compute_face_states ( dir ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none character ( len =* ), intent ( in ) :: dir integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real , dimension ( 3 ) :: P !< polynomial approximation real , dimension ( 3 ) :: B !< smoothness factor real , dimension ( 3 ) :: w !< wieght real , dimension ( 3 ) :: g !< linear wieght real , dimension ( - 2 : 2 ) :: u !< state_variable real :: eps = 1 e - 6 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 select case ( dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right end select do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} P ( 1 ) = ( 2.0 * U ( - 2 ) - 7.0 * U ( - 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( - 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( 1 ) - 1.0 * U ( 2 )) / 6.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 2 ) - 2.0 * U ( - 1 ) + U ( 0 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 2 ) - 4.0 * U ( - 1 ) + 3.0 * U ( 0 )) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 1 ) - 2.0 * U ( 0 ) + U ( 1 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 1 ) - U ( 1 )) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( U ( 0 ) - 2.0 * U ( 1 ) + U ( 2 )) ** 2 + ( 1.0 / 4.0 ) * ( 3.0 * U ( 0 ) - 4.0 * U ( 1 ) + U ( 2 )) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 2.0 * U ( 2 ) - 7.0 * U ( 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( - 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( - 1 ) - 1.0 * U ( - 2 )) / 6.0 !B(1) = (13.0/12.0)*(U( 2)-2.0*U( 1)+U( 0))**2 + (1.0/4.0)*(    U(2)-4.0*U( 1)+3.0*U( 0))**2 !B(2) = (13.0/12.0)*(U( 1)-2.0*U( 0)+U(-1))**2 + (1.0/4.0)*(    U(1)-              U(-1))**2 !B(3) = (13.0/12.0)*(U( 0)-2.0*U(-1)+U(-2))**2 + (1.0/4.0)*(3.0*U(0)-4.0*U(-1)+    U(-2))**2 w ( 1 ) = g ( 1 ) / ( eps + B ( 3 )) ** 2 w ( 2 ) = g ( 2 ) / ( eps + B ( 2 )) ** 2 w ( 3 ) = g ( 3 ) / ( eps + B ( 1 )) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states subroutine compute_weno_states () !< Call Weno scheme for all the three direction I,J, and K call compute_face_states ( 'x' ) call compute_face_states ( 'y' ) call compute_face_states ( 'z' ) end subroutine compute_weno_states end module weno","tags":"","loc":"sourcefile/weno.f90.html","title":"weno.f90 – FEST-3D"},{"text":"Higher face state reconstuction method: WENO for non uniform grids This file depends on sourcefile~~weno_nm.f90~~EfferentGraph sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~utils.f90 utils.f90 sourcefile~weno_nm.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~weno_nm.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules weno_NM Source Code weno_NM.f90 Source Code !< Higher face state reconstuction method: WENO for non uniform grids module weno_NM !< !<Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., !<“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” !<Acta Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. !----------------------------------------------------------------- use utils , only : alloc , dealloc , dmsg use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : volume use global_vars , only : qp use global_vars , only : n_var use global_vars , only : pressure use global_vars , only : pressure_inf use global_vars , only : ilimiter_switch use global_vars , only : process_id implicit none private ! Private variables real , dimension (:, :, :, :), allocatable , target :: x_qp_left !< Store primitive state at the I-face left side real , dimension (:, :, :, :), allocatable , target :: x_qp_right !< Store primitive state at the I-face right side real , dimension (:, :, :, :), allocatable , target :: y_qp_left !< Store primitive state at the J-face left side real , dimension (:, :, :, :), allocatable , target :: y_qp_right !< Store primitive state at the J-face right side real , dimension (:, :, :, :), allocatable , target :: z_qp_left !< Store primitive state at the K-face left side real , dimension (:, :, :, :), allocatable , target :: z_qp_right !< Store primitive state at the K-face right side real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_weno_NM_states public :: x_qp_left , x_qp_right public :: y_qp_left , y_qp_right public :: z_qp_left , z_qp_right !  TVD_scheme = trim('koren') contains subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'weno_NM' , 'setup_weno_NM' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'weno_NM' , 'destroy_weno_NM' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) end subroutine destroy_scheme subroutine compute_face_states ( dir ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none character ( len =* ), intent ( in ) :: dir integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real , dimension ( 3 ) :: P !< polynomial approximation real , dimension ( 3 ) :: B !< smoothness factor real , dimension ( 3 ) :: w !< wieght real , dimension ( 3 ) :: g !< linear wieght real , dimension ( - 2 : 2 ) :: u !<state_variable real :: eps = 1 e - 6 real :: alpha real , dimension ( - 2 : 2 ) :: vol real :: U11 real :: U00 real :: U21 real :: U10 real :: U01 real :: U12 real :: alpha12 real :: alpha01 real :: alpha10 real :: alpha21 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 select case ( dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right end select do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} Vol ( - 2 ) = volume ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f ) !volume_{i-2} Vol ( - 1 ) = volume ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f ) !volume_{i-1} Vol ( 0 ) = volume ( i , j , k ) !volume_{i} Vol ( 1 ) = volume ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f ) !volume_{i+1} Vol ( 2 ) = volume ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f ) !volume_{i+2} alpha12 = Vol ( 2 ) / ( Vol ( 1 ) + Vol ( 2 )) alpha01 = Vol ( 1 ) / ( Vol ( 0 ) + Vol ( 1 )) alpha10 = Vol ( 0 ) / ( Vol ( - 1 ) + Vol ( 0 )) alpha21 = vol ( - 1 ) / ( Vol ( - 2 ) + Vol ( - 1 )) U01 = ( 1.0 - alpha01 ) * U ( 0 ) + alpha01 * U ( 1 ) U12 = ( 1.0 - alpha12 ) * U ( 1 ) + alpha12 * U ( 2 ) U10 = ( 1.0 - alpha10 ) * U ( - 1 ) + alpha10 * U ( 0 ) U21 = ( 1.0 - alpha21 ) * U ( - 2 ) + alpha21 * U ( - 1 ) U00 = U ( - 1 ) + ( 1.0 - alpha21 ) * ( U ( - 1 ) - U ( - 2 )) U11 = U ( 1 ) + alpha12 * ( U ( 1 ) - U ( 2 )) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U10 - 2.0 * U00 ) / 3.0 P ( 2 ) = ( - 1.0 * U10 + 2.0 * U ( 0 ) + 2.0 * U01 ) / 3.0 P ( 3 ) = ( 2.0 * U01 + 2.0 * U ( 1 ) - 1.0 * U12 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 2.0 * U00 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U10 - 2.0 * U00 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( 0 ) + 2 * U01 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u10 + 2.0 * U01 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 1 ) + 2 * U12 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U01 + 8.0 * U ( 1 ) - 2.0 * U12 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U01 - 2.0 * U11 ) / 3.0 P ( 2 ) = ( - 1.0 * U01 + 2.0 * U ( 0 ) + 2.0 * U10 ) / 3.0 P ( 3 ) = ( 2.0 * U10 + 2.0 * U ( - 1 ) - 1.0 * U21 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 2.0 * U11 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U01 - 2.0 * U11 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 0 ) + 2 * U10 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u01 + 2.0 * U10 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( - 1 ) + 2 * U21 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U10 + 8.0 * U ( - 1 ) - 2.0 * U21 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states subroutine compute_weno_NM_states () !< Call Weno scheme for all the three direction I,J, and K call compute_face_states ( 'x' ) call compute_face_states ( 'y' ) call compute_face_states ( 'z' ) end subroutine compute_weno_NM_states end module weno_NM","tags":"","loc":"sourcefile/weno_nm.f90.html","title":"weno_NM.f90 – FEST-3D"},{"text":"Higher order face state reconstruction method:PPM This file depends on sourcefile~~ppm.f90~~EfferentGraph sourcefile~ppm.f90 ppm.f90 sourcefile~utils.f90 utils.f90 sourcefile~ppm.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ppm.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ppm Source Code ppm.f90 Source Code !< Higher order face state reconstruction method:PPM module ppm !< !<Reference: Colella, P. and Woodward, P.R., The piecewise !<parabolic method (PPM) for gas-dynamical simulations, Journal !<of computational physics, vol. 54, no. 1, pp.174-201, 1984 !------------------------------------------------------------------- use utils , only : alloc , dealloc , dmsg use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : qp use global_vars , only : n_var use global_vars , only : pressure use global_vars , only : pressure_inf use global_vars , only : ilimiter_switch use global_vars , only : jlimiter_switch use global_vars , only : klimiter_switch use global_vars , only : iPB_switch use global_vars , only : jPB_switch use global_vars , only : kPB_switch implicit none private real , dimension (:, :, :, :), allocatable , target :: x_qp_face_estimate !< Store the I face estimate from 4th order reconstruction real , dimension (:, :, :, :), allocatable , target :: y_qp_face_estimate !< Store the J face estimate from 4th order reconstruction real , dimension (:, :, :, :), allocatable , target :: z_qp_face_estimate !< Store the K face estimate from 4th order reconstruction real , dimension (:, :, :, :), allocatable , target :: x_qp_left !< Store primitive state at the I-face left side real , dimension (:, :, :, :), allocatable , target :: x_qp_right !< Store primitive state at the I-face right side real , dimension (:, :, :, :), allocatable , target :: y_qp_left !< Store primitive state at the J-face left side real , dimension (:, :, :, :), allocatable , target :: y_qp_right !< Store primitive state at the J-face right side real , dimension (:, :, :, :), allocatable , target :: z_qp_left !< Store primitive state at the K-face left side real , dimension (:, :, :, :), allocatable , target :: z_qp_right !< Store primitive state at the K-face right side real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right real , dimension (:, :, :), allocatable :: pdif !< Used for pressure based witch ! Public members public :: setup_scheme public :: destroy_scheme public :: compute_ppm_states !   public :: output_data public :: x_qp_left , x_qp_right public :: y_qp_left , y_qp_right public :: z_qp_left , z_qp_right contains subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'ppm' , 'setup_ppm' ) call alloc ( x_qp_face_estimate , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_face_estimate.' ) call alloc ( y_qp_face_estimate , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_face_estimate.' ) call alloc ( z_qp_face_estimate , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_face_estimate.' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) call alloc ( pdif , 0 , imx , 0 , jmx , 0 , kmx , & errmsg = 'Error: Unable to allocate memory for' // & 'pdif' ) end subroutine setup_scheme subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'ppm' , 'destroy_ppm' ) call dealloc ( x_qp_face_estimate ) call dealloc ( y_qp_face_estimate ) call dealloc ( z_qp_face_estimate ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) call dealloc ( pdif ) end subroutine destroy_scheme subroutine compute_face_estimates ( f_dir ) !< Subroutine to calculate state at the face, generalized for implicit none character , intent ( in ) :: f_dir integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :, :), pointer :: f_qp_estimate call dmsg ( 1 , 'ppm' , 'compute_face_estimates' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_estimate => x_qp_face_estimate case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_estimate => y_qp_face_estimate case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_estimate => z_qp_face_estimate case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select !TODO: Vectorize this?? ! Interior faces do k = ( 1 - k_f ), kmx - 1 + 2 * k_f do j = ( 1 - j_f ), jmx - 1 + 2 * j_f do i = ( 1 - i_f ), imx - 1 + 2 * i_f f_qp_estimate ( i , j , k , :) = ( 7. * ( qp ( i , j , k , :) + & qp ( i - i_f , j - j_f , k - k_f , :)) - ( qp ( i + i_f , j + j_f , k + k_f , :) + & qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , :))) / 1 2. end do end do end do end subroutine compute_face_estimates subroutine remove_extrema ( f_dir ) !< Remove extrema from the state estimated. !< Limiting the value in case of PPM implicit none character , intent ( in ) :: f_dir integer :: i , j , k , l integer :: i_f , j_f , k_f ! Flags to determine face direction real :: dqrl , dq6 call dmsg ( 1 , 'ppm' , 'remove_extrema' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ppm' , 'remove_extrema' , & 'Direction not recognised' ) stop end select !TODO: Vectorize this? Or will it be ugly? ! Loop over cells (including ghost cells) do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f if (( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - qp ( i , j , k , l )) * & ( qp ( i , j , k , l ) - f_qp_right ( i , j , k , l )) <= 0 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = qp ( i , j , k , l ) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) else dqrl = f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - f_qp_right ( i , j , k , l ) dq6 = 6. * ( qp ( i , j , k , l ) - 0.5 * ( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) + & f_qp_right ( i , j , k , l ))) if ( dqrl * dq6 > dqrl * dqrl ) then f_qp_right ( i , j , k , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_left ( i + i_f , j + j_f , k + k_f , l ) else if ( - dqrl * dqrl > dqrl * dq6 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_right ( i , j , k , l ) end if end if end do end do end do end do end subroutine remove_extrema subroutine pressure_based_switching ( f_dir ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none ! Character can be x or y or z character , intent ( in ) :: f_dir integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real :: pd2 call dmsg ( 1 , 'ppm' , 'pressure_based_switching' ) select case ( f_dir ) case ( 'x' ) f_qp_left => x_qp_left f_qp_right => x_qp_right i_f = 1 j_f = 0 k_f = 0 i_end = imx j_end = jmx - 1 k_end = kmx - 1 case ( 'y' ) f_qp_left => y_qp_left f_qp_right => y_qp_right i_f = 0 j_f = 1 k_f = 0 i_end = imx - 1 j_end = jmx k_end = kmx - 1 case ( 'z' ) f_qp_left => z_qp_left f_qp_right => z_qp_right i_f = 0 j_f = 0 k_f = 1 i_end = imx - 1 j_end = jmx - 1 k_end = kmx case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 pd2 = abs ( pressure ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 ) - & pressure ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( kmx - 1 )) = & pdif ( 1 : imx - 1 - i_f * ( imx - 2 ), 1 : jmx - 1 - j_f * ( jmx - 2 ), & 1 : kmx - 1 - k_f * ( kmx - 2 )) pdif ((( imx - 1 ) * i_f ) + 1 : imx - 1 + i_f , & (( jmx - 1 ) * j_f ) + 1 : jmx - 1 + j_f , & (( kmx - 1 ) * k_f ) + 1 : kmx - 1 + k_f ) & = & pdif ( i_f * ( imx - 2 ) + 1 : imx - 1 , & j_f * ( jmx - 2 ) + 1 : jmx - 1 , & k_f * ( kmx - 2 ) + 1 : kmx - 1 ) ! Loop over faces do k = 1 , kmx - ( 1 - k_f ) do j = 1 , jmx - ( 1 - j_f ) do i = 1 , imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching subroutine init_left_and_right_xi_estimates () !< Initialize the left and right state at I direction face implicit none ! x_qp_left and x_qp_right are stored at faces. x_qp_left = x_qp_face_estimate x_qp_right = x_qp_face_estimate end subroutine init_left_and_right_xi_estimates subroutine init_left_and_right_eta_estimates () !< Initialize the left and right state at J direction face implicit none ! y_qp_left and y_qp_right are stored at faces. y_qp_left = y_qp_face_estimate y_qp_right = y_qp_face_estimate end subroutine init_left_and_right_eta_estimates subroutine init_left_and_right_zeta_estimates () !< Initialize the left and right state at K direction face implicit none ! y_qp_left and y_qp_right are stored at faces. z_qp_left = z_qp_face_estimate z_qp_right = z_qp_face_estimate end subroutine init_left_and_right_zeta_estimates subroutine compute_ppm_states () !< Call PPM face-state reconstruction for each face !< with optional call for remove extrema based on !< input limter switch and call pressure based switching !< based on input pressure based switch implicit none call compute_face_estimates ( 'x' ) call init_left_and_right_xi_estimates () if ( ilimiter_switch == 1 ) then call remove_extrema ( 'x' ) end if if ( iPB_switch == 1 ) then call pressure_based_switching ( 'x' ) end if call compute_face_estimates ( 'y' ) call init_left_and_right_eta_estimates () if ( jlimiter_switch == 1 ) then call remove_extrema ( 'y' ) end if if ( jPB_switch == 1 ) then call pressure_based_switching ( 'y' ) end if call compute_face_estimates ( 'z' ) call init_left_and_right_zeta_estimates () if ( klimiter_switch == 1 ) then call remove_extrema ( 'z' ) end if if ( kPB_switch == 1 ) then call pressure_based_switching ( 'z' ) end if end subroutine compute_ppm_states end module ppm","tags":"","loc":"sourcefile/ppm.f90.html","title":"ppm.f90 – FEST-3D"},{"text":"Setup boundary condition for the domain This file depends on sourcefile~~bc.f90~~EfferentGraph sourcefile~bc.f90 bc.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~utils.f90 utils.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~bc.f90->sourcefile~global_vars.f90 sourcefile~read_bc.f90->sourcefile~global_vars.f90 sourcefile~layout.f90 layout.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~global.f90 global.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~bc.f90~~AfferentGraph sourcefile~bc.f90 bc.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bc Source Code bc.f90 Source Code !< Setup boundary condition for the domain module bc !< Setup boundary condition for the domain !-------------------------------------------- ! 170515  Jatinder Pal Singh Sandhu ! Aim : setup boundary condition to domain !------------------------------------------- use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id use global_vars , only : accur use global_vars , only : c1 use global_vars , only : c2 use global_vars , only : c3 use global_vars , only : id use global_vars , only : face_names use global_vars , only : make_F_flux_zero use global_vars , only : make_G_flux_zero use global_vars , only : make_H_flux_zero use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : PbcId use utils , only : alloc use utils , only : dealloc use read_bc , only : read_fixed_values implicit none private integer :: face_num !< Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax public :: setup_bc public :: destroy_bc contains subroutine setup_bc () !< Initialization and allocate memory of boundary condition variables implicit none !check for periodic bc if ( PbcId ( 1 ) >= 0 ) imin_id =- 10 if ( PbcId ( 2 ) >= 0 ) imax_id =- 10 if ( PbcId ( 3 ) >= 0 ) jmin_id =- 10 if ( PbcId ( 4 ) >= 0 ) jmax_id =- 10 if ( PbcId ( 5 ) >= 0 ) kmin_id =- 10 if ( PbcId ( 6 ) >= 0 ) kmax_id =- 10 ! assign name to each face face_names ( 1 ) = \"imin\" face_names ( 2 ) = \"imax\" face_names ( 3 ) = \"jmin\" face_names ( 4 ) = \"jmax\" face_names ( 5 ) = \"kmin\" face_names ( 6 ) = \"kmax\" id ( 1 ) = imin_id id ( 2 ) = imax_id id ( 3 ) = jmin_id id ( 4 ) = jmax_id id ( 5 ) = kmin_id id ( 6 ) = kmax_id c2 = 1 + accur c3 = 0.5 * accur c1 = c2 - c3 call read_fixed_values () call alloc ( make_F_flux_zero , 1 , imx ) call alloc ( make_G_flux_zero , 1 , jmx ) call alloc ( make_H_flux_zero , 1 , kmx ) make_F_flux_zero = 1 make_G_flux_zero = 1 make_H_flux_zero = 1 if ( imin_id ==- 5 . or . imin_id ==- 6 . or . imin_id ==- 7 ) make_F_flux_zero ( 1 ) = 0 if ( jmin_id ==- 5 . or . jmin_id ==- 6 . or . jmin_id ==- 7 ) make_G_flux_zero ( 1 ) = 0 if ( kmin_id ==- 5 . or . kmin_id ==- 6 . or . kmin_id ==- 7 ) make_H_flux_zero ( 1 ) = 0 if ( imax_id ==- 5 . or . imax_id ==- 6 . or . imax_id ==- 7 ) make_F_flux_zero ( imx ) = 0 if ( jmax_id ==- 5 . or . jmax_id ==- 6 . or . jmax_id ==- 7 ) make_G_flux_zero ( jmx ) = 0 if ( kmax_id ==- 5 . or . kmax_id ==- 6 . or . kmax_id ==- 7 ) make_H_flux_zero ( kmx ) = 0 end subroutine setup_bc subroutine destroy_bc () !< Deallocate memory from boundary condition variables implicit none call dealloc ( make_F_flux_zero ) call dealloc ( make_G_flux_zero ) call dealloc ( make_H_flux_zero ) end subroutine destroy_bc end module bc","tags":"","loc":"sourcefile/bc.f90.html","title":"bc.f90 – FEST-3D"},{"text":"A module contains generalized subroutine to copy variable in ghost cells This file depends on sourcefile~~copy_bc.f90~~EfferentGraph sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~copy_bc.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~copy_bc.f90~~AfferentGraph sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefilecopy_bcf90AfferentGraph = svgPanZoom('#sourcefilecopy_bcf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules copy_bc Source Code copy_bc.f90 Source Code !< A module contains generalized subroutine to copy variable in ghost cells module copy_bc !< A module contains generalized subroutine to copy variable in ghost cells !-------------------------------------------- ! 170515  Jatinder Pal Singh Sandhu ! Aim : applying boundary condition to domain !------------------------------------------- use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : c1 use global_vars , only : c2 use global_vars , only : c3 implicit none private public :: copy1 public :: copy3 contains subroutine copy1 ( var , type , face ) !< Copy 1 layer of interior cell to first ghost cell layer implicit none character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real :: a2 = 1 select case ( type ) case ( \"anti\" ) a2 = - 1 case ( \"symm\" ) a2 = 1 case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy1 subroutine copy3 ( var , type , face ) !< Copy 3 layer of interior cell to three ghost cell layer implicit none character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real :: a1 = 1 real :: a2 = 1 real :: a3 = 0 integer :: i1 = 1 integer :: i2 = 2 integer :: i3 = 3 select case ( type ) case ( \"anti\" ) a1 = 1. ; i1 = 1 a2 = - 1. ; i2 = 2 a3 = 0. ; i3 = 3 case ( \"flat\" ) a1 = 1. ; i1 = 1 a2 = 1. ; i2 = 1 a3 = 0. ; i3 = 1 case ( \"symm\" ) a1 = c1 ; i1 = 1 a2 = c2 ; i2 = 2 a3 = c3 ; i3 = 3 ! do nothing ! use default value continue case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i1 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i2 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i3 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i1 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i2 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i3 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i1 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i2 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i3 + 1 , 1 : kmx - 1 )) / a1 case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i1 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i2 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i3 - 1 , 1 : kmx - 1 )) / a1 case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 + 1 )) / a1 case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 - 1 )) / a1 case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy3 end module copy_bc","tags":"","loc":"sourcefile/copy_bc.f90.html","title":"copy_bc.f90 – FEST-3D"},{"text":"Apply boundary condition at every iteration This file depends on sourcefile~~bc_primitive.f90~~EfferentGraph sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~utils.f90 utils.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~bc_primitive.f90->sourcefile~global_vars.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~read_bc.f90->sourcefile~global_vars.f90 sourcefile~layout.f90 layout.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~global.f90 global.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~ft_bc.f90->sourcefile~global_vars.f90 sourcefile~copy_bc.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~bc_primitive.f90~~AfferentGraph sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bc_primitive Source Code bc_primitive.f90 Source Code !< Apply boundary condition at every iteration module bc_primitive !< Apply boundary condition at every iteration !-------------------------------------------- ! 170515  Jatinder Pal Singh Sandhu ! Aim : applying boundary condition to domain !------------------------------------------- #include \"../error.inc\" use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id use global_vars , only : fixed_density use global_vars , only : fixed_x_speed use global_vars , only : fixed_y_speed use global_vars , only : fixed_z_speed use global_vars , only : fixed_pressure use global_vars , only : fixed_tk use global_vars , only : fixed_tw use global_vars , only : fixed_tkl use global_vars , only : fixed_tgm use global_vars , only : fixed_wall_temperature use global_vars , only : fixed_Ttemperature use global_vars , only : fixed_Tpressure use global_vars , only : fixed_tv use global_vars , only : mu_ref use global_vars , only : R_gas use global_vars , only : sutherland_temp use global_vars , only : pressure use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : accur use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : xnx use global_vars , only : xny use global_vars , only : xnz use global_vars , only : ynx use global_vars , only : yny use global_vars , only : ynz use global_vars , only : znx use global_vars , only : zny use global_vars , only : znz use global_vars , only : mu_t use global_vars , only : T_ref use global_vars , only : dist use global_vars , only : process_id use global_vars , only : tk_inf use global_vars , only : tw_inf use global_vars , only : te_inf use global_vars , only : tv_inf use global_vars , only : tgm_inf use global_vars , only : tkl_inf use global_vars , only : face_names use global_vars , only : id use global_vars , only : gm use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : density_inf use global_vars , only : pressure_inf use global_vars , only : vel_mag use global_vars , only : qp use global_vars , only : current_iter use global_sst , only : beta1 use utils , only : turbulence_read_error use read_bc , only : read_fixed_values use copy_bc , only : copy3 use FT_bc , only : flow_tangency implicit none private integer :: face_num !< Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax public :: populate_ghost_primitive contains subroutine populate_ghost_primitive () !< Populate the state variables in the ghost cell !< with particular value based on the boundary conditio !< being applied at that face implicit none integer :: i character ( len = 4 ) :: face do i = 1 , 6 face_num = i face = face_names ( face_num ) select case ( id ( face_num )) case ( - 1 ) call supersonic_inlet ( face ) case ( - 2 ) call supersonic_outlet ( face ) case ( - 3 ) call subsonic_inlet ( face ) case ( - 4 ) call subsonic_outlet ( face ) case ( - 5 ) call wall ( face ) case ( - 6 ) call slip_wall ( face ) case ( - 7 ) call pole ( face ) case ( - 8 ) call far_field ( face ) case ( - 9 ) call periodic_bc ( face ) case ( - 11 ) call total_pressure ( face ) case Default if ( id ( i ) >= 0 . or . id ( i ) ==- 10 ) then continue !interface boundary else print * , \" boundary condition not recognised -> id is :\" , id ( i ) end if end select end do !        qp(0,0,:,:) = 0.5*(qp(0,1,:,:)+qp(1,0,:,:)) !        qp(0,jmx,:,:) = 0.5*(qp(0,jmx-1,:,:)+qp(1,jmx,:,:)) !        qp(imx,0,:,:) = 0.5*(qp(imx,1,:,:)+qp(imx-1,0,:,:)) !        qp(imx,jmx,:,:) = 0.5*(qp(imx,jmx-1,:,:)+qp(imx-1,jmx,:,:)) !        qp(0,:,0,:) = 0.5*(qp(0,:,1,:)+qp(1,:,0,:)) !        qp(0,:,kmx,:) = 0.5*(qp(0,:,kmx-1,:)+qp(1,:,kmx,:)) !        qp(imx,:,0,:) = 0.5*(qp(imx,:,1,:)+qp(imx-1,:,0,:)) !        qp(imx,:,kmx,:) = 0.5*(qp(imx,:,jmx-1,:)+qp(imx-1,:,jmx,:)) qp (:, 0 , 0 ,:) = 0.33 * ( qp (:, 1 , 1 ,:) + qp (:, 0 , 1 ,:) + qp (:, 1 , 0 ,:)) qp (:, 0 , kmx ,:) = 0.33 * ( qp (:, 1 , kmx - 1 ,:) + qp (:, 0 , kmx - 1 ,:) + qp (:, 1 , kmx ,:)) qp (:, jmx , 0 ,:) = 0.33 * ( qp (:, jmx - 1 , 1 ,:) + qp (:, jmx , 1 ,:) + qp (:, jmx - 1 , 0 ,:)) qp (:, jmx , kmx ,:) = 0.33 * ( qp (:, jmx - 1 , kmx - 1 ,:) + qp (:, jmx , kmx - 1 ,:) + qp (:, jmx - 1 , kmx ,:)) qp ( imx , 0 ,:,:) = 0.33 * ( qp ( imx - 1 , 1 ,:,:) + qp ( imx - 1 , 0 ,:,:) + qp ( imx , 1 ,:,:)) qp ( 0 , 0 ,:,:) = 0.33 * ( qp ( 1 , 1 ,:,:) + qp ( 1 , 0 ,:,:) + qp ( 0 , 1 ,:,:)) qp ( 0 , jmx ,:,:) = 0.33 * ( qp ( 1 , jmx - 1 ,:,:) + qp ( 1 , jmx ,:,:) + qp ( 0 , jmx - 1 ,:,:)) qp ( imx , jmx ,:,:) = 0.33 * ( qp ( imx - 1 , jmx - 1 ,:,:) + qp ( imx - 1 , jmx ,:,:) + qp ( imx , jmx - 1 ,:,:)) qp ( 0 , 0 , 0 ,:) = 0.33 * ( qp ( 1 , 0 , 0 ,:) + qp ( 0 , 1 , 0 ,:) + qp ( 0 , 0 , 1 ,:)) qp ( imx , 0 , 0 ,:) = 0.33 * ( qp ( imx - 1 , 0 , 0 ,:) + qp ( imx , 1 , 0 ,:) + qp ( imx , 0 , 1 ,:)) qp ( 0 , jmx , 0 ,:) = 0.33 * ( qp ( 1 , jmx , 0 ,:) + qp ( 0 , jmx - 1 , 0 ,:) + qp ( 0 , jmx , 1 ,:)) qp ( 0 , 0 , kmx ,:) = 0.33 * ( qp ( 1 , 0 , kmx ,:) + qp ( 0 , 1 , kmx ,:) + qp ( 0 , 0 , kmx - 1 ,:)) qp ( imx , jmx , 0 ,:) = 0.33 * ( qp ( imx - 1 , jmx , 0 ,:) + qp ( imx , jmx - 1 , 0 ,:) + qp ( imx , jmx , 1 ,:)) qp ( imx , 0 , kmx ,:) = 0.33 * ( qp ( imx - 1 , 0 , kmx ,:) + qp ( imx , 1 , kmx ,:) + qp ( imx , 0 , kmx - 1 ,:)) qp ( 0 , jmx , kmx ,:) = 0.33 * ( qp ( 1 , jmx , kmx ,:) + qp ( 0 , jmx - 1 , kmx ,:) + qp ( 0 , jmx , kmx - 1 ,:)) qp ( imx , jmx , kmx ,:) = 0.33 * ( qp ( imx - 1 , jmx , kmx ,:) + qp ( imx , jmx - 1 , kmx ,:) + qp ( imx , jmx , kmx - 1 ,:)) end subroutine populate_ghost_primitive subroutine supersonic_inlet ( face ) !< Supersonic inlet boundary condition !< All the values of state variables are fixed implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , fixed_density , face ) call fix ( x_speed , fixed_x_speed , face ) call fix ( y_speed , fixed_y_speed , face ) call fix ( z_speed , fixed_z_speed , face ) call fix ( pressure , fixed_pressure , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if end subroutine supersonic_inlet subroutine supersonic_outlet ( face ) !< Supersonic outlet boundary condition. !< All the values of state variables are copied !< from inside the domain implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) call copy3 ( pressure , \"flat\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine supersonic_outlet subroutine subsonic_inlet ( face ) !< Subsonic inlet boundary condition. !< All the state variables's value expect pressure !< is fixed and pressure is copied from inside the !< domain implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , fixed_density , face ) call fix ( x_speed , fixed_x_speed , face ) call fix ( y_speed , fixed_y_speed , face ) call fix ( z_speed , fixed_z_speed , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tw , face ) case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if call copy3 ( pressure , \"flat\" , face ) end subroutine subsonic_inlet subroutine subsonic_outlet ( face ) !< Subsonic outlet boundary condition. !< All the state variables's value expect pressure !< is copied from the inside of the domain and pressure !< is fixed implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) if ( current_iter <= 2 ) then call fix ( pressure , fixed_pressure , face ) end if select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine subsonic_outlet subroutine wall ( face ) !< Adiabatic/Isothermal wall boundary condition implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( pressure , \"symm\" , face ) call temp_based_density ( fixed_wall_temperature , face ) call no_slip ( face ) end subroutine wall subroutine slip_wall ( face ) !< Slip wall boundary condition. !< Maintain flow tangency implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"symm\" , face ) call copy3 ( pressure , \"symm\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"symm\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"symm\" , face ) call copy3 ( tw , \"symm\" , face ) case ( 'kkl' ) call copy3 ( tk , \"symm\" , face ) call copy3 ( tkl , \"symm\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select call flow_tangency ( face ) end subroutine slip_wall subroutine pole ( face ) !< Boundary condition for the block face !< with zero area; turning into a pole implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) call copy3 ( pressure , \"flat\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT call turbulence_read_error () end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine pole subroutine fix ( var , fix_val , face ) !< Generalized subroutine to fix particular value !< at particular face implicit none real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) , intent ( out ) :: var !< Variable of which values are being fixed in the ghost cell real , dimension ( 1 : 6 ) , intent ( in ) :: fix_val !< Amount of value that need to be fixed. character ( len =* ) , intent ( in ) :: face !< Name of the face at which boundary condition is called select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = fix_val ( 3 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = fix_val ( 4 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = fix_val ( 5 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = fix_val ( 6 ) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine fix subroutine no_slip ( face ) !< No-slip wall boundary condition. All the !< component of velocity throught face is zero implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( x_speed , \"anti\" , face ) call copy3 ( y_speed , \"anti\" , face ) call copy3 ( z_speed , \"anti\" , face ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"anti\" , face ) case ( \"sst\" , 'sst2003' ) call copy3 ( tk , \"anti\" , face ) call set_omega_at_wall ( face ) case ( \"kkl\" ) call copy3 ( tk , \"anti\" , face ) call copy3 ( tkl , \"anti\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine no_slip subroutine set_omega_at_wall ( face ) !< Set value of turbulence variable: omega (turbulenct dissipation rate). !< Value fixed is accourding to the SST turbulence model implicit none character ( len =* ), intent ( in ) :: face real :: T_face real :: mu real :: rho integer :: i , j , k , l select case ( face ) case ( \"imin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( 0 , j , k ) / density ( 0 , j , k )) + ( pressure ( 1 , j , k ) / density ( 1 , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( 0 , j , k ) + density ( 1 , j , k )) tw ( 1 - l , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( 1 , j , k )) ** 2 ) - tw ( l , j , k ) end do end do end do case ( \"imax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( imx - 1 , j , k ) / density ( imx - 1 , j , k )) + ( pressure ( imx , j , k ) / density ( imx , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( imx - 1 , j , k ) + density ( imx , j , k )) tw ( imx + l - 1 , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( imx - 1 , j , k )) ** 2 ) - tw ( imx - l , j , k ) end do end do end do case ( \"jmin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , 0 , k ) / density ( i , 0 , k )) + ( pressure ( i , 1 , k ) / density ( i , 1 , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , 0 , k ) + density ( i , 1 , k )) tw ( i , 1 - l , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , 1 , k )) ** 2 ) - tw ( i , l , k ) end do end do end do case ( \"jmax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , jmx - 1 , k ) / density ( i , jmx - 1 , k )) + ( pressure ( i , jmx , k ) / density ( i , jmx , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , jmx - 1 , k ) + density ( i , jmx , k )) tw ( i , jmx + l - 1 , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , jmx - 1 , k )) ** 2 ) - tw ( i , jmx - l , k ) end do end do end do case ( \"kmin\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , 0 ) / density ( i , j , 0 )) + ( pressure ( i , j , 1 ) / density ( i , j , 1 ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , 0 ) + density ( i , j , 1 )) tw ( i , j , 1 - l ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , 1 )) ** 2 ) - tw ( i , j , l ) end do end do end do case ( \"kmax\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , kmx - 1 ) / density ( i , j , kmx - 1 )) + ( pressure ( i , j , kmx ) / density ( i , j , kmx ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , kmx - 1 ) + density ( i , j , kmx )) tw ( i , j , kmx + l - 1 ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , kmx - 1 )) ** 2 ) - tw ( i , j , kmx - l ) end do end do end do end select end subroutine set_omega_at_wall subroutine check_if_value_fixed ( model ) !< A Fail-check subroutine which set the freestream !< as the fixed value in case not specified explicitly implicit none character ( len =* ), intent ( in ) :: model select case ( model ) case ( \"none\" , \"lctm2015\" ) !do nothing continue case ( \"sa\" , 'saBC' ) if ( fixed_tv ( face_num ) == 0.0 ) fixed_tv ( face_num ) = tv_inf case ( \"sst\" , 'sst2003' ) if ( fixed_tk ( face_num ) == 0. ) fixed_tk ( face_num ) = tk_inf if ( fixed_tw ( face_num ) == 0. ) fixed_tw ( face_num ) = tw_inf case ( \"kkl\" ) if ( fixed_tk ( face_num ) == 0. ) fixed_tk ( face_num ) = tk_inf if ( fixed_tkl ( face_num ) == 0. ) fixed_tkl ( face_num ) = tkl_inf case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) if ( fixed_tgm ( face_num ) == 0.0 ) fixed_tgm ( face_num ) = tgm_inf Case DEFAULT continue end select end subroutine check_if_value_fixed subroutine far_field ( face ) !< Far-field Riemann boundary condition implicit none character ( len =* ) :: face real :: cinf , cexp ! speed of sound real :: Rinf , Rexp ! Riemann invarient real :: Uninf , Unexp ! face normal speed real :: Unb ! normal velocity boundary real :: Cb ! speed of sound boundary real :: vel_diff real :: u , v , w real :: uf , vf , wf integer :: i , j , k real :: s integer , dimension ( 6 ) :: face_already_has_fixed_values = 0 !0=.no. face_already_has_fixed_values = 0 select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - xnx ( i , j , k )) + v * ( - xny ( i , j , k )) + w * ( - xnz ( i , j , k )) Uninf = uf * ( - xnx ( i , j , k )) + vf * ( - xny ( i , j , k )) + wf * ( - xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - xnz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 1 ) = 0 else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - xnz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 1 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 1 ) = 1 end if end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( xnx ( i , j , k )) + v * ( xny ( i , j , k )) + w * ( xnz ( i , j , k )) Uninf = uf * ( xnx ( i , j , k )) + vf * ( xny ( i , j , k )) + wf * ( xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( xnz ( i , j , k )) s = pressure ( i - 1 , j , k ) / ( density ( i - 1 , j , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 2 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( xnz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 2 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 2 ) = 1 end if end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - ynx ( i , j , k )) + v * ( - yny ( i , j , k )) + w * ( - ynz ( i , j , k )) Uninf = uf * ( - ynx ( i , j , k )) + vf * ( - yny ( i , j , k )) + wf * ( - ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - ynz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 3 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - ynz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 3 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 3 ) = 1 end if end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( ynx ( i , j , k )) + v * ( yny ( i , j , k )) + w * ( ynz ( i , j , k )) Uninf = uf * ( ynx ( i , j , k )) + vf * ( yny ( i , j , k )) + wf * ( ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( ynz ( i , j , k )) s = pressure ( i , j - 1 , k ) / ( density ( i , j - 1 , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 4 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( ynz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 4 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 4 ) = 1 end if end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - znx ( i , j , k )) + v * ( - zny ( i , j , k )) + w * ( - znz ( i , j , k )) Uninf = uf * ( - znx ( i , j , k )) + vf * ( - zny ( i , j , k )) + wf * ( - znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - znz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 5 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - znz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 5 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 5 ) = 1 end if end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( znx ( i , j , k )) + v * ( zny ( i , j , k )) + w * ( znz ( i , j , k )) Uninf = uf * ( znx ( i , j , k )) + vf * ( zny ( i , j , k )) + wf * ( znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( znz ( i , j , k )) s = pressure ( i , j , k - 1 ) / ( density ( i , j , k - 1 ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 6 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( znz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 6 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 6 ) = 1 end if end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine far_field subroutine total_pressure ( face ) !< Total Pressure Riemann boundary condition implicit none character ( len =* ) :: face real :: cinf , cexp ! speed of sound real :: Rinf , Rexp ! Riemann invarient real :: Uninf , Unexp ! face normal speed real :: Unb ! normal velocity boundary real :: Cb ! speed of sound boundary real :: vel_diff real :: u , v , w real :: uf , vf , wf real :: Mb integer :: i , j , k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - xnx ( i , j , k )) + v * ( - xny ( i , j , k )) + w * ( - xnz ( i , j , k )) Uninf = uf * ( - xnx ( i , j , k )) + vf * ( - xny ( i , j , k )) + wf * ( - xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i - 1 , j , k ) ** 2 + y_speed ( i - 1 , j , k ) ** 2 + z_speed ( i - 1 , j , k ) ** 2 ) / Cb pressure ( i - 1 , j , k ) = fixed_Tpressure ( 1 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i - 1 , j , k ) = gm * pressure ( i - 1 , j , k ) / ( Cb * Cb ) end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( xnx ( i , j , k )) + v * ( xny ( i , j , k )) + w * ( xnz ( i , j , k )) Uninf = uf * ( xnx ( i , j , k )) + vf * ( xny ( i , j , k )) + wf * ( xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 2 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - ynx ( i , j , k )) + v * ( - yny ( i , j , k )) + w * ( - ynz ( i , j , k )) Uninf = uf * ( - ynx ( i , j , k )) + vf * ( - yny ( i , j , k )) + wf * ( - ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j - 1 , k ) ** 2 + y_speed ( i , j - 1 , k ) ** 2 + z_speed ( i , j - 1 , k ) ** 2 ) / Cb pressure ( i , j - 1 , k ) = fixed_Tpressure ( 3 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j - 1 , k ) = gm * pressure ( i , j - 1 , k ) / ( Cb * Cb ) end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( ynx ( i , j , k )) + v * ( yny ( i , j , k )) + w * ( ynz ( i , j , k )) Uninf = uf * ( ynx ( i , j , k )) + vf * ( yny ( i , j , k )) + wf * ( ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 4 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - znx ( i , j , k )) + v * ( - zny ( i , j , k )) + w * ( - znz ( i , j , k )) Uninf = uf * ( - znx ( i , j , k )) + vf * ( - zny ( i , j , k )) + wf * ( - znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k - 1 ) = fixed_Tpressure ( 5 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k - 1 ) = gm * pressure ( i , j , k - 1 ) / ( Cb * Cb ) end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( znx ( i , j , k )) + v * ( zny ( i , j , k )) + w * ( znz ( i , j , k )) Uninf = uf * ( znx ( i , j , k )) + vf * ( zny ( i , j , k )) + wf * ( znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 6 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine total_pressure subroutine temp_based_density ( temperature , face ) !< Specify the density in the ghost cell based on the !< temperature on the wall. Isothermal or adiabatic implicit none real , dimension ( 1 : 6 ) , intent ( in ) :: temperature character ( len =* ) , intent ( in ) :: face real :: stag_temp integer :: i , j , k select case ( face ) case ( \"imin\" ) if ( temperature ( 1 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * stag_temp ) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * stag_temp ) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 1 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 0 , j , k ) / ( R_gas * density ( i + 0 , j , k ))))) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 1 , j , k ) / ( R_gas * density ( i + 1 , j , k ))))) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 2 , j , k ) / ( R_gas * density ( i + 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"imax\" ) if ( temperature ( 2 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * stag_temp ) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * stag_temp ) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 2 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 0 , j , k ) / ( R_gas * density ( i - 0 , j , k ))))) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k ))))) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 2 , j , k ) / ( R_gas * density ( i - 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"jmin\" ) if ( temperature ( 3 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * stag_temp ) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * stag_temp ) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 3 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 0 , k ) / ( R_gas * density ( i , j + 0 , k ))))) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 1 , k ) / ( R_gas * density ( i , j + 1 , k ))))) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 2 , k ) / ( R_gas * density ( i , j + 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"jmax\" ) if ( temperature ( 4 ) < 0.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * stag_temp ) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * stag_temp ) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 4 ) > 1.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 0 , k ) / ( R_gas * density ( i , j - 0 , k ))))) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k ))))) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 2 , k ) / ( R_gas * density ( i , j - 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"kmin\" ) if ( temperature ( 5 ) < 0.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * stag_temp ) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * stag_temp ) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 5 ) > 1.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 0 ) / ( R_gas * density ( i , j , k + 0 ))))) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 1 ) / ( R_gas * density ( i , j , k + 1 ))))) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 2 ) / ( R_gas * density ( i , j , k + 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"kmax\" ) if ( temperature ( 6 ) < 0.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * stag_temp ) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * stag_temp ) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 6 ) > 1.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 0 ) / ( R_gas * density ( i , j , k - 0 ))))) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 ))))) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 2 ) / ( R_gas * density ( i , j , k - 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine temp_based_density subroutine periodic_bc ( face ) !< Single block periodic boundary condition. !< Not to be used for multiblock boundary condition implicit none character ( len =* ), intent ( in ) :: face select case ( trim ( face )) case ( 'imin' ) qp ( - 2 : 0 ,:,:,:) = qp ( imx - 3 : imx - 1 ,:,:,:) case ( 'imax' ) qp ( imx : imx + 2 ,:,:,:) = qp ( 1 : 3 ,:,:,:) case ( 'jmin' ) qp (:, - 2 : 0 ,:,:) = qp (:, jmx - 3 : jmx - 1 ,:,:) case ( 'jmax' ) qp (:, jmx : jmx + 2 ,:,:) = qp (:, 1 : 3 ,:,:) case ( 'kmin' ) qp (:,:, - 2 : 0 ,:) = qp (:,:, kmx - 3 : kmx - 1 ,:) case ( 'kmax' ) qp (:,:, kmx : kmx + 2 ,:) = qp (:,:, 1 : 3 ,:) case Default Fatal_error end select end subroutine periodic_bc end module bc_primitive","tags":"","loc":"sourcefile/bc_primitive.f90.html","title":"bc_primitive.f90 – FEST-3D"},{"text":"Apply flow tangency boundary condition This file depends on sourcefile~~ft_bc.f90~~EfferentGraph sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~ft_bc.f90->sourcefile~copy_bc.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ft_bc.f90->sourcefile~global_vars.f90 sourcefile~copy_bc.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ft_bc.f90~~AfferentGraph sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules FT_bc Source Code FT_bc.f90 Source Code !< Apply flow tangency boundary condition module FT_bc !< Apply flow tangency boundary condition !-------------------------------------------- ! 170509  Jatinder Pal Singh Sandhu ! Aim : applying Flow tangency boundary condition !------------------------------------------- use global_vars , only : qp use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : xn use global_vars , only : yn use global_vars , only : zn use copy_bc , only : copy3 implicit none private public :: flow_tangency contains subroutine flow_tangency ( face ) !< Apply flow tangency boundary condition implicit none character ( len =* ), intent ( in ) :: face !< Face over which flow tangency condition has to be applied real :: dot1 real :: dot2 real :: dot3 integer :: i integer :: j integer :: k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 dot1 = sum ( qp ( 1 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) dot2 = sum ( qp ( 2 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) dot3 = sum ( qp ( 3 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) qp ( 0 , j , k , 2 : 4 ) = qp ( 1 , j , k , 2 : 4 ) - ( 2 * dot1 * xn ( 1 , j , k , 1 : 3 )) qp ( - 1 , j , k , 2 : 4 ) = qp ( 2 , j , k , 2 : 4 ) - ( 2 * dot2 * xn ( 1 , j , k , 1 : 3 )) qp ( - 2 , j , k , 2 : 4 ) = qp ( 3 , j , k , 2 : 4 ) - ( 2 * dot3 * xn ( 1 , j , k , 1 : 3 )) end do end do case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 dot1 = sum ( qp ( imx - 1 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) dot2 = sum ( qp ( imx - 2 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) dot3 = sum ( qp ( imx - 3 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) qp ( imx + 0 , j , k , 2 : 4 ) = qp ( imx - 1 , j , k , 2 : 4 ) - ( 2 * dot1 * xn ( imx , j , k , 1 : 3 )) qp ( imx + 1 , j , k , 2 : 4 ) = qp ( imx - 2 , j , k , 2 : 4 ) - ( 2 * dot2 * xn ( imx , j , k , 1 : 3 )) qp ( imx + 2 , j , k , 2 : 4 ) = qp ( imx - 3 , j , k , 2 : 4 ) - ( 2 * dot3 * xn ( imx , j , k , 1 : 3 )) end do end do case ( \"jmin\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , 1 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) dot2 = sum ( qp ( i , 2 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) dot3 = sum ( qp ( i , 3 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) qp ( i , 0 , k , 2 : 4 ) = qp ( i , 1 , k , 2 : 4 ) - ( 2 * dot1 * yn ( i , 1 , k , 1 : 3 )) qp ( i , - 1 , k , 2 : 4 ) = qp ( i , 2 , k , 2 : 4 ) - ( 2 * dot2 * yn ( i , 1 , k , 1 : 3 )) qp ( i , - 2 , k , 2 : 4 ) = qp ( i , 3 , k , 2 : 4 ) - ( 2 * dot3 * yn ( i , 1 , k , 1 : 3 )) end do end do case ( \"jmax\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , jmx - 1 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) dot2 = sum ( qp ( i , jmx - 2 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) dot3 = sum ( qp ( i , jmx - 3 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 0 , k , 2 : 4 ) = qp ( i , jmx - 1 , k , 2 : 4 ) - ( 2 * dot1 * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 1 , k , 2 : 4 ) = qp ( i , jmx - 2 , k , 2 : 4 ) - ( 2 * dot2 * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 2 , k , 2 : 4 ) = qp ( i , jmx - 3 , k , 2 : 4 ) - ( 2 * dot3 * yn ( i , jmx , k , 1 : 3 )) end do end do case ( \"kmin\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , j , 1 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) dot2 = sum ( qp ( i , j , 2 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) dot3 = sum ( qp ( i , j , 3 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , 0 , 2 : 4 ) = qp ( i , j , 1 , 2 : 4 ) - ( 2 * dot1 * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , - 1 , 2 : 4 ) = qp ( i , j , 2 , 2 : 4 ) - ( 2 * dot2 * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , - 2 , 2 : 4 ) = qp ( i , j , 3 , 2 : 4 ) - ( 2 * dot3 * zn ( i , j , 1 , 1 : 3 )) end do end do case ( \"kmax\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , j , kmx - 1 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) dot2 = sum ( qp ( i , j , kmx - 2 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) dot3 = sum ( qp ( i , j , kmx - 3 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 0 , 2 : 4 ) = qp ( i , j , kmx - 1 , 2 : 4 ) - ( 2 * dot1 * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 1 , 2 : 4 ) = qp ( i , j , kmx - 2 , 2 : 4 ) - ( 2 * dot2 * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 2 , 2 : 4 ) = qp ( i , j , kmx - 3 , 2 : 4 ) - ( 2 * dot3 * zn ( i , j , kmx , 1 : 3 )) end do end do end select end subroutine flow_tangency end module FT_bc","tags":"","loc":"sourcefile/ft_bc.f90.html","title":"FT_bc.f90 – FEST-3D"},{"text":"Get all the fixed values from the bc_**.md file This file depends on sourcefile~~read_bc.f90~~EfferentGraph sourcefile~read_bc.f90 read_bc.f90 sourcefile~layout.f90 layout.f90 sourcefile~read_bc.f90->sourcefile~layout.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~read_bc.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~utils.f90 utils.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_bc.f90~~AfferentGraph sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90 bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~bc.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileread_bcf90AfferentGraph = svgPanZoom('#sourcefileread_bcf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_bc Source Code read_bc.f90 Source Code !< Get all the fixed values from the bc_**.md file module read_bc !< Get all the fixed values from the bc_**.md file !----------------------------------------------------- ! 170516  Jatinder Pal Singh Sandhu ! Aim : get all the fixed valed from bc_**.md file !----------------------------------------------------- #include \"../error.inc\" use global , only : BOUNDARY_CONDITIONS_FILE_UNIT use global , only : STRING_BUFFER_LENGTH use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : tk_inf use global_vars , only : tw_inf use global_vars , only : tv_inf use global_vars , only : te_inf use global_vars , only : tkl_inf use global_vars , only : fixed_density use global_vars , only : fixed_x_speed use global_vars , only : fixed_y_speed use global_vars , only : fixed_z_speed use global_vars , only : fixed_pressure use global_vars , only : fixed_tk use global_vars , only : fixed_tw use global_vars , only : fixed_te use global_vars , only : fixed_tv use global_vars , only : fixed_tkl use global_vars , only : fixed_Tpressure use global_vars , only : fixed_Ttemperature use global_vars , only : fixed_wall_temperature use global_vars , only : process_id use global_vars , only : turbulence use layout , only : bc_file implicit none private character ( len = STRING_BUFFER_LENGTH ) :: buf !< String to extract single line from the file public :: read_fixed_values contains subroutine read_fixed_values () !< Read fixed values for each block face implicit none integer :: count = 0 call fill_fixed_values () open ( unit = BOUNDARY_CONDITIONS_FILE_UNIT , file = bc_file ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) do while ( count < 6 ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 1 ) == '#' ) then count = count + 1 call get_fixed_values ( count ) end if end do close ( BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine read_fixed_values subroutine get_fixed_values ( count ) !< Extract fixed value from the bc_**.md file implicit none integer , intent ( in ) :: count real :: fix_val integer :: ios do while (. true .) read ( BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 2 ) == '- ' ) then read ( buf ( index ( buf ( 3 :), ' ' ) + 3 :), * , iostat = ios ) fix_val select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_DENSITY\" ) call set_value ( fixed_density , fix_val , density_inf , count , ios ) case ( \"FIX_X_SPEED\" ) call set_value ( fixed_x_speed , fix_val , x_speed_inf , count , ios ) case ( \"FIX_Y_SPEED\" ) call set_value ( fixed_y_speed , fix_val , y_speed_inf , count , ios ) case ( \"FIX_Z_SPEED\" ) call set_value ( fixed_z_speed , fix_val , z_speed_inf , count , ios ) case ( \"FIX_PRESSURE\" ) call set_value ( fixed_pressure , fix_val , pressure_inf , count , ios ) case ( \"WALL_TEMPERATURE\" ) call set_value ( fixed_wall_temperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_TEMPERATURE\" ) call set_value ( fixed_Ttemperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_PRESSURE\" ) call set_value ( fixed_Tpressure , fix_val , 0.0 , count , ios ) end select select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( fixed_tk , fix_val , tk_inf , count , ios ) case ( \"FIX_tw\" ) call set_value ( fixed_tw , fix_val , tw_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"kkl\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( fixed_tk , fix_val , tk_inf , count , ios ) case ( \"FIX_tkl\" ) call set_value ( fixed_tkl , fix_val , tkl_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"sa\" , \"saBC\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tv\" ) call set_value ( fixed_tk , fix_val , tv_inf , count , ios ) case DEFAULT ! no a value to fix continue end select end select else exit end if end do end subroutine get_fixed_values subroutine fill_fixed_values () !< Fill the Fixed_var array with with free-stream value !< or default values. implicit none integer :: count integer :: ios =- 1 do count = 1 , 6 !case (\"FIX_DENSITY\") call set_value ( fixed_density , density_inf , density_inf , count , ios ) !case (\"FIX_X_SPEED\") call set_value ( fixed_x_speed , x_speed_inf , x_speed_inf , count , ios ) !case (\"FIX_Y_SPEED\") call set_value ( fixed_y_speed , y_speed_inf , y_speed_inf , count , ios ) !case (\"FIX_Z_SPEED\") call set_value ( fixed_z_speed , z_speed_inf , z_speed_inf , count , ios ) !case (\"FIX_PRESSURE\") call set_value ( fixed_pressure , pressure_inf , pressure_inf , count , ios ) !case (\"WALL_TEMPERATURE\") call set_value ( fixed_wall_temperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_TEMPERATURE\") call set_value ( fixed_Ttemperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_PRESSURE\") call set_value ( fixed_Tpressure , 0.0 , 0.0 , count , ios ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) !case (\"FIX_tk\") call set_value ( fixed_tk , tk_inf , tk_inf , count , ios ) !case (\"FIX_tw\") call set_value ( fixed_tw , tw_inf , tw_inf , count , ios ) case ( \"kkl\" ) !case (\"FIX_tk\") call set_value ( fixed_tk , tk_inf , tk_inf , count , ios ) !case (\"FIX_tkl\") call set_value ( fixed_tkl , tkl_inf , tkl_inf , count , ios ) case ( \"sa\" , \"saBC\" ) !case (\"FIX_tv\") call set_value ( fixed_tk , tv_inf , tv_inf , count , ios ) case DEFAULT Fatal_error end select end do end subroutine fill_fixed_values subroutine set_value ( fixed_var , fix_val , inf_val , count , ios ) !< Set particular value to the Fixed_var variable implicit none integer , intent ( in ) :: ios integer , intent ( in ) :: count real , intent ( in ) :: fix_val real , intent ( in ) :: inf_val real , intent ( out ), dimension (:) :: fixed_var if ( ios == 0 ) then fixed_var ( count ) = fix_val else fixed_var ( count ) = inf_val end if end subroutine set_value end module read_bc","tags":"","loc":"sourcefile/read_bc.f90.html","title":"read_bc.f90 – FEST-3D"},{"text":"Set value gradients in the ghost cells This file depends on sourcefile~~ghost_gradient.f90~~EfferentGraph sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~utils.f90 utils.f90 sourcefile~ghost_gradient.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~ghost_gradient.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~ghost_gradient.f90~~AfferentGraph sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileghost_gradientf90AfferentGraph = svgPanZoom('#sourcefileghost_gradientf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules ghost_gradients Source Code ghost_gradient.f90 Source Code !< Set value gradients in the ghost cells module ghost_gradients !< Set value gradients in the ghost cells ! --------------------------------------------------------- !   # 170508 - Jatinder Pal Singh Sandhu !--------------------------------------------------------- ! geometry use global_vars , only : imx , jmx , kmx use global_vars , only : xnx , xny , xnz use global_vars , only : ynx , yny , ynz use global_vars , only : znx , zny , znz use global_vars , only : xA , yA , zA use global_vars , only : volume ! state variable use global_vars , only : density use global_vars , only : pressure use global_vars , only : R_gas use global_vars , only : n_grad use global_vars , only : n_var ! state and gradients use global_vars , only : qp use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z ! layout boundary condition id for face use global_vars , only : imin_id use global_vars , only : imax_id use global_vars , only : jmin_id use global_vars , only : jmax_id use global_vars , only : kmin_id use global_vars , only : kmax_id use global_vars , only : fixed_wall_temperature use utils , only : dmsg implicit none public :: apply_gradient_bc contains subroutine apply_gradient_bc () !< Call same subroutine for all the face implicit none call dmsg ( 1 , 'ghost_gradients' , 'apply_gradient_bc' ) if ( imin_id < 0 ) then call apply ( 'imin' ) end if if ( imax_id < 0 ) then call apply ( 'imax' ) end if if ( jmin_id < 0 ) then call apply ( 'jmin' ) end if if ( jmax_id < 0 ) then call apply ( 'jmax' ) end if if ( kmin_id < 0 ) then call apply ( 'kmin' ) end if if ( kmax_id < 0 ) then call apply ( 'kmax' ) end if end subroutine apply_gradient_bc subroutine apply ( face ) !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none character ( len =* ) :: face real , dimension ( n_grad ) :: qp_I real , dimension ( n_grad ) :: qp_G real :: T_I real :: T_G real :: c_x real :: c_y real :: c_z integer :: n integer :: i , j , k , l real :: nx real :: ny real :: nz real :: dot !----------------------------------------------------------- ! gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) ! volume_G = volume_I !----------------------------------------------------------- n = n_grad select case ( face ) case ( 'imin' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 nx = xnx ( i , j , k ) ny = xny ( i , j , k ) nz = xnz ( i , j , k ) c_x = xA ( i , j , k ) * nx / volume ( i , j , k ) c_y = xA ( i , j , k ) * ny / volume ( i , j , k ) c_z = xA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i - 1 , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_z if ( imin_id ==- 5 . and . ( fixed_wall_temperature ( 1 ) < 1. . and . fixed_wall_temperature ( 1 ) >= 0. )) then gradqp_x ( i - 1 , j , k , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i - 1 , j , k , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i - 1 , j , k , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i - 1 , j , k , l ) = gradqp_x ( i - 1 , j , k , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i - 1 , j , k , l ) = gradqp_y ( i - 1 , j , k , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i - 1 , j , k , l ) = gradqp_z ( i - 1 , j , k , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'imax' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx nx = xnx ( i , j , k ) ny = xny ( i , j , k ) nz = xnz ( i , j , k ) c_x = xA ( i , j , k ) * nx / volume ( i - 1 , j , k ) c_y = xA ( i , j , k ) * ny / volume ( i - 1 , j , k ) c_z = xA ( i , j , k ) * nz / volume ( i - 1 , j , k ) T_I = pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i - 1 , j , k , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( imax_id ==- 5 . and . ( fixed_wall_temperature ( 2 ) < 1. . and . fixed_wall_temperature ( 2 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i - 1 , j , k , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i - 1 , j , k , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i - 1 , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i - 1 , j , k , l ) * nx ) + ( gradqp_y ( i - 1 , j , k , l ) * ny ) + ( gradqp_z ( i - 1 , j , k , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i - 1 , j , k , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i - 1 , j , k , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i - 1 , j , k , l ) - dot * nz ) end do end do end do end do case ( 'jmin' ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 nx = ynx ( i , j , k ) ny = yny ( i , j , k ) nz = ynz ( i , j , k ) c_x = yA ( i , j , k ) * nx / volume ( i , j , k ) c_y = yA ( i , j , k ) * ny / volume ( i , j , k ) c_z = yA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i , j - 1 , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_z if ( jmin_id ==- 5 . and . ( fixed_wall_temperature ( 3 ) < 1. . and . fixed_wall_temperature ( 3 ) >= 0. )) then gradqp_x ( i , j - 1 , k , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i , j - 1 , k , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i , j - 1 , k , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i , j - 1 , k , l ) = gradqp_x ( i , j - 1 , k , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i , j - 1 , k , l ) = gradqp_y ( i , j - 1 , k , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i , j - 1 , k , l ) = gradqp_z ( i , j - 1 , k , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'jmax' ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 nx = ynx ( i , j , k ) ny = yny ( i , j , k ) nz = ynz ( i , j , k ) c_x = yA ( i , j , k ) * nx / volume ( i , j , k ) c_y = yA ( i , j , k ) * ny / volume ( i , j , k ) c_z = yA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i , j - 1 , k , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( jmax_id ==- 5 . and . ( fixed_wall_temperature ( 4 ) < 1. . and . fixed_wall_temperature ( 4 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i , j - 1 , k , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i , j - 1 , k , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i , j - 1 , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j - 1 , k , l ) * nx ) + ( gradqp_y ( i , j - 1 , k , l ) * ny ) + ( gradqp_z ( i , j - 1 , k , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i , j - 1 , k , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i , j - 1 , k , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i , j - 1 , k , l ) - dot * nz ) end do end do end do end do case ( 'kmin' ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 nx = znx ( i , j , k ) ny = zny ( i , j , k ) nz = znz ( i , j , k ) c_x = zA ( i , j , k ) * nx / volume ( i , j , k ) c_y = zA ( i , j , k ) * ny / volume ( i , j , k ) c_z = zA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i , j , k - 1 , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_z if ( kmin_id ==- 5 . and . ( fixed_wall_temperature ( 5 ) < 1. . and . fixed_wall_temperature ( 5 ) >= 0. )) then gradqp_x ( i , j , k - 1 , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i , j , k - 1 , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i , j , k - 1 , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i , j , k - 1 , l ) = gradqp_x ( i , j , k - 1 , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i , j , k - 1 , l ) = gradqp_y ( i , j , k - 1 , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i , j , k - 1 , l ) = gradqp_z ( i , j , k - 1 , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'kmax' ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 nx = znx ( i , j , k ) ny = zny ( i , j , k ) nz = znz ( i , j , k ) c_x = zA ( i , j , k ) * nx / volume ( i , j , k ) c_y = zA ( i , j , k ) * ny / volume ( i , j , k ) c_z = zA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i , j , k - 1 , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( kmax_id ==- 5 . and . ( fixed_wall_temperature ( 6 ) < 1. . and . fixed_wall_temperature ( 6 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i , j , k - 1 , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i , j , k - 1 , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i , j , k - 1 , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k - 1 , l ) * nx ) + ( gradqp_y ( i , j , k - 1 , l ) * ny ) + ( gradqp_z ( i , j , k - 1 , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i , j , k - 1 , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i , j , k - 1 , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i , j , k - 1 , l ) - dot * nz ) end do end do end do end do case DEFAULT print * , \"Ghost gradients : Wrong face name string\" end select end subroutine apply end module ghost_gradients","tags":"","loc":"sourcefile/ghost_gradient.f90.html","title":"ghost_gradient.f90 – FEST-3D"},{"text":"Reconstruct the boundary face in case of 4th and 5th order methods This file depends on sourcefile~~boundary_state_reconstruction.f90~~EfferentGraph sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~utils.f90 utils.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~boundary_state_reconstruction.f90~~AfferentGraph sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules boundary_state_reconstruction Source Code boundary_state_reconstruction.f90 Source Code !< Reconstruct the boundary face in case of 4th and 5th order methods module boundary_state_reconstruction !< Reconstruct the boundary face in case of 4th and 5th order higher order !< face state reconstruction method. Since the limited information !< is available at the boundaries, the boundary face is limiter to !< 3rd order accurate and is reconstructed using MUSCL Scheme even when !< rest of the domain is using WENO or PPM use utils , only : dmsg !  use grid,                 only: imx, jmx, kmx use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : imin_id use global_vars , only : jmin_id use global_vars , only : kmin_id use global_vars , only : imax_id use global_vars , only : jmax_id use global_vars , only : kmax_id use global_vars , only : qp use global_vars , only : n_var use global_vars , only : ilimiter_switch use global_vars , only : jlimiter_switch use global_vars , only : klimiter_switch use global_vars , only : itlimiter_switch use global_vars , only : jtlimiter_switch use global_vars , only : ktlimiter_switch use face_interpolant , only : x_qp_left , x_qp_right use face_interpolant , only : y_qp_left , y_qp_right use face_interpolant , only : z_qp_left , z_qp_right implicit none private integer :: ppm_flag = 0 !< Flag to check if reconstruction is required integer :: switch_L = 1 !< Limiter switch public :: reconstruct_boundary_state contains subroutine reconstruct_boundary_state ( interpolant ) !< Call reconstruction based on the flag and boundary condition implicit none character ( len =* ), intent ( in ) :: interpolant call dmsg ( 1 , 'boundary_state_recons' , 'recons_boundary_state' ) if ( interpolant == 'ppm' . or . interpolant == 'weno' . or . interpolant == 'weno_NM' ) ppm_flag = 1 if ( imin_id ==- 7 . or . jmin_id ==- 7 . or . kmin_id ==- 7 ) ppm_flag = 1 if ( imax_id ==- 7 . or . jmax_id ==- 7 . or . kmax_id ==- 7 ) ppm_flag = 1 if ( interpolant /= 'none' ) then if ( imin_id < 0 . and . imin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'imin' ) call reconstruct_imin () end if if ( imax_id < 0 . and . imax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'imax' ) call reconstruct_imax () end if if ( jmin_id < 0 . and . jmin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'jmin' ) call reconstruct_jmin () end if if ( jmax_id < 0 . and . jmax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'jmax' ) call reconstruct_jmax () end if if ( kmin_id < 0 . and . kmin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'kmin' ) call reconstruct_kmin () end if if ( kmax_id < 0 . and . kmax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'kmax' ) call reconstruct_kmax () end if end if end subroutine reconstruct_boundary_state subroutine reconstruct_imin () !< Reconstruct state at the IMIN boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! reconstruct first cell faces for ppm scheme fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right state of firsrt interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of first interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( imin_id ==- 8 . or . imin_id ==- 9 ) then x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else ! right face of first ghost cell x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imin subroutine reconstruct_imax () !< Reconstruct state at the IMAX boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of last interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( imax_id ==- 8 . or . imax_id ==- 9 ) then x_qp_left ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imax subroutine reconstruct_jmin () !< Reconstruct state at the JMIN boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = jtlimiter_switch do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( jmin_id ==- 8 . or . jmin_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) else y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmin subroutine reconstruct_jmax () !< Reconstruct state at the JMAX boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = jtlimiter_switch do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( jmax_id ==- 8 . or . jmax_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) else y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmax subroutine reconstruct_kmin () !< Reconstruct state at the KMIN boundary face with MUSCL scheme implicit none real :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = klimiter_switch if ( ppm_flag == 1 ) then do k = 1 , 1 do l = 1 , n_var if ( l >= 6 ) switch_L = ktlimiter_switch if ( l < 6 ) switch_L = klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first k cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( kmin_id ==- 8 . or . kmin_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) else z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var )) end if end subroutine reconstruct_kmin subroutine reconstruct_kmax () !< Reconstruct state at the KMAX boundary face with MUSCL scheme implicit none real :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = klimiter_switch do k = kmx - 1 , kmx - 1 do l = 1 , n_var if ( l >= 6 ) switch_L = ktlimiter_switch if ( l < 6 ) switch_L = klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 ! left face of kmx ghost cell z_qp_right ( i , j , k + 1 , l ) = 0.5 * ( qp ( i , j , k , l ) + qp ( i , j , k + 1 , l )) if ( ppm_flag == 1 ) then fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last k interior cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end if end do end do end do end do if ( kmax_id ==- 8 . or . kmax_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) else z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var )) end if end subroutine reconstruct_kmax end module boundary_state_reconstruction","tags":"","loc":"sourcefile/boundary_state_reconstruction.f90.html","title":"boundary_state_reconstruction.f90 – FEST-3D"},{"text":"Check for solution's convergence This file depends on sourcefile~~convergence.f90~~EfferentGraph sourcefile~convergence.f90 convergence.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~convergence.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~convergence.f90~~AfferentGraph sourcefile~convergence.f90 convergence.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~convergence.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules convergence Source Code convergence.f90 Source Code !< Check for solution's convergence module convergence !< Check for solution's convergence !------------------------------------- ! 170803  -Jatinder Pal Singh Sandhu !           find if solution converged !------------------------------------- use global_vars , only : Res_abs use global_vars , only : Res_rel use global_vars , only : tolerance use global_vars , only : tolerance_type use global_vars , only : process_id use global_vars , only : current_iter #include \"../error.inc\" implicit none private public :: converged contains function converged () result ( c ) !< Check if the solution seems to have converged !< The solution is said to have converged if the change in !< the residue norm is \"negligible\". !----------------------------------------------------------- implicit none logical :: c real :: check = 1 0. select case ( trim ( tolerance_type )) !include \"convergence_select.inc\" case ( 'Mass_abs' ) check = Res_abs ( 0 ) case ( 'Resnorm_abs' ) check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) check = sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) check = sqrt ( sum ( Res_abs ( 6 :) ** 2 )) case ( 'Continuity_abs' ) check = Res_abs ( 1 ) case ( 'X-mom_abs' ) check = Res_abs ( 2 ) case ( 'Z-mom_abs' ) check = Res_abs ( 3 ) case ( 'Y-mom_abs' ) check = Res_abs ( 4 ) case ( 'Energy_abs' ) check = Res_abs ( 5 ) case ( 'Mass_rel' ) check = Res_rel ( 0 ) case ( 'Resnorm_rel' ) check = sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) check = sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) check = sqrt ( sum ( Res_rel ( 6 :) ** 2 )) case ( 'Continuity_rel' ) check = Res_rel ( 1 ) case ( 'X-mom_rel' ) check = Res_rel ( 2 ) case ( 'Z-mom_rel' ) check = Res_rel ( 3 ) case ( 'Y-mom_rel' ) check = Res_rel ( 4 ) case ( 'Energy_rel' ) check = Res_rel ( 5 ) case ( 'TKE_abs' ) check = Res_abs ( 6 ) case ( 'tv_abs' ) check = Res_abs ( 6 ) case ( 'Dissipation_abs' ) check = Res_abs ( 7 ) case ( 'Omega_abs' ) check = Res_abs ( 7 ) case ( 'Kl_abs' ) check = Res_abs ( 7 ) case ( 'TKE_rel' ) check = Res_rel ( 6 ) case ( 'tv_rel' ) check = Res_rel ( 6 ) case ( 'Dissipation_rel' ) check = Res_rel ( 7 ) case ( 'Omega_rel' ) check = Res_rel ( 7 ) case ( 'Kl_rel' ) check = Res_rel ( 7 ) case DEFAULT ! making absolute resnorm default check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select if ( check < tolerance . and . current_iter > 10 ) then c = . TRUE . else c = . FALSE . end if end function converged end module convergence","tags":"","loc":"sourcefile/convergence.f90.html","title":"convergence.f90 – FEST-3D"},{"text":"Calculate the distance from the wall \n for each cell-center in the domain This file depends on sourcefile~~wall_dist.f90~~EfferentGraph sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~utils.f90 utils.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~wall_dist.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~wall_dist.f90~~AfferentGraph sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~wall_dist.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules wall_dist Source Code wall_dist.f90 Source Code !< Calculate the distance from the wall !< for each cell-center in the domain module wall_dist !< Calculate the distance from the wall !< for each cell-center in the domain use global , only : NODESURF_FILE_UNIT use global , only : WALL_DIST_FILE_UNIT use global , only : wall_dist_file use global , only : surface_node_points use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : dist use utils , only : alloc , dealloc , dmsg !  use grid, only: imx,jmx, kmx, grid_x, grid_y, grid_z implicit none private integer :: n_surfnodes !< Number of surfce node points !  real, public, dimension(:,:,:), allocatable :: dist real , private , dimension (:) , allocatable :: wall_x !< X component of wall surface node point real , private , dimension (:) , allocatable :: wall_y !< Y component of wall surface node point real , private , dimension (:) , allocatable :: wall_z !< Z component of wall surface node point public :: setup_wall_dist public :: destroy_wall_dist public :: find_wall_dist contains subroutine setup_wall_dist () !< Allocate memory to the wall_distance variables !< and read the surface node file implicit none call dmsg ( 1 , 'wall_dist' , 'setup_wall_dist' ) call setup_nodefile () call alloc ( wall_x , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_y , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_z , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( dist , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & \"ERROR: unale to allocate memory to 'Dist' variable \" ) call read_destroy_nodefile end subroutine setup_wall_dist subroutine destroy_wall_dist () !< Deallocate the memory of wall_distance variable, !< wall_x, wall_y, and wall_z implicit none call dmsg ( 1 , 'wall_dist' , 'destroy_wall_dist' ) call dealloc ( wall_x ) call dealloc ( wall_y ) call dealloc ( wall_z ) call dealloc ( dist ) end subroutine destroy_wall_dist subroutine setup_nodefile () !< Open and read first line of surface_node_point file implicit none integer :: ios open ( NODESURF_FILE_UNIT , file = surface_node_points , status = 'old' , IOSTAT = ios ) if ( ios /= 0 ) then call dmsg ( 5 , 'wall_dist' , 'setup_nodefile' , & \"!!! -->file containg surface nodepoints not found\" ) end if read ( NODESURF_FILE_UNIT , * ) n_surfnodes end subroutine setup_nodefile subroutine read_destroy_nodefile () !< Read, and close surface_node_point file implicit none integer :: i do i = 1 , n_surfnodes read ( NODESURF_FILE_UNIT , * ) wall_x ( i ), wall_y ( i ), wall_z ( i ) end do close ( NODESURF_FILE_UNIT ) end subroutine read_destroy_nodefile subroutine find_wall_dist () !< Determine the minimum wall distance from the wall surface node points implicit none integer :: i , j , k , n real :: current_dist real , dimension (:,:,:), allocatable :: node_dist call dmsg ( 1 , 'wall_dist' , 'find_wall_dist' ) call alloc ( node_dist , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 ) do k = - 2 , kmx + 3 do j = - 2 , jmx + 3 do i = - 2 , imx + 3 node_dist ( i , j , k ) = 1.e+20 do n = 1 , n_surfnodes current_dist = sqrt (( wall_x ( n ) - grid_x ( i , j , k )) ** 2 & + ( wall_y ( n ) - grid_y ( i , j , k )) ** 2 & + ( wall_z ( n ) - grid_z ( i , j , k )) ** 2 & ) node_dist ( i , j , k ) = min ( node_dist ( i , j , k ), current_dist ) end do end do end do end do do k =- 2 , kmx + 2 do j =- 2 , jmx + 2 do i =- 2 , imx + 2 dist ( i , j , k ) = 0.125 * ( node_dist ( i , j , k )& + node_dist ( i , j + 1 , k )& + node_dist ( i , j + 1 , k + 1 )& + node_dist ( i , j , k + 1 )& + node_dist ( i + 1 , j , k + 1 )& + node_dist ( i + 1 , j , k )& + node_dist ( i + 1 , j + 1 , k )& + node_dist ( i + 1 , j + 1 , k + 1 )& ) end do end do end do call dealloc ( node_dist ) call dmsg ( 1 , 'wall_dist' , 'find_wall_dist-> complete' ) end subroutine find_wall_dist end module wall_dist","tags":"","loc":"sourcefile/wall_dist.f90.html","title":"wall_dist.f90 – FEST-3D"},{"text":"Detect all the grid points on the wall boundary condition This file depends on sourcefile~~wall.f90~~EfferentGraph sourcefile~wall.f90 wall.f90 sourcefile~string.f90 string.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~wall.f90->sourcefile~global_vars.f90 sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~global.f90 global.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~wall.f90~~AfferentGraph sourcefile~wall.f90 wall.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~wall.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules wall Source Code wall.f90 Source Code !< Detect all the grid points on the wall boundary condition module wall !< Detect all the grid points on the wall boundary condition !< and store them in a single file use global , only : surface_node_points use global , only : NODESURF_FILE_UNIT use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : process_id use global_vars , only : total_process use global_vars , only : id use string use bitwise use utils , only : alloc , dealloc , dmsg , DEBUG_LEVEL #include \"../error.inc\" #include \"../mpi.inc\" private integer :: ierr !< Integer to store error real :: buf integer :: BUFSIZE !< Size of buffer for mpi integer :: new_type !< Create new type for MPI integer :: thisfile !< File hadler integer , parameter :: maxlen = 70 !< Maximum length for string real , private , dimension (:, :), allocatable , target :: wallc !< Centre of wall surface real , private , dimension (:), pointer :: wall_x !< X coordiante of center of wall surface real , private , dimension (:), pointer :: wall_y !< Y coordiante of center of wall surface real , private , dimension (:), pointer :: wall_z !< Z coordiante of center of wall surface integer , dimension ( 6 ) :: no_slip_flag = 0 !< Flag to detect wall integer , public :: n_wall !< Number of points on the wall integer , public :: total_n_wall !< Total number of points on the block across all processes character ( len = maxlen ), dimension (:), allocatable :: str !< Store all wall corridnate of current process in a string vector character ( len = maxlen ) :: line !< Line to write in output file character , parameter :: lf = Achar ( 10 ) !< End of line character ! For gather all the data to process 0 integer , dimension (:), allocatable :: n_wall_buf !< Store n_wall points of all processors in a array form integer , dimension (:), allocatable :: write_flag !< Check if current processor has any wall points to write public :: write_surfnode contains subroutine write_surfnode () !< Extract and write the wall surface node points !< in a file shared by all the MPI processes implicit none integer :: count integer :: i call setup_surface () call surface_points () call MPI_GATHER ( n_wall , 1 , MPI_Integer , n_wall_buf , 1 , & MPI_integer , 0 , MPI_COMM_WORLD , ierr ) total_n_wall = sum ( n_wall_buf (:)) call MPI_Bcast ( total_n_wall , 1 , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) call MPI_Bcast ( n_wall_buf , total_process , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) write_flag = 0 count = 0 do i = 1 , total_process if ( n_wall_buf ( i ) > 0 ) then write_flag ( i ) = count count = count + 1 end if end do call MPI_TYPE_CONTIGUOUS ( maxlen , MPI_Character , new_type , ierr ) call MPI_TYPE_COMMIT ( new_type , ierr ) if ( process_id == 0 ) then write ( line , '(I0)' ) total_n_wall line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) if ( n_wall > 0 ) then do i = 1 , n_wall write ( line , '(3(ES18.10E3,4x))' ) wall_x ( i ), wall_y ( i ), wall_z ( i ) line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end do end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call destroy_surface () end subroutine write_surfnode subroutine allocate_memory () !< Allocate memory to str and wallc variable array implicit none call dmsg ( 1 , 'wall_find' , 'setup_surface' ) n_wall = - 1 n_wall = (( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 1 )) & + ( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 2 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 3 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 4 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 5 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 6 )) & ) allocate ( str ( 1 : n_wall )) call alloc ( wallc , 1 , n_wall , 1 , 3 ,& errmsg = 'Error: Unable to allocate memory for wallc' ) allocate ( n_wall_buf ( 1 : total_process )) allocate ( write_flag ( 1 : total_process )) end subroutine allocate_memory subroutine link_aliases () !< Link pointers wall_x, wall_y, wall_z to wallc implicit none call dmsg ( 1 , 'wall_find' , 'link_aliases' ) wall_x ( 1 : n_wall ) => wallc ( 1 : n_wall , 1 ) wall_y ( 1 : n_wall ) => wallc ( 1 : n_wall , 2 ) wall_z ( 1 : n_wall ) => wallc ( 1 : n_wall , 3 ) end subroutine link_aliases subroutine unlink_aliases () !< Unlink all the pointer used in this module implicit none call dmsg ( 1 , 'wall_find' , 'unlink_aliases' ) nullify ( wall_x ) nullify ( wall_y ) nullify ( wall_z ) end subroutine unlink_aliases subroutine deallocate_memory () !< Deallocate memory from the Wallc array implicit none call dmsg ( 1 , 'wall_find' , 'dealloate_memory' ) call dealloc ( wallc ) end subroutine deallocate_memory subroutine setup_surface () !< Open MPI_shared write file, allocate memory and !< setup pointers implicit none integer :: stat call dmsg ( 1 , 'wall_find' , 'setup_surface' ) if ( process_id == 0 ) then open ( NODESURF_FILE_UNIT , file = surface_node_points , iostat = stat ) if ( stat == 0 ) close ( NODESURF_FILE_UNIT , status = 'delete' ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_OPEN ( MPI_COMM_WORLD , surface_node_points , & MPI_MODE_WRONLY + MPI_MODE_CREATE + MPI_MODE_EXCL , & MPI_INFO_NULL , thisfile , ierr ) call find_wall () call allocate_memory () call link_aliases () end subroutine setup_surface subroutine destroy_surface () !< Deallocate memory, unlink pointers, and close MPI_shared file implicit none call dmsg ( 1 , 'wall_find' , 'destroy_surface' ) call deallocate_memory () call unlink_aliases () call MPI_FILE_CLOSE ( thisfile , ierr ) end subroutine destroy_surface subroutine find_wall () !< Setup wall flag for all six boundary of the block implicit none integer :: i NO_slip_flag = 0 do i = 1 , 6 if ( id ( i ) ==- 5 ) NO_SLIP_FLAG ( i ) = 1 end do end subroutine find_wall subroutine surface_points () !< Extract surface points and store them !< in a string vector str(ind) implicit none integer :: OL integer :: i , j , k , ind integer :: im = 1 , ix = 1 integer :: jm = 1 , jx = 1 integer :: km = 1 , kx = 1 call dmsg ( 1 , 'wall_find' , 'surface_points' ) ind = 0 do OL = 1 , 6 if ( NO_SLIP_flag ( OL ) == 1 ) then select case ( OL ) case ( 1 ) km = 1 jm = 1 im = 1 kx = kmx jx = jmx ix = 1 case ( 2 ) km = 1 jm = 1 im = imx kx = kmx jx = jmx ix = imx case ( 3 ) km = 1 jm = 1 im = 1 kx = kmx jx = 1 ix = imx case ( 4 ) km = 1 jm = jmx im = 1 kx = kmx jx = jmx ix = imx case ( 5 ) km = 1 jm = 1 im = 1 kx = 1 jx = jmx ix = imx case ( 6 ) km = kmx jm = 1 im = 1 kx = kmx jx = jmx ix = imx case DEFAULT call dmsg ( 5 , \"wall_find\" , 'Surface_points' , 'FATAL  ERROR: select case' ) km = 1 jm = 1 im = 1 kx = - 1 jx = - 1 ix = - 1 end select do k = km , kx do j = jm , jx do i = im , ix ind = ind + 1 wall_x ( ind ) = grid_x ( i , j , k ) wall_y ( ind ) = grid_y ( i , j , k ) wall_z ( ind ) = grid_z ( i , j , k ) write ( str ( ind ), '(3(f0.16, 4x))' ) wall_x ( ind ), wall_y ( ind ), wall_z ( ind ) end do end do end do end if end do end subroutine surface_points end module wall","tags":"","loc":"sourcefile/wall.f90.html","title":"wall.f90 – FEST-3D"},{"text":"Writing solution in the output file in tecplot format with\n node data instead of cell-center data. This file depends on sourcefile~~write_output_tec_node.f90~~EfferentGraph sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~string.f90 string.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_tec_node.f90~~AfferentGraph sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 var pansourcefilewrite_output_tec_nodef90AfferentGraph = svgPanZoom('#sourcefilewrite_output_tec_nodef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_tec_node Source Code write_output_tec_node.f90 Source Code !< Writing solution in the output file in tecplot format with !< node data instead of cell-center data. module write_output_tec_node !< Writing solution in the output file in tecplot format with !< node data instead of cell-center data. !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- use global , only : OUT_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global_vars , only : write_data_format use global_vars , only : write_file_format use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : gm use global_vars , only : dist use global_vars , only : vis_resnorm use global_vars , only : cont_resnorm use global_vars , only : x_mom_resnorm use global_vars , only : y_mom_resnorm use global_vars , only : z_mom_resnorm use global_vars , only : energy_resnorm use global_vars , only : resnorm use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : intermittency use global_vars , only : turbulence use global_vars , only : mu_ref use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : w_count use global_vars , only : w_list use global_sst , only : sst_F1 use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : process_id use global_vars , only : checkpoint_iter_count use utils use string implicit none private integer :: i , j , k real :: speed_inf character ( len = 8 ) :: file_format character ( len = 16 ) :: data_format character :: newline = achar ( 10 ) character ( len =* ), parameter :: format = \"(35e25.15)\" public :: write_file contains subroutine write_file () !< Write output file in the tecplot format with node data implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) ! case('Wall_distance') !   call write_scalar(dist, \"Wall_dist\", 1) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) ! case('Mass_residue') !   call write_scalar(mass_residue, \"Mass_residue\", 1) ! case('X_mom_residue') !   call write_scalar(x_mom_residue, \"X_mom_residue\", 1) ! case('Y_mom_residue') !   call write_scalar(y_mom_residue, \"Y_mom_residue\", 1) ! case('Z_mom_residue') !   call write_scalar(z_mom_residue, \"Z_mom_residue\", 1) ! case('Energy_residue') !   call write_scalar(energy_residue, \"Energy_residue\", 1) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header () !< Write the header in the output file implicit none integer :: n integer :: total call dmsg ( 1 , 'write_output_vtk' , 'write_header' ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx - 1 , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=Nodal)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , checkpoint_iter_count end subroutine write_header subroutine write_grid () !< Write grid information in the output file implicit none ! write grid point coordinates call dmsg ( 1 , 'write_output_tec_node' , 'write_grid' ) write ( OUT_FILE_UNIT , format ) ((( grid_x ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( grid_y ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( grid_z ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_grid subroutine write_scalar ( var , name , index ) !< Write scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'write_output_tec_node' , trim ( name )) write ( OUT_FILE_UNIT , format ) ((( 0.25 * ( var ( i , j , k ) + var ( i - 1 , j , k )& + var ( i , j - 1 , k ) + var ( i - 1 , j - 1 , k ))& , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_scalar end module write_output_tec_node","tags":"","loc":"sourcefile/write_output_tec_node.f90.html","title":"write_output_tec_node.f90 – FEST-3D"},{"text":"Vtk module to write the solution in the vtk format This file depends on sourcefile~~write_output_vtk.f90~~EfferentGraph sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~string.f90 string.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_vtk.f90~~AfferentGraph sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 var pansourcefilewrite_output_vtkf90AfferentGraph = svgPanZoom('#sourcefilewrite_output_vtkf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_vtk Source Code write_output_vtk.f90 Source Code !< Vtk module to write the solution in the vtk format module write_output_vtk !< Vtk module to write the solution in the vtk format !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use global , only : OUT_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global_vars , only : write_data_format use global_vars , only : write_file_format use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : te use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : gm use global_vars , only : dist use global_vars , only : vis_resnorm use global_vars , only : cont_resnorm use global_vars , only : x_mom_resnorm use global_vars , only : y_mom_resnorm use global_vars , only : z_mom_resnorm use global_vars , only : energy_resnorm use global_vars , only : resnorm use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : Tv_residue use global_vars , only : intermittency use global_vars , only : ExtraVar1 use global_vars , only : ExtraVar2 use global_vars , only : ExtraVar3 use global_vars , only : ExtraVar4 use global_vars , only : ExtraVar5 use global_vars , only : process_id use global_vars , only : turbulence use global_vars , only : mu_ref use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : w_count use global_vars , only : w_list use global_sst , only : sst_F1 use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use utils use string implicit none private integer :: i , j , k real :: speed_inf character ( len = 8 ) :: file_format character ( len = 16 ) :: data_format character :: newline = achar ( 10 ) public :: write_file contains subroutine write_file () !< Write the header and variables in the file \"process_xx.dat\" implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_velocity () case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Dissipation' ) call write_scalar ( te , \"Dissipation\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"dist\" , - 2 ) case ( 'Resnorm' ) call write_resnorm () case ( 'TKE_residue' ) call write_scalar ( TKE_residue , \"TKE_residue\" , 1 ) case ( 'Tv_residue' ) call write_scalar ( Tv_residue , \"Tv_residue\" , 1 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'y-mom-residue' ) call write_scalar ( y_mom_residue , 'Y_mom_residue' , 1 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) case ( 'extravar1' ) if ( allocated ( ExtraVar1 )) then call write_scalar ( ExtraVar1 , \"ExtraVar1\" , - 2 ) else Issue_warning end if case ( 'extravar2' ) if ( allocated ( ExtraVar2 )) then call write_scalar ( ExtraVar2 , \"ExtraVar2\" , - 2 ) else Issue_warning end if case ( 'extravar3' ) if ( allocated ( ExtraVar3 )) then call write_scalar ( ExtraVar3 , \"ExtraVar3\" , - 2 ) else Issue_warning end if case ( 'extravar4' ) if ( allocated ( ExtraVar4 )) then call write_scalar ( ExtraVar4 , \"ExtraVar4\" , - 2 ) else Issue_warning end if case ( 'extravar5' ) if ( allocated ( ExtraVar5 )) then call write_scalar ( ExtraVar5 , \"ExtraVar5\" , - 2 ) else Issue_warning end if case ( 'do not write' ) ! do nothing continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header () !< Write the header in the output file in the tecplot format implicit none DebugCall ( \"write_header\" ) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a)' ) '# vtk DataFile Version 3.1' write ( OUT_FILE_UNIT , '(a)' ) 'cfd-iitm output' ! comment line write ( OUT_FILE_UNIT , '(a)' ) trim ( Write_data_format ) write ( OUT_FILE_UNIT , '(a)' ) 'DATASET STRUCTURED_GRID' !write(OUT_FILE_UNIT, *) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) '# vtk DataFile Version 3.1' // newline write ( OUT_FILE_UNIT ) 'cfd-iitm output' // newline write ( OUT_FILE_UNIT ) trim ( Write_data_format ) // newline write ( OUT_FILE_UNIT ) 'DATASET STRUCTURED_GRID' // newline write ( OUT_FILE_UNIT ) newline end if end subroutine write_header subroutine write_grid () !< Write the grid information in the output file implicit none ! write grid point coordinates DebugCall ( \"write_grid\" ) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a, i0, a, i0, a, i0)' ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT , fmt = '(a, i0, a)' ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT , fmt = '(f0.16, a, f0.16, a, f0.16)' ) & grid_x ( i , j , k ), ' ' , grid_y ( i , j , k ), ' ' , grid_z ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT ) & grid_x ( i , j , k ), ' ' , grid_y ( i , j , k ), ' ' , grid_z ( i , j , k ), newline end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_grid subroutine write_velocity () !< Write the velocity vector in the output file implicit none DebugCall ( \"write_velocity\" ) ! Cell data ! Writing Velocity if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a, i0)' ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT , '(a)' ) 'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES27.16E4, a, ES27.16E4, a, ES27.16E4)' ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT ) 'VECTORS Velocity DOUBLE' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ), newline end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_velocity subroutine write_resnorm () !< Write the residual information in the output file implicit none DebugCall ( \"write_resnorm\" ) ! Writing resnorm for each cell if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS Resnorm FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' speed_inf = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 & + z_speed_inf ** 2 ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 energy_resnorm = ( & ( & energy_residue ( i , j , k ) / & ( density_inf * speed_inf * & (( 0.5 * speed_inf * speed_inf ) + & ( gm / ( gm - 1 ) * pressure_inf / density_inf )))& ) ** 2 & ) x_mom_resnorm = ( & ( x_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) y_mom_resnorm = ( & ( y_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) z_mom_resnorm = ( & ( z_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) cont_resnorm = ( & ( mass_residue ( i , j , k ) / & ( density_inf * speed_inf )) ** 2 & ) vis_resnorm = sqrt ( & cont_resnorm + & x_mom_resnorm + & y_mom_resnorm + & z_mom_resnorm + & energy_resnorm & ) write ( OUT_FILE_UNIT , fmt = '(f0.16)' ) vis_resnorm end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'SCALARS Resnorm DOUBLE' write ( OUT_FILE_UNIT ) 'LOOKUP_TABLE default' speed_inf = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 & + z_speed_inf ** 2 ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 energy_resnorm = ( & ( & energy_residue ( i , j , k ) / & ( density_inf * speed_inf * & (( 0.5 * speed_inf * speed_inf ) + & ( gm / ( gm - 1 ) * pressure_inf / density_inf )))& ) ** 2 & ) x_mom_resnorm = ( & ( x_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) y_mom_resnorm = ( & ( y_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) z_mom_resnorm = ( & ( z_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) cont_resnorm = ( & ( mass_residue ( i , j , k ) / & ( density_inf * speed_inf )) ** 2 & ) vis_resnorm = sqrt ( & cont_resnorm + & x_mom_resnorm + & y_mom_resnorm + & z_mom_resnorm + & energy_resnorm & ) write ( OUT_FILE_UNIT ) vis_resnorm end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_resnorm subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name character ( len = 128 ) :: line DebugCall ( \"write_scalar: \" // trim ( name )) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS ' // trim ( name ) // ' FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES25.16E4)' ) var ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'SCALARS ' // trim ( name ) // ' FLOAT' // newline write ( OUT_FILE_UNIT ) 'LOOKUP_TABLE default' // newline do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( line , \"(ES28.16E4)\" ) var ( i , j , k ) write ( OUT_FILE_UNIT ) trim ( line ) // newline end do end do end do write ( OUT_FILE_UNIT ) newline end if end subroutine write_scalar end module write_output_vtk","tags":"","loc":"sourcefile/write_output_vtk.f90.html","title":"write_output_vtk.f90 – FEST-3D"},{"text":"Tecplot module to write the solution in the tecplot format This file depends on sourcefile~~write_output_tec.f90~~EfferentGraph sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~string.f90 string.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output_tec.f90~~AfferentGraph sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 var pansourcefilewrite_output_tecf90AfferentGraph = svgPanZoom('#sourcefilewrite_output_tecf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output_tec Source Code write_output_tec.f90 Source Code !< Tecplot module to write the solution in the tecplot format module write_output_tec !< Tecplot module to write the solution in the tecplot format !--------------------------------------------------------- ! This module write state + other variable in output file !--------------------------------------------------------- #include \"../../debug.h\" #include \"../../error.h\" use global , only : OUT_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global_vars , only : write_data_format use global_vars , only : write_file_format use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : gm use global_vars , only : dist use global_vars , only : vis_resnorm use global_vars , only : cont_resnorm use global_vars , only : x_mom_resnorm use global_vars , only : y_mom_resnorm use global_vars , only : z_mom_resnorm use global_vars , only : energy_resnorm use global_vars , only : resnorm use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : omega_residue use global_vars , only : tv_residue use global_vars , only : intermittency use global_vars , only : ExtraVar1 use global_vars , only : ExtraVar2 use global_vars , only : ExtraVar3 use global_vars , only : ExtraVar4 use global_vars , only : ExtraVar5 use global_vars , only : turbulence use global_vars , only : mu_ref use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : w_count use global_vars , only : w_list use global_sst , only : sst_F1 use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : process_id use global_vars , only : checkpoint_iter_count use utils use string implicit none private integer :: i , j , k real :: speed_inf character ( len = 8 ) :: file_format character ( len = 16 ) :: data_format character :: newline = achar ( 10 ) character ( len =* ), parameter :: format = \"(1ES28.15E4)\" public :: write_file contains subroutine write_file () !< Write the header and variables in the file \"process_xx.dat\". implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"Wall_dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'Mass_residue' ) call write_scalar ( mass_residue , \"Mass_residue\" , 1 ) case ( 'X_mom_residue' ) call write_scalar ( x_mom_residue , \"X_mom_residue\" , 1 ) case ( 'Y_mom_residue' ) call write_scalar ( y_mom_residue , \"Y_mom_residue\" , 1 ) case ( 'Z_mom_residue' ) call write_scalar ( z_mom_residue , \"Z_mom_residue\" , 1 ) case ( 'Energy_residue' ) call write_scalar ( energy_residue , \"Energy_residue\" , 1 ) case ( 'TKE_residue' ) call write_scalar ( tke_residue , \"TKE_residue\" , 1 ) case ( 'Omega_residue' ) call write_scalar ( omega_residue , \"Omega_residue\" , 1 ) case ( 'Tv_residue' ) call write_scalar ( tv_residue , \"Tv_residue\" , 1 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) case ( 'extravar1' ) if ( allocated ( ExtraVar1 )) then call write_scalar ( ExtraVar1 , \"ExtraVar1\" , - 2 ) else Issue_warning end if case ( 'extravar2' ) if ( allocated ( ExtraVar2 )) then call write_scalar ( ExtraVar2 , \"ExtraVar2\" , - 2 ) else Issue_warning end if case ( 'extravar3' ) if ( allocated ( ExtraVar3 )) then call write_scalar ( ExtraVar3 , \"ExtraVar3\" , - 2 ) else Issue_warning end if case ( 'extravar4' ) if ( allocated ( ExtraVar4 )) then call write_scalar ( ExtraVar4 , \"ExtraVar4\" , - 2 ) else Issue_warning end if case ( 'extravar5' ) if ( allocated ( ExtraVar5 )) then call write_scalar ( ExtraVar5 , \"ExtraVar5\" , - 2 ) else Issue_warning end if case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file subroutine write_header () !< Write the header in the output file in the tecplot format implicit none integer :: n integer :: total DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=CELLCENTERED)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , checkpoint_iter_count end subroutine write_header subroutine write_grid () !< Write the grid information in the output file implicit none ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , format ) ((( grid_x ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( grid_y ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( grid_z ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine write_grid subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine write_scalar end module write_output_tec","tags":"","loc":"sourcefile/write_output_tec.f90.html","title":"write_output_tec.f90 – FEST-3D"},{"text":"Check, create, and purge folder in the time_directory folder This file depends on sourcefile~~dump_solution.f90~~EfferentGraph sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~global.f90 global.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~utils.f90 utils.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~layout.f90 layout.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~write_output.f90->sourcefile~global_vars.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 var pansourcefiledump_solutionf90EfferentGraph = svgPanZoom('#sourcefiledump_solutionf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~dump_solution.f90~~AfferentGraph sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 var pansourcefiledump_solutionf90AfferentGraph = svgPanZoom('#sourcefiledump_solutionf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules dump_solution Source Code dump_solution.f90 Source Code !<  Check, create, and purge folder in the time_directory folder module dump_solution !< This module contians subroutine that !<  1. check if point of dumping condition is arrived. !<  2. create particular folder for dump. !<  3. dump data in that folder. !<  4. purge folders if required. !------------------------------------------ use global , only : FILE_NAME_LENGTH use global , only : RESTART_FILE_UNIT use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : last_iter use global_vars , only : checkpoint_iter use global_vars , only : checkpoint_iter_count use global_vars , only : purge_write use global_vars , only : sim_clock use global_vars , only : outfile use global_vars , only : restartfile use global_vars , only : resnorm_0 use global_vars , only : vis_resnorm_0 use global_vars , only : turb_resnorm_0 use global_vars , only : cont_resnorm_0 use global_vars , only : x_mom_resnorm_0 use global_vars , only : y_mom_resnorm_0 use global_vars , only : z_mom_resnorm_0 use global_vars , only : energy_resnorm_0 use global_vars , only : TKE_resnorm_0 use global_vars , only : omega_resnorm_0 use global_vars , only : turbulence use utils use string use write_output , only : write_file use layout , only : process_id implicit none private character ( len = FILE_NAME_LENGTH ) :: dump_dirname !< Name(check point number) of the directory to create character ( len = FILE_NAME_LENGTH ) :: purge_dirname !< Name(check point number) of the directory to remove public :: checkpoint contains subroutine checkpoint () !< Create a checkpoint dump file if the time has come !----------------------------------------------------------- implicit none if ( checkpoint_iter . ne . 0 ) then if ( mod ( current_iter , checkpoint_iter ) == 0 & . or . current_iter == max_iters ) then call make_dump_dir () call dump_data () print * , \"writing data at: \" , current_iter , checkpoint_iter_count call purge_dump_dir () checkpoint_iter_count = checkpoint_iter_count + 1 call dmsg ( 3 , 'dump_solution' , 'checkpoint' , & 'Checkpoint created at iteration: ' + current_iter ) end if end if end subroutine checkpoint subroutine create_directory ( dirname ) !< Create a directory to keep the solution files from all the processor implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: mkdircmd mkdircmd = 'mkdir -p ' // trim ( dirname ) call system ( mkdircmd ) end subroutine create_directory subroutine remove_directory ( dirname ) !< Remove a directory implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: rmdircmd rmdircmd = 'rm -rf ' // trim ( dirname ) call system ( rmdircmd ) end subroutine remove_directory subroutine purge_dump_dir () !< Purge the directory based on the input implicit none integer :: purge_num purge_num = checkpoint_iter_count - purge_write if ( purge_write /= 0 . and . purge_num > 0 ) then write ( purge_dirname , '(A,I4.4)' ) 'time_directories/' , purge_num call remove_directory ( purge_dirname ) end if end subroutine purge_dump_dir subroutine make_dump_dir () !< Solution directory and sub-directory in created with particular number implicit none write ( dump_dirname , '(A,I4.4)' ) 'time_directories/' , checkpoint_iter_count call create_directory ( dump_dirname ) call create_directory ( trim ( dump_dirname ) // '/restart' ) end subroutine make_dump_dir subroutine dump_data () !< Call to write save files in the directory implicit none !      character(len=FILE_NAME_LENGTH) :: filename call dmsg ( 1 , 'dump_solution' , 'dump_data' ) write ( restartfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/restart/process_' , process_id write ( outfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/process_' , process_id call write_restart_log () call write_file () end subroutine dump_data subroutine write_restart_log () !< Call to write log file in the subdirectory \"restart\". !< It is useful information while restarting the solver implicit none open ( RESTART_FILE_UNIT , file = restartfile ) select case ( turbulence ) case ( 'none' ) write ( RESTART_FILE_UNIT , '(A)' ) 'viscous' case ( 'sst' , 'sst2003' , 'kkl' , 'ke' , 'kw' , 'sa' , 'saBC' , 'des-sst' ) write ( RESTART_FILE_UNIT , '(A)' ) trim ( turbulence ) case DEFAULT call dmsg ( 5 , 'dump_solution' , 'write_restart_log' ,& 'ERROR: Turbulence model not recognised' ) end select call write_initial_resnorm () close ( RESTART_FILE_UNIT ) end subroutine write_restart_log subroutine write_initial_resnorm () !< Writing Initial resnorom in the log file to !< maintian continuity of resnorm while restrarting implicit none write ( RESTART_FILE_UNIT , '(I0)' ) current_iter + last_iter write ( RESTART_FILE_UNIT , '(f0.16)' ) resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) vis_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) turb_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) cont_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) x_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) y_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) z_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) energy_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) TKE_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) omega_resnorm_0 end subroutine write_initial_resnorm end module dump_solution","tags":"","loc":"sourcefile/dump_solution.f90.html","title":"dump_solution.f90 – FEST-3D"},{"text":"Open/close and call other modules for writing solution This file depends on sourcefile~~write_output.f90~~EfferentGraph sourcefile~write_output.f90 write_output.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~global.f90 global.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~utils.f90 utils.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~write_output.f90->sourcefile~global_vars.f90 sourcefile~string.f90 string.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_vars.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~write_output.f90~~AfferentGraph sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~source.f90 var pansourcefilewrite_outputf90AfferentGraph = svgPanZoom('#sourcefilewrite_outputf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules write_output Source Code write_output.f90 Source Code !< Open/close and call other modules for writing solution module write_output !< Open/close and call other modules for writing solution !< based on the input: type of file, either vtk or tecplot !< modules are called use global , only : OUT_FILE_UNIT use global_vars , only : outfile use global_vars , only : outfile use global_vars , only : write_data_format use global_vars , only : write_file_format use utils use string use write_output_vtk , only : write_file_vtk => write_file use write_output_tec , only : write_file_tec => write_file use write_output_tec_node , only : write_file_tec_nodal => write_file implicit none private character ( len = 16 ) :: data_format character ( len = 16 ) :: file_format public write_file contains subroutine setup_file () !< Setup the file type based on the input implicit none call dmsg ( 1 , 'write_output_vtk' , 'setup_file' ) if ( write_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( write_file_format == \"tecplot\" . or . write_file_format == \"tecplot_nodal\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk', 'tecplot' and 'tecplot_nodal' \" end if if ( write_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( write_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file subroutine open_file ( filename ) !< Open the file to write the solution implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'write_output_vtk' , 'open_file' ) open ( OUT_FILE_UNIT , file = trim ( filename ) // trim ( file_format ) + '.part' , form = trim ( data_format )) end subroutine open_file subroutine close_file ( filename ) !< Close the file after writing solution. implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'write_output_vtk' , 'close_file' ) call rename ( trim ( filename ) // trim ( file_format ) + '.part' , trim ( filename ) // trim ( file_format )) close ( OUT_FILE_UNIT ) end subroutine close_file subroutine write_file () !< Writing output in the file according to the input file type implicit none call setup_file () call open_file ( outfile ) select case ( write_file_format ) case ( 'vtk' ) call write_file_vtk () case ( 'tecplot' ) call write_file_tec () case ( 'tecplot_nodal' ) call write_file_tec_nodal () case DEFAULT call dmsg ( 5 , 'write_output' , 'write_file' ,& 'ERROR: write file format nor recognised. READ format -> ' // write_file_format ) end select call close_file ( outfile ) end subroutine write_file end module write_output","tags":"","loc":"sourcefile/write_output.f90.html","title":"write_output.f90 – FEST-3D"},{"text":"Read the restart file in the vtk format This file depends on sourcefile~~read_output_vtk.f90~~EfferentGraph sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~string.f90 string.f90 sourcefile~read_output_vtk.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~read_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~read_output_vtk.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output_vtk.f90~~AfferentGraph sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileread_output_vtkf90AfferentGraph = svgPanZoom('#sourcefileread_output_vtkf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output_vtk Source Code read_output_vtk.f90 Source Code !< Read the restart file in the vtk format module read_output_vtk !< Read the restart file in the vtk format !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- use global , only : IN_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global_vars , only : read_data_format use global_vars , only : read_file_format use global_vars , only : start_from use global_vars , only : process_id use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : intermittency use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : gm use global_vars , only : dist use global_vars , only : turbulence use global_vars , only : vis_resnorm use global_vars , only : cont_resnorm use global_vars , only : x_mom_resnorm use global_vars , only : y_mom_resnorm use global_vars , only : z_mom_resnorm use global_vars , only : energy_resnorm use global_vars , only : resnorm use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : resnorm_0 use global_vars , only : vis_resnorm_0 use global_vars , only : turb_resnorm_0 use global_vars , only : cont_resnorm_0 use global_vars , only : x_mom_resnorm_0 use global_vars , only : y_mom_resnorm_0 use global_vars , only : z_mom_resnorm_0 use global_vars , only : energy_resnorm_0 use global_vars , only : TKE_resnorm_0 use global_vars , only : omega_resnorm_0 use global_vars , only : mu_ref use global_vars , only : r_count use global_vars , only : r_list use global_vars , only : previous_flow_type use utils use string implicit none private integer :: i , j , k public :: read_file contains subroutine read_file () !< Read all the variable for the vtk restart file implicit none integer :: n call read_header () call read_grid () do n = 1 , r_count select case ( trim ( r_list ( n ))) case ( 'Velocity' ) call read_velocity () case ( 'Density' ) call read_scalar ( density , 'Density' , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , 'Pressure' , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'Intermittecny' ) call read_scalar ( intermittency , 'Intermittecny' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( r_list ( n )) end select end do end subroutine read_file subroutine read_header () !< Skip read the header in the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , 'read_header' ) read ( IN_FILE_UNIT , * ) !'# vtk DataFile Version 3.1' read ( IN_FILE_UNIT , * ) !'cfd-iitm output'   ! comment line read ( IN_FILE_UNIT , * ) !trim(read_data_format) read ( IN_FILE_UNIT , * ) !'DATASET STRUCTURED_GRID' !read(IN_FILE_UNIT, *) end subroutine read_header subroutine read_grid () !< Skip the grid read in the restart file implicit none ! read grid point coordinates call dmsg ( 1 , 'read_output_vtk' , 'read_grid' ) read ( IN_FILE_UNIT , * ) !'DIMENSIONS ', imx, ' ', jmx, ' ', kmx read ( IN_FILE_UNIT , * ) !'POINTS ', imx*jmx*kmx, ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( IN_FILE_UNIT , * ) !grid_x(i, j, k), ' ', grid_y(i, j, k), ' ', grid_z(i, j, k) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_grid subroutine read_velocity () !< Read velocity vector from the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , 'read_velocity' ) read ( IN_FILE_UNIT , * ) !'CELL_DATA ', (imx-1)*(jmx-1)*(kmx-1) read ( IN_FILE_UNIT , * ) !'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) x_speed ( i , j , k ), y_speed ( i , j , k ), z_speed ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_velocity subroutine read_scalar ( var , name , index ) !< Read scalar from the vtk file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'read_output_vtk' , trim ( name )) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) var ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_scalar subroutine skip_scalar () !< Skip read scalar from the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , \"skip_scalar\" ) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine skip_scalar end module read_output_vtk","tags":"","loc":"sourcefile/read_output_vtk.f90.html","title":"read_output_vtk.f90 – FEST-3D"},{"text":"Read the restart file in the tecplot format This file depends on sourcefile~~read_output_tec.f90~~EfferentGraph sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~string.f90 string.f90 sourcefile~read_output_tec.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~read_output_tec.f90->sourcefile~global_sst.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~read_output_tec.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~read_output_tec.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output_tec.f90~~AfferentGraph sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileread_output_tecf90AfferentGraph = svgPanZoom('#sourcefileread_output_tecf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output_tec Source Code read_output_tec.f90 Source Code !< Read the restart file in the tecplot format module read_output_tec !< Read the restart file in the tecplot format !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- use global , only : IN_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global_vars , only : read_data_format use global_vars , only : read_file_format use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : tk use global_vars , only : tw use global_vars , only : tkl use global_vars , only : tv use global_vars , only : tgm use global_vars , only : mu use global_vars , only : mu_t use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : gm use global_vars , only : dist use global_vars , only : vis_resnorm use global_vars , only : cont_resnorm use global_vars , only : x_mom_resnorm use global_vars , only : y_mom_resnorm use global_vars , only : z_mom_resnorm use global_vars , only : energy_resnorm use global_vars , only : resnorm use global_vars , only : mass_residue use global_vars , only : x_mom_residue use global_vars , only : y_mom_residue use global_vars , only : z_mom_residue use global_vars , only : energy_residue use global_vars , only : TKE_residue use global_vars , only : intermittency use global_vars , only : turbulence use global_vars , only : mu_ref use global_vars , only : current_iter use global_vars , only : max_iters use global_vars , only : r_count use global_vars , only : r_list use global_sst , only : sst_F1 use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : process_id use utils use string implicit none private integer :: i , j , k public :: read_file contains subroutine read_file () !< Read all the variable for the tecplot restart file implicit none integer :: n call read_header () call read_grid () do n = 1 , r_count select case ( trim ( r_list ( n ))) case ( 'Velocity' ) call read_scalar ( x_speed , \"u\" , - 2 ) call read_scalar ( y_speed , \"v\" , - 2 ) call read_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call read_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'Intermittency' ) call read_scalar ( intermittency , 'Intermittency' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( r_list ( n )) end select end do end subroutine read_file subroutine read_header () !< Skip read the header in the tecplot file implicit none integer :: n call dmsg ( 1 , 'read_output_tec' , 'read_header' ) read ( IN_FILE_UNIT , * ) !\"variables = x y z \" do n = 1 , r_count read ( IN_FILE_UNIT , * ) !trim(w_list(n)) end do read ( IN_FILE_UNIT , * ) ! \"zone T=block\" ... read ( IN_FILE_UNIT , * ) !\"Varlocation=([1-3]=Nodal)\" read ( IN_FILE_UNIT , * ) !\"Varlocation=([4-\",total,\"]=CELLCENTERED)\" read ( IN_FILE_UNIT , * ) !\"STRANDID\" read ( IN_FILE_UNIT , * ) !\"SolutionTime\" end subroutine read_header subroutine read_grid () !< Skip the grid read in the restart file implicit none real :: dummy ! read grid point coordinates call dmsg ( 1 , 'read_output_tec' , 'read_grid' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine read_grid subroutine read_scalar ( var , name , index ) !< Read scalar from the tecplot file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'read_output_tec' , trim ( name )) read ( IN_FILE_UNIT , * ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine read_scalar subroutine skip_scalar () !< Skip read scalar from the tecplot file implicit none real :: dummy call dmsg ( 1 , 'read_output_tec' , \"skip_scalar\" ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine skip_scalar end module read_output_tec","tags":"","loc":"sourcefile/read_output_tec.f90.html","title":"read_output_tec.f90 – FEST-3D"},{"text":"This module read input control files which include:\n   1. control.md\n   2. fvscheme.md\n   3. flow.md\n   4. res_control.md\n   5. state_read_write_control.md This file depends on sourcefile~~read.f90~~EfferentGraph sourcefile~read.f90 read.f90 sourcefile~string.f90 string.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~utils.f90 utils.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read.f90~~AfferentGraph sourcefile~read.f90 read.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~read.f90 sourcefile~time.f90 time.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~update.f90->sourcefile~time.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read Source Code read.f90 Source Code !< This module read input control files which include: !<   1. control.md !<   2. fvscheme.md !<   3. flow.md !<   4. res_control.md !<   5. state_read_write_control.md module read !< This module read input control files which include: !<   1. control.md !<   2. fvscheme.md !<   3. flow.md !<   4. res_control.md !<   5. state_read_write_control.md !------------------------------------------------------ #include \"../../debug.h\" use global , only : CONTROL_FILE_UNIT use global , only : SCHEME_FILE_UNIT use global , only : FLOW_FILE_UNIT use global , only : control_file use global , only : scheme_file use global , only : flow_file use global , only : STRING_BUFFER_LENGTH use global , only : OUTIN_FILE_UNIT use global , only : outin_file use global , only : RES_CONTROL_FILE_UNIT use global , only : res_control_file use global_vars , only : CFL use global_vars , only : max_iters use global_vars , only : start_from use global_vars , only : checkpoint_iter use global_vars , only : res_write_interval use global_vars , only : write_file_format use global_vars , only : write_data_format use global_vars , only : read_file_format use global_vars , only : read_data_format use global_vars , only : write_percision use global_vars , only : purge_write use global_vars , only : tolerance use global_vars , only : tolerance_type use global_vars , only : process_id use global_vars , only : time_stepping_method use global_vars , only : time_step_accuracy use global_vars , only : global_time_step use global_vars , only : n_var use global_vars , only : free_stream_density use global_vars , only : free_stream_x_speed use global_vars , only : free_stream_y_speed use global_vars , only : free_stream_z_speed use global_vars , only : free_stream_pressure use global_vars , only : free_stream_tu use global_vars , only : free_stream_tgm use global_vars , only : mu_ratio_inf use global_vars , only : gm !gamma use global_vars , only : R_gas !univarsal gas constant use global_vars , only : mu_ref !viscoity use global_vars , only : mu_variation !viscoity variation type use global_vars , only : T_ref use global_vars , only : Sutherland_temp use global_vars , only : Pr !prandtl number use global_vars , only : tPr !Turbulent prandtl number use global_vars , only : ilimiter_switch use global_vars , only : jlimiter_switch use global_vars , only : klimiter_switch use global_vars , only : itlimiter_switch use global_vars , only : jtlimiter_switch use global_vars , only : ktlimiter_switch use global_vars , only : iPB_switch use global_vars , only : jPB_switch use global_vars , only : kPB_switch use global_vars , only : accur use global_vars , only : interpolant use global_vars , only : scheme_name use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : r_list use global_vars , only : w_list use global_vars , only : r_count use global_vars , only : w_count use global_vars , only : Res_list use global_vars , only : Res_count use utils , only : DEBUG_LEVEL use utils , only : dmsg use string use fclose , only : close_file implicit none private public :: read_input_and_controls contains subroutine read_input_and_controls () !< Read all the input control files implicit none call read_controls () call read_scheme () call read_flow () call read_output_control () call read_Res_list () end subroutine read_input_and_controls subroutine get_next_token ( token_file_unit , buf ) !< Extract the next token from the config file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: token_file_unit character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( token_file_unit , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do call dmsg ( 0 , 'read' , 'get_next_token' , 'Returning: ' // trim ( buf )) end subroutine get_next_token subroutine read_controls () !< Read control.md file !--------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_controls' ) open ( CONTROL_FILE_UNIT , file = control_file , status = 'old' , action = 'read' ) !ignoring file header read ( CONTROL_FILE_UNIT , * ) read ( CONTROL_FILE_UNIT , * ) read ( CONTROL_FILE_UNIT , * ) ! READ CFL call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) CFL DebugInfo ( \"CFL = \" // trim ( buf )) ! READ start_from call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) start_from DebugInfo ( 'Start from  level = ' // trim ( buf )) ! READ max_iters call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) max_iters DebugInfo ( 'Stop at iteration = ' // trim ( buf )) ! READ checkpoint_iter call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) checkpoint_iter DebugInfo ( ' Solution write interval = ' // trim ( buf )) ! READ write_file_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_file_format DebugInfo ( 'Solution file format  = ' // trim ( buf )) ! READ write_data_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_data_format DebugInfo ( 'solution file data format = ' // trim ( buf )) ! READ read_file_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) read_file_format DebugInfo ( 'Restart file format  = ' // trim ( buf )) ! READ_read data_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) read_data_format DebugInfo ( 'Restart file data format = ' // trim ( buf )) ! READ write_percision call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_percision DebugInfo ( 'File write percision = ' // trim ( buf )) ! READ purge_write call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) purge_write DebugInfo ( 'Purge folder more then  = ' // trim ( buf )) ! READ res_write_interval call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) res_write_interval DebugInfo ( 'resnorm write interval  = ' // trim ( buf )) ! READ tolerance call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) tolerance , tolerance_type DebugInfo ( trim ( tolerance_type ) // ' Tolerance  = ' // trim ( buf )) ! READ DEBUG_LEVEL call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) DEBUG_LEVEL DebugInfo ( 'DEBUG_LEVEL = ' // trim ( buf )) close ( CONTROL_FILE_UNIT ) end subroutine read_controls subroutine read_scheme () !< Read fvscheme.md control file !-------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf integer :: ios DebugCall ( 'read_scheme' ) open ( SCHEME_FILE_UNIT , file = scheme_file , status = 'old' , action = 'read' ) ! ignoring file header read ( SCHEME_FILE_UNIT , * ) read ( SCHEME_FILE_UNIT , * ) read ( SCHEME_FILE_UNIT , * ) ! read scheme name call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme_name DebugInfo ( 'scheme_name = ' // trim ( buf )) ! read interpolant call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) interpolant interpolant = trim ( interpolant ) DebugInfo ( 'interpolant = ' // trim ( buf )) ! read ilimiter and PB switch call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) ilimiter_switch , jlimiter_switch , klimiter_switch , & iPB_switch , jPB_switch , kPB_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) DebugInfo ( 'PB switch = ' // trim ( buf ) ) ! read turbulent limiter call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) itlimiter_switch , jtlimiter_switch , ktlimiter_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) ! read turbulence model call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) turbulence DebugInfo ( 'Turbulence Model = ' // trim ( buf )) ! read transition model call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) transition DebugInfo ( 'Transition Model = ' // trim ( buf )) ! read time stepping method call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * , iostat = ios ) time_stepping_method , global_time_step if ( ios /= 0 ) then read ( buf , * ) time_stepping_method global_time_step = - 1 end if DebugInfo ( 'time_stepping_method = ' // trim ( buf )) DebugInfo ( 'global_time_step = ' // trim ( buf )) ! read time integration method call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) time_step_accuracy DebugInfo ( 'time_step_accuracy  = ' // trim ( buf )) ! read higher order boundary call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) accur DebugInfo ( 'higher order boundary  = ' // trim ( buf )) close ( SCHEME_FILE_UNIT ) end subroutine read_scheme subroutine read_flow () !< Read flow.md control file !-------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_flow' ) open ( FLOW_FILE_UNIT , file = flow_file , status = 'old' , action = 'read' ) ! ignoring file header read ( FLOW_FILE_UNIT , * ) read ( FLOW_FILE_UNIT , * ) read ( FLOW_FILE_UNIT , * ) ! read number of variable call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) n_var DebugInfo ( 'Number of variables = ' // trim ( buf )) ! read rho_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_density DebugInfo ( 'free_stream_density = ' // trim ( buf )) ! read u_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_x_speed DebugInfo ( 'free_stream_x_speed = ' // trim ( buf )) ! read v_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_y_speed DebugInfo ( 'free_stream_y_speed = ' // trim ( buf )) ! read w_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_z_speed DebugInfo ( 'free_stream_z_speed = ' // trim ( buf )) ! read P_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_pressure DebugInfo ( 'free_stream_pressure = ' // trim ( buf )) ! read turbulence intensity in percentage call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_tu DebugInfo ( 'free_stream_Turb_intensity = ' // trim ( buf )) ! read viscosity ratio call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_ratio_inf DebugInfo ( 'free_stream_mu_ratio = ' // trim ( buf )) ! read intermittency call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_tgm DebugInfo ( 'free_stream_Intermittency = ' // trim ( buf )) ! read reference viscosity call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_ref DebugInfo ( 'mu_reference = ' // trim ( buf )) ! Type of variation for viscosity call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_variation DebugInfo ( 'mu_variation = ' // trim ( buf )) ! read T_red call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) T_ref DebugInfo ( 'T_reference = ' // trim ( buf )) ! read Sutherland temp call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) Sutherland_temp DebugInfo ( 'Sutherland temperature = ' // trim ( buf )) ! read prandtl number call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) Pr , tPr DebugInfo ( 'Prandtl Number = ' // trim ( buf )) ! read gamma call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) gm DebugInfo ( 'gamma = ' // trim ( buf )) ! read universal gas constant call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) R_gas DebugInfo ( 'R_gas = ' // trim ( buf )) close ( FLOW_FILE_UNIT ) end subroutine read_flow subroutine read_output_control () !< Read output_contorl.md file implicit none integer :: i character ( len = 64 ) :: buf integer :: ios call get_rw_count () call close_file ( OUTIN_FILE_UNIT ) open ( OUTIN_FILE_UNIT , file = outin_file , status = 'old' , action = 'read' ) ! variables to write do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , w_count read ( OUTIN_FILE_UNIT , * ) buf read ( buf , * ) w_list ( i ) end do ! restart variables to read do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , r_count read ( OUTIN_FILE_UNIT , * ) buf read ( buf , * ) r_list ( i ) end do if ( r_count == 0 ) r_list = w_list close ( OUTIN_FILE_UNIT ) end subroutine read_output_control subroutine get_rw_count () !< Get read/write count implicit none integer :: ios character ( len = 64 ) :: buf r_count = 0 w_count = 0 call close_file ( OUTIN_FILE_UNIT ) open ( OUTIN_FILE_UNIT , file = outin_file , status = 'old' , action = 'read' ) ! write list dimension do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do w_count = 0 do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT w_count = w_count + 1 end do if ( w_count > 0 ) then allocate ( w_list ( 1 : w_count )) else w_count = 3 allocate ( w_list ( 1 : w_count )) w_list ( 1 ) = \"Velocity\" w_list ( 2 ) = \"Density\" w_list ( 3 ) = \"Pressure\" end if ! read list dimesnion do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do r_count = 0 do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT r_count = r_count + 1 end do if ( r_count == 0 ) then allocate ( r_list ( 1 : w_count )) else allocate ( r_list ( 1 : r_count )) end if close ( OUTIN_FILE_UNIT ) end subroutine get_rw_count subroutine get_count_within_braces ( handler , count ) !< Get number of variables between two curly braces implicit none integer , intent ( in ) :: handler !< File handler from which list number is extracted integer , intent ( out ) :: count !< Extracted count integer :: skip ! skipping lines outside braces skip = get_number_of_line ( '{' , handler ) ! finding actual count if any count = get_number_of_line ( '}' , handler ) end subroutine get_count_within_braces function get_number_of_line ( till , infile ) result ( number ) !< Get number of lines till some character like \"#\" implicit none integer , intent ( in ) :: infile character ( len = 1 ), intent ( in ) :: till character ( len = 64 ) :: buf integer :: ios integer :: number number = 0 do while (. true .) read ( infile , * , iostat = ios ) buf if ( trim ( buf ) == till ) EXIT if ( is_iostat_end ( ios )) EXIT number = number + 1 end do end function get_number_of_line subroutine read_Res_list () !< Read Residual file: res_control.md implicit none integer :: i integer :: skip open ( RES_CONTROL_FILE_UNIT , file = res_control_file , status = 'old' , action = 'read' ) call get_count_within_braces ( RES_CONTROL_FILE_UNIT , Res_count ) call close_file ( RES_CONTROL_FILE_UNIT ) open ( RES_CONTROL_FILE_UNIT , file = res_control_file , status = 'old' , action = 'read' ) ! skipping line skip = get_number_of_line ( '{' , RES_CONTROL_FILE_UNIT ) !reading vaules if ( Res_count == 0 ) then allocate ( Res_list ( 1 : 2 )) Res_count = 2 Res_list ( 1 ) = \"Mass_abs\" Res_list ( 2 ) = \"Resnorm_abs\" else allocate ( Res_list ( 1 : Res_count )) end if do i = 1 , Res_count read ( RES_CONTROL_FILE_UNIT , * ) Res_list ( i ) end do call close_file ( RES_CONTROL_FILE_UNIT ) end subroutine read_Res_list end module read","tags":"","loc":"sourcefile/read.f90.html","title":"read.f90 – FEST-3D"},{"text":"Read output files from the restart folder This file depends on sourcefile~~read_output.f90~~EfferentGraph sourcefile~read_output.f90 read_output.f90 sourcefile~global.f90 global.f90 sourcefile~read_output.f90->sourcefile~global.f90 sourcefile~utils.f90 utils.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~read_output.f90->sourcefile~global_vars.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~string.f90 string.f90 sourcefile~read_output.f90->sourcefile~string.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~read_output.f90->sourcefile~check_outout_control.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~read_output_vtk.f90->sourcefile~string.f90 sourcefile~check_outout_control.f90->sourcefile~global_vars.f90 sourcefile~str_case.f90 str_case.f90 sourcefile~check_outout_control.f90->sourcefile~str_case.f90 sourcefile~read_output_tec.f90->sourcefile~global.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90->sourcefile~global_vars.f90 sourcefile~read_output_tec.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~read_output_tec.f90->sourcefile~global_sst.f90 sourcefile~str_case.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~read_output.f90~~AfferentGraph sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules read_output Source Code read_output.f90 Source Code !< Read output files from the restart folder module read_output !< Read output files from the restart folder !--------------------------------------------------------- ! This module read state + other variable in output file !--------------------------------------------------------- use global , only : IN_FILE_UNIT use global , only : RESTART_FILE_UNIT use global_vars , only : infile use global_vars , only : restartfile use global_vars , only : read_data_format use global_vars , only : read_file_format use global_vars , only : start_from use global_vars , only : process_id use global_vars , only : resnorm_0 use global_vars , only : vis_resnorm_0 use global_vars , only : turb_resnorm_0 use global_vars , only : cont_resnorm_0 use global_vars , only : x_mom_resnorm_0 use global_vars , only : y_mom_resnorm_0 use global_vars , only : z_mom_resnorm_0 use global_vars , only : energy_resnorm_0 use global_vars , only : TKE_resnorm_0 use global_vars , only : omega_resnorm_0 use global_vars , only : previous_flow_type use global_vars , only : last_iter use global_vars , only : mu_ref use read_output_vtk , only : read_file_vtk => read_file use read_output_tec , only : read_file_tec => read_file use check_output_control , only : verify_read_control use utils use string implicit none private integer :: i , j , k real :: speed_inf !< Free-stream velocity magnitude character ( len = 8 ) :: file_format !< Read file format character ( len = 16 ) :: data_format !< Read file data type character ( len = 16 ) :: read_flow_type !< Previous flow type public :: read_file contains subroutine read_file () !< Read restart file implicit none call setup_file call open_file ( infile ) call read_restart_file () call verify_read_control () select case ( read_file_format ) case ( 'vtk' ) call read_file_vtk () case ( 'tecplot' ) call read_file_tec () case DEFAULT call dmsg ( 5 , 'read_output' , 'read_file' ,& 'ERROR: read file format not recognised. READ format -> ' // read_file_format ) end select call close_file () end subroutine read_file subroutine setup_file () !< Steup the file to read the restart state. implicit none call dmsg ( 1 , 'read_output_vtk' , 'setup_file' ) if ( read_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( read_file_format == \"tecplot\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk' and 'tecplot' \" end if if ( read_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( read_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if !write(infile,'(a,i4.4,a,i2.2)') 'time_directories/',start_from,'process_',process_id end subroutine setup_file subroutine open_file ( filename ) !< Open file from the restart folder implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'read_output_vtk' , 'open_file' ) write ( restartfile , '(A,I4.4,A,I2.2)' ) 'time_directories/' , start_from ,& '/restart/process_' , process_id open ( IN_FILE_UNIT , file = trim ( filename ) // trim ( file_format )) !, form=trim(data_format)) open ( RESTART_FILE_UNIT , file = restartfile , status = 'old' ) end subroutine open_file subroutine close_file () !< Close the file after reading implicit none call dmsg ( 1 , 'read_output_vtk' , 'close_files' ) close ( IN_FILE_UNIT ) close ( RESTART_FILE_UNIT ) end subroutine close_file subroutine read_restart_file () !< Read the sub-directory log file in the restart folder implicit none read ( RESTART_FILE_UNIT , * ) previous_flow_type read ( RESTART_FILE_UNIT , * ) last_iter read ( RESTART_FILE_UNIT , * ) resnorm_0 read ( RESTART_FILE_UNIT , * ) vis_resnorm_0 read ( RESTART_FILE_UNIT , * ) turb_resnorm_0 read ( RESTART_FILE_UNIT , * ) cont_resnorm_0 read ( RESTART_FILE_UNIT , * ) x_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) y_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) z_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) energy_resnorm_0 read ( RESTART_FILE_UNIT , * ) TKE_resnorm_0 read ( RESTART_FILE_UNIT , * ) omega_resnorm_0 end subroutine read_restart_file end module read_output","tags":"","loc":"sourcefile/read_output.f90.html","title":"read_output.f90 – FEST-3D"},{"text":"Utility module to allocate, deallocate and debug message This file depends on sourcefile~~utils.f90~~EfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~utils.f90~~AfferentGraph sourcefile~utils.f90 utils.f90 sourcefile~weno_nm.f90 weno_NM.f90 sourcefile~weno_nm.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~utils.f90 sourcefile~time.f90 time.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~kkl_gradients.f90->sourcefile~utils.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~layout.f90 layout.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~lctm2015_gradients.f90->sourcefile~utils.f90 sourcefile~slau.f90 slau.f90 sourcefile~slau.f90->sourcefile~utils.f90 sourcefile~ausm.f90 ausm.f90 sourcefile~ausm.f90->sourcefile~utils.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~utils.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~muscl.f90 muscl.f90 sourcefile~muscl.f90->sourcefile~utils.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~utils.f90 sourcefile~van_leer.f90 van_leer.f90 sourcefile~van_leer.f90->sourcefile~utils.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~ausmp.f90 ausmP.f90 sourcefile~ausmp.f90->sourcefile~utils.f90 sourcefile~source.f90 source.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~utils.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~utils.f90 sourcefile~bc.f90 bc.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~sst_gradients.f90->sourcefile~utils.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~ppm.f90 ppm.f90 sourcefile~ppm.f90->sourcefile~utils.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~sa_gradients.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~ldfss0.f90 ldfss0.f90 sourcefile~ldfss0.f90->sourcefile~utils.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~cc.f90 CC.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~laminar_gradients.f90->sourcefile~utils.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~utils.f90 sourcefile~wall.f90 wall.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~grid.f90 grid.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~weno.f90 weno.f90 sourcefile~weno.f90->sourcefile~utils.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~ghost_gradient.f90->sourcefile~utils.f90 sourcefile~ausmup.f90 ausmUP.f90 sourcefile~ausmup.f90->sourcefile~utils.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~utils.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules utils Source Code utils.f90 Source Code !< Utility module to allocate, deallocate and debug message module utils !< Utility module to allocate, deallocate and debug message use global_vars , only : process_id implicit none private integer , public :: DEBUG_LEVEL = 1 !< Debug level is an input from the control file. !< 5-> important calls only, and, !< 1-> all the calls public :: alloc interface alloc module procedure alloc_rank1_real , & alloc_rank2_real , & alloc_rank3_real , & alloc_rank4_real , & alloc_rank5_real , & alloc_rank6_real , & alloc_rank1_integer ,& alloc_rank2_integer ,& alloc_rank3_integer end interface alloc public :: dealloc interface dealloc module procedure dealloc_rank1_real , & dealloc_rank2_real , & dealloc_rank3_real , & dealloc_rank4_real , & dealloc_rank5_real , & dealloc_rank6_real , & dealloc_rank1_integer ,& dealloc_rank2_integer ,& dealloc_rank3_integer end interface dealloc public :: dmsg public :: turbulence_read_error contains include \"allocate_memory_implementation.inc\" include \"deallocate_memory_implementation.inc\" subroutine dmsg ( level , prog , method , msg ) !< Based on the debug level input this !< soubroutine will output/print or skip the debug !< message. This subroutine is called in the !< starting of every other subrotune for debuging. !< This will be depricated in the later version. !--------------------------------------------------------------- ! Print a DEBUG message ! ! Input arguments: !   level -> integer !       the message's debug level !   prog -> character !       module / program name !   method -> character !       subroutine / function name !   msg -> character !       message !--------------------------------------------------------------- implicit none character ( len =* ), optional :: prog !< Module or program name character ( len =* ), optional :: method !< Subroutine or function name character ( len =* ), optional :: msg !< Message to print character ( len = 256 ) :: ifmsg integer :: level !< The message's debug level !            if (process_id == 0) then if ( level < DEBUG_LEVEL ) then ! Don't print the message return end if ifmsg = \"\" if ( present ( msg )) then ifmsg = \" >--> \" // trim ( msg ) end if if (. not . present ( prog ) . and . . not . present ( method ) . and . & . not . present ( msg )) then print * , 'Please provide atleast one of the following:' print * , '- Module / program name' print * , '- Subroutine / function name' print * , '- A custom message' stop end if print '(A7,I1.1,A,I2,A2,A,A2,A,A,A1)' , 'Debug: ' , level , \" id - \" , process_id , ' (' , & trim ( prog ), ', ' , trim ( method ), trim ( ifmsg ), ')' !           end if end subroutine dmsg subroutine turbulence_read_error () print * , \"ERROR: Turbulence model not recognised\" STOP end subroutine turbulence_read_error end module utils","tags":"","loc":"sourcefile/utils.f90.html","title":"utils.f90 – FEST-3D"},{"text":"Check for the input from the output_control.md file This file depends on sourcefile~~check_outout_control.f90~~EfferentGraph sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~check_outout_control.f90->sourcefile~global_vars.f90 sourcefile~str_case.f90 str_case.f90 sourcefile~check_outout_control.f90->sourcefile~str_case.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~str_case.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~check_outout_control.f90~~AfferentGraph sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~check_outout_control.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefilecheck_outout_controlf90AfferentGraph = svgPanZoom('#sourcefilecheck_outout_controlf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules check_output_control Source Code check_outout_control.f90 Source Code !< Check for the input from the output_control.md file module check_output_control !< Check for the input from the output_control.md file ! --------------------------------------------- ! 170619 -jatinder pal singh sandhu ! Aim: to check wheter input are correct or not !---------------------------------------------- use global_vars , only : r_list use global_vars , only : w_list use global_vars , only : previous_flow_type use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : mu_ref use global_vars , only : r_count use global_vars , only : w_count use str_case , only : lcase implicit none private public :: verify_write_control public :: verify_read_control contains subroutine verify_write_control () !< Verify all the variable being asked to write in the output file. !< This is a fail-safe subroutine which do not allow to write the incorrect input variable implicit none integer :: n character ( len =* ), parameter :: err = \"Control Error: can't write variable - \" do n = 1 , w_count select case ( trim ( lcase ( w_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) w_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) w_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) w_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) if ( mu_ref /= 0.0 ) then w_list ( n ) = \"Mu\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) if ( turbulence /= 'none' ) then w_list ( n ) = \"Mu_t\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"TKE\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'omega' , 'tw' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'kl' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'tv' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) if ( turbulence /= \"none\" ) then w_list ( n ) = \"Wall_distance\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'resnorm' ) w_list ( n ) = \"Resnorm\" case ( 'tke_residue' ) w_list ( n ) = \"TKE_residue\" case ( 'omega_residue' ) w_list ( n ) = \"Omega_residue\" case ( 'tv_residue' ) w_list ( n ) = \"Tv_residue\" case ( 'mass_residue' ) w_list ( n ) = \"Mass_residue\" case ( 'x_mom_residue' ) w_list ( n ) = \"X_mom_residue\" case ( 'y_mom_residue' ) w_list ( n ) = \"Y_mom_residue\" case ( 'z_mom_residue' ) w_list ( n ) = \"Z_mom_residue\" case ( 'energy_residue' ) w_list ( n ) = \"Energy_residue\" case ( 'f1' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then w_list ( n ) = \"F1\" else w_list ( n ) = 'do not write' end if case ( 'dudx' ) w_list ( n ) = \"Dudx\" case ( 'dudy' ) w_list ( n ) = \"Dudy\" case ( 'dudz' ) w_list ( n ) = \"Dudz\" case ( 'dvdx' ) w_list ( n ) = \"Dvdx\" case ( 'dvdy' ) w_list ( n ) = \"Dvdy\" case ( 'dvdz' ) w_list ( n ) = \"Dvdz\" case ( 'dwdx' ) w_list ( n ) = \"Dwdx\" case ( 'dwdy' ) w_list ( n ) = \"Dwdy\" case ( 'dwdz' ) w_list ( n ) = \"Dwdz\" case ( 'dTdx' ) w_list ( n ) = \"DTdx\" case ( 'dTdy' ) w_list ( n ) = \"DTdy\" case ( 'dTdz' ) w_list ( n ) = \"DTdz\" case ( 'dtkdx' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkdy' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkdz' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdx' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdy' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdz' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedx' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedy' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedz' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldx' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldy' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldz' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdx' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdy' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdz' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'intermittency' ) select case ( trim ( turbulence )) case ( 'saBC' ) w_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'tgm' ) select case ( trim ( transition )) case ( 'lctm2015' ) w_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) w_list ( n ) = trim ( lcase ( w_list ( n ))) case Default print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select end do end subroutine verify_write_control subroutine verify_read_control () !< Verify all the variable being asked to read in the output file. !< This is a fail-safe subroutine which do not allow to read the incorrect input variable. !< Based on previous flow type some varible might be skipped implicit none integer :: n character ( len =* ), parameter :: err = \"Control Error: can't read variable - \" do n = 1 , r_count select case ( trim ( lcase ( r_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) r_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) r_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) r_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) r_list ( n ) = \"do not read\" ! if (mu_ref/=0.0) then !   r_list(n) = \"Mu\" ! else !   print*, err//trim(r_list(n))//\" from file\" !   r_list(n) = \"do not read\" ! end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) r_list ( n ) = \"do not read\" !if (turbulence/='none') then !  r_list(n) = \"Mu_t\" !else !  print*, err//trim(r_list(n))//\" from file\" !  r_list(n) = \"do not read\" !end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) r_list ( n ) = \"TKE\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'omega' , 'tw' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) r_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( turbulence )) case ( 'ke' ) select case ( trim ( previous_flow_type )) case ( 'ke' ) r_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'kl' ) select case ( trim ( turbulence )) case ( 'kkl' ) select case ( trim ( previous_flow_type )) case ( 'kkl' ) r_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'tv' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) select case ( trim ( previous_flow_type )) case ( 'sa' , 'saBC' ) r_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) r_list ( n ) = \"do not read\" !if(turbulence/=\"none\") then !  r_list(n) = \"Wall_distance\" !else !  print*, err//trim(r_list(n))//\" from file\" !  r_list(n) = \"do not read\" !end if case ( 'intermittency' ) select case ( trim ( turbulence )) case ( 'saBC' ) select case ( trim ( previous_flow_type )) case ( 'saBC' ) r_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case ( 'tgm' ) select case ( trim ( transition )) case ( 'lctm2015' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' ) r_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case ( 'resnorm' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Resnorm\" case ( 'tke_residue' ) r_list ( n ) = \"do not read\" !r_list(n) = \"TKE_residue\" case ( 'omega_residue' ) r_list ( n ) = \"do not read\" !w_list(n) = \"Omega_residue\" case ( 'f1' ) r_list ( n ) = \"do not read\" !r_list(n) = \"F1\" case ( 'dudx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudx\" case ( 'dudy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudy\" case ( 'dudz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudz\" case ( 'dvdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdx\" case ( 'dvdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdy\" case ( 'dvdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdz\" case ( 'dwdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdx\" case ( 'dwdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdy\" case ( 'dwdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdz\" case ( 'dTdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdx\" case ( 'dTdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdy\" case ( 'dTdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdz\" case ( 'dtkdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdx\" case ( 'dtkdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdy\" case ( 'dtkdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdz\" case ( 'dtwdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdx\" case ( 'dtwdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdy\" case ( 'dtwdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdz\" case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) r_list ( n ) = \"do not read\" !r_list(n) = trim(lcase(w_list(n))) case Default print * , err // trim ( r_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select end do end subroutine verify_read_control end module check_output_control","tags":"","loc":"sourcefile/check_outout_control.f90.html","title":"check_outout_control.f90 – FEST-3D"},{"text":"All the bitwise operation Files dependent on this one sourcefile~~bitwise.f90~~AfferentGraph sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90 wall.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~wall.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules bitwise Source Code bitwise.f90 Source Code !< All the bitwise operation module bitwise !< To apply bitwise (and) and (or) to integer which represents the binary or oct number implicit none interface operator (. and .) module procedure int4_and_int4 , & int8_and_int8 end interface operator (. and .) interface operator (. or .) module procedure int4_or_int4 , int4_1D_or_int4_1D , & int4_1D_or_int4 , int4_2D_or_int4_2D , & int4_2D_or_int4 , int8_or_int8 end interface operator (. or .) interface assignment ( = ) module procedure int4_from_string , & int8_from_string end interface assignment ( = ) interface bin2int module procedure bin_to_int4 , bin_to_int8 end interface bin2int interface oct2int module procedure oct_to_int4 , oct_to_int8 end interface oct2int contains function int4_and_int4 ( a , b ) result ( r ) !< Bitwise 'AND' over two integer of kind 4 implicit none integer ( kind = 4 ), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ) :: r r = iand ( a , b ) end function int4_and_int4 function int8_and_int8 ( a , b ) result ( r ) !< Bitwise 'AND' over two integer of kind 8 implicit none integer ( kind = 8 ), intent ( in ) :: a integer ( kind = 8 ), intent ( in ) :: b integer ( kind = 8 ) :: r r = iand ( a , b ) end function int8_and_int8 function int4_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over two integer of kind 4 implicit none integer ( kind = 4 ), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ) :: r r = ior ( a , b ) end function int4_or_int4 function int4_1D_or_int4_1D ( a , b ) result ( r ) !< Bitwise 'OR' over two 1D integer array of kind 4 implicit none integer ( kind = 4 ), dimension (:), intent ( in ) :: a integer ( kind = 4 ), dimension (:), intent ( in ) :: b integer ( kind = 4 ), dimension ( size ( a )) :: r if ( size ( a ) /= size ( b )) then print * , \"Error: Sizes of arrays being 'or'ed should be the same.\" stop end if r = ior ( a , b ) end function int4_1D_or_int4_1D function int4_1D_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over one 1D integer array and integer of kind 4 implicit none integer ( kind = 4 ), dimension (:), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ), dimension ( size ( a )) :: r integer :: i i = 1 do while ( i <= size ( a )) r ( i ) = ior ( a ( i ), b ) i = i + 1 end do end function int4_1D_or_int4 function int4_2D_or_int4_2D ( a , b ) result ( r ) !< Bitwise 'OR' over two 2D integer array of kind 4 implicit none integer ( kind = 4 ), dimension (:, :), intent ( in ) :: a integer ( kind = 4 ), dimension (:, :), intent ( in ) :: b integer ( kind = 4 ), dimension ( 1 : 2 ) :: na , nb integer ( kind = 4 ), dimension (:, :), allocatable :: r na = shape ( a ) nb = shape ( b ) if (( na ( 1 ) /= nb ( 1 )) . or . ( na ( 2 ) /= nb ( 2 ))) then print * , \"Error: Sizes of arrays being 'or'ed should be the same.\" stop end if allocate ( r ( 1 : na ( 1 ), 1 : na ( 2 ))) r = ior ( a , b ) end function int4_2D_or_int4_2D function int4_2D_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over one 2D integer array and integer of kind 4 implicit none integer ( kind = 4 ), dimension (:, :), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ), dimension ( 1 : 2 ) :: n integer ( kind = 4 ), dimension (:, :), allocatable :: r integer :: i , j n = shape ( a ) allocate ( r ( 1 : n ( 1 ), 1 : n ( 2 ))) do j = 1 , n ( 2 ) do i = 1 , n ( 1 ) r ( i , j ) = ior ( a ( i , j ), b ) end do end do end function int4_2D_or_int4 function int8_or_int8 ( a , b ) result ( r ) !< Bitwise 'OR' over two integer of kind 8 implicit none integer ( kind = 8 ), intent ( in ) :: a integer ( kind = 8 ), intent ( in ) :: b integer ( kind = 8 ) :: r r = ior ( a , b ) end function int8_or_int8 subroutine bin_to_int4 ( r , binstr ) !< String of binary number converted to integer of kind 4 implicit none character ( len =* ) :: binstr integer ( kind = 4 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( binstr ) r = 0 do while ( i > 0 ) read ( binstr ( i : i ), * ) current_digit r = r + (( 2 ** ( len ( binstr ) - i )) * current_digit ) i = i - 1 end do end subroutine bin_to_int4 subroutine bin_to_int8 ( r , binstr ) !< String of binary number converted to integer of kind 8 implicit none character ( len =* ) :: binstr integer ( kind = 8 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( binstr ) r = 0 do while ( i > 0 ) read ( binstr ( i : i ), * ) current_digit r = r + (( 2 ** ( len ( binstr ) - i )) * current_digit ) i = i - 1 end do end subroutine bin_to_int8 subroutine oct_to_int4 ( r , octstr ) !< String of octal number converted to integer of kind 4 implicit none character ( len =* ) :: octstr integer ( kind = 4 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( octstr ) r = 0 do while ( i > 0 ) read ( octstr ( i : i ), * ) current_digit r = r + (( 8 ** ( len ( octstr ) - i )) * current_digit ) i = i - 1 end do end subroutine oct_to_int4 subroutine oct_to_int8 ( r , octstr ) !< String of octal number converted to integer of kind 8 implicit none character ( len =* ) :: octstr integer ( kind = 8 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( octstr ) r = 0 do while ( i > 0 ) read ( octstr ( i : i ), * ) current_digit r = r + (( 8 ** ( len ( octstr ) - i )) * current_digit ) i = i - 1 end do end subroutine oct_to_int8 subroutine int4_from_string ( lhs , rhs ) !< Get integer of kind 4 from the string which might contain either octal or binary number implicit none integer ( kind = 4 ), intent ( out ) :: lhs character ( len =* ), intent ( in ) :: rhs character ( len = len ( rhs ) - 1 ) :: temp temp = rhs ( 2 :) if ( rhs ( 1 : 1 ) == 'b' ) then call bin2int ( lhs , temp ) else if ( rhs ( 1 : 1 ) == 'o' ) then call oct2int ( lhs , temp ) end if end subroutine int4_from_string subroutine int8_from_string ( lhs , rhs ) !< Get integer of kind 8 from the string which might contain either octal or binary number implicit none integer ( kind = 8 ), intent ( out ) :: lhs character ( len =* ), intent ( in ) :: rhs character ( len = len ( rhs ) - 1 ) :: temp temp = rhs ( 2 :) if ( rhs ( 1 : 1 ) == 'b' ) then call bin2int ( lhs , temp ) else if ( rhs ( 1 : 1 ) == 'o' ) then call oct2int ( lhs , temp ) end if end subroutine int8_from_string end module bitwise","tags":"","loc":"sourcefile/bitwise.f90.html","title":"bitwise.f90 – FEST-3D"},{"text":"Change the full string to particular case: upper or lower. This file depends on sourcefile~~str_case.f90~~EfferentGraph sourcefile~str_case.f90 str_case.f90 sourcefile~global.f90 global.f90 sourcefile~str_case.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~str_case.f90~~AfferentGraph sourcefile~str_case.f90 str_case.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~check_outout_control.f90->sourcefile~str_case.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~check_outout_control.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefilestr_casef90AfferentGraph = svgPanZoom('#sourcefilestr_casef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules str_case Source Code str_case.f90 Source Code !< Change the full string to particular case: upper or lower. module str_case !< Change the full string to particular case: upper or lower. use global , only : STRING_BUFFER_LENGTH implicit none private character ( len = STRING_BUFFER_LENGTH ) :: res public :: ucase public :: lcase contains function ucase ( text ) result ( res ) !<Mmake the whole string to upper case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of upper case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"abcdefghijklmnopqrstuvwxyz\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ( C : C ) END DO end function ucase function lcase ( text ) result ( res ) !< Make the whole string to lower case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of lower case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"abcdefghijklmnopqrstuvwxyz\" ( C : C ) END DO end function lcase end module str_case","tags":"","loc":"sourcefile/str_case.f90.html","title":"str_case.f90 – FEST-3D"},{"text":"Different opration on and to string Files dependent on this one sourcefile~~string.f90~~AfferentGraph sourcefile~string.f90 string.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~string.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output_vtk.f90->sourcefile~string.f90 sourcefile~write_output_tec_node.f90->sourcefile~string.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~read_output.f90->sourcefile~string.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~string.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~source.f90 source.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~resnorm.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~read_output_tec.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~string.f90 sourcefile~lusgs.f90->sourcefile~mapping.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~read_output_vtk.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~write_output_tec.f90->sourcefile~string.f90 sourcefile~update.f90->sourcefile~string.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~string.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~create_and_erase.f90->sourcefile~read.f90 sourcefile~create_and_erase.f90->sourcefile~wall.f90 sourcefile~create_and_erase.f90->sourcefile~grid.f90 sourcefile~plusgs.f90->sourcefile~string.f90 sourcefile~plusgs.f90->sourcefile~mapping.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~grid.f90->sourcefile~mapping.f90 var pansourcefilestringf90AfferentGraph = svgPanZoom('#sourcefilestringf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules string Source Code string.f90 Source Code !< Different opration on and to string module string !< Module to convert int, real, or bool to string !< and concatenate int, real, bool, and string itself to string !------------------------------------------------------------------- ! String manipulation ! ! This module implements the to_string family of methods which allow ! other type variables to be converted to strings. ! ! This module also overloads the string concatenation operator (//) ! so that strings can be concatenated with other strings, ! integers, reals and logicals. !------------------------------------------------------------------- implicit none integer , parameter :: MAX_STRING_LEN = 256 integer , private :: dec_ = 6 integer , private :: exp_ = - 1 character , private :: form_ = 'F' logical , private :: reset_flag = . FALSE . !TODO: Implement a reset flag. If this flag is set to true, reset !the parameters dec, exp, form after one operation (can be changed !to some other integer?). This should be set by the chfmt method. interface tostr module procedure int_to_str , & real_to_str , & bool_to_str end interface tostr interface operator ( + ) module procedure str_cat_str , & str_cat_int , & int_cat_str , & str_cat_real , & real_cat_str , & str_cat_bool , & bool_cat_str end interface operator ( + ) interface len module procedure intlen , reallen end interface len contains include \"tostr_implementation.inc\" include \"strcat_implementation.inc\" include \"typelen_implementation.inc\" subroutine chfmt ( d , e , f ) !< Change format specifier for reals !----------------------------------------------------------- ! Change format specifier for reals ! ! Inputs: !   d -> integer, optional !       digits after decimal !   e -> integer, optional !       digits in exponent !       When this is set to -1, the exponent part is dropped !   f -> character, optional !       form !       Valid options: 'F' (decimal), 'E' (exponential), !           'S' (scientific), 'N' (engineering) !       If 'F' is specified, then the value for e is !           overridden and set to -1. ! ! If no arguments are passed, this function resets all the ! parameters to their default values (as provided in the ! following table. Else, only the passed arguments will be ! updated (the others will be left unchanged). ! ! This function is sticky; a format once set will continue ! to apply till either it is changed or the program ends. ! ! Default values: !   d (digits after decimal) --> 6 !   e (digits in exponent) --> -1 !   f (form) --> 'F' (decimal) ! !TODO: Add support for width also? !http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html !----------------------------------------------------------- implicit none integer , intent ( in ), optional :: d integer , intent ( in ), optional :: e character , intent ( in ), optional :: f if (. not . ( present ( d ) . or . present ( e ) . or . present ( f ))) then dec_ = 6 exp_ = 0 form_ = 'F' else if ( present ( d )) dec_ = d if ( present ( e )) exp_ = e if ( present ( f )) then if (. not . ( f . eq . 'F' . or . f . eq . 'E' . or . & f . eq . 'S' . or . f . eq . 'N' )) then print * , 'Error: Unknown kind specified.' stop end if form_ = f if ( form_ . eq . 'F' ) exp_ = - 1 end if end if end subroutine chfmt subroutine disp ( s ) !< Display the contents of the string ! ! This function trims the string before printing it. !----------------------------------------------------------- implicit none character ( len = MAX_STRING_LEN ), intent ( in ) :: s print * , trim ( s ) end subroutine disp end module string","tags":"","loc":"sourcefile/string.f90.html","title":"string.f90 – FEST-3D"},{"text":"Open all files required This file depends on sourcefile~~fopen.f90~~EfferentGraph sourcefile~fopen.f90 fopen.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~fopen.f90->sourcefile~fclose.f90 sourcefile~global.f90 global.f90 sourcefile~fopen.f90->sourcefile~global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules fopen Source Code fopen.f90 Source Code !< Open all files required module fopen !< Open all files required by the solver. Input and auxillary file !--------------------------------------------- ! 17082  Jatinder Pal Singh Sandhu !  Aim : efficient open of files only with handler !--------------------------------------------- ! File unit numbers use global , only : CONFIG_FILE_UNIT use global , only : GRID_FILE_UNIT use global , only : STATE_FILE_UNIT use global , only : IN_FILE_UNIT use global , only : OUT_FILE_UNIT use global , only : RESNORM_FILE_UNIT use global , only : TEMP_NODE_FILE_UNIT use global , only : LAYOUT_FILE_UNIT use global , only : NODESURF_FILE_UNIT use global , only : WALL_DIST_FILE_UNIT use global , only : RES_CONTROL_FILE_UNIT use global , only : INFO_FILE_UNIT use global , only : CONTROL_FILE_UNIT use global , only : SCHEME_FILE_UNIT use global , only : FLOW_FILE_UNIT use global , only : RESTART_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : STOP_FILE_UNIT use global , only : BOUNDARY_CONDITIONS_FILE_UNIT use fclose , only : close_file implicit none private !  public :: open_all_files public :: open_file contains subroutine open_file ( handler ) !< Open single file implicit none integer , intent ( in ) :: handler select case ( handler ) case ( 1 ) close_file ( handler ) open ( handler ,) case ( 2 ) end select end subroutine open_file end module fopen","tags":"","loc":"sourcefile/fopen.f90.html","title":"fopen.f90 – FEST-3D"},{"text":"Start and stop the solver This file depends on sourcefile~~start_finish.f90~~EfferentGraph sourcefile~start_finish.f90 start_finish.f90 sourcefile~solver.f90 solver.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~start_finish.f90->sourcefile~fclose.f90 sourcefile~wall.f90 wall.f90 sourcefile~solver.f90->sourcefile~wall.f90 sourcefile~time.f90 time.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~boundary_state_reconstruction.f90 boundary_state_reconstruction.f90 sourcefile~solver.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~summon_grad_evaluation.f90 summon_grad_evaluation.f90 sourcefile~solver.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~solver.f90->sourcefile~global_vars.f90 sourcefile~layout.f90 layout.f90 sourcefile~solver.f90->sourcefile~layout.f90 sourcefile~state.f90 state.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~solver.f90->sourcefile~wall_dist.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~source.f90 source.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~bc.f90 bc.f90 sourcefile~solver.f90->sourcefile~bc.f90 sourcefile~geometry.f90 geometry.f90 sourcefile~solver.f90->sourcefile~geometry.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~utils.f90 utils.f90 sourcefile~solver.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~string.f90 string.f90 sourcefile~solver.f90->sourcefile~string.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~read.f90 read.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~cc.f90 CC.f90 sourcefile~solver.f90->sourcefile~cc.f90 sourcefile~global.f90 global.f90 sourcefile~solver.f90->sourcefile~global.f90 sourcefile~grid.f90 grid.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~wall.f90->sourcefile~global_vars.f90 sourcefile~wall.f90->sourcefile~utils.f90 sourcefile~wall.f90->sourcefile~string.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~bitwise.f90 bitwise.f90 sourcefile~wall.f90->sourcefile~bitwise.f90 sourcefile~time.f90->sourcefile~global_vars.f90 sourcefile~time.f90->sourcefile~geometry.f90 sourcefile~time.f90->sourcefile~utils.f90 sourcefile~time.f90->sourcefile~string.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~global_vars.f90 sourcefile~boundary_state_reconstruction.f90->sourcefile~utils.f90 sourcefile~interface1.f90->sourcefile~global_vars.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~interface1.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~global_vars.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~utils.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~string.f90 sourcefile~ghost_gradient.f90 ghost_gradient.f90 sourcefile~summon_grad_evaluation.f90->sourcefile~ghost_gradient.f90 sourcefile~viscous2.f90->sourcefile~global_vars.f90 sourcefile~viscous2.f90->sourcefile~geometry.f90 sourcefile~viscous2.f90->sourcefile~utils.f90 sourcefile~viscous2.f90->sourcefile~string.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~state.f90->sourcefile~global_vars.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~gradients.f90->sourcefile~global_vars.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~wall_dist.f90->sourcefile~global_vars.f90 sourcefile~wall_dist.f90->sourcefile~utils.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~mapping.f90->sourcefile~global_vars.f90 sourcefile~mapping.f90->sourcefile~utils.f90 sourcefile~mapping.f90->sourcefile~string.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~resnorm.f90->sourcefile~fclose.f90 sourcefile~resnorm.f90->sourcefile~global_vars.f90 sourcefile~resnorm.f90->sourcefile~layout.f90 sourcefile~resnorm.f90->sourcefile~utils.f90 sourcefile~resnorm.f90->sourcefile~string.f90 sourcefile~resnorm.f90->sourcefile~global.f90 sourcefile~source.f90->sourcefile~global_vars.f90 sourcefile~source.f90->sourcefile~layout.f90 sourcefile~source.f90->sourcefile~utils.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~source.f90->sourcefile~string.f90 sourcefile~source.f90->sourcefile~cc.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~bc.f90->sourcefile~global_vars.f90 sourcefile~bc.f90->sourcefile~utils.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~bc.f90->sourcefile~read_bc.f90 sourcefile~geometry.f90->sourcefile~global_vars.f90 sourcefile~geometry.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_vars.f90 sourcefile~viscosity.f90->sourcefile~utils.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~copy_bc.f90 copy_bc.f90 sourcefile~viscosity.f90->sourcefile~copy_bc.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~global_vars.f90 sourcefile~dump_solution.f90->sourcefile~layout.f90 sourcefile~dump_solution.f90->sourcefile~utils.f90 sourcefile~dump_solution.f90->sourcefile~string.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~bc_primitive.f90->sourcefile~global_vars.f90 sourcefile~bc_primitive.f90->sourcefile~utils.f90 sourcefile~bc_primitive.f90->sourcefile~copy_bc.f90 sourcefile~ft_bc.f90 FT_bc.f90 sourcefile~bc_primitive.f90->sourcefile~ft_bc.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~read_bc.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~read.f90->sourcefile~global_vars.f90 sourcefile~read.f90->sourcefile~utils.f90 sourcefile~read.f90->sourcefile~string.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~boundary_state_reconstruction.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~summon_grad_evaluation.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~update.f90->sourcefile~global_vars.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~update.f90->sourcefile~geometry.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~update.f90->sourcefile~utils.f90 sourcefile~update.f90->sourcefile~string.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~cc.f90->sourcefile~global_vars.f90 sourcefile~cc.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global_vars.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~grid.f90->sourcefile~utils.f90 sourcefile~grid.f90->sourcefile~global.f90 var pansourcefilestart_finishf90EfferentGraph = svgPanZoom('#sourcefilestart_finishf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~start_finish.f90~~AfferentGraph sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~start_finish.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules start_finish Source Code start_finish.f90 Source Code !< Start and stop the solver module start_finish !< Start and stop the solver use fclose , only : close_all_files use solver , only : destroy_solver use solver , only : setup_solver #include \"../mpi.inc\" private public :: abort_run public :: finish_run public :: start_run contains subroutine abort_run () !< Aborting the solver implicit none integer :: ierr call close_all_files () call destroy_solver () call MPI_FINALIZE ( ierr ) stop end subroutine abort_run subroutine finish_run () !< Finishing the solution computation implicit none integer :: ierr call close_all_files () call destroy_solver () call MPI_FINALIZE ( ierr ) end subroutine finish_run subroutine start_run () !< Starting the solver setup implicit none integer :: ierr call MPI_INIT ( ierr ) call setup_solver () end subroutine start_run end module start_finish","tags":"","loc":"sourcefile/start_finish.f90.html","title":"start_finish.f90 – FEST-3D"},{"text":"Close all the opened files This file depends on sourcefile~~fclose.f90~~EfferentGraph sourcefile~fclose.f90 fclose.f90 sourcefile~global.f90 global.f90 sourcefile~fclose.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~fclose.f90~~AfferentGraph sourcefile~fclose.f90 fclose.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~mapping.f90->sourcefile~fclose.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~resnorm.f90->sourcefile~fclose.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~start_finish.f90->sourcefile~fclose.f90 sourcefile~solver.f90 solver.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~fclose.f90 sourcefile~fopen.f90 fopen.f90 sourcefile~fopen.f90->sourcefile~fclose.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~interface1.f90 interface1.f90 sourcefile~interface1.f90->sourcefile~mapping.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~read.f90 sourcefile~time.f90 time.f90 sourcefile~create_and_erase.f90->sourcefile~time.f90 sourcefile~grid.f90 grid.f90 sourcefile~create_and_erase.f90->sourcefile~grid.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~mapping.f90 sourcefile~time.f90->sourcefile~read.f90 sourcefile~grid.f90->sourcefile~mapping.f90 sourcefile~solver.f90->sourcefile~mapping.f90 sourcefile~solver.f90->sourcefile~resnorm.f90 sourcefile~solver.f90->sourcefile~read.f90 sourcefile~solver.f90->sourcefile~interface1.f90 sourcefile~solver.f90->sourcefile~time.f90 sourcefile~solver.f90->sourcefile~grid.f90 sourcefile~update.f90 update.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~lusgs.f90->sourcefile~mapping.f90 sourcefile~update.f90->sourcefile~interface1.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~time.f90 sourcefile~update.f90->sourcefile~lusgs.f90 var pansourcefilefclosef90AfferentGraph = svgPanZoom('#sourcefilefclosef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules fclose Source Code fclose.f90 Source Code !< Close all the opened files module fclose !< Close all the opened files !--------------------------------------------- ! 170513  Jatinder Pal Singh Sandhu !  Aim : close all opened file. !--------------------------------------------- ! File unit numbers use global , only : CONFIG_FILE_UNIT use global , only : GRID_FILE_UNIT use global , only : STATE_FILE_UNIT use global , only : IN_FILE_UNIT use global , only : OUT_FILE_UNIT use global , only : RESNORM_FILE_UNIT use global , only : TEMP_NODE_FILE_UNIT use global , only : LAYOUT_FILE_UNIT use global , only : NODESURF_FILE_UNIT use global , only : WALL_DIST_FILE_UNIT use global , only : RES_CONTROL_FILE_UNIT use global , only : INFO_FILE_UNIT use global , only : CONTROL_FILE_UNIT use global , only : SCHEME_FILE_UNIT use global , only : FLOW_FILE_UNIT use global , only : RESTART_FILE_UNIT use global , only : OUTIN_FILE_UNIT use global , only : STOP_FILE_UNIT use global , only : BOUNDARY_CONDITIONS_FILE_UNIT implicit none private public :: close_all_files public :: close_file contains subroutine close_all_files !< Call to close all files implicit none call close_file ( CONFIG_FILE_UNIT ) call close_file ( GRID_FILE_UNIT ) call close_file ( STATE_FILE_UNIT ) call close_file ( IN_FILE_UNIT ) call close_file ( OUT_FILE_UNIT ) call close_file ( RESNORM_FILE_UNIT ) call close_file ( TEMP_NODE_FILE_UNIT ) call close_file ( LAYOUT_FILE_UNIT ) call close_file ( NODESURF_FILE_UNIT ) call close_file ( WALL_DIST_FILE_UNIT ) call close_file ( RES_CONTROL_FILE_UNIT ) call close_file ( INFO_FILE_UNIT ) call close_file ( CONTROL_FILE_UNIT ) call close_file ( SCHEME_FILE_UNIT ) call close_file ( FLOW_FILE_UNIT ) call close_file ( RESTART_FILE_UNIT ) call close_file ( OUTIN_FILE_UNIT ) call close_file ( STOP_FILE_UNIT ) call close_file ( BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine close_all_files subroutine close_file ( handler ) !Generalized subroutine to close single file implicit none integer , intent ( in ) :: handler logical :: ok inquire ( handler , opened = ok ) if ( ok ) close ( handler ) end subroutine close_file end module fclose","tags":"","loc":"sourcefile/fclose.f90.html","title":"fclose.f90 – FEST-3D"},{"text":"Setup and nullify pointers for SST model to the main array which stores gradient of all variables This file depends on sourcefile~~sst_gradients.f90~~EfferentGraph sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~sst_gradients.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~sst_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sst_gradients.f90~~AfferentGraph sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sst_gradients Source Code sst_gradients.f90 Source Code !< Setup and nullify pointers for SST model to the main array which stores gradient of all variables module sst_gradients !< Setup and nullify pointers for SST model to the main array which stores gradient of all variables !--------------------------------------------------------------- ! 1705009  Jatinder Pal Singh Sandhu !          - first build ! aim : link sst pointer to allocated memory for gradients !--------------------------------------------------------------- #include \"../debug.h\" #include \"../error.h\" use global_vars , only : process_id use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradtw_x use global_vars , only : gradtw_y use global_vars , only : gradtw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use global_vars , only : gradtgm_x use global_vars , only : gradtgm_y use global_vars , only : gradtgm_z use utils , only : dmsg implicit none private public :: setup_sst_grad public :: destroy_sst_grad contains subroutine setup_sst_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_sst_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) end subroutine setup_sst_grad subroutine destroy_sst_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_sst_grad' ) nullify ( gradtk_x ) nullify ( gradtw_x ) nullify ( gradtk_y ) nullify ( gradtw_y ) nullify ( gradtk_z ) nullify ( gradtw_z ) end subroutine destroy_sst_grad end module sst_gradients","tags":"","loc":"sourcefile/sst_gradients.f90.html","title":"sst_gradients.f90 – FEST-3D"},{"text":"Link/Pointer to the gradient of u,v,w, and Temperature This file depends on sourcefile~~laminar_gradients.f90~~EfferentGraph sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~laminar_gradients.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~laminar_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~laminar_gradients.f90~~AfferentGraph sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules laminar_gradients Source Code laminar_gradients.f90 Source Code !< Link/Pointer to the gradient of u,v,w, and Temperature module laminar_gradients !< Link/Pointer to the gradient of u,v,w, and Temperature !--------------------------------------------------------------- ! 1705009  Jatinder Pal Singh Sandhu !          - first build ! aim : link laminar pointer to allocated memory for gradients !--------------------------------------------------------------- #include \"../debug.h\" use global_vars , only : process_id use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : n_grad use global_vars , only : gradu_x use global_vars , only : gradu_y use global_vars , only : gradu_z use global_vars , only : gradv_x use global_vars , only : gradv_y use global_vars , only : gradv_z use global_vars , only : gradw_x use global_vars , only : gradw_y use global_vars , only : gradw_z use global_vars , only : gradT_x use global_vars , only : gradT_y use global_vars , only : gradT_z use utils , only : dmsg implicit none contains subroutine setup_laminar_grad () !< Setup pointer to the gradient of U, v, w, Temperature !< with respect to x, y, and z implicit none DebugCall ( 'setup_laminar_grad' ) gradu_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 1 ) gradv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 2 ) gradw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 3 ) gradT_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 4 ) gradu_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 1 ) gradv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 2 ) gradw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 3 ) gradT_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 4 ) gradu_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 1 ) gradv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 2 ) gradw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 3 ) gradT_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 4 ) end subroutine setup_laminar_grad subroutine destroy_laminar_grad () !< Unlink the laminar gradient pointers implicit none DebugCall ( 'destroy_laminar_grad' ) nullify ( gradu_x ) nullify ( gradv_x ) nullify ( gradw_x ) nullify ( gradT_x ) nullify ( gradu_y ) nullify ( gradv_y ) nullify ( gradw_y ) nullify ( gradT_y ) nullify ( gradu_z ) nullify ( gradv_z ) nullify ( gradw_z ) nullify ( gradT_z ) end subroutine destroy_laminar_grad end module laminar_gradients","tags":"","loc":"sourcefile/laminar_gradients.f90.html","title":"laminar_gradients.f90 – FEST-3D"},{"text":"Allocate memory to laminar gradients if flow is viscous and\n allocate memory to tubulence gradients base upon the model being used This file depends on sourcefile~~gradients.f90~~EfferentGraph sourcefile~gradients.f90 gradients.f90 sourcefile~laminar_gradients.f90 laminar_gradients.f90 sourcefile~gradients.f90->sourcefile~laminar_gradients.f90 sourcefile~sst_gradients.f90 sst_gradients.f90 sourcefile~gradients.f90->sourcefile~sst_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~gradients.f90->sourcefile~utils.f90 sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~gradients.f90->sourcefile~global_vars.f90 sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~laminar_gradients.f90->sourcefile~utils.f90 sourcefile~laminar_gradients.f90->sourcefile~global_vars.f90 sourcefile~sst_gradients.f90->sourcefile~utils.f90 sourcefile~sst_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~kkl_gradients.f90->sourcefile~utils.f90 sourcefile~kkl_gradients.f90->sourcefile~global_vars.f90 sourcefile~sa_gradients.f90->sourcefile~utils.f90 sourcefile~sa_gradients.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~lctm2015_gradients.f90->sourcefile~utils.f90 sourcefile~lctm2015_gradients.f90->sourcefile~global_vars.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~gradients.f90~~AfferentGraph sourcefile~gradients.f90 gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules gradients Source Code gradients.f90 Source Code !< Allocate memory to laminar gradients if flow is viscous and !< allocate memory to tubulence gradients base upon the model being used module gradients !< Allocate memory to laminar gradients if flow is viscous and !< allocate memory to tubulence gradients base upon the model being used !------------------------------------------------------------------ ! 170509  Jatinder Pal Singh Sandhu !         - first build !------------------------------------------------------------------- #include \"../error.h\" #include \"../debug.h\" use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : mu_ref use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : n_grad use global_vars , only : sst_n_grad use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : process_id use utils , only : dmsg use utils , only : dealloc use utils , only : alloc use utils , only : turbulence_read_error use laminar_gradients , only : setup_laminar_grad use laminar_gradients , only : destroy_laminar_grad use sst_gradients , only : setup_sst_grad use sst_gradients , only : destroy_sst_grad use kkl_gradients , only : setup_kkl_grad use kkl_gradients , only : destroy_kkl_grad use sa_gradients , only : setup_sa_grad use sa_gradients , only : destroy_sa_grad use lctm2015_gradients , only : setup_lctm2015_grad use lctm2015_gradients , only : destroy_lctm2015_grad implicit none private public :: setup_gradients public :: destroy_gradients contains subroutine setup_gradients !< Memoery allocation to the gradient variables and !< setup pointer to the slice to the main gradient variable !< based on the various models being used. implicit none DebugCall ( \"setup_gradients\" ) if ( mu_ref /= 0 ) then call get_n_grad () call allocate_memory () ! Linking pointer to laminar gradients call setup_laminar_grad () ! Linking pointer to turbulent gradients select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call setup_sa_grad () case ( 'sst' , 'sst2003' ) call setup_sst_grad () case ( 'kkl' ) call setup_kkl_grad () case DEFAULT !call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) call setup_lctm2015_grad () case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine setup_gradients subroutine destroy_gradients !< Deallocate memoery and nullify pointers !< to the gradient variables. implicit none DebugCall ( \"destroy_gradients\" ) if ( mu_ref /= 0 ) then call destroy_memory () ! unlink laminar grad pointer call destroy_laminar_grad () !unlink turublent grad pointer select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call destroy_sa_grad () case ( 'sst' , 'sst2003' ) call destroy_sst_grad () case ( 'kkl' ) call destroy_kkl_grad () case DEFAULT ! call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) call destroy_lctm2015_grad () case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine destroy_gradients subroutine get_n_grad () !< Set number of variables for which !< gradient is required based on the !< being used implicit none DebugCall ( \"get_n_grad\" ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) n_grad = 5 case ( 'sst' , 'sst2003' ) n_grad = 6 case ( 'kkl' ) n_grad = 6 case DEFAULT !call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) n_grad = n_grad + 1 case ( 'none' , 'bc' ) n_grad = n_grad + 0 case DEFAULT Fatal_error end Select end subroutine get_n_grad subroutine allocate_memory () !< Allocating memory to the gradient variable being used implicit none DebugCall ( \"allocate_memory\" ) call alloc ( gradqp_x , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_x\" )) call alloc ( gradqp_y , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_y\" )) call alloc ( gradqp_z , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_z\" )) end subroutine allocate_memory subroutine destroy_memory () !< Deallocate memeory from the gradient variables implicit none DebugCall ( \"deallocate_memory\" ) call dealloc ( gradqp_x ) call dealloc ( gradqp_y ) call dealloc ( gradqp_z ) end subroutine destroy_memory end module gradients","tags":"","loc":"sourcefile/gradients.f90.html","title":"gradients.f90 – FEST-3D"},{"text":"Allocate memory to the state variables and initialize them This file depends on sourcefile~~state.f90~~EfferentGraph sourcefile~state.f90 state.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~state.f90->sourcefile~read_output.f90 sourcefile~global.f90 global.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~utils.f90 utils.f90 sourcefile~state.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~state.f90->sourcefile~global_vars.f90 sourcefile~layout.f90 layout.f90 sourcefile~state.f90->sourcefile~layout.f90 sourcefile~string.f90 string.f90 sourcefile~state.f90->sourcefile~string.f90 sourcefile~check_outout_control.f90 check_outout_control.f90 sourcefile~state.f90->sourcefile~check_outout_control.f90 sourcefile~read_output.f90->sourcefile~global.f90 sourcefile~read_output.f90->sourcefile~utils.f90 sourcefile~read_output.f90->sourcefile~global_vars.f90 sourcefile~read_output.f90->sourcefile~string.f90 sourcefile~read_output.f90->sourcefile~check_outout_control.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output.f90->sourcefile~read_output_vtk.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~layout.f90->sourcefile~utils.f90 sourcefile~layout.f90->sourcefile~global_vars.f90 sourcefile~check_outout_control.f90->sourcefile~global_vars.f90 sourcefile~str_case.f90 str_case.f90 sourcefile~check_outout_control.f90->sourcefile~str_case.f90 sourcefile~read_output_tec.f90->sourcefile~global.f90 sourcefile~read_output_tec.f90->sourcefile~utils.f90 sourcefile~read_output_tec.f90->sourcefile~global_vars.f90 sourcefile~read_output_tec.f90->sourcefile~string.f90 sourcefile~global_sst.f90 global_sst.f90 sourcefile~read_output_tec.f90->sourcefile~global_sst.f90 sourcefile~str_case.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90->sourcefile~utils.f90 sourcefile~read_output_vtk.f90->sourcefile~global_vars.f90 sourcefile~read_output_vtk.f90->sourcefile~string.f90 var pansourcefilestatef90EfferentGraph = svgPanZoom('#sourcefilestatef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~state.f90~~AfferentGraph sourcefile~state.f90 state.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules state Source Code state.f90 Source Code !< Allocate memory to the state variables and initialize them module state !< Allocate memory to the state variables and initialize them !< The state of the system is defined using the density, velocity and !< pressure (primitive variables qp), and trubulent and transition !< variables at the cell-center points. !------------------------------------------------------------------- ! The state module contains the state variables and the methods that ! act on them. !------------------------------------------------------------------- #include \"../debug.h\" #include \"../error.h\" use global , only : FILE_NAME_LENGTH , STATE_FILE_UNIT , OUT_FILE_UNIT , & DESCRIPTION_STRING_LENGTH , STRING_BUFFER_LENGTH use global_vars , only : start_from use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : grid_x use global_vars , only : grid_y use global_vars , only : grid_z use global_vars , only : xnx , xny , xnz !face unit normal x use global_vars , only : ynx , yny , ynz !face unit normal y use global_vars , only : znx , zny , znz !face unit normal z use global_vars , only : n_var use global_vars , only : sst_n_var use global_vars , only : qp use global_vars , only : qp_inf use global_vars , only : density use global_vars , only : x_speed use global_vars , only : y_speed use global_vars , only : z_speed use global_vars , only : pressure use global_vars , only : density_inf use global_vars , only : x_speed_inf use global_vars , only : y_speed_inf use global_vars , only : z_speed_inf use global_vars , only : pressure_inf use global_vars , only : tk use global_vars , only : tw use global_vars , only : te use global_vars , only : tv use global_vars , only : tkl use global_vars , only : tgm use global_vars , only : tk_inf use global_vars , only : tw_inf use global_vars , only : te_inf use global_vars , only : tv_inf use global_vars , only : tkl_inf use global_vars , only : tgm_inf use global_vars , only : gm use global_vars , only : mu_ref use global_vars , only : turbulence use global_vars , only : transition use global_vars , only : infile use global_vars , only : intermittency use global_vars , only : ExtraVar1 use global_vars , only : ExtraVar2 use global_vars , only : ExtraVar3 use global_vars , only : ExtraVar4 use global_vars , only : ExtraVar5 use global_vars , only : free_stream_density use global_vars , only : free_stream_x_speed use global_vars , only : free_stream_y_speed use global_vars , only : free_stream_z_speed use global_vars , only : free_stream_pressure use global_vars , only : free_stream_tk use global_vars , only : free_stream_tw use global_vars , only : free_stream_tu use global_vars , only : free_stream_tgm use global_vars , only : vel_mag use global_vars , only : MInf use global_vars , only : Reynolds_number use global_vars , only : mu_ratio_inf use global_vars , only : Turb_intensity_inf use utils , only : alloc , dealloc , dmsg use layout , only : process_id use string use read_output , only : read_file use check_output_control , only : verify_write_control implicit none private ! Public methods public :: setup_state public :: destroy_state contains subroutine link_aliases () !< Setup state variable pointers implicit none DebugCall ( \"link_aliases\" ) density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 5 ) density_inf => qp_inf ( 1 ) x_speed_inf => qp_inf ( 2 ) y_speed_inf => qp_inf ( 3 ) z_speed_inf => qp_inf ( 4 ) pressure_inf => qp_inf ( 5 ) select case ( trim ( turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) tw_inf => qp_inf ( 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) tkl_inf => qp_inf ( 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tv_inf => qp_inf ( 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) te_inf => qp_inf ( 7 ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, n_var ) tgm_inf => qp_inf ( n_var ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine link_aliases subroutine unlink_aliases () !< Nullify the pointer link implicit none DebugCall ( \"unlink_aliases\" ) nullify ( density ) nullify ( x_speed ) nullify ( y_speed ) nullify ( z_speed ) nullify ( pressure ) nullify ( density_inf ) nullify ( x_speed_inf ) nullify ( y_speed_inf ) nullify ( z_speed_inf ) nullify ( pressure_inf ) select case ( trim ( turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"kw\" , \"des-sst\" ) nullify ( tk ) nullify ( tw ) nullify ( tk_inf ) nullify ( tw_inf ) case ( \"kkl\" ) nullify ( tk ) nullify ( tkl ) nullify ( tk_inf ) nullify ( tkl_inf ) case ( \"sa\" , \"saBC\" ) nullify ( tv ) nullify ( tv_inf ) case ( \"ke\" ) nullify ( tk ) nullify ( te ) nullify ( tk_inf ) nullify ( te_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) nullify ( tgm ) nullify ( tgm_inf ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine unlink_aliases subroutine allocate_memory () !< Allocate memory to the state variables !----------------------------------------------------------- implicit none DebugCall ( \"allocate_memory\" ) ! The state of the system is defined by the primitive ! variables (density, velocity and pressure) at the grid ! cell centers. call alloc ( qp , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var , AErrMsg ( \"qp\" )) call alloc ( qp_inf , 1 , n_var , AErrMsg ( \"qp_inf\" )) end subroutine allocate_memory subroutine deallocate_memory () !< Deallocate memory from the state variable implicit none DebugCall ( \"allocate_memory\" ) call dealloc ( qp ) end subroutine deallocate_memory subroutine setup_state () !< Setup the state module. !< This subroutine should be run before the state variables !< are initilized. This subroutine allocates the memory for !< state variables and sets up the aliases to refer to the !< components of the state !----------------------------------------------------------- implicit none DebugCall ( \"setup_state\" ) call set_n_var_value () call allocate_memory () call link_aliases () call init_infinity_values () call initstate () end subroutine setup_state subroutine destroy_state () !< Destroy the state module. !< This subroutine destroys the state module which includes !< unlinking the aliases for the state components and !< deallocating the memory held by the state variables !----------------------------------------------------------- implicit none DebugCall ( \"destroy_state\" ) call unlink_aliases () call deallocate_memory () end subroutine destroy_state subroutine init_infinity_values () !< Set the values of the infinity variables \"qp_inf\" !----------------------------------------------------------- implicit none DebugCall ( \"init_infinity_values\" ) density_inf = free_stream_density x_speed_inf = free_stream_x_speed y_speed_inf = free_stream_y_speed z_speed_inf = free_stream_z_speed pressure_inf = free_stream_pressure vel_mag = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 + z_speed_inf ** 2 ) MInf = Vel_mag / sqrt ( gm * pressure_inf / density_inf ) Reynolds_number = density_inf * vel_mag * 1.0 / mu_ref Turb_intensity_inf = free_stream_tu / 100 select case ( trim ( turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"kkl\" ) tk_inf = 9 * ( 1 e - 9 ) * ( sound_speed_inf () ** 2 ) tkl_inf = 1.5589 * ( 1 e - 6 ) * ( mu_ref * sound_speed_inf ()) / density_inf case ( \"sa\" ) tv_inf = mu_ratio_inf * mu_ref / density_inf case ( \"saBC\" ) tv_inf = 0.005 * mu_ratio_inf * mu_ref / density_inf case ( \"kw\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"ke\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = 0.09 * density_inf * tk_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"des-sst\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) tgm_inf = free_stream_tgm case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine init_infinity_values function sound_speed_inf () result ( a ) !< Return the free stream speed of sound. !----------------------------------------------------------- implicit none real :: a a = sqrt ( gm * pressure_inf / density_inf ) end function sound_speed_inf subroutine initstate () !< Initialize the state. !< If load file(start_from) is 0, then the state should be !< set to the infinity values. Otherwise, read the state_file !< to get the state values !----------------------------------------------------------- implicit none DebugCall ( \"initstate\" ) call verify_write_control () if ( start_from . eq . 0 ) then ! Set the state to the infinity values call init_state_with_infinity_values () !!---------------------------------------- !!following are added spefically for !! shock tube test case !!--------------------------------------- !if(process_id<2) then !  pressure = 1.0 !  density = 1.0 !  x_speed = 0.0 !  y_speed = 0.0 !  z_speed = 0.0 !else !  pressure = 0.1 !  density = 0.125 !  x_speed = 0.0 !  y_speed = 0.0 !  z_speed = 0.0 !end if !X_speed = 0.0 !Y_speed = 0.0 !Z_speed = 0.0 else write ( infile , '(a,i4.4,a,i2.2)' ) & \"time_directories/\" , start_from , \"/process_\" , process_id ! Set the state to the infinity values so if some ! variable are not restart variable they get free_stream value call init_state_with_infinity_values () call read_file () end if end subroutine initstate subroutine init_state_with_infinity_values () !< Initialize the state based on the infinity values !----------------------------------------------------------- implicit none integer :: i DebugCall ( \"init_state_with_infinity_values\" ) do i = 1 , n_var qp (:, :, :, i ) = qp_inf ( i ) end do end subroutine init_state_with_infinity_values subroutine set_n_var_value () !< Set number of variable to solver for based on !< the tubulence and transition model being used implicit none DebugCall ( \"set_n_var_value\" ) select case ( trim ( turbulence )) case ( 'none' ) n_var = 5 case ( 'sa' , 'saBC' ) n_var = 6 case ( 'sst' , \"sst2003\" , 'bsl' , 'kw' , 'ke' , 'kkl' , 'Des-kw' ) n_var = 7 case DEFAULT n_var = 5 end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) n_var = n_var + 1 case ( 'bc' , 'none' ) n_var = n_var + 0 case DEFAULT Fatal_error end Select end subroutine set_n_var_value end module state","tags":"","loc":"sourcefile/state.f90.html","title":"state.f90 – FEST-3D"},{"text":"Setup and nullify pointers for LCTM2015 transition \nmodel to the main array which stores gradient of all variables This file depends on sourcefile~~lctm2015_gradients.f90~~EfferentGraph sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~lctm2015_gradients.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~lctm2015_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~lctm2015_gradients.f90~~AfferentGraph sourcefile~lctm2015_gradients.f90 lctm2015_gradients.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~lctm2015_gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules lctm2015_gradients Source Code lctm2015_gradients.f90 Source Code !< Setup and nullify pointers for LCTM2015 transition !<model to the main array which stores gradient of all variables module lctm2015_gradients !< Setup and nullify pointers for LCTM2015 transition !<model to the main array which stores gradient of all variables !--------------------------------------------------------------- ! 1705009  Jatinder Pal Singh Sandhu !          - first build ! aim : link LCTM2015 pointer to allocated memory for gradients !--------------------------------------------------------------- #include \"../debug.h\" #include \"../error.h\" use global_vars , only : process_id use global_vars , only : transition use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : n_grad use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : gradtgm_x use global_vars , only : gradtgm_y use global_vars , only : gradtgm_z use utils , only : dmsg implicit none private public :: setup_lctm2015_grad public :: destroy_lctm2015_grad contains subroutine setup_lctm2015_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_sst_grad' ) select case ( trim ( transition )) case ( 'lctm2015' ) gradtgm_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, n_grad ) gradtgm_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, n_grad ) gradtgm_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, n_grad ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine setup_lctm2015_grad subroutine destroy_lctm2015_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_sst_grad' ) select case ( trim ( transition )) case ( 'lctm2015' ) nullify ( gradtgm_x ) nullify ( gradtgm_y ) nullify ( gradtgm_z ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine destroy_lctm2015_grad end module lctm2015_gradients","tags":"","loc":"sourcefile/lctm2015_gradients.f90.html","title":"lctm2015_gradients.f90 – FEST-3D"},{"text":"Setup and nullify pointers for k-kL model to the main array which stores gradient of all variables This file depends on sourcefile~~kkl_gradients.f90~~EfferentGraph sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~kkl_gradients.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~kkl_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~kkl_gradients.f90~~AfferentGraph sourcefile~kkl_gradients.f90 kkl_gradients.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~kkl_gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules kkl_gradients Source Code kkl_gradients.f90 Source Code !< Setup and nullify pointers for k-kL model to the main array which stores gradient of all variables module kkl_gradients !< Setup and nullify pointers for k-kL model to the main array which stores gradient of all variables !--------------------------------------------------------------- ! 1705009  Jatinder Pal Singh Sandhu !          - first build ! aim : link kkl pointer to allocated memory for gradients !--------------------------------------------------------------- #include \"../debug.h\" use global_vars , only : process_id use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : gradtk_x use global_vars , only : gradtk_y use global_vars , only : gradtk_z use global_vars , only : gradtkl_x use global_vars , only : gradtkl_y use global_vars , only : gradtkl_z use utils , only : dmsg implicit none private public :: setup_kkl_grad public :: destroy_kkl_grad contains subroutine setup_kkl_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_kkl_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtkl_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtkl_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtkl_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) end subroutine setup_kkl_grad subroutine destroy_kkl_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_kkl_grad' ) nullify ( gradtk_x ) nullify ( gradtkl_x ) nullify ( gradtk_y ) nullify ( gradtkl_y ) nullify ( gradtk_z ) nullify ( gradtkl_z ) end subroutine destroy_kkl_grad end module kkl_gradients","tags":"","loc":"sourcefile/kkl_gradients.f90.html","title":"kkl_gradients.f90 – FEST-3D"},{"text":"Setup and nullify pointers for SA model to the main array which stores gradient of all variables This file depends on sourcefile~~sa_gradients.f90~~EfferentGraph sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~utils.f90 utils.f90 sourcefile~sa_gradients.f90->sourcefile~utils.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~sa_gradients.f90->sourcefile~global_vars.f90 sourcefile~utils.f90->sourcefile~global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one sourcefile~~sa_gradients.f90~~AfferentGraph sourcefile~sa_gradients.f90 sa_gradients.f90 sourcefile~gradients.f90 gradients.f90 sourcefile~gradients.f90->sourcefile~sa_gradients.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~gradients.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~gradients.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules sa_gradients Source Code sa_gradients.f90 Source Code !< Setup and nullify pointers for SA model to the main array which stores gradient of all variables module sa_gradients !< Setup and nullify pointers for SA model to the main array which stores gradient of all variables !--------------------------------------------------------------- ! 1705009  Jatinder Pal Singh Sandhu !          - first build ! aim : link sst pointer to allocated memory for gradients !--------------------------------------------------------------- #include \"../debug.h\" use global_vars , only : process_id use global_vars , only : imx use global_vars , only : jmx use global_vars , only : kmx use global_vars , only : gradqp_x use global_vars , only : gradqp_y use global_vars , only : gradqp_z use global_vars , only : gradtv_x use global_vars , only : gradtv_y use global_vars , only : gradtv_z use utils , only : dmsg implicit none private public :: setup_sa_grad public :: destroy_sa_grad contains subroutine setup_sa_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( \"setup_sa_grad\" ) gradtv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) end subroutine setup_sa_grad subroutine destroy_sa_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( \"destroy_sa_grad\" ) nullify ( gradtv_x ) nullify ( gradtv_y ) nullify ( gradtv_z ) end subroutine destroy_sa_grad end module sa_gradients","tags":"","loc":"sourcefile/sa_gradients.f90.html","title":"sa_gradients.f90 – FEST-3D"},{"text":"Common variables (can be re-assigned) used by other modules This file depends on sourcefile~~global_vars.f90~~EfferentGraph sourcefile~global_vars.f90 global_vars.f90 sourcefile~global.f90 global.f90 sourcefile~global_vars.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Files dependent on this one global_vars.f90 w ausm.f90 w w ausmP.f90 w w ausmUP.f90 w w bc.f90 w w bc_primitive.f90 w w boundary_state_reconstruction.f90 w w CC.f90 w w check_outout_control.f90 w w convergence.f90 w w copy_bc.f90 w w create_and_erase.f90 w w dump_solution.f90 w w FT_bc.f90 w w geometry.f90 w w ghost_gradient.f90 w w gradients.f90 w w grid.f90 w w interface1.f90 w w kkl_gradients.f90 w w laminar_gradients.f90 w w layout.f90 w w lctm2015_gradients.f90 w w ldfss0.f90 w w lusgs.f90 w w main.f90 w w mapping.f90 w w muscl.f90 w w plusgs.f90 w w ppm.f90 w w read.f90 w w read_bc.f90 w w read_output.f90 w w read_output_tec.f90 w w read_output_vtk.f90 w w resnorm.f90 w w sa_gradients.f90 w w slau.f90 w w solver.f90 w w source.f90 w w sst_gradients.f90 w w state.f90 w w summon_grad_evaluation.f90 w w time.f90 w w update.f90 w w utils.f90 w w van_leer.f90 w w viscosity.f90 w w viscous2.f90 w w wall.f90 w w wall_dist.f90 w w weno.f90 w w weno_NM.f90 w w write_output.f90 w w write_output_tec.f90 w w write_output_tec_node.f90 w w write_output_vtk.f90 w Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_vars Source Code global_vars.f90 Source Code !< Common variables (can be re-assigned) used by other modules module global_vars !< Contains all the public/global variables used by more than one module !---------------------------------------------- use global , only : INTERPOLANT_NAME_LENGTH use global , only : FORMAT_LENGTH use global , only : SCHEME_NAME_LENGTH use global , only : FILE_NAME_LENGTH use global , only : STATE_NAME_LENGTH use global , only : FLOW_TYPE_LENGTH use global , only : TOLERANCE_LENGTH implicit none public ! Parallel processig variables integer :: total_process !< Total number of process to be used for computation integer :: total_entries !< Total enteries in layout.md for each processor integer :: process_id !< Id no. of each processor assinged by MPICH library integer :: imin_id !< Boundary condition number/ID at imin for particulat processor integer :: imax_id !< Boundary condition number/ID at imax for particulat processor integer :: jmin_id !< Boundary condition number/ID at jmin for particulat processor integer :: jmax_id !< Boundary condition number/ID at jmax for particulat processor integer :: kmin_id !< Boundary condition number/ID at kmin for particulat processor integer :: kmax_id !< Boundary condition number/ID at kmax for particulat processor integer :: layers = 3 !< Number of ghost cell layers to transfer with mpi ! Time controls integer :: min_iter = 1 !< Minimum iteration value, starting iteration value integer :: max_iters = 1 !< Maximum iteration value, stop after these many iteration integer :: start_from = 0 !< Number of the folder (in time_directories) to load stored state from to restart computation integer :: checkpoint_iter = 0 !< Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer :: checkpoint_iter_count = 0 !< Counter of folder number to write in time_directories/ integer :: current_iter = 0 !< Current iteration number !write controls integer :: r_count = 0 !< Number of variable to read from the restart file integer :: w_count = 0 !< Number of variable to write in the output file integer :: res_write_interval !< Write resnorm after every \"res_write_interval\" iteration integer :: purge_write !< Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer :: last_iter = 0 !< Last iteration that is stored in the restart file integer :: write_percision = 6 !< Number of place after decimal. Only used for resnorm file character ( len = FORMAT_LENGTH ) :: write_data_format !< write data type. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: write_file_format !< Write file type. Either vtk or tecplot character ( len = FORMAT_LENGTH ) :: read_data_format = 'ASCII' !< Read data type in file. Either ASCII or BINARY character ( len = FORMAT_LENGTH ) :: read_file_format = \"vtk\" !< Read file type. Either vtk or tecplot character ( len = FILE_NAME_LENGTH ) :: outfile !< String to store name of output file character ( len = FILE_NAME_LENGTH ) :: infile !< String to store the name of restart/load file character ( len = FILE_NAME_LENGTH ) :: restartfile !< Sting to store the name of restart log file character ( len = STATE_NAME_LENGTH ), dimension (:), allocatable :: r_list !< Read variable list character ( len = STATE_NAME_LENGTH ), dimension (:), allocatable :: w_list !< Write variable list character ( len = FLOW_TYPE_LENGTH ) :: previous_flow_type = \"none\" !< Type of flow:inviscid, laminar, etc, stored in the load file ! solver specific real :: CFL !< Courant–Friedrichs–Lewy (CFL) (Read from input) real :: tolerance !< Minimum value of resnorm after which simulation stop character ( len = TOLERANCE_LENGTH ) :: tolerance_type = \"abs\" !< Type of tolerance to check:absolute or relative integer :: want_to_stop = 0 !< 0: continue the solver; 1=Stop the solver logical :: Halt = . FALSE . !< Logical value used to stop the solver in main program file. !solver time secific character :: time_stepping_method !< Either local time stepping or global time stepping character ( len = INTERPOLANT_NAME_LENGTH ) :: time_step_accuracy !< Type of time_integration scheme: RK4, none(firt order explicit) implicit, real :: global_time_step !< Value of global time step to march the solution with real , dimension (:, :, :), allocatable :: delta_t !< Local time increment value at each cell center real :: sim_clock !< Simluation clock time !scheme character ( len = SCHEME_NAME_LENGTH ) :: scheme_name !< Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character ( len = INTERPOLANT_NAME_LENGTH ) :: interpolant !< Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM !solution specific (used for Ranga_kutta_4th order) real , dimension (:, :, :, :), allocatable :: qp_n real , dimension (:, :, :, :), allocatable :: dEdx_1 real , dimension (:, :, :, :), allocatable :: dEdx_2 real , dimension (:, :, :, :), allocatable :: dEdx_3 ! state variables viscous integer :: n_var = 5 !< Number of variable to solve for real , dimension (:, :, :, :), allocatable , target :: qp !< Store primitive variable at cell center real , dimension (:) , allocatable , target :: qp_inf !< Store primitive variable at infinity real , dimension (:, :, :) , pointer :: density !< Rho pointer, point to slice of qp (:,:,:,1) real , dimension (:, :, :) , pointer :: x_speed !< U pointer, point to slice of qp (:,:,:,2) real , dimension (:, :, :) , pointer :: y_speed !< V pointer, point to slice of qp (:,:,:,3) real , dimension (:, :, :) , pointer :: z_speed !< W pointer, point to slice of qp (:,:,:,4) real , dimension (:, :, :) , pointer :: pressure !< P pointer, point to slice of qp (:,:,:,5) real , pointer :: density_inf !< Rho pointer, point to slice of qp_inf (1) real , pointer :: x_speed_inf !< U pointer, point to slice of qp_inf (2) real , pointer :: y_speed_inf !< V pointer, point to slice of qp_inf (3) real , pointer :: z_speed_inf !< W pointer, point to slice of qp_inf (4) real , pointer :: pressure_inf !< P pointer, point to slice of qp_inf (5) real :: MInf !< Free-stream Mach number real , dimension (:, :, :), allocatable , target :: intermittency !< Intermiitency pointer real , dimension (:, :, :), allocatable , target :: ExtraVar1 !< Extravar1 used only for debuging or store some sepcial kind of compination of other varialbes real , dimension (:, :, :), allocatable , target :: ExtraVar2 !< Extravar2 used only for debuging or store some sepcial kind of compination of other varialbes real , dimension (:, :, :), allocatable , target :: ExtraVar3 !< Extravar3 used only for debuging or store some sepcial kind of compination of other varialbes real , dimension (:, :, :), allocatable , target :: ExtraVar4 !< Extravar4 used only for debuging or store some sepcial kind of compination of other varialbes real , dimension (:, :, :), allocatable , target :: ExtraVar5 !< Extravar5 used only for debuging or store some sepcial kind of compination of other varialbes ! Freestram variable used to read file before inf pointer are linked and allocated real :: free_stream_density !< Read freestream Density from control file real :: free_stream_x_speed !< Read freestream U from control file real :: free_stream_y_speed !< Read freestream V from control file real :: free_stream_z_speed !< Read freestream W from control file real :: free_stream_pressure !< Read freestream Pressure from control file real :: free_stream_tk !< Read freestream turbulent kinetic energy rate from control file real :: free_stream_tw !< Read freestream turbulent dissipation rate from control file real :: free_stream_te !< Read freestream turbulent dissipation from control file real :: free_stream_tv !< Read freestream turbulent viscosity(SA) from control file real :: free_stream_tkl !< Read freestream kL variable from control file real :: free_stream_tu !< Read freestream turbulence intensity (percentage) from control file real :: free_stream_tgm !< Read freestream turbulence intermittency from control file real :: vel_mag !< Calulated freestream Velocity Magnitude from control file real :: Reynolds_number !< Calculated free_stream Reynolds_number real :: mu_ratio_inf !< Read freestream turbulent viscosity to molecular viscosity ratio real :: Turb_intensity_inf !< Calculate free_stream turbulence intensity real , dimension (:, :, :), allocatable :: dist !< Store wall distance for each cell center real , dimension (:, :, :), allocatable :: CCnormalX !< Cell-Center normal nx with respect to wall; used for transition model (pressure gradient calcualtion) real , dimension (:, :, :), allocatable :: CCnormalY !< Cell-Center normal ny with respect to wall; used for transiton model (pressure gradient calculation) real , dimension (:, :, :), allocatable :: CCnormalZ !< Cell-Center normal nz with respect to wall; used for transiton model (pressure gradient calculation) real , dimension (:, :, :), allocatable :: CCVn !< Store value at Cell-Center of dot product between velocity vector and cell-center normal. {vec(Velocity).normal} real , dimension (:, :, :), allocatable :: DCCVnX !< Store Derivative of Cell-Center CCVn with respect to x real , dimension (:, :, :), allocatable :: DCCVnY !< Store Derivative of Cell-Center CCVn with respect to y real , dimension (:, :, :), allocatable :: DCCVnZ !< Store Derivative of Cell-Center CCVn with respect to z ! state variable turbulent integer :: sst_n_var = 2 integer :: sst_n_grad = 2 !  real, dimension(:, :, :, :), allocatable, target  :: tqp       !< turbulent primitive !  real, dimension(:)         , allocatable, target  :: tqp_inf   !< turbulent primitive at inf real , dimension (:, :, :) , pointer :: tk !< TKE/mass real , dimension (:, :, :) , pointer :: tw !< Omega real , dimension (:, :, :) , pointer :: te !< Dissipation real , dimension (:, :, :) , pointer :: tv !< SA visocity real , dimension (:, :, :) , pointer :: tkl !< KL K-KL method real , dimension (:, :, :) , pointer :: tgm !< Intermittency of LCTM2015 real , pointer :: tk_inf !< TKE/mass at inf real , pointer :: tw_inf !< Omega at inf real , pointer :: te_inf !< Dissipation at inf real , pointer :: tv_inf !< SA viscosity at inf real , pointer :: tkl_inf !< kl at inf real , pointer :: tgm_inf !< Intermittency at inf ! residue variables real , dimension (:, :, :, :) , pointer :: F_p !< Flux pointer for face in the I direction real , dimension (:, :, :, :) , pointer :: G_p !< Flux pointer for face in the G direction real , dimension (:, :, :, :) , pointer :: H_p !< Flux pointer for face in the K direction real , dimension (:, :, :, :) , pointer :: residue !< Store residue at each cell-center real , dimension (:, :, :) , pointer :: mass_residue !< Store continuity equation residual at each cell-center real , dimension (:, :, :) , pointer :: x_mom_residue !< Store x-momentum equation residual at each cell-center real , dimension (:, :, :) , pointer :: y_mom_residue !< Store y-momentum equation residual at each cell-center real , dimension (:, :, :) , pointer :: z_mom_residue !< Store z-momentum equation residual at each cell-center real , dimension (:, :, :) , pointer :: energy_residue !< Store energy equation residual at each cell-center real , dimension (:, :, :) , pointer :: TKE_residue !< Store TKE equation residual at each cell-center real , dimension (:, :, :) , pointer :: omega_residue !< Store Omega equation residual at each cell-center real , dimension (:, :, :) , pointer :: KL_residue !< Store KL equation residual at each cell-center real , dimension (:, :, :) , pointer :: dissipation_residue !< Store Disspaiton equation residual at each cell-center real , dimension (:, :, :) , pointer :: tv_residue !< Store nut equation(SA model) residual at each cell-center ! thermal properties real :: gm !< Gamma commonly 1.4 real :: R_gas !< Univarsal gas constant ! Transport properties real :: mu_ref !< Molecular viscoity reference character ( len = FILE_NAME_LENGTH ) :: mu_variation !< Type of viscosity variaiton: Sutherland or constant ! sutherland law variable real :: T_ref !< Reference Temperature of flow for viscosity calculation real :: Sutherland_temp !< Sutherland temperature for viscosity calculation ! nondimensional numbers real :: Pr = 0.7 !< prandtl number real :: tPr = 0.9 !< turbulent Prandtl number ! switches logical :: supersonic_flag !< Switch for boundary condition. No longer in use integer :: ilimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer :: jlimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer :: klimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer :: itlimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer :: jtlimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer :: ktlimiter_switch !< Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer :: iPB_switch !< Turn on/off application of pressure based switching for higher order methods for I direction faces. integer :: jPB_switch !< Turn on/off application of pressure based switching for higher order methods for J direction faces. integer :: kPB_switch !< Turn on/off application of pressure based switching for higher order methods for K direction faces. character ( len = 8 ) :: turbulence !< Store Turbulence model name character ( len = 8 ) :: transition !< Store Transition model name real , dimension (:, :, :), allocatable , target :: mu !< Cell-center molecular viscosity real , dimension (:, :, :), allocatable , target :: mu_t !< Cell-center turbulent viscosity real , dimension (:, :, :) , pointer :: sst_mu !< Pointer to  turbulent viscosity for SST turbulence model real , dimension (:, :, :) , pointer :: kkl_mu !< Pointer to  turbulent viscosity for KKL turbulence model real , dimension (:, :, :) , pointer :: sa_mu !< Pointer to  turbulent viscosity for SA turbulence model !residual specific character ( len = STATE_NAME_LENGTH ), dimension (:), allocatable :: Res_list integer :: Res_count !< No of variable to save integer :: Res_itr = 3 !< Iteration to save real , dimension (:), allocatable :: Res_abs !< Absolute value real , dimension (:), allocatable :: Res_rel !< Relative value real , dimension (:), allocatable :: Res_save !< Saved iteration for relative real , dimension (:), allocatable :: Res_scale !< Scaling factor real , pointer :: resnorm !<             Residual normalized real , pointer :: vis_resnorm !<  {rho+V+P} equation residual normalized real , pointer :: turb_resnorm !<  Turbulent residual normalized real , pointer :: cont_resnorm !<  Mass residual normalized real , pointer :: x_mom_resnorm !<  X momentum residual normalized real , pointer :: y_mom_resnorm !<  Y momentum residual normalized real , pointer :: z_mom_resnorm !<  Z momentum residual normalized real , pointer :: energy_resnorm !<  Energy residual normalized real , pointer :: TKE_resnorm !<  TKE residual normalized real , pointer :: omega_resnorm !<  Omega residual normalized real , pointer :: resnorm_d1 !<  Residual normalized/same at iter 1 real , pointer :: vis_resnorm_d1 !<  {rho+V+P}  residual normalized/same at iter 1 real , pointer :: turb_resnorm_d1 !<  Turbulent residual normalized/same at iter 1 real , pointer :: cont_resnorm_d1 !<  Mass residual normalized/same at iter 1 real , pointer :: x_mom_resnorm_d1 !<  X momentum residual normalized/same at iter 1 real , pointer :: y_mom_resnorm_d1 !<  Y momentum residual normalized/same at iter 1 real , pointer :: z_mom_resnorm_d1 !<  Z momentum residual normalized/same at iter 1 real , pointer :: energy_resnorm_d1 !<  Energy residual normalized/same at iter 1 real , pointer :: TKE_resnorm_d1 !<  TKE residual normalized/same at iter 1 real , pointer :: omega_resnorm_d1 !<  Omega residual normalized/same at iter 1 real :: resnorm_0 !<  Residual normalized at iter 1 real :: vis_resnorm_0 !<  {rho+V+P}  residual normalized at iter 1 real :: turb_resnorm_0 !<  Turbulent residual normalized at iter 1 real :: cont_resnorm_0 !<  Mass residual normalized at iter 1 real :: x_mom_resnorm_0 !<  X momentum residual normalized at iter 1 real :: y_mom_resnorm_0 !<  Y momentum residual normalized at iter 1 real :: z_mom_resnorm_0 !<  Z momentum residual normalized at iter 1 real :: energy_resnorm_0 !<  Energy residual normalized at iter 1 real :: TKE_resnorm_0 !<  TKE residual normalized at iter 1 real :: omega_resnorm_0 !<  Omega residual normalized at iter 1 !used for MPI manipulation real :: resnorm_0s !<  Residual normalized at iter 1 real :: vis_resnorm_0s !<  {rho+V+P}  residual normalized at iter 1 real :: turb_resnorm_0s !<  Turbulent residual normalized at iter 1 real :: cont_resnorm_0s !<  Mass residual normalized at iter 1 real :: x_mom_resnorm_0s !<  X momentum residual normalized at iter 1 real :: y_mom_resnorm_0s !<  Y momentum residual normalized at iter 1 real :: z_mom_resnorm_0s !<  Z momentum residual normalized at iter 1 real :: energy_resnorm_0s !<  Energy residual normalized at iter 1 real :: TKE_resnorm_0s !<  TKE residual normalized at iter 1 real :: omega_resnorm_0s !<  Omega residual normalized at iter 1 ! grid variables integer :: imx !< Maximum number of grid points in the I direction integer :: jmx !< Maximum number of grid points in the K direction integer :: kmx !< Maximum number of grid points in the K direction integer :: imn , jmn , kmn real , dimension (:, :, :), allocatable :: grid_x !< X corrdinate of the grid point real , dimension (:, :, :), allocatable :: grid_y !< Y corrdinate of the grid point real , dimension (:, :, :), allocatable :: grid_z !< Z corrdinate of the grid point ! geometry variables real , dimension (:, :, :,:), allocatable , target :: xn !< Store unit face normal vector for all I faces real , dimension (:, :, :,:), allocatable , target :: yn !< Store unit face normal vector for all J faces real , dimension (:, :, :,:), allocatable , target :: zn !< Store unit face normal vector for all K faces real , dimension (:, :, :) , pointer :: xnx !< Pointer to x component of face unit normal of I faces real , dimension (:, :, :) , pointer :: xny !< Pointer to y component of face unit normal of I faces real , dimension (:, :, :) , pointer :: xnz !< Pointer to z component of face unit normal of I faces real , dimension (:, :, :) , pointer :: ynx !< Pointer to x component of face unit normal of J faces real , dimension (:, :, :) , pointer :: yny !< Pointer to y component of face unit normal of J faces real , dimension (:, :, :) , pointer :: ynz !< Pointer to z component of face unit normal of J faces real , dimension (:, :, :) , pointer :: znx !< Pointer to x component of face unit normal of K faces real , dimension (:, :, :) , pointer :: zny !< Pointer to y component of face unit normal of K faces real , dimension (:, :, :) , pointer :: znz !< Pointer to z component of face unit normal of K faces real , dimension (:, :, :), allocatable , target :: xA !< Store magnitude of face area vector of I direction faces real , dimension (:, :, :), allocatable , target :: yA !< Store magnitude of face area vector of J direction faces real , dimension (:, :, :), allocatable , target :: zA !< Store magnitude of face area vector of K direction faces real , dimension (:, :, :), allocatable , target :: volume !< Store cell volume real , dimension (:, :, :), allocatable , target :: left_ghost_centroid !< Store the cell center of the ghost cell on 1 face real , dimension (:, :, :), allocatable , target :: right_ghost_centroid !< Store the cell center of the ghost cell on 2 face real , dimension (:, :, :), allocatable , target :: front_ghost_centroid !< Store the cell center of the ghost cell on 3 face real , dimension (:, :, :), allocatable , target :: back_ghost_centroid !< Store the cell center of the ghost cell on 4 face real , dimension (:, :, :), allocatable , target :: top_ghost_centroid !< Store the cell center of the ghost cell on 5 face real , dimension (:, :, :), allocatable , target :: bottom_ghost_centroid !< Store the cell center of the ghost cell on 6 face ! gradients integer :: n_grad = 4 !< Number of variable to store gradient for real , dimension (:, :, :, :), allocatable , target :: gradqp_x !< Store gradient of n_grad variables with respect to direction x real , dimension (:, :, :, :), allocatable , target :: gradqp_y !< Store gradient of n_grad variables with respect to direction y real , dimension (:, :, :, :), allocatable , target :: gradqp_z !< Store gradient of n_grad variables with respect to direction z real , dimension (:, :, :), pointer :: gradu_x !< Gradient of variable U with respect to direction x real , dimension (:, :, :), pointer :: gradu_y !< Gradient of variable U with respect to direction y real , dimension (:, :, :), pointer :: gradu_z !< Gradient of variable U with respect to direction z real , dimension (:, :, :), pointer :: gradv_x !< Gradient of variable V with respect to direction x real , dimension (:, :, :), pointer :: gradv_y !< Gradient of variable V with respect to direction y real , dimension (:, :, :), pointer :: gradv_z !< Gradient of variable V with respect to direction z real , dimension (:, :, :), pointer :: gradw_x !< Gradient of variable W with respect to direction x real , dimension (:, :, :), pointer :: gradw_y !< Gradient of variable W with respect to direction y real , dimension (:, :, :), pointer :: gradw_z !< Gradient of variable W with respect to direction z real , dimension (:, :, :), pointer :: gradT_x !< Gradient of variable Temperature with respect to direction x real , dimension (:, :, :), pointer :: gradT_y !< Gradient of variable Temperature with respect to direction y real , dimension (:, :, :), pointer :: gradT_z !< Gradient of variable Temperature with respect to direction z real , dimension (:, :, :), pointer :: gradtk_x !< Gradient of variable turbulent kinetic energy with respect to direction x real , dimension (:, :, :), pointer :: gradtk_y !< Gradient of variable turbulent kinetic energy with respect to direction y real , dimension (:, :, :), pointer :: gradtk_z !< Gradient of variable turbulent kinetic energy with respect to direction z real , dimension (:, :, :), pointer :: gradtw_x !< Gradient of variable dissipation rate with respect to direction x real , dimension (:, :, :), pointer :: gradtw_y !< Gradient of variable dissipation rate with respect to direction y real , dimension (:, :, :), pointer :: gradtw_z !< Gradient of variable dissipation rate with respect to direction z real , dimension (:, :, :), pointer :: gradtkl_x !< Gradient of variable kL with respect to direction x real , dimension (:, :, :), pointer :: gradtkl_y !< Gradient of variable kL with respect to direction y real , dimension (:, :, :), pointer :: gradtkl_z !< Gradient of variable kL with respect to direction z real , dimension (:, :, :), pointer :: gradte_x !< Gradient of variable turbulent energy dissiaption with respect to direction x real , dimension (:, :, :), pointer :: gradte_y !< Gradient of variable turbulent energy dissiaption with respect to direction y real , dimension (:, :, :), pointer :: gradte_z !< Gradient of variable turbulent energy dissiaption with respect to direction z real , dimension (:, :, :), pointer :: gradtv_x !< Gradient of variable turbulenct visocity(SA mode) with respect to direction x real , dimension (:, :, :), pointer :: gradtv_y !< Gradient of variable turbulenct visocity(SA mode) with respect to direction y real , dimension (:, :, :), pointer :: gradtv_z !< Gradient of variable turbulenct visocity(SA mode) with respect to direction z real , dimension (:, :, :), pointer :: gradtgm_x !< Gradient of variable intermittency with respect to direction x real , dimension (:, :, :), pointer :: gradtgm_y !< Gradient of variable intermittency with respect to direction y real , dimension (:, :, :), pointer :: gradtgm_z !< Gradient of variable intermittency with respect to direction z ! higher order boundary condtioion integer :: accur = 1 !< Switch for higher order boundary condition character ( len = 4 ), dimension ( 6 ) :: face_names !< Store name of all six boundary faces integer , dimension ( 6 ) :: id !< Store the boundary condition ID of all six faces real :: c1 !< First coefficient user for higher order boundary condition real :: c2 !< Second coefficient user for higher order boundary condition real :: c3 !< Third coefficient user for higher order boundary condition ! store fix values for 6 faces of domain real , dimension ( 6 ) :: fixed_density = 0. !< Density value to fix at particular boundary real , dimension ( 6 ) :: fixed_pressure = 0. !< Pressure value to fix at particular boundary real , dimension ( 6 ) :: fixed_x_speed = 0. !< X component of velocity to fix at particular boundary condition real , dimension ( 6 ) :: fixed_y_speed = 0. !< Y component of velocity to fix at particular boundary condition real , dimension ( 6 ) :: fixed_z_speed = 0. !< Z component of velocity to fix at particular boundary condition real , dimension ( 6 ) :: fixed_tk = 0. !< Turbulent kinetic energy value to fix at particular boundary condition real , dimension ( 6 ) :: fixed_tw = 0. !< Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real , dimension ( 6 ) :: fixed_te = 0. !< Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real , dimension ( 6 ) :: fixed_tv = 0. !< Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real , dimension ( 6 ) :: fixed_tkl = 0. !< (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real , dimension ( 6 ) :: fixed_tgm = 0. !<  Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real , dimension ( 6 ) :: fixed_wall_temperature = 0. !<  Fixed wall temperature value to apply at isothermal wall boundary condition. real , dimension ( 6 ) :: fixed_Tpressure = 0. !<  Fixed Total Pressure value to apply at particular boundary condition real , dimension ( 6 ) :: fixed_Ttemperature = 0. !<  Fixed Total Temperature value to apply at particular boundary condition ! variable for post_processing integer :: N_blocks !< Total number of blocks integer :: I_blocks !< Total number of blocks  in I direction integer :: J_blocks !< Total number of blocks  in J direction integer :: K_blocks !< Total number of blocks  in K direction integer , dimension (:), allocatable :: imin integer , dimension (:), allocatable :: imax integer , dimension (:), allocatable :: jmin integer , dimension (:), allocatable :: jmax integer , dimension (:), allocatable :: kmin integer , dimension (:), allocatable :: kmax !interface mapping integer , dimension ( 6 ) :: ilo , ihi !< Store the lower and upper bound of the indecies of I loop for the interface mapping integer , dimension ( 6 ) :: jlo , jhi !< Store the lower and upper bound of the indecies of J loop for the interface mapping integer , dimension ( 6 ) :: klo , khi !< Store the lower and upper bound of the indecies of K loop for the interface mapping integer , dimension ( 6 ) :: dir_switch = 0 !< Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer , dimension ( 6 ) :: otherface !< Store the face number with which the current interface is connected. !zero flux faces integer , dimension (:), allocatable :: make_F_flux_zero !< Store zero to boundary face, which has wall ID, to make F flux zero integer , dimension (:), allocatable :: make_G_flux_zero !< Store zero to boundary face, which has wall ID, to make G flux zero integer , dimension (:), allocatable :: make_H_flux_zero !< Store zero to boundary face, which has wall ID, to make H flux zero !periodic boundary condition integer , dimension ( 6 ) :: PbcId = - 1 !< Block ID for Periodic boundary condition end module global_vars","tags":"","loc":"sourcefile/global_vars.f90.html","title":"global_vars.f90 – FEST-3D"},{"text":"Common constant/parameters variables used by most other modules Files dependent on this one sourcefile~~global.f90~~AfferentGraph sourcefile~global.f90 global.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~global.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~global.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~global.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~viscous2.f90->sourcefile~global.f90 sourcefile~global_vars.f90 global_vars.f90 sourcefile~global_vars.f90->sourcefile~global.f90 sourcefile~fopen.f90 fopen.f90 sourcefile~fopen.f90->sourcefile~global.f90 sourcefile~layout.f90 layout.f90 sourcefile~layout.f90->sourcefile~global.f90 sourcefile~state.f90 state.f90 sourcefile~state.f90->sourcefile~global.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~global.f90 sourcefile~str_case.f90 str_case.f90 sourcefile~str_case.f90->sourcefile~global.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~global.f90 sourcefile~wall_dist.f90 wall_dist.f90 sourcefile~wall_dist.f90->sourcefile~global.f90 sourcefile~mapping.f90 mapping.f90 sourcefile~mapping.f90->sourcefile~global.f90 sourcefile~resnorm.f90 resnorm.f90 sourcefile~resnorm.f90->sourcefile~global.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output_tec.f90->sourcefile~global.f90 sourcefile~read_bc.f90 read_bc.f90 sourcefile~read_bc.f90->sourcefile~global.f90 sourcefile~fclose.f90 fclose.f90 sourcefile~fclose.f90->sourcefile~global.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~dump_solution.f90->sourcefile~global.f90 sourcefile~read_output_vtk.f90 read_output_vtk.f90 sourcefile~read_output_vtk.f90->sourcefile~global.f90 sourcefile~read.f90 read.f90 sourcefile~read.f90->sourcefile~global.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~global.f90 sourcefile~wall.f90 wall.f90 sourcefile~wall.f90->sourcefile~global.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~global.f90 sourcefile~grid.f90 grid.f90 sourcefile~grid.f90->sourcefile~global.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global Source Code global.f90 Source Code !< Common constant/parameters variables used by most other modules module global !< Common constant/parameters variables used by most other modules implicit none ! String buffer lengths integer , parameter :: FILE_NAME_LENGTH = 64 !< Length of string used for defining any filename integer , parameter :: SCHEME_NAME_LENGTH = 16 !< Length of string used for storing Scheme integer , parameter :: INTERPOLANT_NAME_LENGTH = 10 !< Length of string used for storing  higher order method integer , parameter :: DESCRIPTION_STRING_LENGTH = 64 !< Length of string used for description in message call integer , parameter :: STRING_BUFFER_LENGTH = 128 !< User to define a string of medium length integer , parameter :: ERROR_MESSAGE_LENGTH = 256 !< Length of string used for passing error message during call integer , parameter :: LONG_BUFFER_LENGTH = 256 !<Used to define a string of large size integer , parameter :: FORMAT_LENGTH = 16 !< Length of string used for file format: tecplot or vtk integer , parameter :: STATE_NAME_LENGTH = 64 !< Length of string used in array user for sotring and reading Output/input variable list integer , parameter :: FLOW_TYPE_LENGTH = 64 !< Length of string used for storing type of flow: inviscid, laminar, etc. integer , parameter :: TOLERANCE_LENGTH = 32 !< Length of string used for resnorm types: abs or relative ! File unit numbers integer , parameter :: CONFIG_FILE_UNIT = 1 !< Handler unit for config.md file integer , parameter :: GRID_FILE_UNIT = 2 !< Handler for input Gridfile; eg: grid_00.txt integer , parameter :: BOUNDARY_CONDITIONS_FILE_UNIT = 3 !< Handler for Boundary condition file; eg: bc_00.md integer , parameter :: STATE_FILE_UNIT = 10 !< __Handler no longer in use__ integer , parameter :: IN_FILE_UNIT = 19 !< Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer , parameter :: OUT_FILE_UNIT = 20 !< Handler for output file for each block integer , parameter :: RESNORM_FILE_UNIT = 21 !< Handler for Residual output file. filename: time_directories/aux/resnorm integer , parameter :: TEMP_NODE_FILE_UNIT = 30 !< __Handler no longer in use__ integer , parameter :: LAYOUT_FILE_UNIT = 31 !< Handler for input multi-block layout and boundary condition file. integer , parameter :: NODESURF_FILE_UNIT = 32 !< Handler for storing node point on the wall integer , parameter :: WALL_DIST_FILE_UNIT = 33 !< __Handler no longer in use__ integer , parameter :: RES_CONTROL_FILE_UNIT = 34 !< Handler for residual control file. filename: system/res_control.md integer , parameter :: INFO_FILE_UNIT = 35 !< __Handler NO longer in user__; info is handled using print*, command integer , parameter :: CONTROL_FILE_UNIT = 36 !< Handler for input system/control.md file integer , parameter :: SCHEME_FILE_UNIT = 37 !< Handler for input system/fvscheme.md file integer , parameter :: FLOW_FILE_UNIT = 38 !< Handler for input system/flow.md  file integer , parameter :: RESTART_FILE_UNIT = 39 !< Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer , parameter :: OUTIN_FILE_UNIT = 40 !< Handler for file which controls what variables will be read or stored. system/output_control.md integer , parameter :: MAP_FILE_UNIT = 41 !< Handler for input multi-block mapping file with index and direction. integer , parameter :: PERIODIC_FILE_UNIT = 42 !< Handler for input periodic boundary condition file ! stop file integer , parameter :: STOP_FILE_UNIT = 41 !< Handler for Stop file !Fixed file names character ( len =* ), Parameter :: control_file = \"system/control.md\" !< FILENAME string: Control file character ( len =* ), Parameter :: scheme_file = \"system/fvscheme.md\" !< FILENAME string: Scheme file character ( len =* ), Parameter :: flow_file = \"system/flow.md\" !< FILENAME string: FLow condition file character ( len =* ), Parameter :: outin_file = \"system/output_control.md\" !< FILENAME string: Ouput/Input variable control file character ( len =* ), parameter :: layout_file = 'system/mesh/layout/layout.md' !< FILENAME string: Multiple layout/boundary condition file character ( len =* ), Parameter :: nodefile_temp = \"scratch.dat\" !< FILENAME string: Temperory file for nodesurface points character ( len =* ), Parameter :: surface_node_points = 'time_directories/aux/surfnode.dat' !< FILENAME string: Wall surface node points character ( len =* ), Parameter :: wall_dist_file = 'distance.vtk' !< FILENAME string: Wall distance for debug-- not in use anymore character ( len =* ), parameter :: res_control_file = 'system/res_control.md' !< FILENAME string: Residual write control file character ( len =* ), parameter :: resnorm_file = 'time_directories/aux/resnorm' !< FILENAME string: Residual output file character ( len =* ), parameter :: stop_file = 'system/stopfile' !< FILENAME string: Halt/stop file character ( len =* ), parameter :: mapfile = 'system/mesh/layout/mapping.txt' !< FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character ( len =* ), parameter :: periodicfile = 'system/mesh/layout/periodic.txt' !< FILENAME string: Multiblock periodic boundary condition detials end module global","tags":"","loc":"sourcefile/global.f90.html","title":"global.f90 – FEST-3D"},{"text":"Declare all the constants used by SA turbulence model Files dependent on this one sourcefile~~global_sa.f90~~AfferentGraph sourcefile~global_sa.f90 global_sa.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_sa.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_sa.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~plusgs.f90->sourcefile~global_sa.f90 sourcefile~viscous2.f90->sourcefile~global_sa.f90 sourcefile~source.f90->sourcefile~global_sa.f90 sourcefile~lusgs.f90->sourcefile~global_sa.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileglobal_saf90AfferentGraph = svgPanZoom('#sourcefileglobal_saf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_sa Source Code global_sa.f90 Source Code !< Declare all the constants used by SA turbulence model module global_sa !< Declare all the constants used by SA turbulence model real , parameter :: cb1 = 0.1355 real , parameter :: cb2 = 0.6220 real , parameter :: cw2 = 0.3 real , parameter :: cw3 = 2.0 real , parameter :: cv1 = 7.1 real , parameter :: ct3 = 1.2 real , parameter :: ct4 = 0.5 real , parameter :: sigma_sa = 2. / 3. real , parameter :: kappa_sa = 0.41 real , parameter :: cw1 = ( cb1 / ( kappa_sa ** 2 )) + (( 1 + cb2 ) / sigma_sa ) real , parameter :: cv1_3 = cv1 ** 3 real , parameter :: cw3_6 = cw3 ** 6 end module global_sa","tags":"","loc":"sourcefile/global_sa.f90.html","title":"global_sa.f90 – FEST-3D"},{"text":"Declare all the constants used by SST turbulence model Files dependent on this one sourcefile~~global_sst.f90~~AfferentGraph sourcefile~global_sst.f90 global_sst.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~plusgs.f90->sourcefile~global_sst.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_sst.f90 sourcefile~write_output_vtk.f90 write_output_vtk.f90 sourcefile~write_output_vtk.f90->sourcefile~global_sst.f90 sourcefile~write_output_tec.f90 write_output_tec.f90 sourcefile~write_output_tec.f90->sourcefile~global_sst.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_sst.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~bc_primitive.f90 bc_primitive.f90 sourcefile~update.f90->sourcefile~bc_primitive.f90 sourcefile~write_output_tec_node.f90 write_output_tec_node.f90 sourcefile~write_output_tec_node.f90->sourcefile~global_sst.f90 sourcefile~viscous2.f90->sourcefile~global_sst.f90 sourcefile~lusgs.f90->sourcefile~global_sst.f90 sourcefile~source.f90->sourcefile~global_sst.f90 sourcefile~dump_solution.f90 dump_solution.f90 sourcefile~source.f90->sourcefile~dump_solution.f90 sourcefile~read_output_tec.f90 read_output_tec.f90 sourcefile~read_output_tec.f90->sourcefile~global_sst.f90 sourcefile~bc_primitive.f90->sourcefile~global_sst.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~state.f90 state.f90 sourcefile~create_and_erase.f90->sourcefile~state.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~solver.f90->sourcefile~bc_primitive.f90 sourcefile~solver.f90->sourcefile~dump_solution.f90 sourcefile~solver.f90->sourcefile~state.f90 sourcefile~read_output.f90 read_output.f90 sourcefile~read_output.f90->sourcefile~read_output_tec.f90 sourcefile~write_output.f90 write_output.f90 sourcefile~write_output.f90->sourcefile~write_output_vtk.f90 sourcefile~write_output.f90->sourcefile~write_output_tec.f90 sourcefile~write_output.f90->sourcefile~write_output_tec_node.f90 sourcefile~dump_solution.f90->sourcefile~write_output.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 sourcefile~state.f90->sourcefile~read_output.f90 var pansourcefileglobal_sstf90AfferentGraph = svgPanZoom('#sourcefileglobal_sstf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_sst Source Code global_sst.f90 Source Code !< Declare all the constants used by SST turbulence model module global_sst !< Declare all the constants used by SST turbulence model real , parameter :: sigma_k1 = 0.85 real , parameter :: sigma_k2 = 1.0 real , parameter :: sigma_w1 = 0.5 real , parameter :: sigma_w2 = 0.856 real , parameter :: beta1 = 0.075 real , parameter :: beta2 = 0.0828 real , parameter :: bstar = 0.09 real , parameter :: kappa = 0.41 real , parameter :: a1 = 0.31 real :: gama1 = ( beta1 / bstar ) - (( sigma_w1 * ( kappa ** 2 )) / sqrt ( bstar )) real :: gama2 = ( beta2 / bstar ) - (( sigma_w2 * ( kappa ** 2 )) / sqrt ( bstar )) ! to be used after blending with F1 real :: beta real :: sigma_w real :: sigma_k real :: gama ! blending function real , dimension (:,:,:), allocatable , target :: sst_F1 end module global_sst","tags":"","loc":"sourcefile/global_sst.f90.html","title":"global_sst.f90 – FEST-3D"},{"text":"Declare all the constants used by k-kL turbulence model Files dependent on this one sourcefile~~global_kkl.f90~~AfferentGraph sourcefile~global_kkl.f90 global_kkl.f90 sourcefile~viscosity.f90 viscosity.f90 sourcefile~viscosity.f90->sourcefile~global_kkl.f90 sourcefile~update.f90 update.f90 sourcefile~update.f90->sourcefile~global_kkl.f90 sourcefile~update.f90->sourcefile~viscosity.f90 sourcefile~plusgs.f90 plusgs.f90 sourcefile~update.f90->sourcefile~plusgs.f90 sourcefile~viscous2.f90 viscous2.f90 sourcefile~update.f90->sourcefile~viscous2.f90 sourcefile~source.f90 source.f90 sourcefile~update.f90->sourcefile~source.f90 sourcefile~lusgs.f90 lusgs.f90 sourcefile~update.f90->sourcefile~lusgs.f90 sourcefile~plusgs.f90->sourcefile~global_kkl.f90 sourcefile~viscous2.f90->sourcefile~global_kkl.f90 sourcefile~source.f90->sourcefile~global_kkl.f90 sourcefile~lusgs.f90->sourcefile~global_kkl.f90 sourcefile~create_and_erase.f90 create_and_erase.f90 sourcefile~create_and_erase.f90->sourcefile~source.f90 sourcefile~solver.f90 solver.f90 sourcefile~solver.f90->sourcefile~viscosity.f90 sourcefile~solver.f90->sourcefile~update.f90 sourcefile~solver.f90->sourcefile~viscous2.f90 sourcefile~solver.f90->sourcefile~source.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~solver.f90 sourcefile~start_finish.f90 start_finish.f90 sourcefile~main.f90->sourcefile~start_finish.f90 sourcefile~start_finish.f90->sourcefile~solver.f90 var pansourcefileglobal_kklf90AfferentGraph = svgPanZoom('#sourcefileglobal_kklf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Modules global_kkl Source Code global_kkl.f90 Source Code !< Declare all the constants used by k-kL turbulence model module global_kkl !< Declare all the constants used by k-kL turbulence model real , parameter :: zeta1 = 1.2 real , parameter :: zeta2 = 0.97 real , parameter :: zeta3 = 0.13 real , parameter :: sigma_k = 1.0 real , parameter :: sigma_phi = 1.0 real , parameter :: cmu = 0.09 real , parameter :: kappa = 0.41 real , parameter :: c11 = 1 0.0 real , parameter :: c12 = 1.3 real , parameter :: cd1 = 4.7 real :: cphi1 real :: cphi2 real :: fphi real :: eta end module global_kkl","tags":"","loc":"sourcefile/global_kkl.f90.html","title":"global_kkl.f90 – FEST-3D"},{"text":"public subroutine setup_interface() Allocate memory for the data communication between processors Arguments None Calls proc~~setup_interface~~CallsGraph proc~setup_interface setup_interface interface~alloc alloc proc~setup_interface->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_interface~~CalledByGraph proc~setup_interface setup_interface proc~setup_solver setup_solver proc~setup_solver->proc~setup_interface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_interface Source Code subroutine setup_interface () !< Allocate memory for the data communication between processors implicit none character ( len =* ), parameter :: & errmsg = \"module: interface, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * layers jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * layers kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * layers call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) end subroutine setup_interface","tags":"","loc":"proc/setup_interface.html","title":"setup_interface – FEST-3D"},{"text":"public subroutine destroy_interface() Deallocate all the memory being used  for data communication between processors Arguments None Calls proc~~destroy_interface~~CallsGraph proc~destroy_interface destroy_interface interface~dealloc dealloc proc~destroy_interface->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_interface~~CalledByGraph proc~destroy_interface destroy_interface proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_interface proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_interface Source Code subroutine destroy_interface () !< Deallocate all the memory being used  for data communication between processors implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) end subroutine destroy_interface","tags":"","loc":"proc/destroy_interface.html","title":"destroy_interface – FEST-3D"},{"text":"public subroutine apply_interface() MPISEND_RECV call to exchange interface infromation between\n connected blocks. Arguments None Calls proc~~apply_interface~~CallsGraph proc~apply_interface apply_interface mpi_sendrecv mpi_sendrecv proc~apply_interface->mpi_sendrecv proc~apply_periodic_bc apply_periodic_bc proc~apply_interface->proc~apply_periodic_bc proc~dmsg dmsg proc~apply_interface->proc~dmsg proc~apply_periodic_bc->mpi_sendrecv proc~apply_periodic_bc->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_interface~~CalledByGraph proc~apply_interface apply_interface proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~apply_interface proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_interfaceCalledByGraph = svgPanZoom('#procapply_interfaceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_interface Source Code subroutine apply_interface () !< MPISEND_RECV call to exchange interface infromation between !< connected blocks. implicit none integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !---------------------------------------------------------- ! call pattern is change for first block = 0 ! to avoid O-Grid infinite loop for mpi communication call !----------------------------------------------------------- if ( mod ( process_id , 2 ) == 0 ) then !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(2)==0)then !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(2)==1)then !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(1)==0)then !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(1)==1)then !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if else !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(1)==0)then !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(1)==1)then !          call MPI_RECV(imin_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imin_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(2)==0)then !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(2)==1)then !          call MPI_RECV(imax_recv_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(imax_send_buf,ibuf_size,MPI_DOUBLE_PRECISION,imax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(3)==0)then !          call MPI_SEND(jmin_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(jmin_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(3)==1)then !          call MPI_RECV(jmin_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(jmin_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(4)==0)then !          call MPI_SEND(jmax_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(jmax_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(4)==1)then !          call MPI_RECV(jmax_recv_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(jmax_send_buf,jbuf_size,MPI_DOUBLE_PRECISION,jmax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(5)==0)then !          call MPI_SEND(kmin_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(kmin_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(5)==1)then !          call MPI_RECV(kmin_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(kmin_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmin_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) !        if(mpi_class(6)==0)then !          call MPI_SEND(kmax_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,ierr) !          call MPI_RECV(kmax_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,status, ierr) !        elseif(mpi_class(6)==1)then !          call MPI_RECV(kmax_recv_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,status, ierr) !          call MPI_SEND(kmax_send_buf,kbuf_size,MPI_DOUBLE_PRECISION,kmax_id,tag,MPI_COMM_WORLD,ierr) !        else !          Fatal_error !        end if ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc () end subroutine apply_interface","tags":"","loc":"proc/apply_interface.html","title":"apply_interface – FEST-3D"},{"text":"private subroutine apply_periodic_bc() If a block is connected to another block in perodic\nfashion, this subroutine will take care of that boundary condition. Arguments None Calls proc~~apply_periodic_bc~~CallsGraph proc~apply_periodic_bc apply_periodic_bc mpi_sendrecv mpi_sendrecv proc~apply_periodic_bc->mpi_sendrecv proc~dmsg dmsg proc~apply_periodic_bc->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_periodic_bc~~CalledByGraph proc~apply_periodic_bc apply_periodic_bc proc~apply_interface apply_interface proc~apply_interface->proc~apply_periodic_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~apply_interface proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_periodic_bcCalledByGraph = svgPanZoom('#procapply_periodic_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_periodic_bc Source Code subroutine apply_periodic_bc () !<If a block is connected to another block in perodic !<fashion, this subroutine will take care of that boundary condition. implicit none integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc","tags":"","loc":"proc/apply_periodic_bc.html","title":"apply_periodic_bc – FEST-3D"},{"text":"public function Flux(ql, qr, du, inputs) Calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) Contents Source Code Flux Source Code function Flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for laminar flow. !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux","tags":"","loc":"proc/flux.html","title":"Flux – FEST-3D"},{"text":"public function SpectralRadius(ql, qr, inputs, c1, c2, eps) Calculated spectral radius Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:7) :: inputs real, intent(in), dimension(1:3) :: c1 real, intent(in), dimension(1:3) :: c2 real, intent(in) :: eps Return Value real Called by proc~~spectralradius~~CalledByGraph proc~spectralradius SpectralRadius proc~update_sst_variables update_SST_variables proc~update_sst_variables->proc~spectralradius proc~update_sa_variables update_SA_variables proc~update_sa_variables->proc~spectralradius proc~update_laminar_variables update_laminar_variables proc~update_laminar_variables->proc~spectralradius proc~update_lctm2015 update_lctm2015 proc~update_lctm2015->proc~spectralradius proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocspectralradiusCalledByGraph = svgPanZoom('#procspectralradiusCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SpectralRadius Source Code function SpectralRadius ( ql , qr , inputs , c1 , c2 , eps ) !< Calculated spectral radius implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql real , dimension ( 1 : n_var ), intent ( in ) :: qr real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : 3 ) , intent ( in ) :: c1 real , dimension ( 1 : 3 ) , intent ( in ) :: c2 real , intent ( in ) :: eps ! local variables real :: SpectralRadius real :: NormalSpeed real :: SpeedOfSound real :: vis real :: mu real :: rho real :: distance !extract inputs real :: Area real :: nx real :: ny real :: nz real :: volume real :: mm real :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = 2.0 * gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( 0.5 * (( 1.0 + eps ) * NormalSpeed & + sqrt ((( eps - 1.0 ) ** 2 ) * ( NormalSpeed ** 2 ) & + 4 * eps * ( SpeedOfSound ** 2 ))) + vis ) * Area end function SpectralRadius","tags":"","loc":"proc/spectralradius.html","title":"SpectralRadius – FEST-3D"},{"text":"public function SSTFlux(ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~sstflux~~CalledByGraph proc~sstflux SSTFlux proc~update_sst_variables update_SST_variables proc~update_sst_variables->proc~sstflux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsstfluxCalledByGraph = svgPanZoom('#procsstfluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SSTFlux Source Code function SSTFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SST) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SSTFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux","tags":"","loc":"proc/sstflux.html","title":"SSTFlux – FEST-3D"},{"text":"public function SAFlux(ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~saflux~~CalledByGraph proc~saflux SAFlux proc~update_sa_variables update_SA_variables proc~update_sa_variables->proc~saflux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sa_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsafluxCalledByGraph = svgPanZoom('#procsafluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SAFlux Source Code function SAFlux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent flow (SA) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SAFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtvdx real :: dtvdy real :: dtvdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux","tags":"","loc":"proc/saflux.html","title":"SAFlux – FEST-3D"},{"text":"public function lctm2015flux(ql, qr, du, inputs) Calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~lctm2015flux~~CalledByGraph proc~lctm2015flux lctm2015flux proc~update_lctm2015 update_lctm2015 proc~update_lctm2015->proc~lctm2015flux proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproclctm2015fluxCalledByGraph = svgPanZoom('#proclctm2015fluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lctm2015flux Source Code function lctm2015flux ( ql , qr , du , inputs ) !< Calculate the total flux through face for turbulent/transition flow (LCTM2015) !-------------------------------------- ! calculate the total flux through face !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: lctm2015flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: dtgmdx real :: dtgmdy real :: dtgmdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux","tags":"","loc":"proc/lctm2015flux.html","title":"lctm2015flux – FEST-3D"},{"text":"public subroutine setup_plusgs() Allocate array memory for data communication Arguments None Calls proc~~setup_plusgs~~CallsGraph proc~setup_plusgs setup_plusgs interface~alloc alloc proc~setup_plusgs->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_plusgs~~CalledByGraph proc~setup_plusgs setup_plusgs proc~setup_update setup_update proc~setup_update->proc~setup_plusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_plusgs Source Code subroutine setup_plusgs () !< Allocate array memory for data communication implicit none character ( len =* ), parameter :: & errmsg = \"module: LUSGS, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * 1 jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * 1 kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * 1 call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_plusgs","tags":"","loc":"proc/setup_plusgs.html","title":"setup_plusgs – FEST-3D"},{"text":"public subroutine destroy_plusgs() Unallocate the memory required by LU-SGS module Arguments None Calls proc~~destroy_plusgs~~CallsGraph proc~destroy_plusgs destroy_plusgs interface~dealloc dealloc proc~destroy_plusgs->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_plusgs~~CalledByGraph proc~destroy_plusgs destroy_plusgs proc~destroy_update destroy_update proc~destroy_update->proc~destroy_plusgs proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_plusgs Source Code subroutine destroy_plusgs () !< Unallocate the memory required by LU-SGS module implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) call dealloc ( delQ ) call dealloc ( delQstar ) call dealloc ( dummy ) end subroutine destroy_plusgs","tags":"","loc":"proc/destroy_plusgs.html","title":"destroy_plusgs – FEST-3D"},{"text":"public subroutine update_with_plusgs() Time-integrate with LU_SGS method Arguments None Calls proc~~update_with_plusgs~~CallsGraph proc~update_with_plusgs update_with_plusgs proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~sstflux SSTFlux proc~update_sst_variables->proc~sstflux proc~spectralradius SpectralRadius proc~update_sst_variables->proc~spectralradius proc~saflux SAFlux proc~update_sa_variables->proc~saflux proc~update_sa_variables->proc~spectralradius proc~update_laminar_variables->proc~spectralradius proc~lctm2015flux lctm2015flux proc~update_lctm2015->proc~lctm2015flux proc~update_lctm2015->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_with_plusgs~~CalledByGraph proc~update_with_plusgs update_with_plusgs proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with_plusgs Source Code subroutine update_with_plusgs () !< Time-integrate with LU_SGS method implicit none select case ( trim ( turbulence )) case ( 'none' ) call update_laminar_variables () case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' , 'bc' ) call update_SST_variables () case ( 'lctm2015' ) call update_lctm2015 () case DEFAULT Fatal_error end select case ( 'kkl' ) !          call update_KKL_variables() case ( 'sa' , 'saBC' ) call update_SA_variables () case Default Fatal_error end select end subroutine update_with_plusgs","tags":"","loc":"proc/update_with_plusgs.html","title":"update_with_plusgs – FEST-3D"},{"text":"public subroutine update_laminar_variables() Update laminar flow with LU-SGS scheme Arguments None Calls proc~~update_laminar_variables~~CallsGraph proc~update_laminar_variables update_laminar_variables proc~spectralradius SpectralRadius proc~update_laminar_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_laminar_variables~~CalledByGraph proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_laminar_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_laminar_variablesCalledByGraph = svgPanZoom('#procupdate_laminar_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_laminar_variables Source Code subroutine update_laminar_variables () !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k real , dimension ( 1 : 5 ) :: deltaU real :: D real , dimension ( 1 : 5 ) :: conservativeQ real , dimension ( 1 : 5 ) :: OldIminusFlux real , dimension ( 1 : 5 ) :: OldJminusFlux real , dimension ( 1 : 5 ) :: OldKminusFlux real , dimension ( 1 : 5 ) :: NewIminusFlux real , dimension ( 1 : 5 ) :: NewJminusFlux real , dimension ( 1 : 5 ) :: NewKminusFlux real , dimension ( 1 : 5 ) :: DelIminusFlux real , dimension ( 1 : 5 ) :: DelJminusFlux real , dimension ( 1 : 5 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 5 ) :: Q0 ! state at cell real , dimension ( 1 : 5 ) :: Q1 ! state at neighbours real , dimension ( 1 : 5 ) :: Q2 real , dimension ( 1 : 5 ) :: Q3 real , dimension ( 1 : 5 ) :: Q4 real , dimension ( 1 : 5 ) :: Q5 real , dimension ( 1 : 5 ) :: Q6 real , dimension ( 1 : 5 ) :: DQ0 ! change in state real , dimension ( 1 : 5 ) :: DQ1 real , dimension ( 1 : 5 ) :: DQ2 real , dimension ( 1 : 5 ) :: DQ3 real , dimension ( 1 : 5 ) :: DQ4 real , dimension ( 1 : 5 ) :: DQ5 real , dimension ( 1 : 5 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , H real :: factor real , dimension ( 1 : 5 , 1 : 5 ) :: PrecondInv !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) !deltaU(1:5) = -residue(i,j,k,1:5) & deltaU ( 1 : 5 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 5 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables","tags":"","loc":"proc/update_laminar_variables.html","title":"update_laminar_variables – FEST-3D"},{"text":"public subroutine update_SST_variables() Update the RANS (SST) equation with LU-SGS Arguments None Calls proc~~update_sst_variables~~CallsGraph proc~update_sst_variables update_SST_variables proc~sstflux SSTFlux proc~update_sst_variables->proc~sstflux proc~spectralradius SpectralRadius proc~update_sst_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sst_variables~~CalledByGraph proc~update_sst_variables update_SST_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sst_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sst_variablesCalledByGraph = svgPanZoom('#procupdate_sst_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SST_variables Source Code subroutine update_SST_variables () !< Update the RANS (SST) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , kk , ww , H real :: factor real , dimension ( 1 : 7 , 1 : 7 ) :: PrecondInv ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: De , Dp real :: Fpg real :: dvdy real :: lamd real :: intermittency De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 7 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) kk = Q0 ( 6 ) ww = Q0 ( 7 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * kk * VMag * VMag / 2.0 PrecondInv ( 7 , 1 ) = 0.0 - factor * ww * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * kk * ( - u ) PrecondInv ( 7 , 2 ) = 0.0 - factor * ww * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * kk * ( - v ) PrecondInv ( 7 , 3 ) = 0.0 - factor * ww * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * kk * ( - w ) PrecondInv ( 7 , 4 ) = 0.0 - factor * ww * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * kk * ( 1. ) PrecondInv ( 7 , 5 ) = 0.0 - factor * ww * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * kk * ( - 1. ) PrecondInv ( 7 , 6 ) = 0.0 - factor * ww * ( - 1. ) PrecondInv ( 1 , 7 ) = 0.0 - factor * 1 * ( 0. ) PrecondInv ( 2 , 7 ) = 0.0 - factor * u * ( 0. ) PrecondInv ( 3 , 7 ) = 0.0 - factor * v * ( 0. ) PrecondInv ( 4 , 7 ) = 0.0 - factor * w * ( 0. ) PrecondInv ( 5 , 7 ) = 0.0 - factor * H * ( 0. ) PrecondInv ( 6 , 7 ) = 0.0 - factor * kk * ( 0. ) PrecondInv ( 7 , 7 ) = 1.0 - factor * ww * ( 0. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables","tags":"","loc":"proc/update_sst_variables.html","title":"update_SST_variables – FEST-3D"},{"text":"public subroutine update_SA_variables() Update the RANS (SA) equation with LU-SGS Arguments None Calls proc~~update_sa_variables~~CallsGraph proc~update_sa_variables update_SA_variables proc~saflux SAFlux proc~update_sa_variables->proc~saflux proc~spectralradius SpectralRadius proc~update_sa_variables->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sa_variables~~CalledByGraph proc~update_sa_variables update_SA_variables proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_sa_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sa_variablesCalledByGraph = svgPanZoom('#procupdate_sa_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SA_variables Source Code subroutine update_SA_variables () !< Update the RANS (SA) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 6 ) :: deltaU real , dimension ( 1 : 6 ) :: D real , dimension ( 1 : 6 ) :: conservativeQ real , dimension ( 1 : 6 ) :: OldIminusFlux real , dimension ( 1 : 6 ) :: OldJminusFlux real , dimension ( 1 : 6 ) :: OldKminusFlux real , dimension ( 1 : 6 ) :: NewIminusFlux real , dimension ( 1 : 6 ) :: NewJminusFlux real , dimension ( 1 : 6 ) :: NewKminusFlux real , dimension ( 1 : 6 ) :: DelIminusFlux real , dimension ( 1 : 6 ) :: DelJminusFlux real , dimension ( 1 : 6 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 6 ) :: Q0 ! state at cell real , dimension ( 1 : 6 ) :: Q1 ! state at neighbours real , dimension ( 1 : 6 ) :: Q2 real , dimension ( 1 : 6 ) :: Q3 real , dimension ( 1 : 6 ) :: Q4 real , dimension ( 1 : 6 ) :: Q5 real , dimension ( 1 : 6 ) :: Q6 real , dimension ( 1 : 6 ) :: DQ0 ! change in state real , dimension ( 1 : 6 ) :: DQ1 real , dimension ( 1 : 6 ) :: DQ2 real , dimension ( 1 : 6 ) :: DQ3 real , dimension ( 1 : 6 ) :: DQ4 real , dimension ( 1 : 6 ) :: DQ5 real , dimension ( 1 : 6 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , p , H , tv !r real :: factor real , dimension ( 1 : 6 , 1 : 6 ) :: PrecondInv real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: nu_t real :: glim real :: g_6 real :: gamma_BC real :: dfv1 real :: dfv2 real :: dfw real :: dShat real :: dr real :: dg !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! deltaU ( 1 : 6 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 6 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do !call apply_interface(delQstar, 1) delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) tv = Q0 ( 6 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) PrecondInv ( 1 , 1 ) = 1.0 - factor * 1 * VMag * VMag / 2.0 PrecondInv ( 2 , 1 ) = 0.0 - factor * u * VMag * VMag / 2.0 PrecondInv ( 3 , 1 ) = 0.0 - factor * v * VMag * VMag / 2.0 PrecondInv ( 4 , 1 ) = 0.0 - factor * w * VMag * VMag / 2.0 PrecondInv ( 5 , 1 ) = 0.0 - factor * H * VMag * VMag / 2.0 PrecondInv ( 6 , 1 ) = 0.0 - factor * tv * VMag * VMag / 2.0 PrecondInv ( 1 , 2 ) = 0.0 - factor * 1 * ( - u ) PrecondInv ( 2 , 2 ) = 1.0 - factor * u * ( - u ) PrecondInv ( 3 , 2 ) = 0.0 - factor * v * ( - u ) PrecondInv ( 4 , 2 ) = 0.0 - factor * w * ( - u ) PrecondInv ( 5 , 2 ) = 0.0 - factor * H * ( - u ) PrecondInv ( 6 , 2 ) = 0.0 - factor * tv * ( - u ) PrecondInv ( 1 , 3 ) = 0.0 - factor * 1 * ( - v ) PrecondInv ( 2 , 3 ) = 0.0 - factor * u * ( - v ) PrecondInv ( 3 , 3 ) = 1.0 - factor * v * ( - v ) PrecondInv ( 4 , 3 ) = 0.0 - factor * w * ( - v ) PrecondInv ( 5 , 3 ) = 0.0 - factor * H * ( - v ) PrecondInv ( 6 , 3 ) = 0.0 - factor * tv * ( - v ) PrecondInv ( 1 , 4 ) = 0.0 - factor * 1 * ( - w ) PrecondInv ( 2 , 4 ) = 0.0 - factor * u * ( - w ) PrecondInv ( 3 , 4 ) = 0.0 - factor * v * ( - w ) PrecondInv ( 4 , 4 ) = 1.0 - factor * w * ( - w ) PrecondInv ( 5 , 4 ) = 0.0 - factor * H * ( - w ) PrecondInv ( 6 , 4 ) = 0.0 - factor * tv * ( - w ) PrecondInv ( 1 , 5 ) = 0.0 - factor * 1 * ( 1. ) PrecondInv ( 2 , 5 ) = 0.0 - factor * u * ( 1. ) PrecondInv ( 3 , 5 ) = 0.0 - factor * v * ( 1. ) PrecondInv ( 4 , 5 ) = 0.0 - factor * w * ( 1. ) PrecondInv ( 5 , 5 ) = 1.0 - factor * H * ( 1. ) PrecondInv ( 6 , 5 ) = 0.0 - factor * tv * ( 1. ) PrecondInv ( 1 , 6 ) = 0.0 - factor * 1 * ( - 1. ) PrecondInv ( 2 , 6 ) = 0.0 - factor * u * ( - 1. ) PrecondInv ( 3 , 6 ) = 0.0 - factor * v * ( - 1. ) PrecondInv ( 4 , 6 ) = 0.0 - factor * w * ( - 1. ) PrecondInv ( 5 , 6 ) = 0.0 - factor * H * ( - 1. ) PrecondInv ( 6 , 6 ) = 1.0 - factor * tv * ( - 1. ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables","tags":"","loc":"proc/update_sa_variables.html","title":"update_SA_variables – FEST-3D"},{"text":"public subroutine update_lctm2015() Update the RANS/transition (LCTM2015) equation with LU-SGS Arguments None Calls proc~~update_lctm2015~~CallsGraph proc~update_lctm2015 update_lctm2015 proc~lctm2015flux lctm2015flux proc~update_lctm2015->proc~lctm2015flux proc~spectralradius SpectralRadius proc~update_lctm2015->proc~spectralradius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_lctm2015~~CalledByGraph proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs update_with_plusgs proc~update_with_plusgs->proc~update_lctm2015 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_plusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_lctm2015CalledByGraph = svgPanZoom('#procupdate_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_lctm2015 Source Code subroutine update_lctm2015 () !< Update the RANS/transition (LCTM2015) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 8 ) :: deltaU real , dimension ( 1 : 8 ) :: D real , dimension ( 1 : 8 ) :: conservativeQ real , dimension ( 1 : 8 ) :: OldIminusFlux real , dimension ( 1 : 8 ) :: OldJminusFlux real , dimension ( 1 : 8 ) :: OldKminusFlux real , dimension ( 1 : 8 ) :: NewIminusFlux real , dimension ( 1 : 8 ) :: NewJminusFlux real , dimension ( 1 : 8 ) :: NewKminusFlux real , dimension ( 1 : 8 ) :: DelIminusFlux real , dimension ( 1 : 8 ) :: DelJminusFlux real , dimension ( 1 : 8 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 8 ) :: Q0 ! state at cell real , dimension ( 1 : 8 ) :: Q1 ! state at neighbours real , dimension ( 1 : 8 ) :: Q2 real , dimension ( 1 : 8 ) :: Q3 real , dimension ( 1 : 8 ) :: Q4 real , dimension ( 1 : 8 ) :: Q5 real , dimension ( 1 : 8 ) :: Q6 real , dimension ( 1 : 8 ) :: DQ0 ! change in state real , dimension ( 1 : 8 ) :: DQ1 real , dimension ( 1 : 8 ) :: DQ2 real , dimension ( 1 : 8 ) :: DQ3 real , dimension ( 1 : 8 ) :: DQ4 real , dimension ( 1 : 8 ) :: DQ5 real , dimension ( 1 : 8 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta real :: eps real :: M real :: VMag real :: SoundMag real :: u , v , w , r , p , kk , ww , H , im real :: factor real , dimension ( 1 : 8 , 1 : 8 ) :: PrecondInv real , dimension ( 1 : 8 , 1 : 8 ) :: Identity ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: Dp , De real :: Fpg real :: dvdy real :: lamd Dp = 0.0 De = 0.0 !Identity matrix Identity = 0.0 do i = 1 , 8 Identity ( i , i ) = 1.0 end do !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - matmul ( PrecondInv , residue ( i , j , k , 1 : 8 )) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) !---preconditioning--- r = Q0 ( 1 ) u = Q0 ( 2 ) v = Q0 ( 3 ) w = Q0 ( 4 ) p = Q0 ( 5 ) VMag = sqrt ( u * u + v * v + w * w ) SoundMag = sqrt ( gm * p / r ) M = VMag / SoundMag H = ( gm * p / ( r * ( gm - 1.0 ))) + 0.5 * ( VMag ) eps = min ( 1.0 , max ( M * M , Minf * Minf )) factor = ( 1.0 - eps ) * ( gm - 1.0 ) / ( SoundMag * SoundMag ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 , eps ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 , eps ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 , eps ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 , eps ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 , eps ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 , eps ) !preconditing start PrecondInv (:, 1 ) = VMag * VMag / 2.0 PrecondInv (:, 2 ) = - u PrecondInv (:, 3 ) = - v PrecondInv (:, 4 ) = - w PrecondInv (:, 5 ) = 1.0 PrecondInv (:, 6 ) = - 1.0 PrecondInv (:, 7 ) = 0.0 PrecondInv (:, 8 ) = 0.0 PrecondInv ( 2 ,:) = u * PrecondInv ( 2 ,:) PrecondInv ( 3 ,:) = v * PrecondInv ( 3 ,:) PrecondInv ( 4 ,:) = w * PrecondInv ( 4 ,:) PrecondInv ( 5 ,:) = H * PrecondInv ( 5 ,:) PrecondInv ( 6 ,:) = kk * PrecondInv ( 6 ,:) PrecondInv ( 7 ,:) = ww * PrecondInv ( 7 ,:) PrecondInv ( 8 ,:) = im * PrecondInv ( 8 ,:) PrecondInv = Identity - ( factor * PrecondInv ) !---end preconditioning ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( matmul ( PrecondInv , DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( matmul ( PrecondInv , DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015","tags":"","loc":"proc/update_lctm2015.html","title":"update_lctm2015 – FEST-3D"},{"text":"public subroutine apply_interface(qp, layers) Apply inter-block interface boundary condition Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers Calls proc~~apply_interface~2~~CallsGraph proc~apply_interface~2 apply_interface mpi_sendrecv mpi_sendrecv proc~apply_interface~2->mpi_sendrecv proc~apply_periodic_bc~2 apply_periodic_bc proc~apply_interface~2->proc~apply_periodic_bc~2 proc~dmsg dmsg proc~apply_interface~2->proc~dmsg proc~apply_periodic_bc~2->mpi_sendrecv proc~apply_periodic_bc~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_interface Source Code subroutine apply_interface ( qp , layers ) !< Apply inter-block interface boundary condition implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( delQstar , 1 ) end subroutine apply_interface","tags":"","loc":"proc/apply_interface~2.html","title":"apply_interface – FEST-3D"},{"text":"public subroutine apply_periodic_bc(qp, layers) Apply periodic boundary condition Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers Calls proc~~apply_periodic_bc~2~~CallsGraph proc~apply_periodic_bc~2 apply_periodic_bc mpi_sendrecv mpi_sendrecv proc~apply_periodic_bc~2->mpi_sendrecv proc~dmsg dmsg proc~apply_periodic_bc~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_periodic_bc~2~~CalledByGraph proc~apply_periodic_bc~2 apply_periodic_bc proc~apply_interface~2 apply_interface proc~apply_interface~2->proc~apply_periodic_bc~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_periodic_bc Source Code subroutine apply_periodic_bc ( qp , layers ) !< Apply periodic boundary condition implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc","tags":"","loc":"proc/apply_periodic_bc~2.html","title":"apply_periodic_bc – FEST-3D"},{"text":"public subroutine compute_viscous_fluxes(F, G, H) Call to all viscous flux subroutine based on \n the drection and turbulence/transition model being\n used Arguments Type Intent Optional Attributes Name real, dimension(:, :, :, :), pointer :: F real, dimension(:, :, :, :), pointer :: G real, dimension(:, :, :, :), pointer :: H Calls proc~~compute_viscous_fluxes~~CallsGraph proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes_kkl compute_viscous_fluxes_kkl proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_kkl proc~compute_viscous_fluxes_lctm2015 compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes_laminar compute_viscous_fluxes_laminar proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_laminar proc~compute_viscous_fluxes_sst compute_viscous_fluxes_sst proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sst proc~compute_viscous_fluxes_sa compute_viscous_fluxes_sa proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_viscous_fluxes~~CalledByGraph proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxesCalledByGraph = svgPanZoom('#proccompute_viscous_fluxesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes Source Code subroutine compute_viscous_fluxes ( F , G , H ) !< Call to all viscous flux subroutine based on !< the drection and turbulence/transition model being !< used implicit none real , dimension (:, :, :, :), pointer :: F , G , H call compute_viscous_fluxes_laminar ( F , 'x' ) call compute_viscous_fluxes_laminar ( G , 'y' ) !if(kmx==2)then !  continue !else call compute_viscous_fluxes_laminar ( H , 'z' ) !end if select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_viscous_fluxes_sa ( F , 'x' ) call compute_viscous_fluxes_sa ( G , 'y' ) call compute_viscous_fluxes_sa ( H , 'z' ) case ( 'sst' , 'sst2003' ) call compute_viscous_fluxes_sst ( F , 'x' ) call compute_viscous_fluxes_sst ( G , 'y' ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_sst ( H , 'z' ) end if case ( 'kkl' ) call compute_viscous_fluxes_kkl ( F , 'x' ) call compute_viscous_fluxes_kkl ( G , 'y' ) !if(kmx==2)then !  continue !else call compute_viscous_fluxes_kkl ( H , 'z' ) !end if case DEFAULT Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call compute_viscous_fluxes_lctm2015 ( F , 'x' ) call compute_viscous_fluxes_lctm2015 ( G , 'y' ) if ( kmx == 2 ) then continue else call compute_viscous_fluxes_lctm2015 ( H , 'z' ) end if case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end select if ( any ( isnan ( G ))) then Fatal_error end if if ( any ( isnan ( F ))) then Fatal_error end if if ( any ( isnan ( H ))) then Fatal_error end if end subroutine compute_viscous_fluxes","tags":"","loc":"proc/compute_viscous_fluxes.html","title":"compute_viscous_fluxes – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_laminar(F, direction) Compute viscous fluxes for first five Navier-Stokes equation Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction Called by proc~~compute_viscous_fluxes_laminar~~CalledByGraph proc~compute_viscous_fluxes_laminar compute_viscous_fluxes_laminar proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_laminar proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_laminarCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_laminarCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_laminar Source Code subroutine compute_viscous_fluxes_laminar ( F , direction ) !< Compute viscous fluxes for first five Navier-Stokes equation implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: dudx , dudy , dudz real :: dvdx , dvdy , dvdz real :: dwdx , dwdy , dwdz real :: dTdx , dTdy , dTdz real :: normal_comp real :: d_LR real :: T_RE real :: T_LE real :: K_heat , Qx , Qy , Qz real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: delu real :: delv real :: delw real :: delT real :: Tau_xx real :: Tau_xy real :: Tau_xz real :: Tau_yx real :: Tau_yy real :: Tau_yz real :: Tau_zx real :: Tau_zy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real :: uface real :: vface real :: wface real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dudx = 0.5 * ( gradu_x ( i - ii , j - jj , k - kk ) + gradu_x ( i , j , k )) dudy = 0.5 * ( gradu_y ( i - ii , j - jj , k - kk ) + gradu_y ( i , j , k )) dudz = 0.5 * ( gradu_z ( i - ii , j - jj , k - kk ) + gradu_z ( i , j , k )) dvdx = 0.5 * ( gradv_x ( i - ii , j - jj , k - kk ) + gradv_x ( i , j , k )) dvdy = 0.5 * ( gradv_y ( i - ii , j - jj , k - kk ) + gradv_y ( i , j , k )) dvdz = 0.5 * ( gradv_z ( i - ii , j - jj , k - kk ) + gradv_z ( i , j , k )) dwdx = 0.5 * ( gradw_x ( i - ii , j - jj , k - kk ) + gradw_x ( i , j , k )) dwdy = 0.5 * ( gradw_y ( i - ii , j - jj , k - kk ) + gradw_y ( i , j , k )) dwdz = 0.5 * ( gradw_z ( i - ii , j - jj , k - kk ) + gradw_z ( i , j , k )) dTdx = 0.5 * ( gradT_x ( i - ii , j - jj , k - kk ) + gradT_x ( i , j , k )) dTdy = 0.5 * ( gradT_y ( i - ii , j - jj , k - kk ) + gradT_y ( i , j , k )) dTdz = 0.5 * ( gradT_z ( i - ii , j - jj , k - kk ) + gradT_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! Finding the temperature of left and right element to the face i,j,k T_LE = pressure ( i - ii , j - jj , k - kk ) / ( density ( i - ii , j - jj , k - kk ) * R_gas ) T_RE = pressure ( i , j , k ) / ( density ( i , j , k ) * R_gas ) ! difference in state across face delu = x_speed ( i , j , k ) - x_speed ( i - ii , j - jj , k - kk ) delv = y_speed ( i , j , k ) - y_speed ( i - ii , j - jj , k - kk ) delw = z_speed ( i , j , k ) - z_speed ( i - ii , j - jj , k - kk ) delT = T_RE - T_LE !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( delu - ( dudx * delx + dudy * dely + dudz * delz )) / d_LR dudx = dudx + ( normal_comp * delx / d_LR ) dudy = dudy + ( normal_comp * dely / d_LR ) dudz = dudz + ( normal_comp * delz / d_LR ) normal_comp = ( delv - ( dvdx * delx + dvdy * dely + dvdz * delz )) / d_LR dvdx = dvdx + ( normal_comp * delx / d_LR ) dvdy = dvdy + ( normal_comp * dely / d_LR ) dvdz = dvdz + ( normal_comp * delz / d_LR ) normal_comp = ( delw - ( dwdx * delx + dwdy * dely + dwdz * delz )) / d_LR dwdx = dwdx + ( normal_comp * delx / d_LR ) dwdy = dwdy + ( normal_comp * dely / d_LR ) dwdz = dwdz + ( normal_comp * delz / d_LR ) normal_comp = ( delT - ( dTdx * delx + dTdy * dely + dTdz * delz )) / d_LR dTdx = dTdx + ( normal_comp * delx / d_LR ) dTdy = dTdy + ( normal_comp * dely / d_LR ) dTdz = dTdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) if ( trim ( turbulence ) /= 'none' ) then mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) else mut_f = 0.0 end if ! effective viscosity total_mu = mu_f + mut_f ! Using lambda = -2 * mu / 3 ! diagonal terms of stress tensor Tau_xx = 2. * total_mu * ( dudx - (( dudx + dvdy + dwdz ) / 3. )) Tau_yy = 2. * total_mu * ( dvdy - (( dudx + dvdy + dwdz ) / 3. )) Tau_zz = 2. * total_mu * ( dwdz - (( dudx + dvdy + dwdz ) / 3. )) ! off diagonal symmetrical part of stress tensor Tau_xy = total_mu * ( dvdx + dudy ) Tau_xz = total_mu * ( dwdx + dudz ) Tau_yz = total_mu * ( dwdy + dvdz ) Tau_yx = Tau_xy Tau_zx = Tau_xz Tau_zy = Tau_yz ! Pr: Prandtl Number and tPr: Turbulent Prandtl number ! Qx, Qy, Qz: Conduction fluxes K_heat = ( mu_f / Pr + mut_f / tPr ) * gm * R_gas / ( gm - 1 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) uface = 0.5 * ( x_speed ( i - ii , j - jj , k - kk ) + x_speed ( i , j , k )) vface = 0.5 * ( y_speed ( i - ii , j - jj , k - kk ) + y_speed ( i , j , k )) wface = 0.5 * ( z_speed ( i - ii , j - jj , k - kk ) + z_speed ( i , j , k )) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - (( Tau_xx * nx + Tau_xy * ny + Tau_xz * nz ) * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - (( Tau_yx * nx + Tau_yy * ny + Tau_yz * nz ) * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - (( Tau_zx * nx + Tau_zy * ny + Tau_zz * nz ) * area ) ! Energy flux ! (TijVj + Qi)ni F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * ( & (( Tau_xx * uface + Tau_xy * vface + Tau_xz * wface + Qx ) * nx ) + & (( Tau_yx * uface + Tau_yy * vface + Tau_yz * wface + Qy ) * ny ) + & (( Tau_zx * uface + Tau_zy * vface + Tau_zz * wface + Qz ) * nz ) ) ) end do end do end do end subroutine compute_viscous_fluxes_laminar","tags":"","loc":"proc/compute_viscous_fluxes_laminar.html","title":"compute_viscous_fluxes_laminar – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_sst(F, direction) Compute viscous fluxes for additianal equations due to SST turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F flux array character(len=*), intent(in) :: direction face direction Called by proc~~compute_viscous_fluxes_sst~~CalledByGraph proc~compute_viscous_fluxes_sst compute_viscous_fluxes_sst proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sst proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_sstCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_sstCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_sst Source Code subroutine compute_viscous_fluxes_sst ( F , direction ) !< Compute viscous fluxes for additianal equations due to SST turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< flux array ! local variables real :: tkface real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: deltk real :: deltw real :: Tau_xx real :: Tau_yy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sst variable requirement ---! real :: dtkdx , dtkdy , dtkdz , dtwdx , dtwdy , dtwdz real :: F1 real :: sigma_kf real :: sigma_wf !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtwdx = 0.5 * ( gradtw_x ( i - ii , j - jj , k - kk ) + gradtw_x ( i , j , k )) dtwdy = 0.5 * ( gradtw_y ( i - ii , j - jj , k - kk ) + gradtw_y ( i , j , k )) dtwdz = 0.5 * ( gradtw_z ( i - ii , j - jj , k - kk ) + gradtw_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = tk ( i , j , k ) - tk ( i - ii , j - jj , k - kk ) deltw = tw ( i , j , k ) - tw ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltw - ( dtwdx * delx + dtwdy * dely + dtwdz * delz )) / d_LR dtwdx = dtwdx + ( normal_comp * delx / d_LR ) dtwdy = dtwdy + ( normal_comp * dely / d_LR ) dtwdz = dtwdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( sst_mu ( i - ii , j - jj , k - kk ) + sst_mu ( i , j , k )) F1 = 0.5 * ( sst_F1 ( i - ii , j - jj , k - kk ) + sst_F1 ( i , j , k )) sigma_kf = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_wf = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) total_mu = mu_f + mut_f rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) tkface = 0.5 * ( tk ( i - ii , j - jj , k - kk ) + tk ( i , j , k )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_kf * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_wf * mut_f ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_sst","tags":"","loc":"proc/compute_viscous_fluxes_sst.html","title":"compute_viscous_fluxes_sst – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_kkl(F, direction) Compute viscous fluxes for additianal equations due to k-kL turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction Called by proc~~compute_viscous_fluxes_kkl~~CalledByGraph proc~compute_viscous_fluxes_kkl compute_viscous_fluxes_kkl proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_kkl proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_kklCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_kklCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_kkl Source Code subroutine compute_viscous_fluxes_kkl ( F , direction ) !< Compute viscous fluxes for additianal equations due to k-kL turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: tkface real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: total_mu real :: delx real :: dely real :: delz real :: deltk real :: deltkl real :: Tau_xx real :: Tau_yy real :: Tau_zz real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- kkl variable requirement  ---! real :: dtkdx , dtkdy , dtkdz real :: dtkldx , dtkldy , dtkldz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtkdx = 0.5 * ( gradtk_x ( i - ii , j - jj , k - kk ) + gradtk_x ( i , j , k )) dtkdy = 0.5 * ( gradtk_y ( i - ii , j - jj , k - kk ) + gradtk_y ( i , j , k )) dtkdz = 0.5 * ( gradtk_z ( i - ii , j - jj , k - kk ) + gradtk_z ( i , j , k )) dtkldx = 0.5 * ( gradtkl_x ( i - ii , j - jj , k - kk ) + gradtkl_x ( i , j , k )) dtkldy = 0.5 * ( gradtkl_y ( i - ii , j - jj , k - kk ) + gradtkl_y ( i , j , k )) dtkldz = 0.5 * ( gradtkl_z ( i - ii , j - jj , k - kk ) + gradtkl_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltk = tk ( i , j , k ) - tk ( i - ii , j - jj , k - kk ) deltkl = tkl ( i , j , k ) - tkl ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltk - ( dtkdx * delx + dtkdy * dely + dtkdz * delz )) / d_LR dtkdx = dtkdx + ( normal_comp * delx / d_LR ) dtkdy = dtkdy + ( normal_comp * dely / d_LR ) dtkdz = dtkdz + ( normal_comp * delz / d_LR ) normal_comp = ( deltkl - ( dtkldx * delx + dtkldy * dely + dtkldz * delz )) / d_LR dtkldx = dtkldx + ( normal_comp * delx / d_LR ) dtkldy = dtkldy + ( normal_comp * dely / d_LR ) dtkldz = dtkldz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( kkl_mu ( i - ii , j - jj , k - kk ) + kkl_mu ( i , j , k )) total_mu = mu_f + mut_f rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) tkface = 0.5 * ( tk ( i - ii , j - jj , k - kk ) + tk ( i , j , k )) ! k in reynolds stress Tau_xx = - 2.0 * rhoface * tkface / 3.0 Tau_yy = Tau_xx Tau_zz = Tau_xx ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 2 ) = F ( i , j , k , 2 ) - ( Tau_xx * nx * area ) F ( i , j , k , 3 ) = F ( i , j , k , 3 ) - ( Tau_yy * ny * area ) F ( i , j , k , 4 ) = F ( i , j , k , 4 ) - ( Tau_zz * nz * area ) F ( i , j , k , 5 ) = F ( i , j , k , 5 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + sigma_k * mut_f ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ))) F ( i , j , k , 7 ) = F ( i , j , k , 7 ) - ( area * (( mu_f + sigma_phi * mut_f ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_kkl","tags":"","loc":"proc/compute_viscous_fluxes_kkl.html","title":"compute_viscous_fluxes_kkl – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_sa(F, direction) Compute viscous fluxes for additianal equations due to SA turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction Called by proc~~compute_viscous_fluxes_sa~~CalledByGraph proc~compute_viscous_fluxes_sa compute_viscous_fluxes_sa proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sa proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_saCalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_saCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_sa Source Code subroutine compute_viscous_fluxes_sa ( F , direction ) !< Compute viscous fluxes for additianal equations due to SA turbulence model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: delx real :: dely real :: delz real :: deltv real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real :: dtvdx , dtvdy , dtvdz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtvdx = 0.5 * ( gradtv_x ( i - ii , j - jj , k - kk ) + gradtv_x ( i , j , k )) dtvdy = 0.5 * ( gradtv_y ( i - ii , j - jj , k - kk ) + gradtv_y ( i , j , k )) dtvdz = 0.5 * ( gradtv_z ( i - ii , j - jj , k - kk ) + gradtv_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltv = tv ( i , j , k ) - tv ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltv - ( dtvdx * delx + dtvdy * dely + dtvdz * delz )) / d_LR dtvdx = dtvdx + ( normal_comp * delx / d_LR ) dtvdy = dtvdy + ( normal_comp * dely / d_LR ) dtvdz = dtvdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( tv ( i - ii , j - jj , k - kk ) + tv ( i , j , k )) * rhoface ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , 6 ) = F ( i , j , k , 6 ) - ( area * (( mu_f + mut_f ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ))) / sigma_sa end do end do end do end subroutine compute_viscous_fluxes_sa","tags":"","loc":"proc/compute_viscous_fluxes_sa.html","title":"compute_viscous_fluxes_sa – FEST-3D"},{"text":"private subroutine compute_viscous_fluxes_lctm2015(F, direction) Compute viscous fluxes for additianal equations due to LCTM2015 transition model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction Called by proc~~compute_viscous_fluxes_lctm2015~~CalledByGraph proc~compute_viscous_fluxes_lctm2015 compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes compute_viscous_fluxes proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_viscous_fluxes_lctm2015CalledByGraph = svgPanZoom('#proccompute_viscous_fluxes_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_viscous_fluxes_lctm2015 Source Code subroutine compute_viscous_fluxes_lctm2015 ( F , direction ) !< Compute viscous fluxes for additianal equations due to LCTM2015 transition model implicit none character ( len =* ), intent ( in ) :: direction !< Face direction real , dimension (:, :, :, :), pointer , intent ( inout ) :: F !< Flux array ! local variables real :: rhoface real :: normal_comp real :: d_LR real :: mu_f real :: mut_f real :: delx real :: dely real :: delz real :: deltgm real :: nx real :: ny real :: nz real :: area real , dimension (:, :, :), pointer :: fA real , dimension (:, :, :), pointer :: fnx real , dimension (:, :, :), pointer :: fny real , dimension (:, :, :), pointer :: fnz integer :: i , j , k integer :: ii , jj , kk !--- sa variable requirement ---! real :: dtgmdx , dtgmdy , dtgmdz !-------------------------------------------------------------------- ! select Direction !-------------------------------------------------------------------- select case ( trim ( direction )) case ( 'x' ) ii = 1 jj = 0 kk = 0 fnx => xnx fny => xny fnz => xnz fA ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xA case ( 'y' ) ii = 0 jj = 1 kk = 0 fnx => ynx fny => yny fnz => ynz fA ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yA case ( 'z' ) ii = 0 jj = 0 kk = 1 fnx => znx fny => zny fnz => znz fA ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zA case Default Fatal_error end select !--------------------------------------------------------------------- ! Calculating the turbulent viscous fluxes at the faces !-------------------------------------------------------------------- do k = 1 , kmx - 1 + kk do j = 1 , jmx - 1 + jj do i = 1 , imx - 1 + ii !--- FACE Gradients ---! ! Gradients at face as average of gradients at cell centres dtgmdx = 0.5 * ( gradtgm_x ( i - ii , j - jj , k - kk ) + gradtgm_x ( i , j , k )) dtgmdy = 0.5 * ( gradtgm_y ( i - ii , j - jj , k - kk ) + gradtgm_y ( i , j , k )) dtgmdz = 0.5 * ( gradtgm_z ( i - ii , j - jj , k - kk ) + gradtgm_z ( i , j , k )) !--- For ODD-EVEN coupling error ---! ! distance between cell center of adjacent cell for the i,j,k face delx = CellCenter ( i , j , k , 1 ) - CellCenter ( i - ii , j - jj , k - kk , 1 ) dely = CellCenter ( i , j , k , 2 ) - CellCenter ( i - ii , j - jj , k - kk , 2 ) delz = CellCenter ( i , j , k , 3 ) - CellCenter ( i - ii , j - jj , k - kk , 3 ) d_LR = sqrt ( delx * delx + dely * dely + delz * delz ) ! difference in state across face deltgm = tgm ( i , j , k ) - tgm ( i - ii , j - jj , k - kk ) !normal_comp   = ( delta(phi) - (grad(phi).dot.delR) )/magnitudeR !new grad(phi) =  grad(phi) + correction(normal_comp.dot.delR/magnitudeR) normal_comp = ( deltgm - ( dtgmdx * delx + dtgmdy * dely + dtgmdz * delz )) / d_LR dtgmdx = dtgmdx + ( normal_comp * delx / d_LR ) dtgmdy = dtgmdy + ( normal_comp * dely / d_LR ) dtgmdz = dtgmdz + ( normal_comp * delz / d_LR ) !--- end of ODD-EVEN coupling correction ---! rhoface = 0.5 * ( density ( i - ii , j - jj , k - kk ) + density ( i , j , k )) mu_f = 0.5 * ( mu ( i - ii , j - jj , k - kk ) + mu ( i , j , k )) mut_f = 0.5 * ( mu_t ( i - ii , j - jj , k - kk ) + mu_t ( i , j , k )) ! calling some element from memory and keep them handy for calculation nx = fnx ( i , j , k ) ny = fny ( i , j , k ) nz = fnz ( i , j , k ) area = fA ( i , j , k ) ! adding viscous fluxes to stored convective flux F ( i , j , k , n_var ) = F ( i , j , k , n_var ) - ( area * (( mu_f + mut_f ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ))) end do end do end do end subroutine compute_viscous_fluxes_lctm2015","tags":"","loc":"proc/compute_viscous_fluxes_lctm2015.html","title":"compute_viscous_fluxes_lctm2015 – FEST-3D"},{"text":"private function write_time(time_in_seconds) result(string) Particular format to write time in output log file Arguments Type Intent Optional Attributes Name real, intent(in) :: time_in_seconds Time to output Return Value character(len=64) Time as string in particlar format Called by proc~~write_time~~CalledByGraph proc~write_time write_time proc~destroy_time destroy_time proc~destroy_time->proc~write_time proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_time Source Code function write_time ( time_in_seconds ) result ( string ) !< Particular format to write time in output log file implicit none real , intent ( in ) :: time_in_seconds !< Time to output character ( len = 64 ) :: string !< Time as string in particlar format if ( time_in_seconds > 86400 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 8640 0. , \"days\" elseif ( time_in_seconds > 3600 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 360 0. , \"Hr.\" elseif ( time_in_seconds > 60 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds / 6 0. , \"Min.\" elseif ( time_in_seconds > 0 ) then write ( string , '(f0.16,2x,A)' ) time_in_seconds , \"Sec.\" else write ( string , '(A)' ) \"Not Valid\" end if end function write_time","tags":"","loc":"proc/write_time.html","title":"write_time – FEST-3D"},{"text":"public subroutine setup_time() Allocate memeroy and setup initial clock Arguments None Calls proc~~setup_time~~CallsGraph proc~setup_time setup_time interface~alloc alloc proc~setup_time->interface~alloc proc~dmsg dmsg proc~setup_time->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_time~~CalledByGraph proc~setup_time setup_time proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_time Source Code subroutine setup_time () !< Allocate memeroy and setup initial clock implicit none call dmsg ( 1 , 'time' , 'initmisc' ) call alloc ( delta_t , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , & errmsg = 'Error: Unable to allocate memory for delta_t.' ) CALL SYSTEM_CLOCK ( COUNT_RATE = nb_ticks_sec , COUNT_MAX = nb_ticks_max ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_initial ) CALL CPU_TIME ( t1 ) end subroutine setup_time","tags":"","loc":"proc/setup_time.html","title":"setup_time – FEST-3D"},{"text":"public subroutine destroy_time() Deallocate memory and find simulation time. Arguments None Calls proc~~destroy_time~~CallsGraph proc~destroy_time destroy_time mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~write_time write_time proc~destroy_time->proc~write_time interface~alloc alloc proc~destroy_time->interface~alloc proc~dmsg dmsg proc~destroy_time->proc~dmsg interface~dealloc dealloc proc~destroy_time->interface~dealloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_time~~CalledByGraph proc~destroy_time destroy_time proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_time Source Code subroutine destroy_time () !< Deallocate memory and find simulation time. implicit none real , dimension (:), allocatable :: total_time integer :: ierr call dmsg ( 1 , 'solver' , 'deallocate_misc' ) !simlulation clock data if ( process_id == 0 ) write ( * , '(A)' ) '>> TIME <<' if ( process_id == 0 ) write ( * , '(A)' ) \"Simulation Clock : \" // trim ( write_time ( sim_clock )) call alloc ( total_time , 1 , total_process ) CALL CPU_TIME ( t2 ) CALL SYSTEM_CLOCK ( COUNT = nb_ticks_final ) call dealloc ( delta_t ) nb_ticks = nb_ticks_final - nb_ticks_initial IF ( nb_ticks_final < nb_ticks_initial ) & nb_ticks = nb_ticks + nb_ticks_max elapsed_time = REAL ( nb_ticks ) / nb_ticks_sec cpu_time_elapsed = t2 - t1 write ( * , '(A,I0,A)' ) 'process: ' , process_id ,& \" > SYSTEM clock <: \" // trim ( write_time ( elapsed_time )) // & \" /-\\ CPU time <: \" // trim ( write_time ( cpu_time_elapsed )) !total time including all blocks call MPI_GATHER ( elapsed_time , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( process_id == 0 ) print * , \"Total SYSTEM clock: \" , trim ( write_time ( sum ( total_time ))) call MPI_GATHER ( cpu_time_elapsed , 1 , MPI_DOUBLE_PRECISION , & total_time , 1 , MPI_DOUBLE_PRECISION , 0 , MPI_COMM_WORLD , ierr ) if ( process_id == 0 ) print * , \"Total CPU time    : \" , trim ( write_time ( sum ( total_time ))) call dealloc ( total_time ) end subroutine destroy_time","tags":"","loc":"proc/destroy_time.html","title":"destroy_time – FEST-3D"},{"text":"private subroutine compute_local_time_step() Compute the time step to be used at each cell center Local time stepping can be used to get the solution \n advance towards steady state faster. If only the steady\n state solution is required, i.e., transients are \n irrelevant, use local time stepping. Arguments None Calls proc~~compute_local_time_step~~CallsGraph proc~compute_local_time_step compute_local_time_step proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time proc~dmsg dmsg proc~compute_local_time_step->proc~dmsg proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time x_qp_right x_qp_right proc~compute_local_time_step->x_qp_right x_qp_left x_qp_left proc~compute_local_time_step->x_qp_left y_qp_left y_qp_left proc~compute_local_time_step->y_qp_left z_qp_left z_qp_left proc~compute_local_time_step->z_qp_left y_qp_right y_qp_right proc~compute_local_time_step->y_qp_right z_qp_right z_qp_right proc~compute_local_time_step->z_qp_right proc~add_viscous_time->proc~dmsg proc~add_turbulent_time->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_local_time_step~~CalledByGraph proc~compute_local_time_step compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_local_time_stepCalledByGraph = svgPanZoom('#proccompute_local_time_stepCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_local_time_step Source Code subroutine compute_local_time_step () !< Compute the time step to be used at each cell center !< !< Local time stepping can be used to get the solution !< advance towards steady state faster. If only the steady !< state solution is required, i.e., transients are !< irrelevant, use local time stepping. !----------------------------------------------------------- implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum real :: x_sound_speed_avg , y_sound_speed_avg , z_sound_speed_avg integer :: i , j , k call dmsg ( 1 , 'solver' , 'compute_local_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! For orientation, refer to the report. The standard i,j,k ! direction are marked. All orientation notations are w.r.t ! to the perspective shown in the image. ! Faces with lower index x_sound_speed_avg = 0.5 * ( sqrt ( gm * x_qp_left ( i , j , k , 5 ) / & x_qp_left ( i , j , k , 1 )) + & sqrt ( gm * x_qp_right ( i , j , k , 5 ) / & x_qp_right ( i , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( gm * y_qp_left ( i , j , k , 5 ) / & y_qp_left ( i , j , k , 1 )) + & sqrt ( gm * y_qp_right ( i , j , k , 5 ) / & y_qp_right ( i , j , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( gm * z_qp_left ( i , j , k , 5 ) / & z_qp_left ( i , j , k , 1 )) + & sqrt ( gm * z_qp_right ( i , j , k , 5 ) / & z_qp_right ( i , j , k , 1 )) ) ! For left face: i.e., lower index face along xi direction lmx1 = abs ( & ( x_speed ( i , j , k ) * xnx ( i , j , k )) + & ( y_speed ( i , j , k ) * xny ( i , j , k )) + & ( z_speed ( i , j , k ) * xnz ( i , j , k ))) + & x_sound_speed_avg ! For front face, i.e., lower index face along eta direction lmx2 = abs ( & ( x_speed ( i , j , k ) * ynx ( i , j , k )) + & ( y_speed ( i , j , k ) * yny ( i , j , k )) + & ( z_speed ( i , j , k ) * ynz ( i , j , k ))) + & y_sound_speed_avg ! For bottom face, i.e., lower index face along zeta direction lmx3 = abs ( & ( x_speed ( i , j , k ) * znx ( i , j , k )) + & ( y_speed ( i , j , k ) * zny ( i , j , k )) + & ( z_speed ( i , j , k ) * znz ( i , j , k ))) + & z_sound_speed_avg ! Faces with higher index x_sound_speed_avg = 0.5 * ( sqrt ( gm * x_qp_left ( i + 1 , j , k , 5 ) / x_qp_left ( i + 1 , j , k , 1 )) + & sqrt ( gm * x_qp_right ( i + 1 , j , k , 5 ) / x_qp_right ( i + 1 , j , k , 1 )) ) y_sound_speed_avg = 0.5 * ( sqrt ( gm * y_qp_left ( i , j + 1 , k , 5 ) / y_qp_left ( i , j + 1 , k , 1 )) + & sqrt ( gm * y_qp_right ( i , j + 1 , k , 5 ) / y_qp_right ( i , j + 1 , k , 1 )) ) z_sound_speed_avg = 0.5 * ( sqrt ( gm * z_qp_left ( i , j , k + 1 , 5 ) / z_qp_left ( i , j , k + 1 , 1 )) + & sqrt ( gm * z_qp_right ( i , j , k + 1 , 5 ) / z_qp_right ( i , j , k + 1 , 1 )) ) ! For right face, i.e., higher index face along xi direction lmx4 = abs ( & ( x_speed ( i + 1 , j , k ) * xnx ( i + 1 , j , k )) + & ( y_speed ( i + 1 , j , k ) * xny ( i + 1 , j , k )) + & ( z_speed ( i + 1 , j , k ) * xnz ( i + 1 , j , k ))) + & x_sound_speed_avg ! For back face, i.e., higher index face along eta direction lmx5 = abs ( & ( x_speed ( i , j + 1 , k ) * ynx ( i , j + 1 , k )) + & ( y_speed ( i , j + 1 , k ) * yny ( i , j + 1 , k )) + & ( z_speed ( i , j + 1 , k ) * ynz ( i , j + 1 , k ))) + & y_sound_speed_avg ! For top face, i.e., higher index face along zeta direction lmx6 = abs ( & ( x_speed ( i , j , k + 1 ) * znx ( i , j , k + 1 )) + & ( y_speed ( i , j , k + 1 ) * zny ( i , j , k + 1 )) + & ( z_speed ( i , j , k + 1 ) * znz ( i , j , k + 1 ))) + & z_sound_speed_avg lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) delta_t ( i , j , k ) = 1. / lmxsum delta_t ( i , j , k ) = delta_t ( i , j , k ) * volume ( i , j , k ) * CFL end do end do end do if ( mu_ref /= 0.0 ) then call add_viscous_time () end if if ( mu_ref /= 0 . and . trim ( turbulence ) /= 'none' ) then call add_turbulent_time () end if end subroutine compute_local_time_step","tags":"","loc":"proc/compute_local_time_step.html","title":"compute_local_time_step – FEST-3D"},{"text":"private subroutine compute_global_time_step() Compute a common time step to be used at all cell centers Global time stepping is generally used to get time \n accurate solutions; transients can be studied by \n employing this strategy. Arguments None Calls proc~~compute_global_time_step~~CallsGraph proc~compute_global_time_step compute_global_time_step proc~compute_local_time_step compute_local_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~dmsg dmsg proc~compute_global_time_step->proc~dmsg proc~compute_local_time_step->proc~dmsg proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time x_qp_right x_qp_right proc~compute_local_time_step->x_qp_right x_qp_left x_qp_left proc~compute_local_time_step->x_qp_left y_qp_left y_qp_left proc~compute_local_time_step->y_qp_left z_qp_left z_qp_left proc~compute_local_time_step->z_qp_left y_qp_right y_qp_right proc~compute_local_time_step->y_qp_right z_qp_right z_qp_right proc~compute_local_time_step->z_qp_right proc~add_viscous_time->proc~dmsg proc~add_turbulent_time->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_global_time_step~~CalledByGraph proc~compute_global_time_step compute_global_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_global_time_stepCalledByGraph = svgPanZoom('#proccompute_global_time_stepCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_global_time_step Source Code subroutine compute_global_time_step () !< Compute a common time step to be used at all cell centers !< !< Global time stepping is generally used to get time !< accurate solutions; transients can be studied by !< employing this strategy. !<----------------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'compute_global_time_step' ) if ( global_time_step > 0 ) then delta_t = global_time_step else call compute_local_time_step () ! The global time step is the minimum of all the local time ! steps. delta_t = minval ( delta_t ) end if end subroutine compute_global_time_step","tags":"","loc":"proc/compute_global_time_step.html","title":"compute_global_time_step – FEST-3D"},{"text":"public subroutine compute_time_step() Compute the time step to be used This calls either compute_global_time_step() or \n compute_local_time_step() based on what \n time_stepping_method is set to. Arguments None Calls proc~~compute_time_step~~CallsGraph proc~compute_time_step compute_time_step proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock proc~dmsg dmsg proc~compute_time_step->proc~dmsg proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~compute_local_time_step->proc~dmsg proc~add_viscous_time add_viscous_time proc~compute_local_time_step->proc~add_viscous_time proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step->proc~add_turbulent_time x_qp_right x_qp_right proc~compute_local_time_step->x_qp_right x_qp_left x_qp_left proc~compute_local_time_step->x_qp_left y_qp_left y_qp_left proc~compute_local_time_step->y_qp_left z_qp_left z_qp_left proc~compute_local_time_step->z_qp_left y_qp_right y_qp_right proc~compute_local_time_step->y_qp_right z_qp_right z_qp_right proc~compute_local_time_step->z_qp_right proc~compute_global_time_step->proc~compute_local_time_step proc~compute_global_time_step->proc~dmsg proc~add_viscous_time->proc~dmsg proc~add_turbulent_time->proc~dmsg var panproccompute_time_stepCallsGraph = svgPanZoom('#proccompute_time_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_time_step~~CalledByGraph proc~compute_time_step compute_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_time_step Source Code subroutine compute_time_step () !< Compute the time step to be used !< !< This calls either compute_global_time_step() or !< compute_local_time_step() based on what !< time_stepping_method is set to. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'compute_time_step' ) if ( time_stepping_method . eq . 'g' ) then call compute_global_time_step () else if ( time_stepping_method . eq . 'l' ) then call compute_local_time_step () else call dmsg ( 5 , 'solver' , 'compute_time_step' , & msg = 'Value for time_stepping_method (' // & time_stepping_method // ') not recognized.' ) stop end if !update_simulation clock call update_simulation_clock () end subroutine compute_time_step","tags":"","loc":"proc/compute_time_step.html","title":"compute_time_step – FEST-3D"},{"text":"public subroutine update_simulation_clock() Update the simulation clock It is sometimes useful to know what the simulation time is\n  at every iteration so that a comparison with an analytical\n  solution is possible. Since, the global timesteps used may\n  not be uniform, we need to track this explicitly. Of course, it makes sense to track this only if the time \n  stepping is global and not local. If the time stepping is\n  local, the simulation clock is set to -1. If it is global\n  it is incremented according to the time step found. Arguments None Called by proc~~update_simulation_clock~~CalledByGraph proc~update_simulation_clock update_simulation_clock proc~compute_time_step compute_time_step proc~compute_time_step->proc~update_simulation_clock proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_simulation_clockCalledByGraph = svgPanZoom('#procupdate_simulation_clockCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_simulation_clock Source Code subroutine update_simulation_clock !<  Update the simulation clock !< !<  It is sometimes useful to know what the simulation time is !<  at every iteration so that a comparison with an analytical !<  solution is possible. Since, the global timesteps used may !<  not be uniform, we need to track this explicitly. !< !<  Of course, it makes sense to track this only if the time !<  stepping is global and not local. If the time stepping is !<  local, the simulation clock is set to -1. If it is global !<  it is incremented according to the time step found. !----------------------------------------------------------- implicit none if ( time_stepping_method . eq . 'g' . and . sim_clock >= 0. ) then sim_clock = sim_clock + minval ( delta_t ) else if ( time_stepping_method . eq . 'l' ) then sim_clock = - 1 end if end subroutine update_simulation_clock","tags":"","loc":"proc/update_simulation_clock.html","title":"update_simulation_clock – FEST-3D"},{"text":"private subroutine add_viscous_time() Addition to local time step due to viscous effects Arguments None Calls proc~~add_viscous_time~~CallsGraph proc~add_viscous_time add_viscous_time proc~dmsg dmsg proc~add_viscous_time->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_viscous_time~~CalledByGraph proc~add_viscous_time add_viscous_time proc~compute_local_time_step compute_local_time_step proc~compute_local_time_step->proc~add_viscous_time proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_viscous_timeCalledByGraph = svgPanZoom('#procadd_viscous_timeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_viscous_time Source Code subroutine add_viscous_time () !< Addition to local time step due to viscous effects implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k call dmsg ( 1 , 'time' , 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i - 1 , j , k , 1 ) - CellCenter ( i , j , k , 1 )) * xnx ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 2 ) - CellCenter ( i , j , k , 2 )) * xny ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 3 ) - CellCenter ( i , j , k , 3 )) * xnz ( i , j , k )))) ! For front face, i.e., lower index face along eta direction lmx2 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j - 1 , k , 1 ) - CellCenter ( i , j , k , 1 )) * ynx ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 2 ) - CellCenter ( i , j , k , 2 )) * yny ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 3 ) - CellCenter ( i , j , k , 3 )) * ynz ( i , j , k )))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j , k - 1 , 1 ) - CellCenter ( i , j , k , 1 )) * znx ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 2 ) - CellCenter ( i , j , k , 2 )) * zny ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 3 ) - CellCenter ( i , j , k , 3 )) * znz ( i , j , k )))) ! For right face, i.e., higher index face along xi direction lmx4 = mu ( i + 1 , j , k ) / ( density ( i + 1 , j , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i + 1 , j , k , 1 )) * xnx ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i + 1 , j , k , 2 )) * xny ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i + 1 , j , k , 3 )) * xnz ( i + 1 , j , k )))) ! For back face, i.e., higher index face along eta direction lmx5 = mu ( i , j + 1 , k ) / ( density ( i , j + 1 , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j + 1 , k , 1 )) * ynx ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j + 1 , k , 2 )) * yny ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j + 1 , k , 3 )) * ynz ( i , j + 1 , k )))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu ( i , j , k + 1 ) / ( density ( i , j , k + 1 ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j , k + 1 , 1 )) * znx ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j , k + 1 , 2 )) * zny ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j , k + 1 , 3 )) * znz ( i , j , k + 1 )))) lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) lmxsum = gm * lmxsum / Pr lmxsum = 2. / ( lmxsum + ( 2. * CFL * volume ( i , j , k ) / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * volume ( i , j , k )) end do end do end do end subroutine add_viscous_time","tags":"","loc":"proc/add_viscous_time.html","title":"add_viscous_time – FEST-3D"},{"text":"private subroutine add_turbulent_time() Addition to local time step due to turbulence Arguments None Calls proc~~add_turbulent_time~~CallsGraph proc~add_turbulent_time add_turbulent_time proc~dmsg dmsg proc~add_turbulent_time->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_turbulent_time~~CalledByGraph proc~add_turbulent_time add_turbulent_time proc~compute_local_time_step compute_local_time_step proc~compute_local_time_step->proc~add_turbulent_time proc~compute_global_time_step compute_global_time_step proc~compute_global_time_step->proc~compute_local_time_step proc~compute_time_step compute_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_time_step->proc~compute_global_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~compute_time_step proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_turbulent_timeCalledByGraph = svgPanZoom('#procadd_turbulent_timeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_turbulent_time Source Code subroutine add_turbulent_time () !< Addition to local time step due to turbulence implicit none real :: lmx1 , lmx2 , lmx3 , lmx4 , lmx5 , lmx6 , lmxsum integer :: i , j , k call dmsg ( 1 , 'time' , 'add_viscous_time_step' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! Faces with lower index ! For left face: i.e., lower index face along xi direction lmx1 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i - 1 , j , k , 1 ) - CellCenter ( i , j , k , 1 )) * xnx ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 2 ) - CellCenter ( i , j , k , 2 )) * xny ( i , j , k )) + & (( CellCenter ( i - 1 , j , k , 3 ) - CellCenter ( i , j , k , 3 )) * xnz ( i , j , k )))) ! For front face, i.e., lower index face along eta direction lmx2 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j - 1 , k , 1 ) - CellCenter ( i , j , k , 1 )) * ynx ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 2 ) - CellCenter ( i , j , k , 2 )) * yny ( i , j , k )) + & (( CellCenter ( i , j - 1 , k , 3 ) - CellCenter ( i , j , k , 3 )) * ynz ( i , j , k )))) ! For bottom face, i.e., lower index face along zeta direction lmx3 = mu_t ( i , j , k ) / ( density ( i , j , k ) * abs ( & (( CellCenter ( i , j , k - 1 , 1 ) - CellCenter ( i , j , k , 1 )) * znx ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 2 ) - CellCenter ( i , j , k , 2 )) * zny ( i , j , k )) + & (( CellCenter ( i , j , k - 1 , 3 ) - CellCenter ( i , j , k , 3 )) * znz ( i , j , k )))) ! For right face, i.e., higher index face along xi direction lmx4 = mu_t ( i + 1 , j , k ) / ( density ( i + 1 , j , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i + 1 , j , k , 1 )) * xnx ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i + 1 , j , k , 2 )) * xny ( i + 1 , j , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i + 1 , j , k , 3 )) * xnz ( i + 1 , j , k )))) ! For back face, i.e., higher index face along eta direction lmx5 = mu_t ( i , j + 1 , k ) / ( density ( i , j + 1 , k ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j + 1 , k , 1 )) * ynx ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j + 1 , k , 2 )) * yny ( i , j + 1 , k )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j + 1 , k , 3 )) * ynz ( i , j + 1 , k )))) ! For top face, i.e., higher index face along zeta direction lmx6 = mu_t ( i , j , k + 1 ) / ( density ( i , j , k + 1 ) * abs ( & (( CellCenter ( i , j , k , 1 ) - CellCenter ( i , j , k + 1 , 1 )) * znx ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 2 ) - CellCenter ( i , j , k + 1 , 2 )) * zny ( i , j , k + 1 )) + & (( CellCenter ( i , j , k , 3 ) - CellCenter ( i , j , k + 1 , 3 )) * znz ( i , j , k + 1 )))) lmxsum = ( xA ( i , j , k ) * lmx1 ) + & ( yA ( i , j , k ) * lmx2 ) + & ( zA ( i , j , k ) * lmx3 ) + & ( xA ( i + 1 , j , k ) * lmx4 ) + & ( yA ( i , j + 1 , k ) * lmx5 ) + & ( zA ( i , j , k + 1 ) * lmx6 ) lmxsum = gm * lmxsum / tPr lmxsum = 2. / ( lmxsum + ( 2. * CFL * volume ( i , j , k ) / delta_t ( i , j , k ))) delta_t ( i , j , k ) = CFL * ( lmxsum * volume ( i , j , k )) end do end do end do end subroutine add_turbulent_time","tags":"","loc":"proc/add_turbulent_time.html","title":"add_turbulent_time – FEST-3D"},{"text":"public subroutine setupCC() Allocate memory for the cell center variable only in case of transition model Arguments None Calls proc~~setupcc~~CallsGraph proc~setupcc setupCC interface~alloc alloc proc~setupcc->interface~alloc debugcall debugcall proc~setupcc->debugcall aerrmsg aerrmsg proc~setupcc->aerrmsg proc~find_ccnormal find_CCnormal proc~setupcc->proc~find_ccnormal proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~compute_gradient compute_gradient proc~find_ccnormal->proc~compute_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setupcc~~CalledByGraph proc~setupcc setupCC proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setupCC Source Code subroutine setupCC () !< Allocate memory for the cell center variable only in case of transition model implicit none DebugCall ( \"Setup CC\" ) if (( transition == 'lctm2015' ) . and . turbulence /= 'none' ) then call alloc ( CCnormalX , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalX\" )) call alloc ( CCnormalY , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalY\" )) call alloc ( CCnormalZ , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCnormalZ\" )) call alloc ( CCVn , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"CCVn\" )) call alloc ( DCCVnX , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call alloc ( DCCVnY , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnY\" )) call alloc ( DCCVnZ , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , AErrMsg ( \"DCCVnZ\" )) call find_CCnormal () end if end subroutine setupCC","tags":"","loc":"proc/setupcc.html","title":"setupCC – FEST-3D"},{"text":"public subroutine destroyCC() Deallocate memory from the cell-center variables Arguments None Calls proc~~destroycc~~CallsGraph proc~destroycc destroyCC interface~dealloc dealloc proc~destroycc->interface~dealloc debugcall debugcall proc~destroycc->debugcall proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroycc~~CalledByGraph proc~destroycc destroyCC proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroycc proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroyCC Source Code subroutine destroyCC () !< Deallocate memory from the cell-center variables implicit none DebugCall ( \"Destroy CC\" ) call dealloc ( CCnormalX ) call dealloc ( CCnormalY ) call dealloc ( CCnormalZ ) call dealloc ( CCVn ) call dealloc ( DCCVnX ) call dealloc ( DCCVnY ) call dealloc ( DCCVnZ ) end subroutine destroyCC","tags":"","loc":"proc/destroycc.html","title":"destroyCC – FEST-3D"},{"text":"private subroutine find_CCnormal() Find the cell-center unit normal Arguments None Calls proc~~find_ccnormal~~CallsGraph proc~find_ccnormal find_CCnormal proc~compute_gradient compute_gradient proc~find_ccnormal->proc~compute_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_ccnormal~~CalledByGraph proc~find_ccnormal find_CCnormal proc~setupcc setupCC proc~setupcc->proc~find_ccnormal proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_CCnormal Source Code subroutine find_CCnormal () !< Find the cell-center unit normal implicit none call compute_gradient ( CCnormalX , dist , 'x' ) call compute_gradient ( CCnormalY , dist , 'y' ) call compute_gradient ( CCnormalZ , dist , 'z' ) !using already allocated memeory for storing magnitude CCVn = sqrt ( CCnormalX ** 2 + CCnormalY ** 2 + CCnormalZ ** 2 ) !CCVn hold the magnitude of CCnormal temporaraly and can be !overwritten after next three lines of code. CCnormalX = CCnormalX / ( CCVn + 1 e - 12 ) CCnormalY = CCnormalY / ( CCVn + 1 e - 12 ) CCnormalZ = CCnormalZ / ( CCVn + 1 e - 12 ) end subroutine find_CCnormal","tags":"","loc":"proc/find_ccnormal.html","title":"find_CCnormal – FEST-3D"},{"text":"private subroutine find_CCVn() Taking a dot product between Cell-center velocity and unit normal Arguments None Called by proc~~find_ccvn~~CalledByGraph proc~find_ccvn find_CCVn proc~find_dccvn find_DCCVn proc~find_dccvn->proc~find_ccvn proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfind_ccvnCalledByGraph = svgPanZoom('#procfind_ccvnCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_CCVn Source Code subroutine find_CCVn () !< Taking a dot product between Cell-center velocity and unit normal implicit none CCVn = CCnormalX * x_speed + CCnormalY * y_speed + CCnormalZ * z_speed end subroutine find_CCVn","tags":"","loc":"proc/find_ccvn.html","title":"find_CCVn – FEST-3D"},{"text":"public subroutine find_DCCVn() Find gradient of the dot product between cell velocity and unit normal Arguments None Calls proc~~find_dccvn~~CallsGraph proc~find_dccvn find_DCCVn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_dccvn~~CalledByGraph proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfind_dccvnCalledByGraph = svgPanZoom('#procfind_dccvnCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_DCCVn Source Code subroutine find_DCCVn () !< Find gradient of the dot product between cell velocity and unit normal implicit none call find_CCVn () call compute_gradient ( DCCVnX , dist , 'x' ) call compute_gradient ( DCCVnY , dist , 'y' ) call compute_gradient ( DCCVnZ , dist , 'z' ) end subroutine find_DCCVn","tags":"","loc":"proc/find_dccvn.html","title":"find_DCCVn – FEST-3D"},{"text":"private subroutine compute_gradient(grad, var, dir) Generalized subroutine to calculate gradients Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: grad real, intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: var character(len=*), intent(in) :: dir Called by proc~~compute_gradient~~CalledByGraph proc~compute_gradient compute_gradient proc~find_ccnormal find_CCnormal proc~find_ccnormal->proc~compute_gradient proc~find_dccvn find_DCCVn proc~find_dccvn->proc~compute_gradient proc~setupcc setupCC proc~setupcc->proc~find_ccnormal proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_sst_source_lctm2015->proc~find_dccvn proc~setup_solver setup_solver proc~setup_solver->proc~setupcc proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run proc~iterate_one_more_time_step iterate_one_more_time_step program~main->proc~iterate_one_more_time_step proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step->proc~get_next_solution var panproccompute_gradientCalledByGraph = svgPanZoom('#proccompute_gradientCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_gradient Source Code subroutine compute_gradient ( grad , var , dir ) !< Generalized subroutine to calculate gradients implicit none real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( out ) :: grad real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: var character ( len =* ) , intent ( in ) :: dir real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k ! initialize grad = 0.0 select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * nx ( i , j , k ) * xA ( i , j , k ) & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * ny ( i , j , k ) * yA ( i , j , k ) & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * nz ( i , j , k ) * zA ( i , j , k ) & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient","tags":"","loc":"proc/compute_gradient.html","title":"compute_gradient – FEST-3D"},{"text":"public subroutine evaluate_all_gradients() Call to all the required gradients and \n apply boundary condition for ghost cell\n gradients Arguments None Calls proc~~evaluate_all_gradients~~CallsGraph proc~evaluate_all_gradients evaluate_all_gradients proc~dmsg dmsg proc~evaluate_all_gradients->proc~dmsg proc~compute_gradient_g compute_gradient_G proc~evaluate_all_gradients->proc~compute_gradient_g proc~compute_gradient_t compute_gradient_T proc~evaluate_all_gradients->proc~compute_gradient_t proc~apply_gradient_bc apply_gradient_bc proc~evaluate_all_gradients->proc~apply_gradient_bc proc~apply_gradient_bc->proc~dmsg proc~apply apply proc~apply_gradient_bc->proc~apply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~evaluate_all_gradients~~CalledByGraph proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocevaluate_all_gradientsCalledByGraph = svgPanZoom('#procevaluate_all_gradientsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code evaluate_all_gradients Source Code subroutine evaluate_all_gradients () !< Call to all the required gradients and !< apply boundary condition for ghost cell !< gradients implicit none call dmsg ( 1 , 'summon_grad_evaluation' , 'evaluate_all_gradients' ) call compute_gradient_G ( gradu_x , x_speed , 'x' ) call compute_gradient_G ( gradv_x , y_speed , 'x' ) call compute_gradient_G ( gradw_x , z_speed , 'x' ) call compute_gradient_T ( gradT_x , 'x' ) call compute_gradient_G ( gradu_y , x_speed , 'y' ) call compute_gradient_G ( gradv_y , y_speed , 'y' ) call compute_gradient_G ( gradw_y , z_speed , 'y' ) call compute_gradient_T ( gradT_y , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradu_z , x_speed , 'z' ) call compute_gradient_G ( gradv_z , y_speed , 'z' ) call compute_gradient_G ( gradw_z , z_speed , 'z' ) call compute_gradient_T ( gradT_z , 'z' ) else gradqp_z = 0.0 end if !      include \"compute_gradu_x.inc\" !      include \"compute_gradu_y.inc\" !      include \"compute_gradv_x.inc\" !      include \"compute_gradv_y.inc\" !      include \"compute_gradw_x.inc\" !      include \"compute_gradw_y.inc\" !      include \"compute_gradT_x.inc\" !      include \"compute_gradT_y.inc\" !      if(kmx>2) then !      include \"compute_gradu_z.inc\" !      include \"compute_gradv_z.inc\" !      include \"compute_gradw_z.inc\" !      include \"compute_gradT_z.inc\" !      else !      gradqp_z=0.0 !      end if select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call compute_gradient_G ( gradtv_x , tv , 'x' ) call compute_gradient_G ( gradtv_y , tv , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtv_z , tv , 'z' ) end if case ( 'sst' , 'sst2003' ) call compute_gradient_G ( gradtk_x , tk , 'x' ) call compute_gradient_G ( gradtw_x , tw , 'x' ) call compute_gradient_G ( gradtk_y , tk , 'y' ) call compute_gradient_G ( gradtw_y , tw , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , 'z' ) call compute_gradient_G ( gradtw_z , tw , 'z' ) end if case ( 'kkl' ) call compute_gradient_G ( gradtk_x , tk , 'x' ) call compute_gradient_G ( gradtkl_x , tkl , 'x' ) call compute_gradient_G ( gradtk_y , tk , 'y' ) call compute_gradient_G ( gradtkl_y , tkl , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtk_z , tk , 'z' ) call compute_gradient_G ( gradtkl_z , tkl , 'z' ) end if case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call compute_gradient_G ( gradtgm_x , tgm , 'x' ) call compute_gradient_G ( gradtgm_y , tgm , 'y' ) if ( kmx > 2 ) then call compute_gradient_G ( gradtgm_z , tgm , 'z' ) end if case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select !gradqp_z=0.0 !applying boundary condition to gradients call apply_gradient_bc () end subroutine evaluate_all_gradients","tags":"","loc":"proc/evaluate_all_gradients.html","title":"evaluate_all_gradients – FEST-3D"},{"text":"private subroutine compute_gradient_G(grad, var, dir) Compute gradient of any input scalar Arguments Type Intent Optional Attributes Name real, intent(out), dimension( 0:imx  , 0:jmx  , 0:kmx  ) :: grad Output variable storing the graident of var real, intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: var Input variable of which graident is required character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated Called by proc~~compute_gradient_g~~CalledByGraph proc~compute_gradient_g compute_gradient_G proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~compute_gradient_g proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_gradient_gCalledByGraph = svgPanZoom('#proccompute_gradient_gCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_gradient_G Source Code subroutine compute_gradient_G ( grad , var , dir ) !<  Compute gradient of any input scalar implicit none real , dimension ( 0 : imx , 0 : jmx , 0 : kmx ), intent ( out ) :: grad !< Output variable storing the graident of var real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( in ) :: var !< Input variable of which graident is required character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx grad ( i , j , k ) = ( - ( var ( i - 1 , j , k ) + var ( i , j , k )) * nx ( i , j , k ) * xA ( i , j , k ) & - ( var ( i , j - 1 , k ) + var ( i , j , k )) * ny ( i , j , k ) * yA ( i , j , k ) & - ( var ( i , j , k - 1 ) + var ( i , j , k )) * nz ( i , j , k ) * zA ( i , j , k ) & + ( var ( i + 1 , j , k ) + var ( i , j , k )) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( var ( i , j + 1 , k ) + var ( i , j , k )) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( var ( i , j , k + 1 ) + var ( i , j , k )) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_G","tags":"","loc":"proc/compute_gradient_g.html","title":"compute_gradient_G – FEST-3D"},{"text":"private subroutine compute_gradient_T(grad, dir) Calculate gradient of temperature Arguments Type Intent Optional Attributes Name real, intent(out), dimension( 0:imx  , 0:jmx  , 0:kmx  ) :: grad Output gradient of termperature character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated Called by proc~~compute_gradient_t~~CalledByGraph proc~compute_gradient_t compute_gradient_T proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~compute_gradient_t proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccompute_gradient_tCalledByGraph = svgPanZoom('#proccompute_gradient_tCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_gradient_T Source Code subroutine compute_gradient_T ( grad , dir ) !< Calculate gradient of temperature implicit none real , dimension ( 0 : imx , 0 : jmx , 0 : kmx ), intent ( out ) :: grad !< Output gradient of termperature character ( len =* ) , intent ( in ) :: dir !< Direction with respect to which gradients are calculated real , dimension ( 6 ) :: T real :: cell_T real , dimension (:,:,:), pointer :: nx real , dimension (:,:,:), pointer :: ny real , dimension (:,:,:), pointer :: nz integer :: i integer :: j integer :: k select case ( dir ) case ( 'x' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) case ( 'y' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) case ( 'z' ) nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) case DEFAULT nx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) ny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) nz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) print * , \"ERROR: gradient direction error\" end select grad = 0.0 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx cell_T = ( pressure ( i , j , k ) / density ( i , j , k )) / R_gas T ( 1 ) = ( pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) / R_gas + cell_T T ( 2 ) = ( pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) / R_gas + cell_T T ( 3 ) = ( pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) / R_gas + cell_T T ( 4 ) = ( pressure ( i + 1 , j , k ) / density ( i + 1 , j , k )) / R_gas + cell_T T ( 5 ) = ( pressure ( i , j + 1 , k ) / density ( i , j + 1 , k )) / R_gas + cell_T T ( 6 ) = ( pressure ( i , j , k + 1 ) / density ( i , j , k + 1 )) / R_gas + cell_T grad ( i , j , k ) = ( - T ( 1 ) * nx ( i , j , k ) * xA ( i , j , k ) & - T ( 2 ) * ny ( i , j , k ) * yA ( i , j , k ) & - T ( 3 ) * nz ( i , j , k ) * zA ( i , j , k ) & + T ( 4 ) * nx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + T ( 5 ) * ny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + T ( 6 ) * nz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) end do end do end do if ( any ( isnan ( grad ))) then Fatal_error end if end subroutine compute_gradient_T","tags":"","loc":"proc/compute_gradient_t.html","title":"compute_gradient_T – FEST-3D"},{"text":"public subroutine add_source_term_residue() Call to add different source terms to the residual of different equations. Arguments None Calls proc~~add_source_term_residue~~CallsGraph proc~add_source_term_residue add_source_term_residue proc~dmsg dmsg proc~add_source_term_residue->proc~dmsg proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~add_kkl_source add_kkl_source proc~add_source_term_residue->proc~add_kkl_source proc~add_sst_bc_source add_sst_bc_source proc~add_source_term_residue->proc~add_sst_bc_source proc~add_sabc_source add_saBC_source proc~add_source_term_residue->proc~add_sabc_source proc~add_sst_source add_sst_source proc~add_source_term_residue->proc~add_sst_source proc~add_sa_source add_sa_source proc~add_source_term_residue->proc~add_sa_source proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015->proc~find_dccvn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_source_term_residue~~CalledByGraph proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_source_term_residueCalledByGraph = svgPanZoom('#procadd_source_term_residueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_source_term_residue Source Code subroutine add_source_term_residue () !< Call to add different source terms to the residual of different equations. implicit none call dmsg ( 1 , 'source' , 'add_source_term_residue' ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' ) select case ( trim ( transition )) case ( 'none' ) call add_sa_source () case ( 'bc' ) call add_saBC_source () case DEFAULT Fatal_error end select case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' ) call add_sst_source () case ( 'lctm2015' ) call add_sst_source_lctm2015 () case ( 'bc' ) call add_sst_bc_source () case DEFAULT Fatal_error end select case ( 'kkl' ) call add_kkl_source () case DEFAULT Fatal_error end select end subroutine add_source_term_residue","tags":"","loc":"proc/add_source_term_residue.html","title":"add_source_term_residue – FEST-3D"},{"text":"public subroutine Setup_source() Allcoate memory to the required by the variable Arguments None Called by proc~~setup_source~~CalledByGraph proc~setup_source Setup_source proc~setup_solver setup_solver proc~setup_solver->proc~setup_source proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code Setup_source Source Code subroutine Setup_source () !< Allcoate memory to the required by the variable implicit none !nothing end subroutine Setup_source","tags":"","loc":"proc/setup_source.html","title":"Setup_source – FEST-3D"},{"text":"public subroutine destroy_source() deallocate memory before stoping the solver Arguments None Called by proc~~destroy_source~~CalledByGraph proc~destroy_source destroy_source proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_source proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_source Source Code subroutine destroy_source () !< deallocate memory before stoping the solver implicit none !nothing end subroutine destroy_source","tags":"","loc":"proc/destroy_source.html","title":"destroy_source – FEST-3D"},{"text":"private subroutine add_sst_source() Add residual due to source terms of the SST turbulence model Arguments None Called by proc~~add_sst_source~~CalledByGraph proc~add_sst_source add_sst_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_sourceCalledByGraph = svgPanZoom('#procadd_sst_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_source Source Code subroutine add_sst_source () !< Add residual due to source terms of the SST turbulence model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_k real :: S_w real :: D_k real :: D_w real :: P_k real :: P_w real :: lamda integer :: limiter real :: divergence if ( trim ( turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = sst_mu ( i , j , k ) * ( vort ** 2 ) - (( 2.0 / 3.0 ) * density ( i , j , k ) * tk ( i , j , k ) * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w end do end do end do end subroutine add_sst_source","tags":"","loc":"proc/add_sst_source.html","title":"add_sst_source – FEST-3D"},{"text":"private subroutine add_sst_source_lctm2015() Add residual due to source terms of the LCTM2015 transition model Arguments None Calls proc~~add_sst_source_lctm2015~~CallsGraph proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~find_dccvn find_DCCVn proc~add_sst_source_lctm2015->proc~find_dccvn proc~compute_gradient compute_gradient proc~find_dccvn->proc~compute_gradient proc~find_ccvn find_CCVn proc~find_dccvn->proc~find_ccvn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~add_sst_source_lctm2015~~CalledByGraph proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_source_lctm2015CalledByGraph = svgPanZoom('#procadd_sst_source_lctm2015CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_source_lctm2015 Source Code subroutine add_sst_source_lctm2015 () !< Add residual due to source terms of the LCTM2015 transition model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_K real :: S_w real :: S_gm real :: D_k real :: D_w real :: D_gm real :: P_k real :: P_w real :: P_gm real :: lamda real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: intermittency real :: Pk_lim real :: Fon_lim real :: dudx real :: dudy real :: dudz real :: duds real :: velmag real :: u , v , w real :: lamd real :: Fpg real :: divergence real :: dvdy integer :: limiter if ( trim ( turbulence ) == 'sst2003' ) then limiter = 10 gama1 = 5.0 / 9.0 gama2 = 0.44 else limiter = 20 end if !for pressure gradient calculation call find_DCCVn () do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 intermittency = qp ( i , j , k , n_var ) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( ((( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 ) & + (( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 ) & + (( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 ) & + 2 * ( gradu_x ( i , j , k ) ** 2 ) & + 2 * ( gradv_y ( i , j , k ) ** 2 ) & + 2 * ( gradw_z ( i , j , k ) ** 2 ) & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) CD = max ( CD , 1 0.0 ** ( - limiter )) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ divergence = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) P_k = sst_mu ( i , j , k ) * ( vort * strain ) - (( 2.0 / 3.0 ) * density ( i , j , k ) * tk ( i , j , k ) * divergence ) P_k = min ( P_k , limiter * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ ! --pressure gradient !            u = qp(i,j,k,2) !            v = qp(i,j,k,3) !            w = qp(i,j,k,4) !            velmag = sqrt((u**2) + (v**2) + (w**2)) !            dudx = 0.5*((2.0*u*gradu_x(i,j,k)) + (2.0*v*gradv_x(i,j,k)) + (2.0*w*gradw_x(i,j,k)))/velmag !            dudy = 0.5*((2.0*u*gradu_y(i,j,k)) + (2.0*v*gradv_y(i,j,k)) + (2.0*w*gradw_y(i,j,k)))/velmag !            dudz = 0.5*((2.0*u*gradu_z(i,j,k)) + (2.0*v*gradv_z(i,j,k)) + (2.0*w*gradw_z(i,j,k)))/velmag !            duds = (((u/velmag)*dudx) + ((v/velmag)*dudy) + ((w/velmag)*dudz)) !            !lamd =(-7.57e-3)*(duds*dist(i,j,k)*dist(i,j,k)*density(i,j,k)/mu(i,j,k)) + 0.0128 !            lamd =(+7.57e-3)*(duds*dist(i,j,k)*dist(i,j,k)*density(i,j,k)/mu(i,j,k)) + 0.0128 dvdy = DCCVnX ( i , j , k ) * CCnormalX ( i , j , k ) & + DCCVnY ( i , j , k ) * CCnormalY ( i , j , k ) & + DCCVnZ ( i , j , k ) * CCnormalZ ( i , j , k ) lamd = ( - 7.57e-3 ) * ( dvdy * dist ( i , j , k ) * dist ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k )) + 0.0128 lamd = min ( max ( lamd , - 1.0 ), 1.0 ) if ( lamd >= 0.0 ) then Fpg = min ( 1.0 + 1 4.68 * lamd , 1.5 ) else Fpg = min ( 1.0 - 7.34 * lamd , 3.0 ) end if Fpg = max ( Fpg , 0.0 ) ! --gradient TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL * Fpg ) !Re_theta = 100.0 + 1000.0*exp(-TuL) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) P_gm = 100 * density ( i , j , k ) * strain * intermittency * ( 1.0 - intermittency ) * Fonset D_gm = 0.06 * density ( i , j , k ) * vort * intermittency * Fturb * (( 5 0.0 * intermittency ) - 1.0 ) Fon_lim = min ( max (( Rev / ( 2.2 * 110 0.0 )) - 1.0 , 0.0 ), 3.0 ) Pk_lim = 5 * max ( intermittency - 0.2 , 0.0 ) * ( 1.0 - intermittency ) * Fon_lim * max ( 3 * mu ( i , j , k ) - mu_t ( i , j , k ), 0.0 ) * strain * vort S_k = intermittency * P_k - max ( intermittency , 0.1 ) * D_k + Pk_lim !Source term gm S_W = P_w - D_w + lamda !Source term gm S_gm = P_gm - D_gm !Source term gm S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) S_gm = S_gm * Volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w residue ( i , j , k , n_var ) = residue ( i , j , k , n_var ) - S_gm end do end do end do end subroutine add_sst_source_lctm2015","tags":"","loc":"proc/add_sst_source_lctm2015.html","title":"add_sst_source_lctm2015 – FEST-3D"},{"text":"private subroutine add_sst_bc_source() Add residual due to source terms of the SST-BC transition model Arguments None Called by proc~~add_sst_bc_source~~CalledByGraph proc~add_sst_bc_source add_sst_bc_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sst_bc_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sst_bc_sourceCalledByGraph = svgPanZoom('#procadd_sst_bc_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sst_bc_source Source Code subroutine add_sst_bc_source () !< Add residual due to source terms of the SST-BC transition model implicit none integer :: i , j , k real :: CD real :: F1 real :: vort real :: S_k real :: S_w real :: D_k real :: D_w real :: P_k real :: P_w real :: lamda real :: TuL !--------BC model ----- real :: chi_1 = 0.002 real :: chi_2 = 5.0 real :: nu_BC real :: nu_cr real :: nu_t real :: re_v real :: re_theta real :: re_theta_t real :: term1 real :: term2 real :: term_exponential real :: gamma_BC real :: vmag do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) CD = 2 * density ( i , j , k ) * sigma_w2 * ( gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ) !CD = max(CD, 1e-20) F1 = sst_F1 ( i , j , k ) sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1. - F1 ) sigma_w = sigma_w1 * F1 + sigma_w1 * ( 1. - F1 ) gama = gama1 * F1 + gama2 * ( 1. - F1 ) beta = beta1 * F1 + beta2 * ( 1. - F1 ) ! ____ Dissipation term ___ D_k = bstar * density ( i , j , k ) * tw ( i , j , k ) * tk ( i , j , k ) D_w = beta * density ( i , j , k ) * tw ( i , j , k ) ** 2 ! ____ PRODUCTION term____ P_k = sst_mu ( i , j , k ) * ( vort ** 2 ) P_k = min ( P_k , 2 0.0 * D_k ) P_w = ( density ( i , j , k ) * gama / sst_mu ( i , j , k )) * P_k ! ____ cross diffusion term ___ lamda = ( 1. - F1 ) * CD ! ____Transition modeling  ____ !------ BC model --- vmag = sqrt ( SUM ( qp ( i , j , k , 2 : 4 ) ** 2 )) chi_1 = 0.002 chi_2 = 5.0 nu_t = mu_t ( i , j , k ) / density ( i , j , k ) nu_cr = chi_2 / Reynolds_number nu_bc = nu_t / ( vmag * dist ( i , j , k )) !TuL = min(100.0*sqrt(2.0*tk(i,j,k)/3.0)/(tw(i,j,k)*dist(i,j,k)),100.0) TuL = free_stream_tu !local turbulence intensity might not work for BC model re_v = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * vort / mu ( i , j , k ) re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( TuL + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 100.0 + 1000.0*exp(-TuL) !re_theta_t = 163.0 + exp(6.91 - TuL) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) P_k = gamma_BC * P_k S_k = P_k - D_k !Source term TKE S_w = P_w - D_w + lamda !source term omega S_k = S_k * volume ( i , j , k ) S_w = S_w * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k omega_residue ( i , j , k ) = omega_residue ( i , j , k ) - S_w end do end do end do end subroutine add_sst_bc_source","tags":"","loc":"proc/add_sst_bc_source.html","title":"add_sst_bc_source – FEST-3D"},{"text":"private subroutine add_kkl_source() Add residual due to source terms of the k-kL turbulence model Arguments None Called by proc~~add_kkl_source~~CalledByGraph proc~add_kkl_source add_kkl_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_kkl_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_kkl_sourceCalledByGraph = svgPanZoom('#procadd_kkl_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_kkl_source Source Code subroutine add_kkl_source () !< Add residual due to source terms of the k-kL turbulence model implicit none integer :: i , j , k real :: Tau11 real :: Tau12 real :: Tau13 real :: Tau21 real :: Tau22 real :: Tau23 real :: Tau31 real :: Tau32 real :: Tau33 real :: S11 real :: S12 real :: S13 real :: S21 real :: S22 real :: S23 real :: S31 real :: S32 real :: S33 real :: delv real :: d2udx2 real :: d2udy2 real :: d2udz2 real :: d2vdx2 real :: d2vdy2 real :: d2vdz2 real :: d2wdx2 real :: d2wdy2 real :: d2wdz2 real :: Lvk real :: fp real :: ud real :: udd real :: S_k real :: S_kl real :: D_k real :: D_kl real :: P_k real :: P_kl !change for transition modeling real :: vort real :: Rev real :: Rev1 real :: ReThc real :: Tu real :: term1 do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 S11 = 0.5 * ( gradu_x ( i , j , k ) + gradu_x ( i , j , k )) S12 = 0.5 * ( gradu_y ( i , j , k ) + gradv_x ( i , j , k )) S13 = 0.5 * ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) S21 = 0.5 * ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) S22 = 0.5 * ( gradv_y ( i , j , k ) + gradv_y ( i , j , k )) S23 = 0.5 * ( gradv_z ( i , j , k ) + gradw_y ( i , j , k )) S31 = 0.5 * ( gradw_x ( i , j , k ) + gradu_z ( i , j , k )) S32 = 0.5 * ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) S33 = 0.5 * ( gradw_z ( i , j , k ) + gradw_z ( i , j , k )) delv = gradu_x ( i , j , k ) + gradv_y ( i , j , k ) + gradw_z ( i , j , k ) Tau11 = mu_t ( i , j , k ) * ( 2 * S11 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) Tau12 = mu_t ( i , j , k ) * ( 2 * S12 ) Tau13 = mu_t ( i , j , k ) * ( 2 * S13 ) Tau21 = mu_t ( i , j , k ) * ( 2 * S21 ) Tau22 = mu_t ( i , j , k ) * ( 2 * S22 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) Tau23 = mu_t ( i , j , k ) * ( 2 * S23 ) Tau31 = mu_t ( i , j , k ) * ( 2 * S31 ) Tau32 = mu_t ( i , j , k ) * ( 2 * S32 ) Tau33 = mu_t ( i , j , k ) * ( 2 * S33 - ( 2 / 3 ) * delv ) - ( 2 / 3 ) * density ( i , j , k ) * tk ( i , j , k ) P_k = 0. P_k = P_k + Tau11 * gradu_x ( i , j , k ) + Tau12 * gradu_y ( i , j , k ) + Tau13 * gradu_z ( i , j , k ) P_k = P_k + Tau21 * gradv_x ( i , j , k ) + Tau22 * gradv_y ( i , j , k ) + Tau23 * gradv_z ( i , j , k ) P_k = P_k + Tau31 * gradw_x ( i , j , k ) + Tau32 * gradw_y ( i , j , k ) + Tau33 * gradw_z ( i , j , k ) D_k = ( cmu ** 0.75 ) * density ( i , j , k ) * ( tk ( i , j , k ) ** 2.5 ) / max ( tkl ( i , j , k ), 1.e-20 ) P_k = min ( P_k , 20 * D_k ) ! calculation of Lvk ! first get second order gradients d2udx2 = ( - ( gradu_x ( i - 1 , j , k ) + gradu_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradu_x ( i , j - 1 , k ) + gradu_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradu_x ( i , j , k - 1 ) + gradu_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradu_x ( i + 1 , j , k ) + gradu_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_x ( i , j + 1 , k ) + gradu_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_x ( i , j , k + 1 ) + gradu_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2udy2 = ( - ( gradu_y ( i - 1 , j , k ) + gradu_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradu_y ( i , j - 1 , k ) + gradu_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradu_y ( i , j , k - 1 ) + gradu_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradu_y ( i + 1 , j , k ) + gradu_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_y ( i , j + 1 , k ) + gradu_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_y ( i , j , k + 1 ) + gradu_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2udz2 = ( - ( gradu_z ( i - 1 , j , k ) + gradu_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradu_z ( i , j - 1 , k ) + gradu_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradu_z ( i , j , k - 1 ) + gradu_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradu_z ( i + 1 , j , k ) + gradu_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradu_z ( i , j + 1 , k ) + gradu_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradu_z ( i , j , k + 1 ) + gradu_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) ! gradient of v component d2vdx2 = ( - ( gradv_x ( i - 1 , j , k ) + gradv_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradv_x ( i , j - 1 , k ) + gradv_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradv_x ( i , j , k - 1 ) + gradv_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradv_x ( i + 1 , j , k ) + gradv_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_x ( i , j + 1 , k ) + gradv_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_x ( i , j , k + 1 ) + gradv_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2vdy2 = ( - ( gradv_y ( i - 1 , j , k ) + gradv_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradv_y ( i , j - 1 , k ) + gradv_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradv_y ( i , j , k - 1 ) + gradv_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradv_y ( i + 1 , j , k ) + gradv_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_y ( i , j + 1 , k ) + gradv_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_y ( i , j , k + 1 ) + gradv_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2vdz2 = ( - ( gradv_z ( i - 1 , j , k ) + gradv_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradv_z ( i , j - 1 , k ) + gradv_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradv_z ( i , j , k - 1 ) + gradv_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradv_z ( i + 1 , j , k ) + gradv_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradv_z ( i , j + 1 , k ) + gradv_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradv_z ( i , j , k + 1 ) + gradv_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) !gradients of w components d2wdx2 = ( - ( gradw_x ( i - 1 , j , k ) + gradw_x ( i , j , k )) * xnx ( i , j , k ) * xA ( i , j , k ) & - ( gradw_x ( i , j - 1 , k ) + gradw_x ( i , j , k )) * ynx ( i , j , k ) * yA ( i , j , k ) & - ( gradw_x ( i , j , k - 1 ) + gradw_x ( i , j , k )) * znx ( i , j , k ) * zA ( i , j , k ) & + ( gradw_x ( i + 1 , j , k ) + gradw_x ( i , j , k )) * xnx ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_x ( i , j + 1 , k ) + gradw_x ( i , j , k )) * ynx ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_x ( i , j , k + 1 ) + gradw_x ( i , j , k )) * znx ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2wdy2 = ( - ( gradw_y ( i - 1 , j , k ) + gradw_y ( i , j , k )) * xny ( i , j , k ) * xA ( i , j , k ) & - ( gradw_y ( i , j - 1 , k ) + gradw_y ( i , j , k )) * yny ( i , j , k ) * yA ( i , j , k ) & - ( gradw_y ( i , j , k - 1 ) + gradw_y ( i , j , k )) * zny ( i , j , k ) * zA ( i , j , k ) & + ( gradw_y ( i + 1 , j , k ) + gradw_y ( i , j , k )) * xny ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_y ( i , j + 1 , k ) + gradw_y ( i , j , k )) * yny ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_y ( i , j , k + 1 ) + gradw_y ( i , j , k )) * zny ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) d2wdz2 = ( - ( gradw_z ( i - 1 , j , k ) + gradw_z ( i , j , k )) * xnz ( i , j , k ) * xA ( i , j , k ) & - ( gradw_z ( i , j - 1 , k ) + gradw_z ( i , j , k )) * ynz ( i , j , k ) * yA ( i , j , k ) & - ( gradw_z ( i , j , k - 1 ) + gradw_z ( i , j , k )) * znz ( i , j , k ) * zA ( i , j , k ) & + ( gradw_z ( i + 1 , j , k ) + gradw_z ( i , j , k )) * xnz ( i + 1 , j , k ) * xA ( i + 1 , j , k ) & + ( gradw_z ( i , j + 1 , k ) + gradw_z ( i , j , k )) * ynz ( i , j + 1 , k ) * yA ( i , j + 1 , k ) & + ( gradw_z ( i , j , k + 1 ) + gradw_z ( i , j , k )) * znz ( i , j , k + 1 ) * zA ( i , j , k + 1 ) & ) / ( 2 * volume ( i , j , k )) udd = sqrt ( ( d2udx2 + d2udy2 + d2udz2 ) ** 2 & + ( d2vdx2 + d2vdy2 + d2vdz2 ) ** 2 & + ( d2wdx2 + d2wdy2 + d2wdz2 ) ** 2 ) ud = sqrt ( 2 * ( s11 ** 2 + s12 ** 2 + s13 ** 2 & + s21 ** 2 + s22 ** 2 + s23 ** 2 & + s31 ** 2 + s32 ** 2 + s33 ** 2 )) Lvk = kappa * abs ( ud / max ( udd , 1.e-20 )) fp = min ( max ( P_k / D_k , 0.5 ), 1.0 ) ! Lvk limiter Lvk = max ( Lvk , tkl ( i , j , k ) / max (( tk ( i , j , k ) * c11 ), 1.e-20 )) Lvk = min ( Lvk , c12 * kappa * dist ( i , j , k ) * fp ) eta = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( 0.3 * tk ( i , j , k )) / ( 20 * mu ( i , j , k )) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) cphi2 = zeta3 cphi1 = ( zeta1 - zeta2 * (( tkl ( i , j , k ) / max ( tk ( i , j , k ) * Lvk , 1.e-20 )) ** 2 )) P_kl = cphi1 * tkl ( i , j , k ) * P_k / max ( tk ( i , j , k ), 1.e-20 ) D_kl = cphi2 * density ( i , j , k ) * ( tk ( i , j , k ) ** 1.5 ) S_k = P_k - D_k - 2 * mu ( i , j , k ) * tk ( i , j , k ) / ( dist ( i , j , k ) ** 2 ) !Source term TKE S_kl = P_kl - D_kl - 6 * mu ( i , j , k ) * tkl ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 ) !source term KL S_k = S_k * volume ( i , j , k ) S_kl = S_kl * volume ( i , j , k ) TKE_residue ( i , j , k ) = TKE_residue ( i , j , k ) - S_k KL_residue ( i , j , k ) = KL_residue ( i , j , k ) - S_kl end do end do end do end subroutine add_kkl_source","tags":"","loc":"proc/add_kkl_source.html","title":"add_kkl_source – FEST-3D"},{"text":"private subroutine add_sa_source() Add residual due to source terms of SA turbulence model Arguments None Called by proc~~add_sa_source~~CalledByGraph proc~add_sa_source add_sa_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sa_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sa_sourceCalledByGraph = svgPanZoom('#procadd_sa_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_sa_source Source Code subroutine add_sa_source () !< Add residual due to source terms of SA turbulence model implicit none integer :: i , j , k real :: CD1 real :: CD2 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: vort real :: S_v real :: D_v real :: P_v real :: lamda real :: kd2 real :: xi real :: nu real :: gradrho_x real :: gradrho_y real :: gradrho_z real , dimension ( 6 ) :: RhoFace real , dimension ( 6 ) :: Area real , dimension ( 6 , 3 ) :: Normal do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 RhoFace ( 1 ) = density ( i - 1 , j , k ) + density ( i , j , k ) RhoFace ( 2 ) = density ( i , j - 1 , k ) + density ( i , j , k ) RhoFace ( 3 ) = density ( i , j , k - 1 ) + density ( i , j , k ) RhoFace ( 4 ) = density ( i + 1 , j , k ) + density ( i , j , k ) RhoFace ( 5 ) = density ( i , j + 1 , k ) + density ( i , j , k ) RhoFace ( 6 ) = density ( i , j , k + 1 ) + density ( i , j , k ) Area ( 1 ) = xA ( i , j , k ) Area ( 2 ) = yA ( i , j , k ) Area ( 3 ) = zA ( i , j , k ) Area ( 4 ) = xA ( i + 1 , j , k ) Area ( 5 ) = yA ( i , j + 1 , k ) Area ( 6 ) = zA ( i , j , k + 1 ) Normal ( 1 , 1 : 3 ) = xn ( i , j , k ,:) Normal ( 2 , 1 : 3 ) = yn ( i , j , k ,:) Normal ( 3 , 1 : 3 ) = zn ( i , j , k ,:) Normal ( 4 , 1 : 3 ) = xn ( i + 1 , j , k ,:) Normal ( 5 , 1 : 3 ) = yn ( i , j + 1 , k ,:) Normal ( 6 , 1 : 3 ) = zn ( i , j , k + 1 ,:) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) ! __ vorticity __ vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 nu = mu ( i , j , k ) / density ( i , j , k ) xi = tv ( i , j , k ) / nu ! ___ functions ___ fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) fv2 = 1.0 - xi / ( 1.0 + ( xi * fv1 )) ! ___ Shear stress for production ___ scap = max ( vort + ( tv ( i , j , k ) * fv2 / ( kd2 )), 0.3 * vort ) ! ___ wall function ___ r = min ( tv ( i , j , k ) / ( Scap * kd2 ), 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) fw = g * ( ( 1.0 + ( cw3 ** 6 )) / (( g ** 6 ) + ( cw3 ** 6 )) ) ** ( 1.0 / 6.0 ) ! ____ Dissipation term ___ D_v = density ( i , j , k ) * cw1 * fw * (( tv ( i , j , k ) / dist ( i , j , k )) ** 2 ) ! ____ PRODUCTION term____ P_v = density ( i , j , k ) * cb1 * Scap * tv ( i , j , k ) ! ____ cross diffusion term ___ lamda = density ( i , j , k ) * CD1 / sigma_sa - CD2 * ( nu + tv ( i , j , k )) / sigma_sa S_v = ( P_v - D_v + lamda ) * volume ( i , j , k ) tv_residue ( i , j , k ) = tv_residue ( i , j , k ) - S_v end do end do end do end subroutine add_sa_source","tags":"","loc":"proc/add_sa_source.html","title":"add_sa_source – FEST-3D"},{"text":"private subroutine add_saBC_source() Add residual due to source terms of SABC transition model Arguments None Called by proc~~add_sabc_source~~CalledByGraph proc~add_sabc_source add_saBC_source proc~add_source_term_residue add_source_term_residue proc~add_source_term_residue->proc~add_sabc_source proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocadd_sabc_sourceCalledByGraph = svgPanZoom('#procadd_sabc_sourceCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code add_saBC_source Source Code subroutine add_saBC_source () !< Add residual due to source terms of SABC transition model implicit none integer :: i , j , k real :: CD1 real :: CD2 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: gradrho_x real :: gradrho_y real :: gradrho_z real , dimension ( 6 ) :: RhoFace real , dimension ( 6 ) :: Area real , dimension ( 6 , 3 ) :: Normal ! transition modeling variables real :: chi_1 = 0.002 real :: chi_2 = 5.0 real :: nu_BC real :: nu_cr real :: nu_t real :: u , v , w real :: glim real :: g_6 real :: vmag real :: Production real :: Destruction real :: re_v real :: re_theta real :: re_theta_t real :: term1 real :: term2 real :: term_exponential real :: gamma_BC real :: tu tu = free_stream_tu do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 !Local_vel_mag u = qp ( i , j , k , 2 ) v = qp ( i , j , k , 3 ) w = qp ( i , j , k , 4 ) vmag = sqrt ( u * u + v * v + w * w ) RhoFace ( 1 ) = density ( i - 1 , j , k ) + density ( i , j , k ) RhoFace ( 2 ) = density ( i , j - 1 , k ) + density ( i , j , k ) RhoFace ( 3 ) = density ( i , j , k - 1 ) + density ( i , j , k ) RhoFace ( 4 ) = density ( i + 1 , j , k ) + density ( i , j , k ) RhoFace ( 5 ) = density ( i , j + 1 , k ) + density ( i , j , k ) RhoFace ( 6 ) = density ( i , j , k + 1 ) + density ( i , j , k ) Area ( 1 ) = xA ( i , j , k ) Area ( 2 ) = yA ( i , j , k ) Area ( 3 ) = zA ( i , j , k ) Area ( 4 ) = xA ( i + 1 , j , k ) Area ( 5 ) = yA ( i , j + 1 , k ) Area ( 6 ) = zA ( i , j , k + 1 ) Normal ( 1 , 1 : 3 ) = xn ( i , j , k ,:) Normal ( 2 , 1 : 3 ) = yn ( i , j , k ,:) Normal ( 3 , 1 : 3 ) = zn ( i , j , k ,:) Normal ( 4 , 1 : 3 ) = xn ( i + 1 , j , k ,:) Normal ( 5 , 1 : 3 ) = yn ( i , j + 1 , k ,:) Normal ( 6 , 1 : 3 ) = zn ( i , j , k + 1 ,:) gradrho_x = ( - ( RhoFace ( 1 )) * Normal ( 1 , 1 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 1 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 1 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 1 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 1 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 1 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_y = ( - ( RhoFace ( 1 )) * Normal ( 1 , 2 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 2 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 2 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 2 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 2 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 2 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) gradrho_z = ( - ( RhoFace ( 1 )) * Normal ( 1 , 3 ) * Area ( 1 ) & - ( RhoFace ( 2 )) * Normal ( 2 , 3 ) * Area ( 2 ) & - ( RhoFace ( 3 )) * Normal ( 3 , 3 ) * Area ( 3 ) & + ( RhoFace ( 4 )) * Normal ( 4 , 3 ) * Area ( 4 ) & + ( RhoFace ( 5 )) * Normal ( 5 , 3 ) * Area ( 5 ) & + ( RhoFace ( 6 )) * Normal ( 6 , 3 ) * Area ( 6 ) & ) / ( 2 * volume ( i , j , k )) ! __ vorticity __ Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) ! ___ cross diffusion ___ CD1 = cb2 * (( gradtv_x ( i , j , k ) * gradtv_x ( i , j , k ))& + ( gradtv_y ( i , j , k ) * gradtv_y ( i , j , k ))& + ( gradtv_z ( i , j , k ) * gradtv_z ( i , j , k ))& ) ! ___ addition cross diffusion result conservative form of tv ___ CD2 = (( gradrho_x * gradtv_x ( i , j , k ))& + ( gradrho_y * gradtv_y ( i , j , k ))& + ( gradrho_z * gradtv_z ( i , j , k ))& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = tv ( i , j , k ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + tv ( i , j , k ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat ! ____ PRODUCTION term____ chi_1 = 0.002 chi_2 = 5.0 nu_t = tv ( i , j , k ) * fv1 nu_cr = chi_2 / Reynolds_number nu_bc = nu_t / ( vmag * dist_i ) re_v = dist_i_2 * Omega / nu re_theta = re_v / 2.193 re_theta_t = ( 80 3.73 * (( tu + 0.6067 ) ** ( - 1.027 ))) !re_theta_t = 163.0 + exp(6.91-0.18) term1 = sqrt ( max ( re_theta - re_theta_t , 0. ) / ( chi_1 * re_theta_t )) term2 = sqrt ( max ( nu_BC - nu_cr , 0.0 ) / nu_cr ) term_exponential = ( term1 + term2 ) gamma_BC = 1.0 - exp ( - term_exponential ) !            intermittency(i,j,k) = gamma_BC Production = gamma_BC * cb1 * Shat * tv ( i , j , k ) * volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( tv ( i , j , k ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim Destruction = ( cw1 * fw * tv ( i , j , k ) * tv ( i , j , k ) / dist_i_2 ) * ( volume ( i , j , k )) ! ____ cross diffusion term ___ lamda = ( density ( i , j , k ) * CD1 / sigma_sa - CD2 * ( nu + tv ( i , j , k )) / sigma_sa ) * volume ( i , j , k ) S_v = ( Production - Destruction + lamda ) tv_residue ( i , j , k ) = tv_residue ( i , j , k ) - S_v end do end do end do end subroutine add_saBC_source","tags":"","loc":"proc/add_sabc_source.html","title":"add_saBC_source – FEST-3D"},{"text":"private subroutine allocate_memory() Allocate memory to store the grid Arguments None Calls proc~~allocate_memory~~CallsGraph proc~allocate_memory allocate_memory interface~alloc alloc proc~allocate_memory->interface~alloc proc~dmsg dmsg proc~allocate_memory->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~~CalledByGraph proc~allocate_memory allocate_memory proc~setup_grid setup_grid proc~setup_grid->proc~allocate_memory proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocate memory to store the grid !----------------------------------------------------------- implicit none call dmsg ( 1 , 'grid' , 'allocate_memory' ) call alloc ( grid_x , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_x.' ) call alloc ( grid_y , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_y.' ) call alloc ( grid_z , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for grid_z.' ) ! The alloc function earlier allocates only real arrays. ! A new function has been written to allocate for integers ! as well !           call alloc(sphere_indices, 1, 3, 1, n_sph_ind, & !                   errmsg='Error: Unable to allocate memory for sphere_indices.') end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory.html","title":"allocate_memory – FEST-3D"},{"text":"public subroutine destroy_grid() Deallocate the memory allocated for the grid. Arguments None Calls proc~~destroy_grid~~CallsGraph proc~destroy_grid destroy_grid interface~dealloc dealloc proc~destroy_grid->interface~dealloc proc~dmsg dmsg proc~destroy_grid->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_grid~~CalledByGraph proc~destroy_grid destroy_grid proc~destroy_all destroy_all proc~destroy_all->proc~destroy_grid proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_grid proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_grid Source Code subroutine destroy_grid () !< Deallocate the memory allocated for the grid. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'grid' , 'destroy_memory' ) call dealloc ( grid_x ) call dealloc ( grid_y ) call dealloc ( grid_z ) !           call dealloc(sphere_indices) end subroutine destroy_grid","tags":"","loc":"proc/destroy_grid.html","title":"destroy_grid – FEST-3D"},{"text":"public subroutine setup_grid(gridfile) Read the grid file and initialize the grid Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: gridfile Calls proc~~setup_grid~~CallsGraph proc~setup_grid setup_grid proc~dmsg dmsg proc~setup_grid->proc~dmsg proc~allocate_memory allocate_memory proc~setup_grid->proc~allocate_memory proc~ghost_grid ghost_grid proc~setup_grid->proc~ghost_grid proc~extract_grid_size extract_grid_size proc~setup_grid->proc~extract_grid_size proc~read_interface_map read_interface_map proc~setup_grid->proc~read_interface_map proc~populate_grid_points populate_grid_points proc~setup_grid->proc~populate_grid_points proc~allocate_memory->proc~dmsg interface~alloc alloc proc~allocate_memory->interface~alloc proc~ghost_grid->proc~dmsg mpi_recv mpi_recv proc~ghost_grid->mpi_recv mpi_barrier mpi_barrier proc~ghost_grid->mpi_barrier mpi_send mpi_send proc~ghost_grid->mpi_send proc~extract_grid_size->proc~dmsg proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map->proc~read_periodic_bc_file proc~close_file~3 close_file proc~read_interface_map->proc~close_file~3 proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map->proc~change_map_to_particular_range proc~populate_grid_points->proc~dmsg proc~extract_grid_point extract_grid_point proc~populate_grid_points->proc~extract_grid_point proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~extract_grid_point->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_grid~~CalledByGraph proc~setup_grid setup_grid proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_grid Source Code subroutine setup_grid ( gridfile ) !< Read the grid file and initialize the grid !----------------------------------------------------------- implicit none character ( len = 64 ), intent ( in ) :: gridfile !        character(len=32) :: sphindfile call dmsg ( 1 , 'grid' , 'setup_grid' ) !           sphindfile = 'sphere-indices.txt' open ( GRID_FILE_UNIT , file = gridfile ) !           open(SPHERE_INDICES_FILE_UNIT, file=sphindfile) call extract_grid_size () !           call extract_sphere_indices_size() call allocate_memory () !read interface mapping call read_interface_map () ! ghost grid exchange call populate_grid_points () !           call populate_sphere_indices() close ( GRID_FILE_UNIT ) !           close(SPHERE_INDICES_FILE_UNIT) ! populate ghost grid points call ghost_grid () end subroutine setup_grid","tags":"","loc":"proc/setup_grid.html","title":"setup_grid – FEST-3D"},{"text":"private subroutine extract_grid_size() Extract the grid size from the grid file header Arguments None Calls proc~~extract_grid_size~~CallsGraph proc~extract_grid_size extract_grid_size proc~dmsg dmsg proc~extract_grid_size->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~extract_grid_size~~CalledByGraph proc~extract_grid_size extract_grid_size proc~setup_grid setup_grid proc~setup_grid->proc~extract_grid_size proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code extract_grid_size Source Code subroutine extract_grid_size () !< Extract the grid size from the grid file header ! ! We assume that the grid could be in 1 or 2 dimensions. If ! the grid is in 1 dimension, jmx will be set to 1. ! We assume that at least one number is specified in the ! header, i.e., the grid has atleast one dimension. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: header integer :: ios ! io operation status call dmsg ( 1 , 'grid' , 'extract_grid_size' ) read ( GRID_FILE_UNIT , '(A)' , iostat = ios ) header if ( ios /= 0 ) then print * , 'Error while reading grid file header.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if ! Try to read constants corresponding to two dimensions. read ( header , * , iostat = ios ) imx , jmx , kmx if ( ios /= 0 ) then ! An io error means it was not possible to read kmx ! This means the file does not have kmx  and so, set ! the extent of this direction to 1. Read the remaining ! dimension from the header. read ( header , * , iostat = ios ) imx , jmx if ( ios /= 0 ) then ! This means that jmx does not exist. Repeat again read ( header , * , iostat = ios ) imx if ( ios /= 0 ) then ! Error while reading print * , 'Unable to read grid extent.' stop end if jmx = 1 end if kmx = 1 end if end subroutine extract_grid_size","tags":"","loc":"proc/extract_grid_size.html","title":"extract_grid_size – FEST-3D"},{"text":"private subroutine extract_grid_point(line, i, j, k) Extract a grid point from a line of the grid file. Arguments Type Intent Optional Attributes Name character(len=STRING_BUFFER_LENGTH), intent(in) :: line integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Calls proc~~extract_grid_point~~CallsGraph proc~extract_grid_point extract_grid_point proc~dmsg dmsg proc~extract_grid_point->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~extract_grid_point~~CalledByGraph proc~extract_grid_point extract_grid_point proc~populate_grid_points populate_grid_points proc~populate_grid_points->proc~extract_grid_point proc~setup_grid setup_grid proc~setup_grid->proc~populate_grid_points proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocextract_grid_pointCalledByGraph = svgPanZoom('#procextract_grid_pointCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code extract_grid_point Source Code subroutine extract_grid_point ( line , i , j , k ) !< Extract a grid point from a line of the grid file. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ), intent ( in ) :: line integer , intent ( in ) :: i , j , k call dmsg ( 0 , 'grid' , 'extract_grid_point' ) if ( kmx > 1 ) then read ( line , * ) grid_x ( i , j , k ), grid_y ( i , j , k ), grid_z ( i , j , k ) else if ( jmx > 1 ) then read ( line , * ) grid_x ( i , j , k ), grid_y ( i , j , k ) else read ( line , * ) grid_x ( i , j , k ) grid_y ( i , j , k ) = 0. end if grid_z ( i , j , k ) = 0. end if end subroutine extract_grid_point","tags":"","loc":"proc/extract_grid_point.html","title":"extract_grid_point – FEST-3D"},{"text":"private subroutine populate_grid_points() Use the grid file to populate the grid points. Arguments None Calls proc~~populate_grid_points~~CallsGraph proc~populate_grid_points populate_grid_points proc~dmsg dmsg proc~populate_grid_points->proc~dmsg proc~extract_grid_point extract_grid_point proc~populate_grid_points->proc~extract_grid_point proc~extract_grid_point->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~populate_grid_points~~CalledByGraph proc~populate_grid_points populate_grid_points proc~setup_grid setup_grid proc~setup_grid->proc~populate_grid_points proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code populate_grid_points Source Code subroutine populate_grid_points () !< Use the grid file to populate the grid points. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: line integer :: i , j , k integer :: ios ! io status call dmsg ( 1 , 'grid' , 'populate_grid_point' ) !  print *, imx, jmx, kmx ! Read grid points from the grid file do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( GRID_FILE_UNIT , '(A)' , iostat = ios ) line if ( ios /= 0 ) then print * , 'Error while reading grid line.' print * , 'Current grid point: ' , i , j , k print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH print * , 'Exiting program.' stop end if call extract_grid_point ( line , i , j , k ) end do end do end do end subroutine populate_grid_points","tags":"","loc":"proc/populate_grid_points.html","title":"populate_grid_points – FEST-3D"},{"text":"private subroutine ghost_grid() generate ghost grid for the various operations later. Arguments None Calls proc~~ghost_grid~~CallsGraph proc~ghost_grid ghost_grid mpi_send mpi_send proc~ghost_grid->mpi_send mpi_recv mpi_recv proc~ghost_grid->mpi_recv proc~dmsg dmsg proc~ghost_grid->proc~dmsg mpi_barrier mpi_barrier proc~ghost_grid->mpi_barrier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~ghost_grid~~CalledByGraph proc~ghost_grid ghost_grid proc~setup_grid setup_grid proc~setup_grid->proc~ghost_grid proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code ghost_grid Source Code subroutine ghost_grid () !< generate ghost grid for the various operations later. implicit none integer :: count = 0 integer :: i , j , k , l integer :: ierr integer :: status ( MPI_STATUS_SIZE ) real , dimension (:), allocatable :: imin_send_buffer real , dimension (:), allocatable :: jmin_send_buffer real , dimension (:), allocatable :: kmin_send_buffer real , dimension (:), allocatable :: imin_recv_buffer real , dimension (:), allocatable :: jmin_recv_buffer real , dimension (:), allocatable :: kmin_recv_buffer real , dimension (:), allocatable :: imax_send_buffer real , dimension (:), allocatable :: jmax_send_buffer real , dimension (:), allocatable :: kmax_send_buffer real , dimension (:), allocatable :: imax_recv_buffer real , dimension (:), allocatable :: jmax_recv_buffer real , dimension (:), allocatable :: kmax_recv_buffer !          real, dimension(3) :: delI !          real, dimension(3) :: N !          real  :: dot !          real  :: magnitude !          real :: d1x, d2x, d1y, d2y, d1z, d2z !          integer :: ii,jj,kk ! !          call dmsg(1, 'grid', 'ghost_grid_extrapolate') !          !---IMIN---! !          do k = 1, kmx !           do j = 1, jmx !             ! finding face normal !              ii=1 !              jj=j !              kk=k !              if(j==jmx) jj=j-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii, jj+1, kk+1) - grid_x(ii, jj  , kk) !              d1y = grid_y(ii, jj+1, kk+1) - grid_y(ii, jj  , kk) !              d1z = grid_z(ii, jj+1, kk+1) - grid_z(ii, jj  , kk) !              d2x = grid_x(ii, jj  , kk+1) - grid_x(ii, jj+1, kk) !              d2y = grid_y(ii, jj  , kk+1) - grid_y(ii, jj+1, kk) !              d2z = grid_z(ii, jj  , kk+1) - grid_z(ii, jj+1, kk) !              N(1) = -0.5 * (d1y*d2z - d1z*d2y) !              N(2) = -0.5 * (d1z*d2x - d1x*d2z) !              N(3) = -0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii+1, jj  , kk) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii+1, jj  , kk) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii+1, jj  , kk) !                d2x = grid_x(ii+1, jj  , kk+1) - grid_x(ii+1, jj+1, kk) !                d2y = grid_y(ii+1, jj  , kk+1) - grid_y(ii+1, jj+1, kk) !                d2z = grid_z(ii+1, jj  , kk+1) - grid_z(ii+1, jj+1, kk) !                N(1) = -0.5 * (d1y*d2z - d1z*d2y) !                N(2) = -0.5 * (d1z*d2x - d1x*d2z) !                N(3) = -0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(ii+1,j,k)-grid_x(ii,j,k) !                delI(2) = grid_y(ii+1,j,k)-grid_y(ii,j,k) !                delI(3) = grid_z(ii+1,j,k)-grid_z(ii,j,k) !                dot=SUM(N*delI)/magnitude !                grid_x(ii-l,j,k)= grid_x(ii,j,k) + delI(1) + (l+1)*dot*N(1) !                grid_y(ii-l,j,k)= grid_y(ii,j,k) + delI(2) + (l+1)*dot*N(2) !                grid_z(ii-l,j,k)= grid_z(ii,j,k) + delI(3) + (l+1)*dot*N(3) !             end do !            end do !           end do ! ! !           !--- IMAX ---! !          do k = 1, kmx !           do j = 1, jmx !             ! finding face normal !              ii=imx !              jj=j !              kk=k !              if(j==jmx) jj=j-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii, jj+1, kk+1) - grid_x(ii, jj  , kk) !              d1y = grid_y(ii, jj+1, kk+1) - grid_y(ii, jj  , kk) !              d1z = grid_z(ii, jj+1, kk+1) - grid_z(ii, jj  , kk) !              d2x = grid_x(ii, jj  , kk+1) - grid_x(ii, jj+1, kk) !              d2y = grid_y(ii, jj  , kk+1) - grid_y(ii, jj+1, kk) !              d2z = grid_z(ii, jj  , kk+1) - grid_z(ii, jj+1, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii-1, jj+1, kk+1) - grid_x(ii-1, jj  , kk) !                d1y = grid_y(ii-1, jj+1, kk+1) - grid_y(ii-1, jj  , kk) !                d1z = grid_z(ii-1, jj+1, kk+1) - grid_z(ii-1, jj  , kk) !                d2x = grid_x(ii-1, jj  , kk+1) - grid_x(ii-1, jj+1, kk) !                d2y = grid_y(ii-1, jj  , kk+1) - grid_y(ii-1, jj+1, kk) !                d2z = grid_z(ii-1, jj  , kk+1) - grid_z(ii-1, jj+1, kk) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(ii-1,j,k)-grid_x(ii,j,k) !                delI(2) = grid_y(ii-1,j,k)-grid_y(ii,j,k) !                delI(3) = grid_z(ii-1,j,k)-grid_z(ii,j,k) !                dot=SUM(N*delI)/magnitude !                grid_x(ii+l,j,k)= grid_x(ii,j,k) + delI(1) + (l+1)*dot*N(1) !                grid_y(ii+l,j,k)= grid_y(ii,j,k) + delI(2) + (l+1)*dot*N(2) !                grid_z(ii+l,j,k)= grid_z(ii,j,k) + delI(3) + (l+1)*dot*N(3) !            end do !           end do !          end do ! !          !--- JMIN ---! !          do k = 1, kmx !           do i = -2, imx+3 !             ! finding face normal !              ii=i !              jj=1 !              kk=k !              if(i==imx+3) ii=i-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii+1, jj, kk+1) - grid_x(ii, jj, kk) !              d1y = grid_y(ii+1, jj, kk+1) - grid_y(ii, jj, kk) !              d1z = grid_z(ii+1, jj, kk+1) - grid_z(ii, jj, kk) !              d2x = grid_x(ii+1, jj, kk)   - grid_x(ii, jj, kk+1) !              d2y = grid_y(ii+1, jj, kk)   - grid_y(ii, jj, kk+1) !              d2z = grid_z(ii+1, jj, kk)   - grid_z(ii, jj, kk+1) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii, jj+1, kk) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii, jj+1, kk) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii, jj+1, kk) !                d2x = grid_x(ii+1, jj+1, kk)   - grid_x(ii, jj+1, kk+1) !                d2y = grid_y(ii+1, jj+1, kk)   - grid_y(ii, jj+1, kk+1) !                d2z = grid_z(ii+1, jj+1, kk)   - grid_z(ii, jj+1, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,jj+1,k)-grid_x(i,jj,k) !                delI(2) = grid_y(i,jj+1,k)-grid_y(i,jj,k) !                delI(3) = grid_z(i,jj+1,k)-grid_z(i,jj,k) !                dot=SUM(N*delI)/magnitude !                grid_x(i,jj-l,k)= grid_x(i,jj,k) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,jj-l,k)= grid_y(i,jj,k) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,jj-l,k)= grid_z(i,jj,k) + delI(3) - (l+1)*dot*N(3) !              end do !            end do !          end do ! ! !          !--- JMAX ---! !          do k = 1, kmx !           do i = -2, imx+3 !             ! finding face normal !              ii=i !              jj=jmx !              kk=k !              if(i==imx+3) ii=i-1 !              if(k==kmx) kk=k-1 !              d1x = grid_x(ii+1, jj, kk+1) - grid_x(ii, jj, kk) !              d1y = grid_y(ii+1, jj, kk+1) - grid_y(ii, jj, kk) !              d1z = grid_z(ii+1, jj, kk+1) - grid_z(ii, jj, kk) !              d2x = grid_x(ii+1, jj, kk  ) - grid_x(ii, jj, kk+1) !              d2y = grid_y(ii+1, jj, kk  ) - grid_y(ii, jj, kk+1) !              d2z = grid_z(ii+1, jj, kk  ) - grid_z(ii, jj, kk+1) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj-1, kk+1) - grid_x(ii, jj-1, kk) !                d1y = grid_y(ii+1, jj-1, kk+1) - grid_y(ii, jj-1, kk) !                d1z = grid_z(ii+1, jj-1, kk+1) - grid_z(ii, jj-1, kk) !                d2x = grid_x(ii+1, jj-1, kk  ) - grid_x(ii, jj-1, kk+1) !                d2y = grid_y(ii+1, jj-1, kk  ) - grid_y(ii, jj-1, kk+1) !                d2z = grid_z(ii+1, jj-1, kk  ) - grid_z(ii, jj-1, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,jj-1,k)-grid_x(i,jj,k) !                delI(2) = grid_y(i,jj-1,k)-grid_y(i,jj,k) !                delI(3) = grid_z(i,jj-1,k)-grid_z(i,jj,k) !                dot=SUM(N*delI)/magnitude !                grid_x(i,jj+l,k)= grid_x(i,jj,k) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,jj+l,k)= grid_y(i,jj,k) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,jj+l,k)= grid_z(i,jj,k) + delI(3) - (l+1)*dot*N(3) !              end do !            end do !          end do ! !          !--- KMIN ---! !          do j = -2, jmx+3 !           do i = -2, imx+3 !              ii=i !              jj=j !              kk=1 !              if(i==imx+3) ii=i-1 !              if(j==jmx+3) jj=j-1 !              d1x = grid_x(ii+1, jj+1, kk) - grid_x(ii  , jj, kk) !              d1y = grid_y(ii+1, jj+1, kk) - grid_y(ii  , jj, kk) !              d1z = grid_z(ii+1, jj+1, kk) - grid_z(ii  , jj, kk) !              d2x = grid_x(ii  , jj+1, kk) - grid_x(ii+1, jj, kk) !              d2y = grid_y(ii  , jj+1, kk) - grid_y(ii+1, jj, kk) !              d2z = grid_z(ii  , jj+1, kk) - grid_z(ii+1, jj, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk+1) - grid_x(ii  , jj, kk+1) !                d1y = grid_y(ii+1, jj+1, kk+1) - grid_y(ii  , jj, kk+1) !                d1z = grid_z(ii+1, jj+1, kk+1) - grid_z(ii  , jj, kk+1) !                d2x = grid_x(ii  , jj+1, kk+1) - grid_x(ii+1, jj, kk+1) !                d2y = grid_y(ii  , jj+1, kk+1) - grid_y(ii+1, jj, kk+1) !                d2z = grid_z(ii  , jj+1, kk+1) - grid_z(ii+1, jj, kk+1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,j,kk+1)-grid_x(i,j,kk) !                delI(2) = grid_y(i,j,kk+1)-grid_y(i,j,kk) !                delI(3) = grid_z(i,j,kk+1)-grid_z(i,j,kk) !                dot=SUM(N*delI)/magnitude !                grid_x(i,j,kk-l)= grid_x(i,j,kk) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,j,kk-l)= grid_y(i,j,kk) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,j,kk-l)= grid_z(i,j,kk) + delI(3) - (l+1)*dot*N(3) !            end do !           end do !          end do ! !          !--- KMAX ---! !          do j = -2, jmx+3 !           do i = -2, imx+3 !              ii=i !              jj=j !              kk=kmx !              if(i==imx+3) ii=i-1 !              if(j==jmx+3) jj=j-1 !              d1x = grid_x(ii+1, jj+1, kk) - grid_x(ii  , jj, kk) !              d1y = grid_y(ii+1, jj+1, kk) - grid_y(ii  , jj, kk) !              d1z = grid_z(ii+1, jj+1, kk) - grid_z(ii  , jj, kk) !              d2x = grid_x(ii  , jj+1, kk) - grid_x(ii+1, jj, kk) !              d2y = grid_y(ii  , jj+1, kk) - grid_y(ii+1, jj, kk) !              d2z = grid_z(ii  , jj+1, kk) - grid_z(ii+1, jj, kk) !              N(1) = 0.5 * (d1y*d2z - d1z*d2y) !              N(2) = 0.5 * (d1z*d2x - d1x*d2z) !              N(3) = 0.5 * (d1x*d2y - d1y*d2x) !              magnitude = SUM(N**2) !              if(magnitude==0)then !                d1x = grid_x(ii+1, jj+1, kk-1) - grid_x(ii  , jj, kk-1) !                d1y = grid_y(ii+1, jj+1, kk-1) - grid_y(ii  , jj, kk-1) !                d1z = grid_z(ii+1, jj+1, kk-1) - grid_z(ii  , jj, kk-1) !                d2x = grid_x(ii  , jj+1, kk-1) - grid_x(ii+1, jj, kk-1) !                d2y = grid_y(ii  , jj+1, kk-1) - grid_y(ii+1, jj, kk-1) !                d2z = grid_z(ii  , jj+1, kk-1) - grid_z(ii+1, jj, kk-1) !                N(1) = 0.5 * (d1y*d2z - d1z*d2y) !                N(2) = 0.5 * (d1z*d2x - d1x*d2z) !                N(3) = 0.5 * (d1x*d2y - d1y*d2x) !                magnitude = SUM(N**2) !                if(magnitude==0)then !                  Fatal_error !                end if !              end if !              do l=1,layers !                delI(1) = grid_x(i,j,kk-1)-grid_x(i,j,kk) !                delI(2) = grid_y(i,j,kk-1)-grid_y(i,j,kk) !                delI(3) = grid_z(i,j,kk-1)-grid_z(i,j,kk) !                dot=SUM(N*delI)/magnitude !                grid_x(i,j,kk+l)= grid_x(i,j,kk) + delI(1) - (l+1)*dot*N(1) !                grid_y(i,j,kk+l)= grid_y(i,j,kk) + delI(2) - (l+1)*dot*N(2) !                grid_z(i,j,kk+l)= grid_z(i,j,kk) + delI(3) - (l+1)*dot*N(3) !                print*, grid_x(ii+l,j,k), grid_y(ii+l,j,k), grid_z(ii+l,j,k) !            end do !           end do !          end do !          !------------------------------------------------------------------- !          !getting ghost cell for all faces even if it is a interface cell !          ! <algorithm> !          ! Point_ghost = 2*Point_first_inner_cell - Point_second_inner_cell !          ! </algorithm> !          !------------------------------------------------------------------- ! !--- I faces ---! !imin face -> 0 grid point grid_x ( 0 ,:,:) = 2 * grid_x ( 1 ,:,:) - grid_x ( 2 ,:,:) grid_y ( 0 ,:,:) = 2 * grid_y ( 1 ,:,:) - grid_y ( 2 ,:,:) grid_z ( 0 ,:,:) = 2 * grid_z ( 1 ,:,:) - grid_z ( 2 ,:,:) !imin face -> -1 grid point grid_x ( - 1 ,:,:) = 2 * grid_x ( 0 ,:,:) - grid_x ( 1 ,:,:) grid_y ( - 1 ,:,:) = 2 * grid_y ( 0 ,:,:) - grid_y ( 1 ,:,:) grid_z ( - 1 ,:,:) = 2 * grid_z ( 0 ,:,:) - grid_z ( 1 ,:,:) !imin face -> -2 grid point grid_x ( - 2 ,:,:) = 2 * grid_x ( - 1 ,:,:) - grid_x ( 0 ,:,:) grid_y ( - 2 ,:,:) = 2 * grid_y ( - 1 ,:,:) - grid_y ( 0 ,:,:) grid_z ( - 2 ,:,:) = 2 * grid_z ( - 1 ,:,:) - grid_z ( 0 ,:,:) !imax face -> imx+1 grid point grid_x ( imx + 1 ,:,:) = 2 * grid_x ( imx + 0 ,:,:) - grid_x ( imx - 1 ,:,:) grid_y ( imx + 1 ,:,:) = 2 * grid_y ( imx + 0 ,:,:) - grid_y ( imx - 1 ,:,:) grid_z ( imx + 1 ,:,:) = 2 * grid_z ( imx + 0 ,:,:) - grid_z ( imx - 1 ,:,:) !imax face -> imx+2 grid point grid_x ( imx + 2 ,:,:) = 2 * grid_x ( imx + 1 ,:,:) - grid_x ( imx - 0 ,:,:) grid_y ( imx + 2 ,:,:) = 2 * grid_y ( imx + 1 ,:,:) - grid_y ( imx - 0 ,:,:) grid_z ( imx + 2 ,:,:) = 2 * grid_z ( imx + 1 ,:,:) - grid_z ( imx - 0 ,:,:) !imax face -> imx+3 grid point grid_x ( imx + 3 ,:,:) = 2 * grid_x ( imx + 2 ,:,:) - grid_x ( imx + 1 ,:,:) grid_y ( imx + 3 ,:,:) = 2 * grid_y ( imx + 2 ,:,:) - grid_y ( imx + 1 ,:,:) grid_z ( imx + 3 ,:,:) = 2 * grid_z ( imx + 2 ,:,:) - grid_z ( imx + 1 ,:,:) !--- Jmin faces ---! !jmin faces -> 0 grid point grid_x (:, 0 ,:) = 2 * grid_x (:, 1 ,:) - grid_x (:, 2 ,:) grid_y (:, 0 ,:) = 2 * grid_y (:, 1 ,:) - grid_y (:, 2 ,:) grid_z (:, 0 ,:) = 2 * grid_z (:, 1 ,:) - grid_z (:, 2 ,:) !jmin face -> -1 grid point grid_x (:, - 1 ,:) = 2 * grid_x (:, 0 ,:) - grid_x (:, 1 ,:) grid_y (:, - 1 ,:) = 2 * grid_y (:, 0 ,:) - grid_y (:, 1 ,:) grid_z (:, - 1 ,:) = 2 * grid_z (:, 0 ,:) - grid_z (:, 1 ,:) !jmin face -> -2 grid point grid_x (:, - 2 ,:) = 2 * grid_x (:, - 1 ,:) - grid_x (:, 0 ,:) grid_y (:, - 2 ,:) = 2 * grid_y (:, - 1 ,:) - grid_y (:, 0 ,:) grid_z (:, - 2 ,:) = 2 * grid_z (:, - 1 ,:) - grid_z (:, 0 ,:) !jmax face -> imx+1 grid point grid_x (:, jmx + 1 ,:) = 2 * grid_x (:, jmx + 0 ,:) - grid_x (:, jmx - 1 ,:) grid_y (:, jmx + 1 ,:) = 2 * grid_y (:, jmx + 0 ,:) - grid_y (:, jmx - 1 ,:) grid_z (:, jmx + 1 ,:) = 2 * grid_z (:, jmx + 0 ,:) - grid_z (:, jmx - 1 ,:) !jmax face -> imx+2 grid point grid_x (:, jmx + 2 ,:) = 2 * grid_x (:, jmx + 1 ,:) - grid_x (:, jmx - 0 ,:) grid_y (:, jmx + 2 ,:) = 2 * grid_y (:, jmx + 1 ,:) - grid_y (:, jmx - 0 ,:) grid_z (:, jmx + 2 ,:) = 2 * grid_z (:, jmx + 1 ,:) - grid_z (:, jmx - 0 ,:) !jmax face -> imx+3 grid point grid_x (:, jmx + 3 ,:) = 2 * grid_x (:, jmx + 2 ,:) - grid_x (:, jmx + 1 ,:) grid_y (:, jmx + 3 ,:) = 2 * grid_y (:, jmx + 2 ,:) - grid_y (:, jmx + 1 ,:) grid_z (:, jmx + 3 ,:) = 2 * grid_z (:, jmx + 2 ,:) - grid_z (:, jmx + 1 ,:) !--- Kmax faces ---! !kmin faces -> 0 grid point grid_x (:,:, 0 ) = 2 * grid_x (:,:, 1 ) - grid_x (:,:, 2 ) grid_y (:,:, 0 ) = 2 * grid_y (:,:, 1 ) - grid_y (:,:, 2 ) grid_z (:,:, 0 ) = 2 * grid_z (:,:, 1 ) - grid_z (:,:, 2 ) !kmin face -> -1 grid point grid_x (:,:, - 1 ) = 2 * grid_x (:,:, 0 ) - grid_x (:,:, 1 ) grid_y (:,:, - 1 ) = 2 * grid_y (:,:, 0 ) - grid_y (:,:, 1 ) grid_z (:,:, - 1 ) = 2 * grid_z (:,:, 0 ) - grid_z (:,:, 1 ) !kmin face -> -2 grid point grid_x (:,:, - 2 ) = 2 * grid_x (:,:, - 1 ) - grid_x (:,:, 0 ) grid_y (:,:, - 2 ) = 2 * grid_y (:,:, - 1 ) - grid_y (:,:, 0 ) grid_z (:,:, - 2 ) = 2 * grid_z (:,:, - 1 ) - grid_z (:,:, 0 ) !kmax face -> imx+1 grid point grid_x (:,:, kmx + 1 ) = 2 * grid_x (:,:, kmx + 0 ) - grid_x (:,:, kmx - 1 ) grid_y (:,:, kmx + 1 ) = 2 * grid_y (:,:, kmx + 0 ) - grid_y (:,:, kmx - 1 ) grid_z (:,:, kmx + 1 ) = 2 * grid_z (:,:, kmx + 0 ) - grid_z (:,:, kmx - 1 ) !kmax face -> imx+2 grid point grid_x (:,:, kmx + 2 ) = 2 * grid_x (:,:, kmx + 1 ) - grid_x (:,:, kmx - 0 ) grid_y (:,:, kmx + 2 ) = 2 * grid_y (:,:, kmx + 1 ) - grid_y (:,:, kmx - 0 ) grid_z (:,:, kmx + 2 ) = 2 * grid_z (:,:, kmx + 1 ) - grid_z (:,:, kmx - 0 ) !kmax face -> imx+3 grid point grid_x (:,:, kmx + 3 ) = 2 * grid_x (:,:, kmx + 2 ) - grid_x (:,:, kmx + 1 ) grid_y (:,:, kmx + 3 ) = 2 * grid_y (:,:, kmx + 2 ) - grid_y (:,:, kmx + 1 ) grid_z (:,:, kmx + 3 ) = 2 * grid_z (:,:, kmx + 2 ) - grid_z (:,:, kmx + 1 ) !print*, grid_x(:,:,kmx) !print*, grid_y(:,:,kmx) !print*, grid_z(:,:,kmx) call dmsg ( 1 , 'grid' , 'ghost_grid_interface' ) !---  MPI transfer of grid point across interface  ---! !--- imin face ---! allocate ( imin_send_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmin_send_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmin_send_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imin_recv_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmin_recv_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmin_recv_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imax_send_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmax_send_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmax_send_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) allocate ( imax_recv_buffer ( 3 * layers * ( jmx + 6 ) * ( kmx + 6 ))) allocate ( jmax_recv_buffer ( 3 * layers * ( imx + 6 ) * ( kmx + 6 ))) allocate ( kmax_recv_buffer ( 3 * layers * ( imx + 6 ) * ( jmx + 6 ))) !          if(imin_id>=0)then !            !collect grid point in 1d array !            count=0 !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_x(l+1,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_y(l+1,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imin_send_buffer(count) = grid_z(l+1,j,k) !                end do !              end do !            end do ! !        call MPI_SENDRECV(imin_send_buffer,count, MPI_DOUBLE_PRECISION, imin_id,1,& !                          imin_recv_buffer,count, MPI_DOUBLE_PRECISION, imin_id,1,& !                          MPI_COMM_WORLD,status,ierr) !        !    if(mpi_class(1)==0)then !        !      print*, Process_id, \"imin master\" !        !      call MPI_SEND(imin_send_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD, ierr) !        !      call MPI_RECV(imin_recv_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD,status,ierr) !        !    else !        !      print*, Process_id, \"imin slave\" !        !      call MPI_RECV(imin_recv_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD,status,ierr) !        !      call MPI_SEND(imin_send_buffer, count,MPI_DOUBLE_PRECISION,imin_id,1,MPI_COMM_WORLD, ierr) !        !    end if !             ! distribute grid points !            if(dir_switch(1)==0)then !              count=0 !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_x(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_y(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(1),Gkhi(1) !                  do j=Gjlo(1),Gjhi(1) !                    count=count+1 !                    grid_z(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do !            else !              count=0 !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_x(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_y(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(1),Gjhi(1) !                  do k=Gklo(1),Gkhi(1) !                    count=count+1 !                    grid_z(1-l,j,k) = imin_recv_buffer(count) !                  end do !                end do !              end do !            end if !          end if ! !          !--- IMAX ---! !          if(imax_id>=0)then !            !collect grid point in 1d array !            count=0 !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_x(imx-l,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_y(imx-l,j,k) !                end do !              end do !            end do ! !            do l=1,layers !              do k=-2,kmx+3 !                do j=-2,jmx+3 !                  count=count+1 !                  imax_send_buffer(count) = grid_z(imx-l,j,k) !                end do !              end do !            end do ! !        call MPI_SENDRECV(imax_send_buffer,count, MPI_DOUBLE_PRECISION, imax_id,1,& !                          imax_recv_buffer,count, MPI_DOUBLE_PRECISION, imax_id,1,& !                          MPI_COMM_WORLD,status,ierr) !        !    if(mpi_class(2)==0)then !        !      print*, Process_id, \"imax master\" !        !      call MPI_SEND(imax_send_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD, ierr) !        !      call MPI_RECV(imax_recv_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD,status,ierr) !        !    else !        !      print*, Process_id, \"imax slave\" !        !      call MPI_RECV(imax_recv_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD,status,ierr) !        !      call MPI_SEND(imax_send_buffer, count,MPI_DOUBLE_PRECISION,imax_id,1,MPI_COMM_WORLD, ierr) !        !    end if !             ! distribute grid points !            if(dir_switch(2)==0)then !              count=0 !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_x(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_y(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do k=Gklo(2),Gkhi(2) !                  do j=Gjlo(2),Gjhi(2) !                    count=count+1 !                    grid_z(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do !            else !              count=0 !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_x(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_y(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do ! !              do l=1,layers !                do j=Gjlo(2),Gjhi(2) !                  do k=Gklo(2),Gkhi(2) !                    count=count+1 !                    grid_z(imx+l,j,k) = imax_recv_buffer(count) !                  end do !                end do !              end do !            end if !          end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_x ( i , l + 1 , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_y ( i , l + 1 , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmin_send_buffer ( count ) = grid_z ( i , l + 1 , k ) end do end do end do if ( mpi_class ( 3 ) == 0 ) then call MPI_SEND ( jmin_send_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( jmin_recv_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( jmin_recv_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( jmin_send_buffer , count , MPI_DOUBLE_PRECISION , jmin_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 3 ) == 0 ) then count = 0 do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_x ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_y ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 3 ), Gkhi ( 3 ) do i = Gilo ( 3 ), Gihi ( 3 ) count = count + 1 grid_z ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_x ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_y ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 3 ), Gihi ( 3 ) do k = Gklo ( 3 ), Gkhi ( 3 ) count = count + 1 grid_z ( i , 1 - l , k ) = jmin_recv_buffer ( count ) end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_x ( i , jmx - l , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_y ( i , jmx - l , k ) end do end do end do do l = 1 , layers do k =- 2 , kmx + 3 do i =- 2 , imx + 3 count = count + 1 jmax_send_buffer ( count ) = grid_z ( i , jmx - l , k ) end do end do end do if ( mpi_class ( 4 ) == 0 ) then call MPI_SEND ( jmax_send_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( jmax_recv_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( jmax_recv_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( jmax_send_buffer , count , MPI_DOUBLE_PRECISION , jmax_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 4 ) == 0 ) then count = 0 do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_x ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_y ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do k = Gklo ( 4 ), Gkhi ( 4 ) do i = Gilo ( 4 ), Gihi ( 4 ) count = count + 1 grid_z ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_x ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_y ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 4 ), Gihi ( 4 ) do k = Gklo ( 4 ), Gkhi ( 4 ) count = count + 1 grid_z ( i , jmx + l , k ) = jmax_recv_buffer ( count ) end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_x ( i , j , 1 + l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_y ( i , j , 1 + l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmin_send_buffer ( count ) = grid_z ( i , j , 1 + l ) end do end do end do if ( mpi_class ( 5 ) == 0 ) then call MPI_SEND ( kmin_send_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( kmin_recv_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( kmin_recv_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( kmin_send_buffer , count , MPI_DOUBLE_PRECISION , kmin_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 5 ) == 0 ) then count = 0 do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_x ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_y ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 5 ), Gjhi ( 5 ) do i = Gilo ( 5 ), Gihi ( 5 ) count = count + 1 grid_z ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_x ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_y ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 5 ), Gihi ( 5 ) do j = Gjlo ( 5 ), Gjhi ( 5 ) count = count + 1 grid_z ( i , j , 1 - l ) = kmin_recv_buffer ( count ) end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect grid point in 1d array count = 0 do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_x ( i , j , kmx - l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_y ( i , j , kmx - l ) end do end do end do do l = 1 , layers do j =- 2 , jmx + 3 do i =- 2 , imx + 3 count = count + 1 kmax_send_buffer ( count ) = grid_z ( i , j , kmx - l ) end do end do end do if ( mpi_class ( 6 ) == 0 ) then call MPI_SEND ( kmax_send_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , ierr ) call MPI_RECV ( kmax_recv_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , status , ierr ) else call MPI_RECV ( kmax_recv_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , status , ierr ) call MPI_SEND ( kmax_send_buffer , count , MPI_DOUBLE_PRECISION , kmax_id , 1 , MPI_COMM_WORLD , ierr ) end if ! distribute grid points if ( dir_switch ( 6 ) == 0 ) then count = 0 do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_x ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_y ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do j = Gjlo ( 6 ), Gjhi ( 6 ) do i = Gilo ( 6 ), Gihi ( 6 ) count = count + 1 grid_z ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do else count = 0 do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_x ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_y ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do do l = 1 , layers do i = Gilo ( 6 ), Gihi ( 6 ) do j = Gjlo ( 6 ), Gjhi ( 6 ) count = count + 1 grid_z ( i , j , kmx + l ) = kmax_recv_buffer ( count ) end do end do end do end if end if deallocate ( imin_send_buffer ) deallocate ( jmin_send_buffer ) deallocate ( kmin_send_buffer ) deallocate ( imin_recv_buffer ) deallocate ( jmin_recv_buffer ) deallocate ( kmin_recv_buffer ) deallocate ( imax_send_buffer ) deallocate ( jmax_send_buffer ) deallocate ( kmax_send_buffer ) deallocate ( imax_recv_buffer ) deallocate ( jmax_recv_buffer ) deallocate ( kmax_recv_buffer ) call mpi_barrier ( MPI_COMM_WORLD , ierr ) call dmsg ( 1 , 'grid' , 'done with ghost_grid' ) end subroutine ghost_grid","tags":"","loc":"proc/ghost_grid.html","title":"ghost_grid – FEST-3D"},{"text":"public subroutine setup_all() To setup, create, allocate memory, link pointer\n    (everything that is required before first iteration Arguments None Calls proc~~setup_all~~CallsGraph proc~setup_all setup_all setup_scheme setup_scheme proc~setup_all->setup_scheme initmisc initmisc proc~setup_all->initmisc link_aliases_solver link_aliases_solver proc~setup_all->link_aliases_solver setup_sst_f1 setup_sst_f1 proc~setup_all->setup_sst_f1 proc~setup_geometry setup_geometry proc~setup_all->proc~setup_geometry allocate_memory allocate_memory proc~setup_all->allocate_memory proc~setup_time setup_time proc~setup_all->proc~setup_time setup_resnorm setup_resnorm proc~setup_all->setup_resnorm proc~setup_gradients setup_gradients proc~setup_all->proc~setup_gradients checkpoint checkpoint proc~setup_all->checkpoint proc~setup_state setup_state proc~setup_all->proc~setup_state allocate_buffer_cells allocate_buffer_cells proc~setup_all->allocate_buffer_cells proc~find_wall_dist find_wall_dist proc~setup_all->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_all->proc~setup_wall_dist proc~write_surfnode write_surfnode proc~setup_all->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_all->proc~read_input_and_controls proc~dmsg dmsg proc~setup_all->proc~dmsg proc~setup_bc setup_bc proc~setup_all->proc~setup_bc setup_transport setup_transport proc~setup_all->setup_transport proc~get_process_data get_process_data proc~setup_all->proc~get_process_data proc~read_layout_file read_layout_file proc~setup_all->proc~read_layout_file proc~setup_grid setup_grid proc~setup_all->proc~setup_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_all Source Code subroutine setup_all () !< To setup, create, allocate memory, link pointer !<    (everything that is required before first iteration implicit none call dmsg ( 1 , 'create_erase' , 'setup_all' ) call get_process_data () ! parallel calls call read_layout_file ( process_id ) ! reads layout file calls call read_input_and_controls () ! all input config file are read call setup_grid ( grid_file_buf ) ! read grid call setup_geometry () ! calculate geometric quantities (area, normal and volume) call setup_state () ! allocate memroy and initialize state variable call setup_transport () ! allocate memroy to viscosity call setup_gradients () ! allocate memroy to gradients call setup_bc () ! set id and face_names array call allocate_memory () call allocate_buffer_cells ( 3 ) ! parallel buffers (MPI interafce communication) call setup_scheme () ! face convective flux: memory and scheme if ( turbulence /= 'none' ) then call write_surfnode () call setup_wall_dist () call find_wall_dist () end if call setup_sst_F1 () call link_aliases_solver () call setup_resnorm () call initmisc () checkpoint_iter_count = 0 call checkpoint () ! Create an initial dump file call setup_time () call dmsg ( 5 , 'create_erase' , 'setup_all' , 'Setup complete' ) end subroutine setup_all","tags":"","loc":"proc/setup_all.html","title":"setup_all – FEST-3D"},{"text":"public subroutine destroy_all() Free memory and free pointers Arguments None Calls proc~~destroy_all~~CallsGraph proc~destroy_all destroy_all destroy_resnorm destroy_resnorm proc~destroy_all->destroy_resnorm proc~destroy_time destroy_time proc~destroy_all->proc~destroy_time proc~destroy_gradients destroy_gradients proc~destroy_all->proc~destroy_gradients destroy_transport destroy_transport proc~destroy_all->destroy_transport proc~destroy_grid destroy_grid proc~destroy_all->proc~destroy_grid destroy_sst_f1 destroy_sst_f1 proc~destroy_all->destroy_sst_f1 destroy_scheme destroy_scheme proc~destroy_all->destroy_scheme proc~destroy_state destroy_state proc~destroy_all->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_all->proc~destroy_geometry deallocate_misc deallocate_misc proc~destroy_all->deallocate_misc proc~dmsg dmsg proc~destroy_all->proc~dmsg proc~destroy_wall_dist destroy_wall_dist proc~destroy_all->proc~destroy_wall_dist unlink_aliases_solver unlink_aliases_solver proc~destroy_all->unlink_aliases_solver proc~destroy_time->proc~dmsg interface~alloc alloc proc~destroy_time->interface~alloc mpi_gather mpi_gather proc~destroy_time->mpi_gather interface~dealloc dealloc proc~destroy_time->interface~dealloc proc~write_time write_time proc~destroy_time->proc~write_time proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_memory destroy_memory proc~destroy_gradients->proc~destroy_memory proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients->proc~destroy_kkl_grad debugcall debugcall proc~destroy_gradients->debugcall proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_grid->proc~dmsg proc~destroy_grid->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~destroy_state->proc~deallocate_memory~4 proc~destroy_state->debugcall proc~unlink_aliases~2 unlink_aliases proc~destroy_state->proc~unlink_aliases~2 proc~destroy_geometry->proc~dmsg proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_wall_dist->proc~dmsg proc~destroy_wall_dist->interface~dealloc proc~deallocate_memory~2->proc~dmsg proc~deallocate_memory~2->interface~dealloc proc~destroy_sst_grad->debugcall proc~destroy_memory->interface~dealloc proc~destroy_memory->debugcall proc~destroy_sa_grad->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~destroy_kkl_grad->debugcall proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory~4->debugcall proc~unlink_aliases~2->debugcall proc~destroy_laminar_grad->debugcall proc~destroy_lctm2015_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_all Source Code subroutine destroy_all () !< Free memory and free pointers implicit none call dmsg ( 1 , 'create_erase' , 'destroy_all' ) call destroy_time () call destroy_transport () call destroy_gradients () call destroy_wall_dist () call destroy_scheme () call deallocate_misc () call unlink_aliases_solver () call destroy_state () call destroy_geometry () call destroy_grid () call destroy_resnorm () call destroy_sst_F1 () if ( allocated ( r_list )) deallocate ( r_list ) if ( allocated ( w_list )) deallocate ( w_list ) call dmsg ( 5 , 'create_erase' , 'destroy_all' , 'Memory_freed' ) end subroutine destroy_all","tags":"","loc":"proc/destroy_all.html","title":"destroy_all – FEST-3D"},{"text":"public function Flux(ql, qr, du, inputs) calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) Contents Source Code Flux Source Code function Flux ( ql , qr , du , inputs ) !< calculate the total flux through face for laminar flow. !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 1 : 5 ) = U ( 1 : 5 ) + du ( 1 : 5 ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux = Flux * Area end function Flux","tags":"","loc":"proc/flux~2.html","title":"Flux – FEST-3D"},{"text":"public function SpectralRadius(ql, qr, inputs, c1, c2) Calculate the spectral radius Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:7) :: inputs real, intent(in), dimension(1:3) :: c1 real, intent(in), dimension(1:3) :: c2 Return Value real Called by proc~~spectralradius~2~~CalledByGraph proc~spectralradius~2 SpectralRadius proc~update_sa_variables~2 update_SA_variables proc~update_sa_variables~2->proc~spectralradius~2 proc~update_kkl_variables update_KKL_variables proc~update_kkl_variables->proc~spectralradius~2 proc~update_sst_variables~2 update_SST_variables proc~update_sst_variables~2->proc~spectralradius~2 proc~update_lctm2015~2 update_lctm2015 proc~update_lctm2015~2->proc~spectralradius~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_laminar_variables~2->proc~spectralradius~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_with_lusgs->proc~update_kkl_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_with_lusgs->proc~update_laminar_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocspectralradius2CalledByGraph = svgPanZoom('#procspectralradius2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SpectralRadius Source Code function SpectralRadius ( ql , qr , inputs , c1 , c2 ) !< Calculate the spectral radius implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql real , dimension ( 1 : n_var ), intent ( in ) :: qr real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : 3 ) , intent ( in ) :: c1 real , dimension ( 1 : 3 ) , intent ( in ) :: c2 ! local variables real :: SpectralRadius real :: NormalSpeed real :: SpeedOfSound real :: vis real :: mu real :: rho real :: distance !extract inputs real :: Area real :: nx real :: ny real :: nz real :: volume real :: mm real :: tm Area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mm = inputs ( 6 ) tm = inputs ( 7 ) ! in state vector q (2-4) are the cell center velocity NormalSpeed = 0.5 * ( ( ( ql ( 2 ) + qr ( 2 ) ) * nx ) & + ( ( ql ( 3 ) + qr ( 3 ) ) * ny ) & + ( ( ql ( 4 ) + qr ( 4 ) ) * nz ) & ) NormalSpeed = abs ( NormalSpeed ) SpeedOfSound = 0.5 * ( sqrt ( gm * ql ( 5 ) / ql ( 1 )) + sqrt ( gm * qr ( 5 ) / qr ( 1 )) ) ! visocus part mu = mm / Pr + tm / tPr rho = 0.5 * ( ql ( 1 ) + qr ( 1 ) ) distance = sqrt (( c1 ( 1 ) - c2 ( 1 )) ** 2 + ( c1 ( 2 ) - c2 ( 2 )) ** 2 + ( c1 ( 3 ) - c2 ( 3 )) ** 2 ) vis = gm * ( mm / pr + tm / tpr ) / ( rho * distance ) SpectralRadius = ( NormalSpeed + SpeedOfSound + vis ) * Area end function SpectralRadius","tags":"","loc":"proc/spectralradius~2.html","title":"SpectralRadius – FEST-3D"},{"text":"public function SSTFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~sstflux~2~~CalledByGraph proc~sstflux~2 SSTFlux proc~update_sst_variables~2 update_SST_variables proc~update_sst_variables~2->proc~sstflux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sst_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsstflux2CalledByGraph = svgPanZoom('#procsstflux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SSTFlux Source Code function SSTFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SST) implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SSTFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux = Flux * Area SSTFlux = Flux end function SSTFlux","tags":"","loc":"proc/sstflux~2.html","title":"SSTFlux – FEST-3D"},{"text":"public function KKLFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (k-kL) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~kklflux~~CalledByGraph proc~kklflux KKLFlux proc~update_kkl_variables update_KKL_variables proc~update_kkl_variables->proc~kklflux proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_kkl_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprockklfluxCalledByGraph = svgPanZoom('#prockklfluxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code KKLFlux Source Code function KKLFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (k-kL) implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: KKLFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtkldx real :: dtkldy real :: dtkldz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) W ( 7 ) = max ( W ( 7 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtkldx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtkldy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtkldz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_phi * tmu ) * ( dtkldx * nx + dtkldy * ny + dtkldz * nz ) Flux = Flux * Area KKLFlux = Flux end function KKLFlux","tags":"","loc":"proc/kklflux.html","title":"KKLFlux – FEST-3D"},{"text":"public function SAFlux(ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~saflux~2~~CalledByGraph proc~saflux~2 SAFlux proc~update_sa_variables~2 update_SA_variables proc~update_sa_variables~2->proc~saflux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsaflux2CalledByGraph = svgPanZoom('#procsaflux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code SAFlux Source Code function SAFlux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent flow (SA) !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 7 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: SAFlux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtvdx real :: dtvdy real :: dtvdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: muCap area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 6 ) = max ( W ( 6 ), 1 e - 8 ) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) ! viscous terms muCap = 0.25 * ( P ( 1 ) + W ( 1 )) * ( P ( 6 ) + W ( 6 )) mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtvdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtvdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtvdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz tmu = 0.5 * ( W ( 6 ) + P ( 6 )) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + muCap ) * ( dtvdx * nx + dtvdy * ny + dtvdz * nz ) / sigma_sa Flux = Flux * Area SAFlux = Flux end function SAFlux","tags":"","loc":"proc/saflux~2.html","title":"SAFlux – FEST-3D"},{"text":"public function lctm2015flux(ql, qr, du, inputs) calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Called by proc~~lctm2015flux~2~~CalledByGraph proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2 update_lctm2015 proc~update_lctm2015~2->proc~lctm2015flux~2 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_lctm2015~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproclctm2015flux2CalledByGraph = svgPanZoom('#proclctm2015flux2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lctm2015flux Source Code function lctm2015flux ( ql , qr , du , inputs ) !< calculate the total flux through face for turbulent/transition flow (LCTM2015) !--------------------------------------- implicit none real , dimension ( 1 : n_var ), intent ( in ) :: ql !left state real , dimension ( 1 : n_var ), intent ( in ) :: qr !right state !conservative form of updated neighbour real , dimension ( 1 : n_var ), intent ( in ) :: du real , dimension ( 1 : 8 ) , intent ( in ) :: inputs real , dimension ( 1 : n_var ) :: Flux real , dimension ( 1 : n_var ) :: lctm2015flux real , dimension ( 1 : n_var ) :: U ! conservative variables real , dimension ( 1 : n_var ) :: W ! new primitive variables real , dimension ( 1 : n_var ) :: P ! primitive variables of right cell !for extraction of the inputs real :: area real :: nx real :: ny real :: nz real :: volume real :: mmu real :: tmu real :: dudx real :: dudy real :: dudz real :: dvdx real :: dvdy real :: dvdz real :: dwdx real :: dwdy real :: dwdz real :: dTdx real :: dTdy real :: dTdz real :: dtkdx real :: dtkdy real :: dtkdz real :: dtwdx real :: dtwdy real :: dtwdz real :: dtgmdx real :: dtgmdy real :: dtgmdz real :: T1 , T2 real :: uface real :: vface real :: wface real :: trace real :: Tauxx real :: Tauyy real :: Tauzz real :: Tauxy real :: Tauxz real :: Tauyz real :: Qx real :: Qy real :: Qz real :: HalfRhoUsquare real :: RhoHt real :: K_heat real :: FaceNormalVelocity real :: mu real :: sigma_k real :: sigma_w real :: F1 area = inputs ( 1 ) nx = inputs ( 2 ) ny = inputs ( 3 ) nz = inputs ( 4 ) volume = inputs ( 5 ) mmu = inputs ( 6 ) tmu = inputs ( 7 ) F1 = inputs ( 8 ) !save the old stat in P P = qr ! find conservative variable U ( 1 ) = ql ( 1 ) U ( 2 ) = ql ( 1 ) * ql ( 2 ) U ( 3 ) = ql ( 1 ) * ql ( 3 ) U ( 4 ) = ql ( 1 ) * ql ( 4 ) U ( 5 ) = ( ql ( 5 ) / ( gm - 1.0 ) ) + ( 0.5 * ql ( 1 ) * sum ( ql ( 2 : 4 ) ** 2 ) ) U ( 6 ) = ql ( 1 ) * ql ( 6 ) U ( 7 ) = ql ( 1 ) * ql ( 7 ) U ( 8 ) = ql ( 1 ) * ql ( 8 ) U ( 1 : n_var ) = U ( 1 : n_var ) + du ( 1 : n_var ) W ( 1 ) = U ( 1 ) W ( 2 ) = U ( 2 ) / U ( 1 ) W ( 3 ) = U ( 3 ) / U ( 1 ) W ( 4 ) = U ( 4 ) / U ( 1 ) W ( 5 ) = ( gm - 1.0 ) * ( U ( 5 ) - ( 0.5 * SUM ( U ( 2 : 4 ) ** 2 ) / U ( 1 ) ) ) W ( 6 ) = U ( 6 ) / U ( 1 ) W ( 7 ) = U ( 7 ) / U ( 1 ) W ( 8 ) = U ( 8 ) / U ( 1 ) W ( 6 ) = W ( 6 ) + 0.5 * ( 1. - sign ( 1. , W ( 6 ))) * ( ql ( 6 ) - W ( 6 )) W ( 7 ) = W ( 7 ) + 0.5 * ( 1. - sign ( 1. , W ( 7 ))) * ( ql ( 7 ) - W ( 7 )) W ( 8 ) = max ( W ( 8 ), 0.0 ) !W(8) = min(W(8), 1.0) FaceNormalVelocity = ( W ( 2 ) * nx ) + ( W ( 3 ) * ny ) + ( W ( 4 ) * nz ) uface = 0.5 * ( W ( 2 ) + P ( 2 ) ) vface = 0.5 * ( W ( 3 ) + P ( 3 ) ) wface = 0.5 * ( W ( 4 ) + P ( 4 ) ) Flux ( 1 ) = W ( 1 ) * FaceNormalVelocity Flux ( 2 ) = ( W ( 2 ) * Flux ( 1 ) ) + ( W ( 5 ) * nx ) Flux ( 3 ) = ( W ( 3 ) * Flux ( 1 ) ) + ( W ( 5 ) * ny ) Flux ( 4 ) = ( W ( 4 ) * Flux ( 1 ) ) + ( W ( 5 ) * nz ) HalfRhoUsquare = 0.5 * W ( 1 ) * ( W ( 2 ) * W ( 2 ) + W ( 3 ) * W ( 3 ) + W ( 4 ) * W ( 4 ) ) RhoHt = ( ( gm / ( gm - 1.0 )) * W ( 5 ) ) + HalfRhoUsquare Flux ( 5 ) = RhoHt * FaceNormalVelocity Flux ( 6 ) = ( W ( 6 ) * Flux ( 1 ) ) Flux ( 7 ) = ( W ( 7 ) * Flux ( 1 ) ) Flux ( 8 ) = ( W ( 8 ) * Flux ( 1 ) ) ! viscous terms mu = mmu + tmu T1 = W ( 5 ) / ( W ( 1 ) * R_gas ) T2 = P ( 5 ) / ( P ( 1 ) * R_gas ) dTdx = ( T2 - T1 ) * nx * Area / Volume dTdy = ( T2 - T1 ) * ny * Area / Volume dTdz = ( T2 - T1 ) * nz * Area / Volume dudx = ( P ( 2 ) - W ( 2 ) ) * nx * Area / Volume dudy = ( P ( 2 ) - W ( 2 ) ) * ny * Area / Volume dudz = ( P ( 2 ) - W ( 2 ) ) * nz * Area / Volume dvdx = ( P ( 3 ) - W ( 3 ) ) * nx * Area / Volume dvdy = ( P ( 3 ) - W ( 3 ) ) * ny * Area / Volume dvdz = ( P ( 3 ) - W ( 3 ) ) * nz * Area / Volume dwdx = ( P ( 4 ) - W ( 4 ) ) * nx * Area / Volume dwdy = ( P ( 4 ) - W ( 4 ) ) * ny * Area / Volume dwdz = ( P ( 4 ) - W ( 4 ) ) * nz * Area / Volume dtkdx = ( P ( 6 ) - W ( 6 ) ) * nx * Area / Volume dtkdy = ( P ( 6 ) - W ( 6 ) ) * ny * Area / Volume dtkdz = ( P ( 6 ) - W ( 6 ) ) * nz * Area / Volume dtwdx = ( P ( 7 ) - W ( 7 ) ) * nx * Area / Volume dtwdy = ( P ( 7 ) - W ( 7 ) ) * ny * Area / Volume dtwdz = ( P ( 7 ) - W ( 7 ) ) * nz * Area / Volume dtgmdx = ( P ( 8 ) - W ( 8 ) ) * nx * Area / Volume dtgmdy = ( P ( 8 ) - W ( 8 ) ) * ny * Area / Volume dtgmdz = ( P ( 8 ) - W ( 8 ) ) * nz * Area / Volume trace = dudx + dvdy + dwdz Tauxx = 2. * mu * ( dudx - trace / 3.0 ) Tauyy = 2. * mu * ( dvdy - trace / 3.0 ) Tauzz = 2. * mu * ( dwdz - trace / 3.0 ) Tauxy = mu * ( dvdx + dudy ) Tauxz = mu * ( dwdx + dudz ) Tauyz = mu * ( dwdy + dvdz ) K_heat = ( mmu / Pr + tmu / tpr ) * gm * R_gas / ( gm - 1.0 ) Qx = K_heat * dTdx Qy = K_heat * dTdy Qz = K_heat * dTdz sigma_k = sigma_k1 * F1 + sigma_k2 * ( 1.0 - F1 ) sigma_w = sigma_w1 * F1 + sigma_w2 * ( 1.0 - F1 ) Flux ( 2 ) = Flux ( 2 ) - ( Tauxx * nx + Tauxy * ny + Tauxz * nz ) Flux ( 3 ) = Flux ( 3 ) - ( Tauxy * nx + Tauyy * ny + Tauyz * nz ) Flux ( 4 ) = Flux ( 4 ) - ( Tauxz * nx + Tauyz * ny + Tauzz * nz ) Flux ( 5 ) = Flux ( 5 ) - ( Tauxx * uface + Tauxy * vface + Tauxz * wface + Qx ) * nx Flux ( 5 ) = Flux ( 5 ) - ( Tauxy * uface + Tauyy * vface + Tauyz * wface + Qy ) * ny Flux ( 5 ) = Flux ( 5 ) - ( Tauxz * uface + Tauyz * vface + Tauzz * wface + Qz ) * nz Flux ( 6 ) = Flux ( 6 ) + ( mmu + sigma_k * tmu ) * ( dtkdx * nx + dtkdy * ny + dtkdz * nz ) Flux ( 7 ) = Flux ( 7 ) + ( mmu + sigma_w * tmu ) * ( dtwdx * nx + dtwdy * ny + dtwdz * nz ) Flux ( 8 ) = Flux ( 8 ) + ( mmu + tmu ) * ( dtgmdx * nx + dtgmdy * ny + dtgmdz * nz ) Flux = Flux * Area lctm2015flux = Flux end function lctm2015flux","tags":"","loc":"proc/lctm2015flux~2.html","title":"lctm2015flux – FEST-3D"},{"text":"public subroutine setup_lusgs() allocate array memory for data communication Arguments None Calls proc~~setup_lusgs~~CallsGraph proc~setup_lusgs setup_lusgs interface~alloc alloc proc~setup_lusgs->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_lusgs~~CalledByGraph proc~setup_lusgs setup_lusgs proc~setup_update setup_update proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_lusgs Source Code subroutine setup_lusgs () !< allocate array memory for data communication implicit none character ( len =* ), parameter :: & errmsg = \"module: LUSGS, subrouinte setup\" ibuf_size = ( jmx - 1 ) * ( kmx - 1 ) * n_var * 1 jbuf_size = ( imx - 1 ) * ( kmx - 1 ) * n_var * 1 kbuf_size = ( imx - 1 ) * ( jmx - 1 ) * n_var * 1 call alloc ( imin_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imin_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmin_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmin_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_send_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_send_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_send_buf , 1 , kbuf_size , errmsg ) call alloc ( imax_recv_buf , 1 , ibuf_size , errmsg ) call alloc ( jmax_recv_buf , 1 , jbuf_size , errmsg ) call alloc ( kmax_recv_buf , 1 , kbuf_size , errmsg ) call alloc ( delQ , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) call alloc ( delQstar , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_var ) if ( mu_ref == 0.0 . or . turbulence == 'none' ) then call alloc ( dummy , 0 , imx , 0 , jmx , 0 , kmx ) dummy = 0.0 end if if ( mu_ref == 0.0 ) then mmu => dummy else mmu => mu end if if ( trim ( turbulence ) == 'none' ) then tmu => dummy else tmu => mu_t end if end subroutine setup_lusgs","tags":"","loc":"proc/setup_lusgs.html","title":"setup_lusgs – FEST-3D"},{"text":"public subroutine destroy_lusgs() unallocate the memory required by LU-SGS module Arguments None Calls proc~~destroy_lusgs~~CallsGraph proc~destroy_lusgs destroy_lusgs interface~dealloc dealloc proc~destroy_lusgs->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_lusgs~~CalledByGraph proc~destroy_lusgs destroy_lusgs proc~destroy_update destroy_update proc~destroy_update->proc~destroy_lusgs proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_lusgs Source Code subroutine destroy_lusgs () !< unallocate the memory required by LU-SGS module implicit none call dealloc ( imin_send_buf ) call dealloc ( jmin_send_buf ) call dealloc ( kmin_send_buf ) call dealloc ( imin_recv_buf ) call dealloc ( jmin_recv_buf ) call dealloc ( kmin_recv_buf ) call dealloc ( imax_send_buf ) call dealloc ( jmax_send_buf ) call dealloc ( kmax_send_buf ) call dealloc ( imax_recv_buf ) call dealloc ( jmax_recv_buf ) call dealloc ( kmax_recv_buf ) call dealloc ( delQ ) call dealloc ( delQstar ) call dealloc ( dummy ) end subroutine destroy_lusgs","tags":"","loc":"proc/destroy_lusgs.html","title":"destroy_lusgs – FEST-3D"},{"text":"public subroutine update_with_lusgs() Time-integrate with LU_SGS method Arguments None Calls proc~~update_with_lusgs~~CallsGraph proc~update_with_lusgs update_with_lusgs proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~spectralradius~2 SpectralRadius proc~update_sa_variables~2->proc~spectralradius~2 proc~saflux~2 SAFlux proc~update_sa_variables~2->proc~saflux~2 proc~update_kkl_variables->proc~spectralradius~2 proc~kklflux KKLFlux proc~update_kkl_variables->proc~kklflux proc~update_sst_variables~2->proc~spectralradius~2 proc~sstflux~2 SSTFlux proc~update_sst_variables~2->proc~sstflux~2 proc~update_lctm2015~2->proc~spectralradius~2 proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2->proc~lctm2015flux~2 proc~update_laminar_variables~2->proc~spectralradius~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_with_lusgs~~CalledByGraph proc~update_with_lusgs update_with_lusgs proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with_lusgs Source Code subroutine update_with_lusgs () !< Time-integrate with LU_SGS method implicit none select case ( trim ( turbulence )) case ( 'none' ) call update_laminar_variables () case ( 'sst' , 'sst2003' ) select case ( trim ( transition )) case ( 'none' , 'bc' ) call update_SST_variables () case ( 'lctm2015' ) call update_lctm2015 () case DEFAULT Fatal_error end select case ( 'kkl' ) call update_KKL_variables () case ( 'sa' , 'saBC' ) call update_SA_variables () case Default Fatal_error end select end subroutine update_with_lusgs","tags":"","loc":"proc/update_with_lusgs.html","title":"update_with_lusgs – FEST-3D"},{"text":"public subroutine update_laminar_variables() Update laminar flow with LU-SGS scheme Arguments None Calls proc~~update_laminar_variables~2~~CallsGraph proc~update_laminar_variables~2 update_laminar_variables proc~spectralradius~2 SpectralRadius proc~update_laminar_variables~2->proc~spectralradius~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_laminar_variables~2~~CalledByGraph proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_laminar_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_laminar_variables2CalledByGraph = svgPanZoom('#procupdate_laminar_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_laminar_variables Source Code subroutine update_laminar_variables () !< Update laminar flow with LU-SGS scheme implicit none integer :: i , j , k real , dimension ( 1 : 5 ) :: deltaU real :: D real , dimension ( 1 : 5 ) :: conservativeQ real , dimension ( 1 : 5 ) :: OldIminusFlux real , dimension ( 1 : 5 ) :: OldJminusFlux real , dimension ( 1 : 5 ) :: OldKminusFlux real , dimension ( 1 : 5 ) :: NewIminusFlux real , dimension ( 1 : 5 ) :: NewJminusFlux real , dimension ( 1 : 5 ) :: NewKminusFlux real , dimension ( 1 : 5 ) :: DelIminusFlux real , dimension ( 1 : 5 ) :: DelJminusFlux real , dimension ( 1 : 5 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 5 ) :: Q0 ! state at cell real , dimension ( 1 : 5 ) :: Q1 ! state at neighbours real , dimension ( 1 : 5 ) :: Q2 real , dimension ( 1 : 5 ) :: Q3 real , dimension ( 1 : 5 ) :: Q4 real , dimension ( 1 : 5 ) :: Q5 real , dimension ( 1 : 5 ) :: Q6 real , dimension ( 1 : 5 ) :: DQ0 ! change in state real , dimension ( 1 : 5 ) :: DQ1 real , dimension ( 1 : 5 ) :: DQ2 real , dimension ( 1 : 5 ) :: DQ3 real , dimension ( 1 : 5 ) :: DQ4 real , dimension ( 1 : 5 ) :: DQ5 real , dimension ( 1 : 5 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 5 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 5 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 5 ) = - residue ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 5 )) ) delQstar ( i , j , k , 1 : 5 ) = deltaU ( 1 : 5 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 5 ) Q1 = qp ( i - 1 , j , k , 1 : 5 ) Q2 = qp ( i , j - 1 , k , 1 : 5 ) Q3 = qp ( i , j , k - 1 , 1 : 5 ) Q4 = qp ( i + 1 , j , k , 1 : 5 ) Q5 = qp ( i , j + 1 , k , 1 : 5 ) Q6 = qp ( i , j , k + 1 , 1 : 5 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 5 ) DQ5 = delQ ( i , j + 1 , k , 1 : 5 ) DQ6 = delQ ( i , j , k + 1 , 1 : 5 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) delQ ( i , j , k , 1 : 5 ) = delQstar ( i , j , k , 1 : 5 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 5 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 5 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 5 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) ! add new change into conservative solution conservativeQ ( 1 : 5 ) = conservativeQ ( 1 : 5 ) + delQ ( i , j , k , 1 : 5 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) end do end do end do end subroutine update_laminar_variables","tags":"","loc":"proc/update_laminar_variables~2.html","title":"update_laminar_variables – FEST-3D"},{"text":"public subroutine update_SST_variables() Update the RANS (SST) equation with LU-SGS Arguments None Calls proc~~update_sst_variables~2~~CallsGraph proc~update_sst_variables~2 update_SST_variables proc~spectralradius~2 SpectralRadius proc~update_sst_variables~2->proc~spectralradius~2 proc~sstflux~2 SSTFlux proc~update_sst_variables~2->proc~sstflux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sst_variables~2~~CalledByGraph proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sst_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sst_variables2CalledByGraph = svgPanZoom('#procupdate_sst_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SST_variables Source Code subroutine update_SST_variables () !< Update the RANS (SST) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: De , Dp real :: Fpg real :: dvdy real :: lamd real :: intermittency De = 0.0 Dp = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SSTFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SSTFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SSTFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SSTFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SSTFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - ( residue ( i , j , k , 1 : 7 )) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = SSTFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SSTFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SSTFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SSTFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SSTFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SSTFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * ((( DelIminusFlux ) - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + (( DelJminusFlux ) - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + (( DelKminusFlux ) - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) if ( conservativeQ ( 6 ) > 0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if end do end do end do end subroutine update_SST_variables","tags":"","loc":"proc/update_sst_variables~2.html","title":"update_SST_variables – FEST-3D"},{"text":"public subroutine update_KKL_variables() Update the RANS (k-kL) equation with LU-SGS Arguments None Calls proc~~update_kkl_variables~~CallsGraph proc~update_kkl_variables update_KKL_variables proc~spectralradius~2 SpectralRadius proc~update_kkl_variables->proc~spectralradius~2 proc~kklflux KKLFlux proc~update_kkl_variables->proc~kklflux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_kkl_variables~~CalledByGraph proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_kkl_variables proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_kkl_variablesCalledByGraph = svgPanZoom('#procupdate_kkl_variablesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_KKL_variables Source Code subroutine update_KKL_variables () !< Update the RANS (k-kL) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 7 ) :: deltaU real , dimension ( 1 : 7 ) :: D real , dimension ( 1 : 7 ) :: conservativeQ real , dimension ( 1 : 7 ) :: OldIminusFlux real , dimension ( 1 : 7 ) :: OldJminusFlux real , dimension ( 1 : 7 ) :: OldKminusFlux real , dimension ( 1 : 7 ) :: NewIminusFlux real , dimension ( 1 : 7 ) :: NewJminusFlux real , dimension ( 1 : 7 ) :: NewKminusFlux real , dimension ( 1 : 7 ) :: DelIminusFlux real , dimension ( 1 : 7 ) :: DelJminusFlux real , dimension ( 1 : 7 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 7 ) :: Q0 ! state at cell real , dimension ( 1 : 7 ) :: Q1 ! state at neighbours real , dimension ( 1 : 7 ) :: Q2 real , dimension ( 1 : 7 ) :: Q3 real , dimension ( 1 : 7 ) :: Q4 real , dimension ( 1 : 7 ) :: Q5 real , dimension ( 1 : 7 ) :: Q6 real , dimension ( 1 : 7 ) :: DQ0 ! change in state real , dimension ( 1 : 7 ) :: DQ1 real , dimension ( 1 : 7 ) :: DQ2 real , dimension ( 1 : 7 ) :: DQ3 real , dimension ( 1 : 7 ) :: DQ4 real , dimension ( 1 : 7 ) :: DQ5 real , dimension ( 1 : 7 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 7 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 7 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = KKLFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = KKLFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = KKLFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = KKLFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = KKLFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * volume ( i , j , k ) / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 7 ) = - residue ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 7 )) ) delQstar ( i , j , k , 1 : 7 ) = deltaU ( 1 : 7 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 7 ) Q1 = qp ( i - 1 , j , k , 1 : 7 ) Q2 = qp ( i , j - 1 , k , 1 : 7 ) Q3 = qp ( i , j , k - 1 , 1 : 7 ) Q4 = qp ( i + 1 , j , k , 1 : 7 ) Q5 = qp ( i , j + 1 , k , 1 : 7 ) Q6 = qp ( i , j , k + 1 , 1 : 7 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 7 ) DQ5 = delQ ( i , j + 1 , k , 1 : 7 ) DQ6 = delQ ( i , j , k + 1 , 1 : 7 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = KKLFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = KKLFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = KKLFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = KKLFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = KKLFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = KKLFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) D ( 6 ) = D ( 6 ) + ( 2.5 * ( cmu ** ( 0.75 )) * Q0 ( 1 ) * ( Q0 ( 6 ) ** ( 1.5 )) * volume ( i , j , k ) / Q0 ( 7 )) D ( 6 ) = D ( 6 ) + ( 2 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) D ( 7 ) = D ( 7 ) + ( 6 * mmu ( i , j , k ) * volume ( i , j , k ) / ( dist ( i , j , k ) ** 2 )) delQ ( i , j , k , 1 : 7 ) = delQstar ( i , j , k , 1 : 7 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 7 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 7 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 7 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) ! add new change into conservative solution conservativeQ ( 1 : 7 ) = conservativeQ ( 1 : 7 ) + delQ ( i , j , k , 1 : 7 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) qp ( i , j , k , 7 ) = max ( qp ( i , j , k , 7 ), 1.e-8 ) end do end do end do end subroutine update_KKL_variables","tags":"","loc":"proc/update_kkl_variables.html","title":"update_KKL_variables – FEST-3D"},{"text":"public subroutine update_SA_variables() Update the RANS (SA) equation with LU-SGS Arguments None Calls proc~~update_sa_variables~2~~CallsGraph proc~update_sa_variables~2 update_SA_variables proc~spectralradius~2 SpectralRadius proc~update_sa_variables~2->proc~spectralradius~2 proc~saflux~2 SAFlux proc~update_sa_variables~2->proc~saflux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_sa_variables~2~~CalledByGraph proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_sa_variables~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_sa_variables2CalledByGraph = svgPanZoom('#procupdate_sa_variables2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_SA_variables Source Code subroutine update_SA_variables () !< Update the RANS (SA) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 6 ) :: deltaU real , dimension ( 1 : 6 ) :: D real , dimension ( 1 : 6 ) :: conservativeQ real , dimension ( 1 : 6 ) :: OldIminusFlux real , dimension ( 1 : 6 ) :: OldJminusFlux real , dimension ( 1 : 6 ) :: OldKminusFlux real , dimension ( 1 : 6 ) :: NewIminusFlux real , dimension ( 1 : 6 ) :: NewJminusFlux real , dimension ( 1 : 6 ) :: NewKminusFlux real , dimension ( 1 : 6 ) :: DelIminusFlux real , dimension ( 1 : 6 ) :: DelJminusFlux real , dimension ( 1 : 6 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 6 ) :: Q0 ! state at cell real , dimension ( 1 : 6 ) :: Q1 ! state at neighbours real , dimension ( 1 : 6 ) :: Q2 real , dimension ( 1 : 6 ) :: Q3 real , dimension ( 1 : 6 ) :: Q4 real , dimension ( 1 : 6 ) :: Q5 real , dimension ( 1 : 6 ) :: Q6 real , dimension ( 1 : 6 ) :: DQ0 ! change in state real , dimension ( 1 : 6 ) :: DQ1 real , dimension ( 1 : 6 ) :: DQ2 real , dimension ( 1 : 6 ) :: DQ3 real , dimension ( 1 : 6 ) :: DQ4 real , dimension ( 1 : 6 ) :: DQ5 real , dimension ( 1 : 6 ) :: DQ6 real , dimension ( 1 : 7 ) :: Flist1 real , dimension ( 1 : 7 ) :: Flist2 real , dimension ( 1 : 7 ) :: Flist3 real , dimension ( 1 : 7 ) :: Flist4 real , dimension ( 1 : 7 ) :: Flist5 real , dimension ( 1 : 7 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: fv1 real :: fv2 real :: fw real :: g real :: Scap real :: r real :: S_v real :: D_v real :: P_v real :: lamda real :: dist_i real :: dist_i_2 real :: Ji real :: Ji_2 real :: Ji_3 real :: S real :: Omega real :: k2 real :: inv_k2_d2 real :: Shat real :: inv_Shat real :: nu real :: nu_t real :: glim real :: g_6 real :: gamma_BC real :: dfv1 real :: dfv2 real :: dfw real :: dShat real :: dr real :: dg !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 6 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 6 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = SAFlux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = SAFlux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = SAFlux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = SAFlux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = SAFlux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! deltaU ( 1 : 6 ) = - residue ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 6 )) ) delQstar ( i , j , k , 1 : 6 ) = deltaU ( 1 : 6 ) / D end do end do end do !call apply_interface(delQstar, 1) delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 6 ) Q1 = qp ( i - 1 , j , k , 1 : 6 ) Q2 = qp ( i , j - 1 , k , 1 : 6 ) Q3 = qp ( i , j , k - 1 , 1 : 6 ) Q4 = qp ( i + 1 , j , k , 1 : 6 ) Q5 = qp ( i , j + 1 , k , 1 : 6 ) Q6 = qp ( i , j , k + 1 , 1 : 6 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 6 ) DQ5 = delQ ( i , j + 1 , k , 1 : 6 ) DQ6 = delQ ( i , j , k + 1 , 1 : 6 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) NewIminusFlux = SAFlux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = SAFlux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = SAFlux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = SAFlux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = SAFlux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = SAFlux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) ! -- source term derivatives -- ! Omega = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) dist_i = dist ( i , j , k ) dist_i_2 = dist_i * dist_i k2 = kappa_sa * kappa_sa nu = mu ( i , j , k ) / density ( i , j , k ) Ji = Q0 ( 6 ) / nu Ji_2 = Ji * Ji Ji_3 = Ji_2 * ji ! ___ functions ___ fv1 = ( Ji_3 ) / (( Ji_3 ) + ( cv1_3 )) fv2 = 1.0 - Ji / ( 1.0 + ( Ji * fv1 )) ! ___ Shear stress for production ___ S = Omega inv_k2_d2 = 1.0 / ( k2 * dist_i_2 ) Shat = S + Q0 ( 6 ) * fv2 * inv_k2_d2 Shat = max ( Shat , 1.0e-10 ) inv_Shat = 1.0 / Shat dfv1 = 3.0 * Ji_2 * cv1_3 / ( nu * ( Ji_3 + cv1_3 ) ** 2 ) dfv2 = - (( 1.0 / nu ) - Ji_2 * dfv1 ) / (( 1.0 + Ji * fv1 ) ** 2 ) dShat = ( fv2 + Q0 ( 6 ) * dfv2 ) * inv_k2_d2 D = D - cb1 * ( Q0 ( 6 ) * dShat + Shat ) * Volume ( i , j , k ) ! ___ Destruction term___ ! r = min ( Q0 ( 6 ) * inv_Shat * inv_k2_d2 , 1 0.0 ) g = r + cw2 * (( r ** 6 ) - r ) g_6 = g ** 6 glim = (( 1.0 + cw3_6 ) / ( g_6 + cw3_6 )) ** ( 1.0 / 6.0 ) fw = g * glim dr = ( Shat - Q0 ( 6 ) * dShat ) * inv_Shat * inv_Shat * inv_k2_d2 dg = dr * ( 1.0 + cw2 * ( 6.0 * ( r ** 5 ) - 1.0 )) dfw = dg * glim * ( 1.0 - g_6 / ( g_6 + cw3_6 )) D = D + cw1 * ( dfw * Q0 ( 6 ) + 2 * fw ) * Q0 ( 6 ) / dist_i_2 * volume ( i , j , k ) ! --  end of source term -- ! delQ ( i , j , k , 1 : 6 ) = delQstar ( i , j , k , 1 : 6 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 6 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 6 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 6 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) ! add new change into conservative solution conservativeQ ( 1 : 6 ) = conservativeQ ( 1 : 6 ) + delQ ( i , j , k , 1 : 6 ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) qp ( i , j , k , 6 ) = max ( qp ( i , j , k , 6 ), 1.e-8 ) end do end do end do end subroutine update_SA_variables","tags":"","loc":"proc/update_sa_variables~2.html","title":"update_SA_variables – FEST-3D"},{"text":"public subroutine update_lctm2015() Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS Arguments None Calls proc~~update_lctm2015~2~~CallsGraph proc~update_lctm2015~2 update_lctm2015 proc~spectralradius~2 SpectralRadius proc~update_lctm2015~2->proc~spectralradius~2 proc~lctm2015flux~2 lctm2015flux proc~update_lctm2015~2->proc~lctm2015flux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~update_lctm2015~2~~CalledByGraph proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs update_with_lusgs proc~update_with_lusgs->proc~update_lctm2015~2 proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with_lusgs proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocupdate_lctm20152CalledByGraph = svgPanZoom('#procupdate_lctm20152CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_lctm2015 Source Code subroutine update_lctm2015 () !< Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS implicit none integer :: i , j , k real , dimension ( 1 : 8 ) :: deltaU real , dimension ( 1 : 8 ) :: D real , dimension ( 1 : 8 ) :: conservativeQ real , dimension ( 1 : 8 ) :: OldIminusFlux real , dimension ( 1 : 8 ) :: OldJminusFlux real , dimension ( 1 : 8 ) :: OldKminusFlux real , dimension ( 1 : 8 ) :: NewIminusFlux real , dimension ( 1 : 8 ) :: NewJminusFlux real , dimension ( 1 : 8 ) :: NewKminusFlux real , dimension ( 1 : 8 ) :: DelIminusFlux real , dimension ( 1 : 8 ) :: DelJminusFlux real , dimension ( 1 : 8 ) :: DelKminusFlux real , dimension ( 1 : 6 ) :: LambdaTimesArea real , dimension ( 1 : 8 ) :: Q0 ! state at cell real , dimension ( 1 : 8 ) :: Q1 ! state at neighbours real , dimension ( 1 : 8 ) :: Q2 real , dimension ( 1 : 8 ) :: Q3 real , dimension ( 1 : 8 ) :: Q4 real , dimension ( 1 : 8 ) :: Q5 real , dimension ( 1 : 8 ) :: Q6 real , dimension ( 1 : 8 ) :: DQ0 ! change in state real , dimension ( 1 : 8 ) :: DQ1 real , dimension ( 1 : 8 ) :: DQ2 real , dimension ( 1 : 8 ) :: DQ3 real , dimension ( 1 : 8 ) :: DQ4 real , dimension ( 1 : 8 ) :: DQ5 real , dimension ( 1 : 8 ) :: DQ6 real , dimension ( 1 : 8 ) :: Flist1 real , dimension ( 1 : 8 ) :: Flist2 real , dimension ( 1 : 8 ) :: Flist3 real , dimension ( 1 : 8 ) :: Flist4 real , dimension ( 1 : 8 ) :: Flist5 real , dimension ( 1 : 8 ) :: Flist6 real , dimension ( 1 : 3 ) :: C0 real , dimension ( 1 : 3 ) :: C1 real , dimension ( 1 : 3 ) :: C2 real , dimension ( 1 : 3 ) :: C3 real , dimension ( 1 : 3 ) :: C4 real , dimension ( 1 : 3 ) :: C5 real , dimension ( 1 : 3 ) :: C6 real :: beta ! intermittency real :: Fonset1 real :: Fonset2 real :: Fonset3 real :: Fonset real :: Rev Real :: RT real :: Fturb real :: Re_theta real :: TuL real :: gradtk real :: strain real :: vort real :: Dp , De Dp = 0.0 De = 0.0 !intialize delQ delQstar = 0.0 !forward sweep do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ1 = delQstar ( i - 1 , j , k , 1 : 8 ) DQ2 = delQstar ( i , j - 1 , k , 1 : 8 ) DQ3 = delQstar ( i , j , k - 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ1 , Flist1 ) NewJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ2 , Flist2 ) NewKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ3 , Flist3 ) OldIminusFlux = lctm2015Flux ( Q1 , Q0 , DQ0 , Flist1 ) OldJminusFlux = lctm2015Flux ( Q2 , Q0 , DQ0 , Flist2 ) OldKminusFlux = lctm2015Flux ( Q3 , Q0 , DQ0 , Flist3 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) !storing D in Iflux array for backward sweep !F_p(i,j,k,1) = D deltaU ( 1 : 8 ) = - residue ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 1 ) * delQstar ( i - 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 2 ) * delQstar ( i , j - 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 3 ) * delQstar ( i , j , k - 1 , 1 : 8 )) ) delQstar ( i , j , k , 1 : 8 ) = deltaU ( 1 : 8 ) / D end do end do end do delQ = 0.0 !backward sweep do i = imx - 1 , 1 , - 1 do j = jmx - 1 , 1 , - 1 do k = kmx - 1 , 1 , - 1 C0 = CellCenter ( i , j , k ,:) C1 = CellCenter ( i - 1 , j , k ,:) C2 = CellCenter ( i , j - 1 , k ,:) C3 = CellCenter ( i , j , k - 1 ,:) C4 = CellCenter ( i + 1 , j , k ,:) C5 = CellCenter ( i , j + 1 , k ,:) C6 = CellCenter ( i , j , k + 1 ,:) Q0 = qp ( i , j , k , 1 : 8 ) Q1 = qp ( i - 1 , j , k , 1 : 8 ) Q2 = qp ( i , j - 1 , k , 1 : 8 ) Q3 = qp ( i , j , k - 1 , 1 : 8 ) Q4 = qp ( i + 1 , j , k , 1 : 8 ) Q5 = qp ( i , j + 1 , k , 1 : 8 ) Q6 = qp ( i , j , k + 1 , 1 : 8 ) DQ0 = 0.0 DQ4 = delQ ( i + 1 , j , k , 1 : 8 ) DQ5 = delQ ( i , j + 1 , k , 1 : 8 ) DQ6 = delQ ( i , j , k + 1 , 1 : 8 ) Flist1 ( 1 ) = xA ( i , j , k ) Flist1 ( 2 ) = - xnx ( i , j , k ) Flist1 ( 3 ) = - xny ( i , j , k ) Flist1 ( 4 ) = - xnz ( i , j , k ) Flist1 ( 5 ) = 0.5 * ( volume ( i - 1 , j , k ) + volume ( i , j , k )) Flist1 ( 6 ) = 0.5 * ( mmu ( i - 1 , j , k ) + mmu ( i , j , k )) Flist1 ( 7 ) = 0.5 * ( tmu ( i - 1 , j , k ) + tmu ( i , j , k )) Flist1 ( 8 ) = 0.5 * ( sst_F1 ( i - 1 , j , k ) + sst_F1 ( i , j , k )) Flist2 ( 1 ) = yA ( i , j , k ) Flist2 ( 2 ) = - ynx ( i , j , k ) Flist2 ( 3 ) = - yny ( i , j , k ) Flist2 ( 4 ) = - ynz ( i , j , k ) Flist2 ( 5 ) = 0.5 * ( volume ( i , j - 1 , k ) + volume ( i , j , k )) Flist2 ( 6 ) = 0.5 * ( mmu ( i , j - 1 , k ) + mmu ( i , j , k )) Flist2 ( 7 ) = 0.5 * ( tmu ( i , j - 1 , k ) + tmu ( i , j , k )) Flist2 ( 8 ) = 0.5 * ( sst_F1 ( i , j - 1 , k ) + sst_F1 ( i , j , k )) Flist3 ( 1 ) = zA ( i , j , k ) Flist3 ( 2 ) = - znx ( i , j , k ) Flist3 ( 3 ) = - zny ( i , j , k ) Flist3 ( 4 ) = - znz ( i , j , k ) Flist3 ( 5 ) = 0.5 * ( volume ( i , j , k - 1 ) + volume ( i , j , k )) Flist3 ( 6 ) = 0.5 * ( mmu ( i , j , k - 1 ) + mmu ( i , j , k )) Flist3 ( 7 ) = 0.5 * ( tmu ( i , j , k - 1 ) + tmu ( i , j , k )) Flist3 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k - 1 ) + sst_F1 ( i , j , k )) Flist4 ( 1 ) = xA ( i + 1 , j , k ) Flist4 ( 2 ) = + xnx ( i + 1 , j , k ) Flist4 ( 3 ) = + xny ( i + 1 , j , k ) Flist4 ( 4 ) = + xnz ( i + 1 , j , k ) Flist4 ( 5 ) = 0.5 * ( volume ( i + 1 , j , k ) + volume ( i , j , k )) Flist4 ( 6 ) = 0.5 * ( mmu ( i + 1 , j , k ) + mmu ( i , j , k )) Flist4 ( 7 ) = 0.5 * ( tmu ( i + 1 , j , k ) + tmu ( i , j , k )) Flist4 ( 8 ) = 0.5 * ( sst_F1 ( i + 1 , j , k ) + sst_F1 ( i , j , k )) Flist5 ( 1 ) = yA ( i , j + 1 , k ) Flist5 ( 2 ) = + ynx ( i , j + 1 , k ) Flist5 ( 3 ) = + yny ( i , j + 1 , k ) Flist5 ( 4 ) = + ynz ( i , j + 1 , k ) Flist5 ( 5 ) = 0.5 * ( volume ( i , j + 1 , k ) + volume ( i , j , k )) Flist5 ( 6 ) = 0.5 * ( mmu ( i , j + 1 , k ) + mmu ( i , j , k )) Flist5 ( 7 ) = 0.5 * ( tmu ( i , j + 1 , k ) + tmu ( i , j , k )) Flist5 ( 8 ) = 0.5 * ( sst_F1 ( i , j + 1 , k ) + sst_F1 ( i , j , k )) Flist6 ( 1 ) = zA ( i , j , k + 1 ) Flist6 ( 2 ) = + znx ( i , j , k + 1 ) Flist6 ( 3 ) = + zny ( i , j , k + 1 ) Flist6 ( 4 ) = + znz ( i , j , k + 1 ) Flist6 ( 5 ) = 0.5 * ( volume ( i , j , k + 1 ) + volume ( i , j , k )) Flist6 ( 6 ) = 0.5 * ( mmu ( i , j , k + 1 ) + mmu ( i , j , k )) Flist6 ( 7 ) = 0.5 * ( tmu ( i , j , k + 1 ) + tmu ( i , j , k )) Flist6 ( 8 ) = 0.5 * ( sst_F1 ( i , j , k + 1 ) + sst_F1 ( i , j , k )) NewIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ4 , Flist4 ) NewJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ5 , Flist5 ) NewKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ6 , Flist6 ) OldIminusFlux = lctm2015Flux ( Q4 , Q0 , DQ0 , Flist4 ) OldJminusFlux = lctm2015Flux ( Q5 , Q0 , DQ0 , Flist5 ) OldKminusFlux = lctm2015Flux ( Q6 , Q0 , DQ0 , Flist6 ) LambdaTimesArea ( 1 ) = SpectralRadius ( Q1 , Q0 , Flist1 , C1 , C0 ) LambdaTimesArea ( 2 ) = SpectralRadius ( Q2 , Q0 , Flist2 , C2 , C0 ) LambdaTimesArea ( 3 ) = SpectralRadius ( Q3 , Q0 , Flist3 , C3 , C0 ) LambdaTimesArea ( 4 ) = SpectralRadius ( Q4 , Q0 , Flist4 , C4 , C0 ) LambdaTimesArea ( 5 ) = SpectralRadius ( Q5 , Q0 , Flist5 , C5 , C0 ) LambdaTimesArea ( 6 ) = SpectralRadius ( Q6 , Q0 , Flist6 , C6 , C0 ) ! multiply above flux with area to get correct values DelIminusFlux = NewIminusFlux - OldIminusFlux DelJminusFlux = NewJminusFlux - OldJminusFlux DelKminusFlux = NewKminusFlux - OldKminusFlux D = ( volume ( i , j , k ) / delta_t ( i , j , k )) + 0.5 * SUM ( LambdaTimesArea ) beta = sst_F1 ( i , j , k ) * beta1 + ( 1.0 - sst_F1 ( i , j , k )) * beta2 !D(6) = (D(6) + bstar*qp(i,j,k,7)*volume(i,j,k)) D ( 6 ) = ( D ( 6 ) + ( bstar * qp ( i , j , k , 7 )) * volume ( i , j , k )) D ( 7 ) = ( D ( 7 ) + 2.0 * beta * qp ( i , j , k , 7 ) * volume ( i , j , k )) !gamma vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) strain = sqrt ( (( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) ** 2 & + 2 * ( gradu_x ( i , j , k )) ** 2 & + 2 * ( gradv_y ( i , j , k )) ** 2 & + 2 * ( gradw_z ( i , j , k )) ** 2 & )& ) TuL = min ( 10 0.0 * sqrt ( 2.0 * tk ( i , j , k ) / 3.0 ) / ( tw ( i , j , k ) * dist ( i , j , k )), 10 0.0 ) Re_theta = 10 0.0 + 100 0.0 * exp ( - TuL ) Rev = density ( i , j , k ) * dist ( i , j , k ) * dist ( i , j , k ) * strain / mu ( i , j , k ) RT = density ( i , j , k ) * tk ( i , j , k ) / ( mu ( i , j , k ) * tw ( i , j , k )) Fturb = exp ( - ( 0.5 * Rt ) ** 4 ) Fonset1 = Rev / ( 2.2 * Re_theta ) Fonset2 = min ( Fonset1 , 2.0 ) Fonset3 = max ( 1.0 - ( RT / 3.5 ) ** 3 , 0.0 ) Fonset = max ( Fonset2 - Fonset3 , 0.0 ) Dp = 100 * density ( i , j , k ) * strain * Fonset * ( 1.0 - 2.0 * Q0 ( 8 )) De = 0.06 * vort * Fturb * density ( i , j , k ) * ( 2.0 * 5 0.0 * Q0 ( 8 ) - 1.0 ) D ( 8 ) = ( D ( 8 ) + ( - Dp + DE ) * volume ( i , j , k )) delQ ( i , j , k , 1 : 8 ) = delQstar ( i , j , k , 1 : 8 ) & - 0.5 * (( DelIminusFlux - LambdaTimesArea ( 4 ) * delQ ( i + 1 , j , k , 1 : 8 )) & + ( DelJminusFlux - LambdaTimesArea ( 5 ) * delQ ( i , j + 1 , k , 1 : 8 )) & + ( DelKminusFlux - LambdaTimesArea ( 6 ) * delQ ( i , j , k + 1 , 1 : 8 )) ) / D end do end do end do do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 conservativeQ ( 1 ) = qp ( i , j , k , 1 ) conservativeQ ( 2 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 2 ) conservativeQ ( 3 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 3 ) conservativeQ ( 4 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 4 ) conservativeQ ( 5 ) = ( qp ( i , j , k , 5 ) / ( gm - 1.0 )) + ( 0.5 * qp ( i , j , k , 1 ) * sum ( qp ( i , j , k , 2 : 4 ) ** 2 ) ) conservativeQ ( 6 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 6 ) conservativeQ ( 7 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 7 ) conservativeQ ( 8 ) = qp ( i , j , k , 1 ) * qp ( i , j , k , 8 ) ! add new change into conservative solution conservativeQ ( 1 : n_var ) = conservativeQ ( 1 : n_var ) + delQ ( i , j , k , 1 : n_var ) ! convert back conservative to primitive qp ( i , j , k , 1 ) = conservativeQ ( 1 ) qp ( i , j , k , 2 ) = conservativeQ ( 2 ) / conservativeQ ( 1 ) qp ( i , j , k , 3 ) = conservativeQ ( 3 ) / conservativeQ ( 1 ) qp ( i , j , k , 4 ) = conservativeQ ( 4 ) / conservativeQ ( 1 ) qp ( i , j , k , 5 ) = ( gm - 1.0 ) * ( conservativeQ ( 5 ) - ( 0.5 * sum ( conservativeQ ( 2 : 4 ) ** 2 ) / conservativeQ ( 1 )) ) !              qp(i,j,k,6) = conservativeQ(6) / conservativeQ(1) !              qp(i,j,k,7) = conservativeQ(7) / conservativeQ(1) if ( conservativeQ ( 6 ) > 0.0 ) then qp ( i , j , k , 6 ) = conservativeQ ( 6 ) / conservativeQ ( 1 ) end if if ( conservativeQ ( 7 ) > 0.0 ) then qp ( i , j , k , 7 ) = conservativeQ ( 7 ) / conservativeQ ( 1 ) end if qp ( i , j , k , 8 ) = conservativeQ ( 8 ) / conservativeQ ( 1 ) qp ( i , j , k , 8 ) = max ( qp ( i , j , k , 8 ), 0.0 ) !qp(i,j,k,8) = min(qp(i,j,k,8), 1.0) end do end do end do end subroutine update_lctm2015","tags":"","loc":"proc/update_lctm2015~2.html","title":"update_lctm2015 – FEST-3D"},{"text":"public subroutine apply_interface(qp, layers) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers Calls proc~~apply_interface~3~~CallsGraph proc~apply_interface~3 apply_interface mpi_sendrecv mpi_sendrecv proc~apply_interface~3->mpi_sendrecv proc~dmsg dmsg proc~apply_interface~3->proc~dmsg proc~apply_periodic_bc~3 apply_periodic_bc proc~apply_interface~3->proc~apply_periodic_bc~3 proc~apply_periodic_bc~3->mpi_sendrecv proc~apply_periodic_bc~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_interface Source Code subroutine apply_interface ( qp , layers ) implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 !--- IMIN ---! call dmsg ( 1 , 'interface' , 'apply_interface' ) if ( imin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 1 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 1 ), Pjhi ( 1 ), PjDir ( 1 ) do k = Pklo ( 1 ), Pkhi ( 1 ), PkDir ( 1 ) count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if end if !--- IMAX ---! if ( imax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , imax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 2 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) do j = Pjlo ( 2 ), Pjhi ( 2 ), PjDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 2 ), Pjhi ( 2 ), Pjdir ( 2 ) do k = Pklo ( 2 ), Pkhi ( 2 ), PkDir ( 2 ) count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if end if !--- JMIN ---! if ( jmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 3 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 3 ), Pihi ( 3 ), PiDir ( 3 ) do k = Pklo ( 3 ), Pkhi ( 3 ), PkDir ( 3 ) count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if end if !--- JMAX ---! if ( jmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , jmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 4 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 4 ), Pihi ( 4 ), PiDir ( 4 ) do k = Pklo ( 4 ), Pkhi ( 4 ), PkDir ( 4 ) count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if end if !--- KMIN ---! if ( kmin_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmin_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 5 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 5 ), Pihi ( 5 ), PiDir ( 5 ) do j = Pjlo ( 5 ), Pjhi ( 5 ), PjDir ( 5 ) count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if end if !--- KMAX ---! if ( kmax_id >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , kmax_id , tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data if ( dir_switch ( 6 ) == 0 ) then count = 0 do n = 1 , n_var do l = 1 , layers do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do else count = 0 do n = 1 , n_var do l = 1 , layers do i = Pilo ( 6 ), Pihi ( 6 ), PiDir ( 6 ) do j = Pjlo ( 6 ), Pjhi ( 6 ), PjDir ( 6 ) count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end if call apply_periodic_bc ( delQstar , 1 ) end subroutine apply_interface","tags":"","loc":"proc/apply_interface~3.html","title":"apply_interface – FEST-3D"},{"text":"public subroutine apply_periodic_bc(qp, layers) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers Calls proc~~apply_periodic_bc~3~~CallsGraph proc~apply_periodic_bc~3 apply_periodic_bc mpi_sendrecv mpi_sendrecv proc~apply_periodic_bc~3->mpi_sendrecv proc~dmsg dmsg proc~apply_periodic_bc~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_periodic_bc~3~~CalledByGraph proc~apply_periodic_bc~3 apply_periodic_bc proc~apply_interface~3 apply_interface proc~apply_interface~3->proc~apply_periodic_bc~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_periodic_bc Source Code subroutine apply_periodic_bc ( qp , layers ) implicit none integer , intent ( in ) :: layers real , dimension ( 0 : imx , 0 : jmx , 0 : kmx , 1 : n_var ), intent ( inout ) :: qp integer :: i , j , k , n , l integer :: status ( MPI_STATUS_SIZE ) integer :: ierr integer :: tag = 1 integer :: count = 0 call dmsg ( 1 , 'interface' , 'apply_periodic_boundary_condition' ) if ( PbcId ( 1 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imin_send_buf ( count ) = qp ( l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imin_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& imin_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 1 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( 1 - l , j , k , n ) = imin_recv_buf ( count ) end do end do end do end do end if if ( PbcId ( 2 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 imax_send_buf ( count ) = qp ( imx - l , j , k , n ) end do end do end do end do call MPI_SENDRECV ( imax_send_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& imax_recv_buf , ibuf_size , MPI_DOUBLE_PRECISION , PbcId ( 2 ), tag ,& MPI_COMM_WORLD , status , ierr ) count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do j = 1 , jmx - 1 count = count + 1 qp ( imx + l - 1 , j , k , n ) = imax_recv_buf ( count ) end do end do end do end do end if !--- JMIN ---! if ( PbcId ( 3 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmin_send_buf ( count ) = qp ( i , l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmin_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& jmin_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 3 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , 1 - l , k , n ) = jmin_recv_buf ( count ) end do end do end do end do end if !--- JMAX ---! if ( PbcId ( 4 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 jmax_send_buf ( count ) = qp ( i , jmx - l , k , n ) end do end do end do end do call MPI_SENDRECV ( jmax_send_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& jmax_recv_buf , jbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 4 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do k = 1 , kmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , jmx + l - 1 , k , n ) = jmax_recv_buf ( count ) end do end do end do end do end if !--- KMIN ---! if ( PbcId ( 5 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmin_send_buf ( count ) = qp ( i , j , l , n ) end do end do end do end do call MPI_SENDRECV ( kmin_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& kmin_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 5 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , 1 - l , n ) = kmin_recv_buf ( count ) end do end do end do end do end if !--- KMAX ---! if ( PbcId ( 6 ) >= 0 ) then !collect data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 kmax_send_buf ( count ) = qp ( i , j , kmx - l , n ) end do end do end do end do call MPI_SENDRECV ( kmax_send_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& kmax_recv_buf , kbuf_size , MPI_DOUBLE_PRECISION , PbcId ( 6 ), tag ,& MPI_COMM_WORLD , status , ierr ) ! redistribute data count = 0 do n = 1 , n_var do l = 1 , layers do j = 1 , jmx - 1 do i = 1 , imx - 1 count = count + 1 qp ( i , j , kmx + l - 1 , n ) = kmax_recv_buf ( count ) end do end do end do end do end if end subroutine apply_periodic_bc","tags":"","loc":"proc/apply_periodic_bc~3.html","title":"apply_periodic_bc – FEST-3D"},{"text":"public subroutine setup_resnorm() Allocate memory, setup scale and file to write Arguments None Calls proc~~setup_resnorm~~CallsGraph proc~setup_resnorm setup_resnorm proc~allocate_memory~2 allocate_memory proc~setup_resnorm->proc~allocate_memory~2 proc~setup_scale setup_scale proc~setup_resnorm->proc~setup_scale proc~setup_file setup_file proc~setup_resnorm->proc~setup_file interface~alloc alloc proc~allocate_memory~2->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_resnorm~~CalledByGraph proc~setup_resnorm setup_resnorm proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_resnorm Source Code subroutine setup_resnorm () !< Allocate memory, setup scale and file to write implicit none call allocate_memory () call setup_scale () call setup_file () end subroutine setup_resnorm","tags":"","loc":"proc/setup_resnorm.html","title":"setup_resnorm – FEST-3D"},{"text":"public subroutine find_resnorm() Find the normalized residual for each processor Arguments None Calls proc~~find_resnorm~~CallsGraph proc~find_resnorm find_resnorm proc~write_resnorm write_resnorm proc~find_resnorm->proc~write_resnorm proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm->proc~assemble_resnom_at_each_process mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_resnorm~~CalledByGraph proc~find_resnorm find_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_resnorm Source Code subroutine find_resnorm () !< Find the normalized residual for each processor implicit none call get_absolute_resnorm () call collect_resnorm_from_all_blocks () call assemble_resnom_at_each_process () call get_relative_resnorm () if (( mod ( current_iter , res_write_interval ) == 0 . or . & current_iter == Res_itr . or . & current_iter == 1 ) . and . & process_id == 0 ) then call write_resnorm () end if end subroutine find_resnorm","tags":"","loc":"proc/find_resnorm.html","title":"find_resnorm – FEST-3D"},{"text":"public subroutine destroy_resnorm() Deallocate memory and close residual file Arguments None Calls proc~~destroy_resnorm~~CallsGraph proc~destroy_resnorm destroy_resnorm proc~close_file~3 close_file proc~destroy_resnorm->proc~close_file~3 proc~deallocate_memory deallocate_memory proc~destroy_resnorm->proc~deallocate_memory interface~dealloc dealloc proc~deallocate_memory->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_resnorm~~CalledByGraph proc~destroy_resnorm destroy_resnorm proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_resnorm proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_resnorm Source Code subroutine destroy_resnorm () !< Deallocate memory and close residual file implicit none call deallocate_memory () call close_file ( RESNORM_FILE_UNIT ) end subroutine destroy_resnorm","tags":"","loc":"proc/destroy_resnorm.html","title":"destroy_resnorm – FEST-3D"},{"text":"private subroutine setup_file() Open the residual file to write Arguments None Called by proc~~setup_file~~CalledByGraph proc~setup_file setup_file proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~setup_file proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file () !< Open the residual file to write implicit none integer :: i if ( process_id == 0 ) then if ( start_from == 0 ) then open ( RESNORM_FILE_UNIT , file = resnorm_file ) else open ( RESNORM_FILE_UNIT , file = resnorm_file , status = 'old' , position = 'append' , action = 'write' ) end if write ( RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) \"Iteration\" do i = 1 , Res_count write ( RESNORM_FILE_UNIT , '(A,2x)' , advance = 'no' ) trim ( Res_list ( i )) end do write ( RESNORM_FILE_UNIT , * ) end if end subroutine setup_file","tags":"","loc":"proc/setup_file.html","title":"setup_file – FEST-3D"},{"text":"private subroutine allocate_memory() Allocate memory to MPI Communication Arguments None Calls proc~~allocate_memory~2~~CallsGraph proc~allocate_memory~2 allocate_memory interface~alloc alloc proc~allocate_memory~2->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~2~~CalledByGraph proc~allocate_memory~2 allocate_memory proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~allocate_memory~2 proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocate memory to MPI Communication implicit none call alloc ( Res_abs , 0 , n_var ) call alloc ( Res_rel , 0 , n_var ) call alloc ( Res_scale , 0 , n_var ) call alloc ( Res_save , 0 , n_var ) call alloc ( buffer , 1 ,( n_var + 1 ) * total_process ) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~2.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine deallocate_memory() Deallocate memory required for MPI Communication Arguments None Calls proc~~deallocate_memory~~CallsGraph proc~deallocate_memory deallocate_memory interface~dealloc dealloc proc~deallocate_memory->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~deallocate_memory~~CalledByGraph proc~deallocate_memory deallocate_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_resnorm proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code deallocate_memory Source Code subroutine deallocate_memory () !< Deallocate memory required for MPI Communication implicit none call dealloc ( Res_abs ) call dealloc ( Res_rel ) call dealloc ( Res_scale ) call dealloc ( Res_save ) call dealloc ( buffer ) if ( allocated ( Res_list )) deallocate ( Res_list ) end subroutine deallocate_memory","tags":"","loc":"proc/deallocate_memory.html","title":"deallocate_memory – FEST-3D"},{"text":"private subroutine setup_scale() Setup scale required for relative and absolute\n residual for writing in the file. Arguments None Called by proc~~setup_scale~~CalledByGraph proc~setup_scale setup_scale proc~setup_resnorm setup_resnorm proc~setup_resnorm->proc~setup_scale proc~setup_solver setup_solver proc~setup_solver->proc~setup_resnorm proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scale Source Code subroutine setup_scale () !< Setup scale required for relative and absolute !< residual for writing in the file. implicit none Res_scale ( 0 ) = 1. Res_scale ( 1 ) = density_inf * vel_mag Res_scale ( 2 ) = density_inf * vel_mag * vel_mag Res_scale ( 3 ) = density_inf * vel_mag * vel_mag Res_scale ( 4 ) = density_inf * vel_mag * vel_mag Res_scale ( 5 ) = ( 0.5 * density_inf * vel_mag ** 3 + & (( gm / ( gm - 1. )) * pressure_inf )) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'kkl' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tkl_inf case ( 'des' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'sa' , 'saBC' ) Res_scale ( 6 ) = density_inf * vel_mag * tv_inf case ( 'kw' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * tw_inf case ( 'ke' ) Res_scale ( 6 ) = density_inf * vel_mag * tk_inf Res_scale ( 7 ) = density_inf * vel_mag * te_inf case DEFAULT Fatal_error end select end subroutine setup_scale","tags":"","loc":"proc/setup_scale.html","title":"setup_scale – FEST-3D"},{"text":"private subroutine get_absolute_resnorm() Get absolute residual for current process Arguments None Called by proc~~get_absolute_resnorm~~CalledByGraph proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_absolute_resnorm Source Code subroutine get_absolute_resnorm () !< Get absolute residual for current process implicit none integer :: i do i = 1 , n_var Res_abs ( i ) = ( sum ( Residue (:,:,:, i ) ** 2 ) / Res_scale ( i ) ** 2 ) end do merror = ( & sum ( F_p ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 )) & - sum ( F_p ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 )) & + sum ( G_p ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 )) & - sum ( G_p ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 )) & + sum ( H_p ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 )) & - sum ( H_p ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 )) & ) Res_abs ( 0 ) = ( merror / Res_scale ( 0 )) end subroutine get_absolute_resnorm","tags":"","loc":"proc/get_absolute_resnorm.html","title":"get_absolute_resnorm – FEST-3D"},{"text":"private subroutine collect_resnorm_from_all_blocks() MPI Communication to gather residual from all processes Arguments None Calls proc~~collect_resnorm_from_all_blocks~~CallsGraph proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~collect_resnorm_from_all_blocks~~CalledByGraph proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm find_resnorm proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code collect_resnorm_from_all_blocks Source Code subroutine collect_resnorm_from_all_blocks () !< MPI Communication to gather residual from all processes implicit none integer :: ierr call MPI_ALLGATHER ( Res_abs , n_var + 1 , MPI_DOUBLE_PRECISION , & buffer , n_var + 1 , MPI_DOUBLE_PRECISION , MPI_COMM_WORLD , ierr ) end subroutine collect_resnorm_from_all_blocks","tags":"","loc":"proc/collect_resnorm_from_all_blocks.html","title":"collect_resnorm_from_all_blocks – FEST-3D"},{"text":"private subroutine assemble_resnom_at_each_process() Sum residual obtained from all the processes after MPI_Communication Arguments None Called by proc~~assemble_resnom_at_each_process~~CalledByGraph proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm find_resnorm proc~find_resnorm->proc~assemble_resnom_at_each_process proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code assemble_resnom_at_each_process Source Code subroutine assemble_resnom_at_each_process () !< Sum residual obtained from all the processes after MPI_Communication implicit none integer :: i , j Res_abs = 0. do i = 0 , total_process - 1 do j = 0 , n_var Res_abs ( j ) = Res_abs ( j ) + buffer (( j + 1 ) + ( n_var + 1 ) * i ) end do end do Res_abs ( 1 :) = sqrt ( Res_abs ( 1 :)) Res_abs ( 0 ) = abs ( Res_abs ( 0 )) end subroutine assemble_resnom_at_each_process","tags":"","loc":"proc/assemble_resnom_at_each_process.html","title":"assemble_resnom_at_each_process – FEST-3D"},{"text":"private subroutine get_relative_resnorm() Get relative residual with respect to first iteration residual Arguments None Called by proc~~get_relative_resnorm~~CalledByGraph proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_relative_resnorm Source Code subroutine get_relative_resnorm () !< Get relative residual with respect to first iteration residual implicit none if ( current_iter <= Res_itr ) Res_save = Res_abs Res_rel = Res_abs / Res_save end subroutine get_relative_resnorm","tags":"","loc":"proc/get_relative_resnorm.html","title":"get_relative_resnorm – FEST-3D"},{"text":"private subroutine write_resnorm() Writing the residual in the file to save. Arguments None Called by proc~~write_resnorm~~CalledByGraph proc~write_resnorm write_resnorm proc~find_resnorm find_resnorm proc~find_resnorm->proc~write_resnorm proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~find_resnorm program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_resnorm Source Code subroutine write_resnorm () !< Writing the residual in the file to save. implicit none integer :: i integer :: n = 6 character ( len = 20 ) :: frm n = write_percision write ( frm , '(A,I0,A,I0,A)' ) \"(e\" , n + 8 , \".\" , n , \"E2, 4x)\" write ( RESNORM_FILE_UNIT , '(I0,4x)' , advance = 'no' ) current_iter + last_iter do i = 1 , Res_count select case ( trim ( Res_list ( i ))) !include \"resnorm_write_cases.inc\" case ( 'Mass_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 0 ) case ( 'Resnorm_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) if ( trim ( turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 6 :) ** 2 )) end if case ( 'Continuity_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 1 ) case ( 'X_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 2 ) case ( 'Y_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 3 ) case ( 'Z_mom_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 4 ) case ( 'Energy_abs' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 5 ) case ( 'Mass_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 0 ) case ( 'Resnorm_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) if ( trim ( turbulence ) /= 'none' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_rel ( 6 :) ** 2 )) end if case ( 'Continuity_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 1 ) case ( 'X-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 2 ) case ( 'Y-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 3 ) case ( 'Z-mom_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 4 ) case ( 'Energy_rel' ) write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 5 ) case ( 'TKE_abs' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'kkl' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Tv_abs' ) if ( trim ( turbulence ) == 'sa' . or . trim ( turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 6 ) end if case ( 'Dissipation_abs' ) if ( trim ( turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Omega_abs' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'Kl_abs' ) if ( trim ( turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_abs ( 7 ) end if case ( 'TKE_rel' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'kkl' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Tv_rel' ) if ( trim ( turbulence ) == 'sa' . or . trim ( turbulence ) == 'saBC' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 6 ) end if case ( 'Dissipation_rel' ) if ( trim ( turbulence ) == 'ke' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Omega_rel' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case ( 'Kl_rel' ) if ( trim ( turbulence ) == 'kkl' ) then write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) Res_rel ( 7 ) end if case DEFAULT ! making absolute resnorm default write ( RESNORM_FILE_UNIT , frm , advance = 'no' ) sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select end do write ( RESNORM_FILE_UNIT , * ) end subroutine write_resnorm","tags":"","loc":"proc/write_resnorm.html","title":"write_resnorm – FEST-3D"},{"text":"public subroutine setup_solver() Call to allocate memoery and initialize domain Arguments None Calls proc~~setup_solver~~CallsGraph proc~setup_solver setup_solver setup_scheme setup_scheme proc~setup_solver->setup_scheme proc~initmisc initmisc proc~setup_solver->proc~initmisc mpi_barrier mpi_barrier proc~setup_solver->mpi_barrier proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~setup_time setup_time proc~setup_solver->proc~setup_time proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~checkpoint checkpoint proc~setup_solver->proc~checkpoint proc~setupcc setupCC proc~setup_solver->proc~setupcc proc~setup_source Setup_source proc~setup_solver->proc~setup_source proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~find_wall_dist find_wall_dist proc~setup_solver->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_solver->proc~setup_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_solver->proc~read_input_and_controls proc~dmsg dmsg proc~setup_solver->proc~dmsg proc~setup_interface setup_interface proc~setup_solver->proc~setup_interface proc~setup_bc setup_bc proc~setup_solver->proc~setup_bc proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_viscosity setup_viscosity proc~setup_solver->proc~setup_viscosity proc~get_process_data get_process_data proc~setup_solver->proc~get_process_data proc~setup_update setup_update proc~setup_solver->proc~setup_update proc~read_layout_file read_layout_file proc~setup_solver->proc~read_layout_file proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_solver~~CalledByGraph proc~setup_solver setup_solver proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_solver Source Code subroutine setup_solver () !< Call to allocate memoery and initialize domain !-------------------------------------------------- implicit none integer :: ierr call dmsg ( 1 , 'solver' , 'setup_solver' ) call get_process_data () ! parallel calls call read_layout_file ( process_id ) ! reads layout file calls call read_input_and_controls () call setup_grid ( grid_file_buf ) call setup_geometry () call setup_viscosity () call setup_state () call setup_gradients () call setup_source call setup_bc () call setup_time () call setup_update () call setup_interface () call setup_scheme () if ( turbulence /= 'none' ) then call write_surfnode () call setup_wall_dist () call mpi_barrier ( MPI_COMM_WORLD , ierr ) call find_wall_dist () end if call setupCC () call setup_resnorm () call initmisc () checkpoint_iter_count = 0 call checkpoint () ! Create an initial dump file current_iter = 1 call dmsg ( 1 , 'solver' , 'setup_solver' , 'checkpoint' ) if ( process_id == 0 ) then open ( STOP_FILE_UNIT , file = stop_file ) end if call dmsg ( 1 , 'solver' , 'setup_solver' , 'Setup solver complete' ) end subroutine setup_solver","tags":"","loc":"proc/setup_solver.html","title":"setup_solver – FEST-3D"},{"text":"public subroutine destroy_solver() Call to different modules to deallocate memory Arguments None Calls proc~~destroy_solver~~CallsGraph proc~destroy_solver destroy_solver proc~destroycc destroyCC proc~destroy_solver->proc~destroycc proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time proc~destroy_gradients destroy_gradients proc~destroy_solver->proc~destroy_gradients proc~destroy_grid destroy_grid proc~destroy_solver->proc~destroy_grid proc~destroy_resnorm destroy_resnorm proc~destroy_solver->proc~destroy_resnorm destroy_scheme destroy_scheme proc~destroy_solver->destroy_scheme proc~destroy_state destroy_state proc~destroy_solver->proc~destroy_state proc~destroy_interface destroy_interface proc~destroy_solver->proc~destroy_interface proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~destroy_viscosity destroy_viscosity proc~destroy_solver->proc~destroy_viscosity proc~dmsg dmsg proc~destroy_solver->proc~dmsg proc~destroy_update destroy_update proc~destroy_solver->proc~destroy_update proc~destroy_wall_dist destroy_wall_dist proc~destroy_solver->proc~destroy_wall_dist proc~destroy_bc destroy_bc proc~destroy_solver->proc~destroy_bc proc~destroy_source destroy_source proc~destroy_solver->proc~destroy_source interface~dealloc dealloc proc~destroycc->interface~dealloc debugcall debugcall proc~destroycc->debugcall proc~destroy_time->proc~dmsg interface~alloc alloc proc~destroy_time->interface~alloc mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~destroy_time->interface~dealloc proc~write_time write_time proc~destroy_time->proc~write_time proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_memory destroy_memory proc~destroy_gradients->proc~destroy_memory proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients->proc~destroy_kkl_grad proc~destroy_gradients->debugcall proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_grid->proc~dmsg proc~destroy_grid->interface~dealloc proc~close_file~3 close_file proc~destroy_resnorm->proc~close_file~3 proc~deallocate_memory deallocate_memory proc~destroy_resnorm->proc~deallocate_memory proc~deallocate_memory~4 deallocate_memory proc~destroy_state->proc~deallocate_memory~4 proc~destroy_state->debugcall proc~unlink_aliases~2 unlink_aliases proc~destroy_state->proc~unlink_aliases~2 proc~destroy_interface->interface~dealloc proc~destroy_geometry->proc~dmsg proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_viscosity->interface~dealloc proc~destroy_lusgs destroy_lusgs proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_update->interface~dealloc proc~destroy_wall_dist->proc~dmsg proc~destroy_wall_dist->interface~dealloc proc~destroy_bc->interface~dealloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_solver~~CalledByGraph proc~destroy_solver destroy_solver proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_solver Source Code subroutine destroy_solver () !< Call to different modules to deallocate memory !-------------------------------------------------- implicit none call dmsg ( 1 , 'solver' , 'destroy_solver' ) if ( process_id == 0 ) then close ( STOP_FILE_UNIT ) end if call destroy_update () call destroy_viscosity () call destroy_gradients () call destroyCC () if ( turbulence /= 'none' ) then call destroy_wall_dist () end if call destroy_scheme () call destroy_source () call destroy_state () call destroy_geometry () call destroy_grid () call destroy_resnorm () call destroy_interface () call destroy_time () call destroy_bc () if ( allocated ( r_list )) deallocate ( r_list ) if ( allocated ( w_list )) deallocate ( w_list ) end subroutine destroy_solver","tags":"","loc":"proc/destroy_solver.html","title":"destroy_solver – FEST-3D"},{"text":"private subroutine initmisc() Initilize miscellaneous variables Arguments None Calls proc~~initmisc~~CallsGraph proc~initmisc initmisc proc~dmsg dmsg proc~initmisc->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initmisc~~CalledByGraph proc~initmisc initmisc proc~setup_solver setup_solver proc~setup_solver->proc~initmisc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initmisc Source Code subroutine initmisc () !< Initilize miscellaneous variables !---------------------------------- implicit none call dmsg ( 1 , 'solver' , 'initmisc' ) sim_clock = 0. current_iter = 0 end subroutine initmisc","tags":"","loc":"proc/initmisc.html","title":"initmisc – FEST-3D"},{"text":"public subroutine iterate_one_more_time_step() Perform one time step iteration Arguments None Calls proc~~iterate_one_more_time_step~~CallsGraph proc~iterate_one_more_time_step iterate_one_more_time_step proc~find_resnorm find_resnorm proc~iterate_one_more_time_step->proc~find_resnorm proc~checkpoint checkpoint proc~iterate_one_more_time_step->proc~checkpoint proc~dmsg dmsg proc~iterate_one_more_time_step->proc~dmsg proc~get_next_solution get_next_solution proc~iterate_one_more_time_step->proc~get_next_solution mpi_bcast mpi_bcast proc~iterate_one_more_time_step->mpi_bcast proc~assemble_resnom_at_each_process assemble_resnom_at_each_process proc~find_resnorm->proc~assemble_resnom_at_each_process proc~write_resnorm write_resnorm proc~find_resnorm->proc~write_resnorm proc~get_relative_resnorm get_relative_resnorm proc~find_resnorm->proc~get_relative_resnorm proc~collect_resnorm_from_all_blocks collect_resnorm_from_all_blocks proc~find_resnorm->proc~collect_resnorm_from_all_blocks proc~get_absolute_resnorm get_absolute_resnorm proc~find_resnorm->proc~get_absolute_resnorm proc~checkpoint->proc~dmsg proc~make_dump_dir make_dump_dir proc~checkpoint->proc~make_dump_dir proc~dump_data dump_data proc~checkpoint->proc~dump_data proc~purge_dump_dir purge_dump_dir proc~checkpoint->proc~purge_dump_dir proc~update_with update_with proc~get_next_solution->proc~update_with proc~compute_time_step compute_time_step proc~get_next_solution->proc~compute_time_step proc~update_with_lusgs update_with_lusgs proc~get_next_solution->proc~update_with_lusgs proc~update_laminar_variables_conservative update_laminar_variables_conservative proc~get_next_solution->proc~update_laminar_variables_conservative proc~update_with_plusgs update_with_plusgs proc~get_next_solution->proc~update_with_plusgs proc~update_turbulent_variables_conservative update_turbulent_variables_conservative proc~get_next_solution->proc~update_turbulent_variables_conservative proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution->proc~get_total_conservative_residue proc~create_directory create_directory proc~make_dump_dir->proc~create_directory proc~compute_time_step->proc~dmsg proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~dump_data->proc~dmsg proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log mpi_allgather mpi_allgather proc~collect_resnorm_from_all_blocks->mpi_allgather proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory compute_residue compute_residue proc~get_total_conservative_residue->compute_residue proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->compute_face_interpolant proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes compute_fluxes compute_fluxes proc~get_total_conservative_residue->compute_fluxes var panprociterate_one_more_time_stepCallsGraph = svgPanZoom('#prociterate_one_more_time_stepCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~iterate_one_more_time_step~~CalledByGraph proc~iterate_one_more_time_step iterate_one_more_time_step program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code iterate_one_more_time_step Source Code subroutine iterate_one_more_time_step () !< Perform one time step iteration !  This subroutine performs one iteration by stepping through !  time once. !----------------------------------------------------------- implicit none integer :: ierr call dmsg ( 1 , 'solver' , 'iterate_one_more_time_step' ) if ( process_id == 0 ) then print * , current_iter end if call get_next_solution () if (( mod ( current_iter , res_write_interval ) == 0 . or . & current_iter == Res_itr . or . & current_iter == 1 )) then call find_resnorm () end if call checkpoint () current_iter = current_iter + 1 if ( process_id == 0 ) then REWIND ( STOP_FILE_UNIT ) read ( STOP_FILE_UNIT , * ) want_to_stop end if call MPI_BCAST ( want_to_stop , 1 , MPI_INTEGER , 0 , MPI_COMM_WORLD , ierr ) !if (want_to_stop==1) max_iters=current_iter-1 if ( want_to_stop == 1 ) Halt = . TRUE . end subroutine iterate_one_more_time_step","tags":"","loc":"proc/iterate_one_more_time_step.html","title":"iterate_one_more_time_step – FEST-3D"},{"text":"public subroutine read_interface_map() Read mapping file in the system/mesh/layout/mapping.txt Arguments None Calls proc~~read_interface_map~~CallsGraph proc~read_interface_map read_interface_map proc~close_file~3 close_file proc~read_interface_map->proc~close_file~3 proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map->proc~change_map_to_particular_range proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map->proc~read_periodic_bc_file Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_interface_map~~CalledByGraph proc~read_interface_map read_interface_map proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_interface_map Source Code subroutine read_interface_map () !< Read mapping file in the system/mesh/layout/mapping.txt implicit none integer :: ios integer :: max_call integer :: i integer :: b1 , b2 , f1 , f2 integer :: s11 , s12 , s21 , s22 integer :: e11 , e12 , e21 , e22 integer :: switch integer :: class !--- initialize indicies --! max_call = total_process * 6 ilo ( 1 ) = 1 ; ihi ( 1 ) = 1 ilo ( 2 ) = imx ; ihi ( 2 ) = imx ilo ( 3 ) = 1 ; ihi ( 3 ) = imx ilo ( 4 ) = 1 ; ihi ( 4 ) = imx ilo ( 5 ) = 1 ; ihi ( 5 ) = imx ilo ( 6 ) = 1 ; ihi ( 6 ) = imx jlo ( 1 ) = 1 ; jhi ( 1 ) = jmx jlo ( 2 ) = 1 ; jhi ( 2 ) = jmx jlo ( 3 ) = 1 ; jhi ( 3 ) = 1 jlo ( 4 ) = jmx ; jhi ( 4 ) = jmx jlo ( 5 ) = 1 ; jhi ( 5 ) = jmx jlo ( 6 ) = 1 ; jhi ( 6 ) = jmx klo ( 1 ) = 1 ; khi ( 1 ) = kmx klo ( 2 ) = 1 ; khi ( 2 ) = kmx klo ( 3 ) = 1 ; khi ( 3 ) = kmx klo ( 4 ) = 1 ; khi ( 4 ) = kmx klo ( 5 ) = 1 ; khi ( 5 ) = 1 klo ( 6 ) = kmx ; khi ( 6 ) = kmx otherface ( 1 ) = 2 otherface ( 2 ) = 1 otherface ( 3 ) = 4 otherface ( 4 ) = 3 otherface ( 5 ) = 6 otherface ( 6 ) = 5 dir_switch = 0 !--- end of variable intializaiton --! !--- reading map file  ---! open ( MAP_FILE_UNIT , file = mapfile , status = 'old' , action = 'read' ) read ( MAP_FILE_UNIT , * ) ! ignore header do i = 1 , max_call read ( MAP_FILE_UNIT , * , iostat = ios ) b1 , f1 , s11 , e11 , s12 , e12 ,& b2 , f2 , s21 , e21 , s22 , e22 , switch , class if ( is_iostat_end ( ios )) EXIT if ( b1 == process_id ) then if ( f1 == 1 ) then otherface ( 1 ) = f2 jlo ( 1 ) = s21 jhi ( 1 ) = e21 klo ( 1 ) = s22 khi ( 1 ) = e22 dir_switch ( 1 ) = switch mpi_class ( 1 ) = class elseif ( f1 == 2 ) then otherface ( 2 ) = f2 jlo ( 2 ) = s21 jhi ( 2 ) = e21 klo ( 2 ) = s22 khi ( 2 ) = e22 dir_switch ( 2 ) = switch mpi_class ( 2 ) = class elseif ( f1 == 3 ) then otherface ( 3 ) = f2 ilo ( 3 ) = s21 ihi ( 3 ) = e21 klo ( 3 ) = s22 khi ( 3 ) = e22 dir_switch ( 3 ) = switch mpi_class ( 3 ) = class elseif ( f1 == 4 ) then otherface ( 4 ) = f2 ilo ( 4 ) = s21 ihi ( 4 ) = e21 klo ( 4 ) = s22 khi ( 4 ) = e22 dir_switch ( 4 ) = switch mpi_class ( 4 ) = class elseif ( f1 == 5 ) then otherface ( 5 ) = f2 ilo ( 5 ) = s21 ihi ( 5 ) = e21 jlo ( 5 ) = s22 jhi ( 5 ) = e22 dir_switch ( 5 ) = switch mpi_class ( 5 ) = class elseif ( f1 == 6 ) then otherface ( 6 ) = f2 ilo ( 6 ) = s21 ihi ( 6 ) = e21 jlo ( 6 ) = s22 jhi ( 6 ) = e22 dir_switch ( 6 ) = switch mpi_class ( 6 ) = class end if else continue end if end do call close_file ( MAP_FILE_UNIT ) call change_map_to_particular_range () call read_periodic_bc_file () end subroutine read_interface_map","tags":"","loc":"proc/read_interface_map.html","title":"read_interface_map – FEST-3D"},{"text":"private subroutine change_map_to_particular_range() Modified the indicies for MPI communication Arguments None Called by proc~~change_map_to_particular_range~~CalledByGraph proc~change_map_to_particular_range change_map_to_particular_range proc~read_interface_map read_interface_map proc~read_interface_map->proc~change_map_to_particular_range proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocchange_map_to_particular_rangeCalledByGraph = svgPanZoom('#procchange_map_to_particular_rangeCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code change_map_to_particular_range Source Code subroutine change_map_to_particular_range () !< Modified the indicies for MPI communication !------------------------------------- !eg: 1-kmx to 0 to kmx for data transfer !-------------------------------------- implicit none integer :: i Pilo = ilo Pjlo = jlo Pklo = klo Pihi = ihi Pjhi = jhi Pkhi = khi PiDir = 1 PjDir = 1 PkDir = 1 do i = 1 , 6 if ( ilo ( i ) == 1 . and . i > 2 ) then Pilo ( i ) = 1 Gilo ( i ) =- 2 end if if ( jlo ( i ) == 1 . and . ( i > 4 . or . i < 3 ) ) then Pjlo ( i ) = 1 Gjlo ( i ) =- 2 end if if ( klo ( i ) == 1 . and . i < 5 ) then Pklo ( i ) = 1 Gklo ( i ) =- 2 end if if ( ihi ( i ) == 1 . and . i > 2 ) then Pihi ( i ) = 1 Gihi ( i ) =- 2 PiDir ( i ) =- 1 end if if ( jhi ( i ) == 1 . and . ( i > 4 . or . i < 3 )) then Pjhi ( i ) = 1 Gjhi ( i ) =- 2 PjDir ( i ) =- 1 end if if ( khi ( i ) == 1 . and . i < 5 ) then Pkhi ( i ) = 1 Gkhi ( i ) =- 2 PkDir ( i ) =- 1 end if if ( ilo ( i ) > 1 . and . i > 2 ) then Gilo ( i ) = ilo ( i ) + 3 Pilo ( i ) = ilo ( i ) - 1 PiDir ( i ) =- 1 end if if ( jlo ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjlo ( i ) = jlo ( i ) + 3 Pjlo ( i ) = jlo ( i ) - 1 PjDir ( i ) =- 1 end if if ( klo ( i ) > 1 . and . i < 5 ) then Gklo ( i ) = klo ( i ) + 3 Pklo ( i ) = klo ( i ) - 1 PkDir ( i ) =- 1 end if if ( ihi ( i ) > 1 . and . i > 2 ) then Gihi ( i ) = ihi ( i ) + 3 Pihi ( i ) = ihi ( i ) - 1 end if if ( jhi ( i ) > 1 . and . ( i > 4 . or . i < 5 )) then Gjhi ( i ) = jhi ( i ) + 3 Pjhi ( i ) = jhi ( i ) - 1 end if if ( khi ( i ) > 1 . and . i < 5 ) then Gkhi ( i ) = khi ( i ) + 3 Pkhi ( i ) = khi ( i ) - 1 end if end do end subroutine change_map_to_particular_range","tags":"","loc":"proc/change_map_to_particular_range.html","title":"change_map_to_particular_range – FEST-3D"},{"text":"private subroutine read_periodic_bc_file() Read periodic.md file in the system/mesh/layout/periodic.md Arguments None Called by proc~~read_periodic_bc_file~~CalledByGraph proc~read_periodic_bc_file read_periodic_bc_file proc~read_interface_map read_interface_map proc~read_interface_map->proc~read_periodic_bc_file proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~setup_solver setup_solver proc~setup_solver->proc~setup_grid proc~setup_all setup_all proc~setup_all->proc~setup_grid proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocread_periodic_bc_fileCalledByGraph = svgPanZoom('#procread_periodic_bc_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_periodic_bc_file Source Code subroutine read_periodic_bc_file () !< Read periodic.md file in the system/mesh/layout/periodic.md implicit none integer :: ios integer :: max_call integer :: i integer :: b1 , b2 integer :: f1 , f2 integer :: class open ( PERIODIC_FILE_UNIT , file = periodicfile , status = 'old' , action = 'read' ) read ( PERIODIC_FILE_UNIT , * ) !ignore first line (header) max_call = total_process * 6 do i = 1 , max_call read ( PERIODIC_FILE_UNIT , * , iostat = ios ) b1 , b2 , f1 , f2 , class if ( is_iostat_end ( ios )) EXIT if ( b1 == process_id ) then PbcId ( f1 ) = b2 end if end do close ( PERIODIC_FILE_UNIT ) end subroutine read_periodic_bc_file","tags":"","loc":"proc/read_periodic_bc_file.html","title":"read_periodic_bc_file – FEST-3D"},{"text":"public subroutine get_process_data() Get Processor Id and total number of processors Arguments None Calls proc~~get_process_data~~CallsGraph proc~get_process_data get_process_data mpi_comm_size mpi_comm_size proc~get_process_data->mpi_comm_size mpi_comm_rank mpi_comm_rank proc~get_process_data->mpi_comm_rank Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_process_data~~CalledByGraph proc~get_process_data get_process_data proc~setup_solver setup_solver proc~setup_solver->proc~get_process_data proc~setup_all setup_all proc~setup_all->proc~get_process_data proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_process_data Source Code subroutine get_process_data () !<Get Processor Id and total number of processors implicit none ! Finds and sets process data integer :: ierr call MPI_COMM_RANK ( MPI_COMM_WORLD , process_id , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , total_process , ierr ) end subroutine get_process_data","tags":"","loc":"proc/get_process_data.html","title":"get_process_data – FEST-3D"},{"text":"public subroutine get_next_token_parallel(buf) Extract the next token from the layout file Each token is on a separate line.\n There may be multiple comments (lines beginning with #) \n and blank lines in between.\n The purpose of this subroutine is to ignore all these \n lines and return the next \"useful\" line. Arguments Type Intent Optional Attributes Name character(len=STRING_BUFFER_LENGTH), intent(out) :: buf Calls proc~~get_next_token_parallel~~CallsGraph proc~get_next_token_parallel get_next_token_parallel proc~dmsg dmsg proc~get_next_token_parallel->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_next_token_parallel~~CalledByGraph proc~get_next_token_parallel get_next_token_parallel proc~read_layout_file read_layout_file proc~read_layout_file->proc~get_next_token_parallel proc~setup_solver setup_solver proc~setup_solver->proc~read_layout_file proc~setup_all setup_all proc~setup_all->proc~read_layout_file proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_token_parallel Source Code subroutine get_next_token_parallel ( buf ) !< Extract the next token from the layout file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( CONFIG_FILE_UNIT , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do call dmsg ( 0 , 'solver' , 'get_next_token' , 'Returning: ' // trim ( buf )) end subroutine get_next_token_parallel","tags":"","loc":"proc/get_next_token_parallel.html","title":"get_next_token_parallel – FEST-3D"},{"text":"public subroutine read_layout_file(process_id) Read the layout file for particular processor Arguments Type Intent Optional Attributes Name integer, intent(in) :: process_id Processor id for current block Calls proc~~read_layout_file~~CallsGraph proc~read_layout_file read_layout_file proc~dmsg dmsg proc~read_layout_file->proc~dmsg proc~get_next_token_parallel get_next_token_parallel proc~read_layout_file->proc~get_next_token_parallel proc~get_next_token_parallel->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_layout_file~~CalledByGraph proc~read_layout_file read_layout_file proc~setup_solver setup_solver proc~setup_solver->proc~read_layout_file proc~setup_all setup_all proc~setup_all->proc~read_layout_file proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_layout_file Source Code subroutine read_layout_file ( process_id ) !< Read the layout file for particular processor implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf integer , intent ( in ) :: process_id !< Processor id for current block integer :: i , buf_id call dmsg ( 1 , 'layout' , 'read_layout_file' ) open ( CONFIG_FILE_UNIT , file = layout_file ) ! Read the parameters from the file call get_next_token_parallel ( buf ) read ( buf , * ) total_process call get_next_token_parallel ( buf ) read ( buf , * ) total_entries i = 0 !print *, process_id call get_next_token_parallel ( buf ) do while ( i < process_id ) call get_next_token_parallel ( buf ) i = i + 1 end do read ( buf , * ) buf_id , grid_file_buf , bc_file , imin_id , imax_id , jmin_id , jmax_id , kmin_id , kmax_id write ( grid_file_buf , '(A)' ) 'system/mesh/gridfiles/' // trim ( grid_file_buf ) write ( bc_file , '(A)' ) 'system/mesh/bc/' // trim ( bc_file ) end subroutine read_layout_file","tags":"","loc":"proc/read_layout_file.html","title":"read_layout_file – FEST-3D"},{"text":"public subroutine calculate_viscosity() Calculate molecular and turbulent viscosity Arguments None Called by proc~~calculate_viscosity~~CalledByGraph proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~calculate_viscosity proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccalculate_viscosityCalledByGraph = svgPanZoom('#proccalculate_viscosityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code calculate_viscosity Source Code subroutine calculate_viscosity () !< Calculate molecular and turbulent viscosity implicit none integer :: i , j , k real :: T ! molecular viscosity real :: c ! kkl eddy viscosity !- sst varibales -! real :: F real :: arg2 real :: vort real :: NUM real :: DENOM ! for arg2 real :: var1 real :: var2 !for vorticity real :: wijwij real :: wx real :: wy real :: wz !for strain calculation real :: SijSij real :: Sxx , Syy , Szz real :: Sxy , Szx , Syz real :: strain !for arg1 real :: arg1 real :: CD real :: right real :: left ! sa variables real :: fv1 real :: xi !--- calculate_molecular_viscosity ---! if ( mu_ref /= 0. ) then select case ( trim ( mu_variation )) case ( 'sutherland_law' ) ! apply_sutherland_law do k = 0 , kmx do j = 0 , jmx do i = 0 , imx T = pressure ( i , j , k ) / ( density ( i , j , k ) * R_gas ) mu ( i , j , k ) = mu_ref * (( T / T_ref ) ** ( 1.5 )) & * (( T_ref + Sutherland_temp )& / ( T + Sutherland_temp )) end do end do end do case ( 'constant' ) !do nothing !mu will be equal to mu_ref continue case DEFAULT print * , \"mu_variation not recognized:\" print * , \"   found '\" , trim ( mu_variation ), \"'\" print * , \"accepted values: 1) sutherland_law\" print * , \"                 2) constant\" Fatal_error end select end if !--- end molecular viscosity calculation---! !--- calculate_turbulent_viscosity  ---! if ( turbulence /= 'none' ) then select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) !call calculate_sa_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! xsi xi = tv ( i , j , k ) * density ( i , j , k ) / mu ( i , j , k ) !calculation fo fv1 function fv1 = ( xi ** 3 ) / (( xi ** 3 ) + ( cv1 ** 3 )) sa_mu ( i , j , k ) = density ( i , j , k ) * tv ( i , j , k ) * fv1 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sa_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sa_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sa_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sa_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sa_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sa_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sa_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sa_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sa_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sa_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sa_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sa_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sa_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sa_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sa_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sa_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sa_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sa_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sa_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sa eddy viscosity  ---! case ( 'sst2003' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! calculate_arg2() var1 = sqrt ( tk ( i , j , k )) / ( bstar * tw ( i , j , k ) * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ( i , j , k )) / (( dist ( i , j , k ) ** 2 ) * tw ( i , j , k )) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( sxx = ( gradu_x ( i , j , k )) syy = ( gradv_y ( i , j , k )) szz = ( gradw_z ( i , j , k )) syz = ( gradw_y ( i , j , k ) + gradv_z ( i , j , k )) szx = ( gradu_z ( i , j , k ) + gradw_x ( i , j , k )) sxy = ( gradv_x ( i , j , k ) + gradu_y ( i , j , k )) SijSij = ( 2.0 * ( sxx ** 2 )) + ( 2.0 * ( syy ** 2 )) + ( 2.0 * ( szz ** 2 )) + syz ** 2 + szx ** 2 + sxy ** 2 strain = sqrt ( SijSij ) NUM = density ( i , j , k ) * a1 * tk ( i , j , k ) DENOM = max ( max (( a1 * tw ( i , j , k )), strain * F ), 1.0e-10 ) sst_mu ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density ( i , j , k ) * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ), & 1.0e-10 ) right = 4 * ( density ( i , j , k ) * sigma_w2 * tk ( i , j , k )) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( tk ( i , j , k )) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst2003 eddy viscosity  and blending fucntion calculation ---! case ( 'sst' ) !call calculate_sst_mu() do k = 0 , kmx do j = 0 , jmx do i = 0 , imx ! calculate_arg2() var1 = sqrt ( tk ( i , j , k )) / ( bstar * tw ( i , j , k ) * dist ( i , j , k )) var2 = 500 * ( mu ( i , j , k ) / density ( i , j , k )) / (( dist ( i , j , k ) ** 2 ) * tw ( i , j , k )) arg2 = max ( 2 * var1 , var2 ) ! calculate_f2() F = tanh ( arg2 ** 2 ) ! calculate_vorticity( wx = ( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) wy = ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) wz = ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) wijwij = wx ** 2 + wy ** 2 + wz ** 2 vort = sqrt ( wijwij ) NUM = density ( i , j , k ) * a1 * tk ( i , j , k ) DENOM = max ( max (( a1 * tw ( i , j , k )), vort * F ), 1.e-20 ) sst_mu ( i , j , k ) = NUM / DENOM !-- end eddy visocisyt calculation --! !-- calculating blending function F1 --! CD = max ( 2 * density ( i , j , k ) * sigma_w2 * ( & gradtk_x ( i , j , k ) * gradtw_x ( i , j , k )& + gradtk_y ( i , j , k ) * gradtw_y ( i , j , k )& + gradtk_z ( i , j , k ) * gradtw_z ( i , j , k )& ) / tw ( i , j , k ), & 1 e - 20 ) right = 4 * ( density ( i , j , k ) * sigma_w2 * tk ( i , j , k )) / ( CD * ( dist ( i , j , k ) ** 2 )) left = max ( var1 , var2 ) arg1 = min ( left , right ) sst_F1 ( i , j , k ) = tanh ( arg1 ** 4 ) !-- end of blending function F1 calculation --! end do end do end do select case ( trim ( transition )) case ( 'lctm2015' ) do k = 0 , kmx do j = 0 , jmx do i = 0 , imx !modified blending function (Menter 2015) var1 = density ( i , j , k ) * dist ( i , j , k ) * sqrt ( tk ( i , j , k )) / mu ( i , j , k ) var2 = exp ( - ( var1 / 120 ) ** 8 ) sst_F1 ( i , j , k ) = max ( sst_F1 ( i , j , k ), var2 ) end do end do end do case DEFAULT !do nothing continue end select ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 1 , - 2 , - 3 , - 4 , - 6 , - 7 , - 8 , - 9 ) !call copy1(sst_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(sst_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) sst_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) sst_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - sst_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) sst_F1 ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = sst_F1 ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) sst_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) sst_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - sst_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) sst_F1 ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = sst_F1 ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - sst_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = sst_F1 ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of sst eddy viscosity  and blending fucntion calculation ---! case ( 'kkl' ) !--- calculate_kkl_mu() c = cmu ** 0.25 do k = 0 , kmx do j = 0 , jmx do i = 0 , imx kkl_mu ( i , j , k ) = c * density ( i , j , k ) * tkl ( i , j , k )& / ( max ( sqrt ( tk ( i , j , k )), 1.e-20 )) if ( tkl ( i , j , k ) < 1.e-14 . or . tk ( i , j , k ) < 1.e-14 ) & kkl_mu ( i , j , k ) = 0.0 end do end do end do ! populating ghost cell do i = 1 , 6 select case ( id ( i )) case ( - 10 , 0 :) !interface continue case ( - 4 : - 1 , - 6 , - 8 , - 9 ) !call copy1(kkl_mu, \"symm\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) kkl_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = kkl_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) kkl_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = kkl_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) kkl_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = kkl_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) kkl_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = kkl_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select case ( - 5 ) !call copy1(kkl_mu, \"anti\", face_names(i)) select case ( face_names ( i )) case ( \"imin\" ) kkl_mu ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = - kkl_mu ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) kkl_mu ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = - kkl_mu ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) kkl_mu ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = - kkl_mu ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) kkl_mu ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = - kkl_mu ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = - kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = - kkl_mu ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" Fatal_error end select end select end do !--- end of kkl eddy viscosity calculation ---! case DEFAULT !call turbulence_read_error() Fatal_error end select end if !--- end turbulent viscosity calculation---! !--- check on viscosity ---! if ( any ( isnan ( mu ))) then Fatal_error end if end subroutine calculate_viscosity","tags":"","loc":"proc/calculate_viscosity.html","title":"calculate_viscosity – FEST-3D"},{"text":"public subroutine setup_viscosity() Allocate and pointer for molecular and turbulent viscosity Arguments None Calls proc~~setup_viscosity~~CallsGraph proc~setup_viscosity setup_viscosity interface~alloc alloc proc~setup_viscosity->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_viscosity~~CalledByGraph proc~setup_viscosity setup_viscosity proc~setup_solver setup_solver proc~setup_solver->proc~setup_viscosity proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_viscosity Source Code subroutine setup_viscosity () !< Allocate and pointer for molecular and turbulent viscosity !setup_molecular_viscosity() if ( mu_ref /= 0. ) then call alloc ( mu , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) mu = mu_ref !intialize end if !--- setup_turbulent_viscosity ---! if ( turbulence /= 'none' ) then call alloc ( mu_t , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) sa_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) case ( 'sst' , 'sst2003' ) sst_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) !-- sst blending funciton F1 --! call alloc ( sst_F1 , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 ) sst_F1 = 0. !-- sst blnding function setup compete--! case ( 'kkl' ) kkl_mu ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => mu_t (:,:,:) case DEFAULT !call turbulence_read_error() Fatal_error end select end if ! --- end turbulent viscosity setup ---! end subroutine setup_viscosity","tags":"","loc":"proc/setup_viscosity.html","title":"setup_viscosity – FEST-3D"},{"text":"public subroutine destroy_viscosity() Deallocate and nullify viscosity (turbulent/molecular) Arguments None Calls proc~~destroy_viscosity~~CallsGraph proc~destroy_viscosity destroy_viscosity interface~dealloc dealloc proc~destroy_viscosity->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_viscosity~~CalledByGraph proc~destroy_viscosity destroy_viscosity proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_viscosity proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_viscosity Source Code subroutine destroy_viscosity () !< Deallocate and nullify viscosity (turbulent/molecular) ! destroy_molecular_viscosity ---! if ( mu_ref /= 0. ) then call dealloc ( mu ) end if !--- destroy_turbulent_viscosity ---! if ( turbulence /= 'none' ) then select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) nullify ( sa_mu ) case ( 'sst' , 'sst2003' ) nullify ( sst_mu ) !-- blending funciton F1 --! call dealloc ( sst_F1 ) !--- sst blending funciton destoryed--! case ( 'kkl' ) nullify ( kkl_mu ) case DEFAULT !call turbulence_read_error() Fatal_error end select call dealloc ( mu_t ) end if !--- end of turublent viscosity destruction ---! end subroutine destroy_viscosity","tags":"","loc":"proc/destroy_viscosity.html","title":"destroy_viscosity – FEST-3D"},{"text":"public subroutine setup_update() Allocate memory to variables required based \n on the time-integration scheme. Arguments None Calls proc~~setup_update~~CallsGraph proc~setup_update setup_update interface~alloc alloc proc~setup_update->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_update->proc~setup_lusgs proc~setup_plusgs setup_plusgs proc~setup_update->proc~setup_plusgs proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~setup_lusgs->interface~alloc proc~setup_plusgs->interface~alloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_update~~CalledByGraph proc~setup_update setup_update proc~setup_solver setup_solver proc~setup_solver->proc~setup_update proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_update Source Code subroutine setup_update () !< Allocate memory to variables required based !< on the time-integration scheme. implicit none call alloc ( u1 , 1 , n_var ) call alloc ( u2 , 1 , n_var ) call alloc ( R , 1 , n_var ) call alloc ( aux , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) select case ( time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) call alloc ( R_store , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var ) case ( \"TVDRK2\" , \"TVDRK3\" , \"TVDRK4\" ) call alloc ( U_store , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var ) case ( \"implicit\" ) call setup_lusgs () case ( \"plusgs\" ) call setup_plusgs () case default Fatal_error end select end subroutine setup_update","tags":"","loc":"proc/setup_update.html","title":"setup_update – FEST-3D"},{"text":"public subroutine destroy_update() Dellocate memory from all variables Arguments None Calls proc~~destroy_update~~CallsGraph proc~destroy_update destroy_update proc~destroy_lusgs destroy_lusgs proc~destroy_update->proc~destroy_lusgs interface~dealloc dealloc proc~destroy_update->interface~dealloc proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_lusgs->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real proc~destroy_plusgs->interface~dealloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_update~~CalledByGraph proc~destroy_update destroy_update proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_update Source Code subroutine destroy_update () !< Dellocate memory from all variables implicit none select case ( time_step_accuracy ) case ( \"none\" ) ! Do nothing continue case ( \"RK2\" , \"RK4\" ) call dealloc ( U_store ) call dealloc ( R_store ) case ( \"TVDRK2\" , \"TVDRK3\" , \"TVDRK4\" ) call dealloc ( U_store ) case ( \"implicit\" ) call destroy_lusgs () case ( \"plusgs\" ) call destroy_plusgs () case default Fatal_error end select call dealloc ( u1 ) call dealloc ( u2 ) call dealloc ( R ) call dealloc ( aux ) end subroutine destroy_update","tags":"","loc":"proc/destroy_update.html","title":"destroy_update – FEST-3D"},{"text":"public subroutine get_next_solution() Get solution at next time-step using scheme\n given in the input file. Arguments None Calls proc~~get_next_solution~~CallsGraph proc~get_next_solution get_next_solution proc~update_with update_with proc~get_next_solution->proc~update_with proc~compute_time_step compute_time_step proc~get_next_solution->proc~compute_time_step proc~update_with_lusgs update_with_lusgs proc~get_next_solution->proc~update_with_lusgs proc~update_laminar_variables_conservative update_laminar_variables_conservative proc~get_next_solution->proc~update_laminar_variables_conservative proc~update_with_plusgs update_with_plusgs proc~get_next_solution->proc~update_with_plusgs proc~update_turbulent_variables_conservative update_turbulent_variables_conservative proc~get_next_solution->proc~update_turbulent_variables_conservative proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution->proc~get_total_conservative_residue proc~compute_local_time_step compute_local_time_step proc~compute_time_step->proc~compute_local_time_step proc~compute_global_time_step compute_global_time_step proc~compute_time_step->proc~compute_global_time_step proc~dmsg dmsg proc~compute_time_step->proc~dmsg proc~update_simulation_clock update_simulation_clock proc~compute_time_step->proc~update_simulation_clock proc~update_kkl_variables update_KKL_variables proc~update_with_lusgs->proc~update_kkl_variables proc~update_sa_variables~2 update_SA_variables proc~update_with_lusgs->proc~update_sa_variables~2 proc~update_lctm2015~2 update_lctm2015 proc~update_with_lusgs->proc~update_lctm2015~2 proc~update_laminar_variables~2 update_laminar_variables proc~update_with_lusgs->proc~update_laminar_variables~2 proc~update_sst_variables~2 update_SST_variables proc~update_with_lusgs->proc~update_sst_variables~2 proc~update_lctm2015 update_lctm2015 proc~update_with_plusgs->proc~update_lctm2015 proc~update_laminar_variables update_laminar_variables proc~update_with_plusgs->proc~update_laminar_variables proc~update_sa_variables update_SA_variables proc~update_with_plusgs->proc~update_sa_variables proc~update_sst_variables update_SST_variables proc~update_with_plusgs->proc~update_sst_variables proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue compute_residue compute_residue proc~get_total_conservative_residue->compute_residue compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->compute_face_interpolant proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes compute_fluxes compute_fluxes proc~get_total_conservative_residue->compute_fluxes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_next_solution~~CalledByGraph proc~get_next_solution get_next_solution proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_solution Source Code subroutine get_next_solution () !< Get solution at next time-step using scheme !< given in the input file. implicit none select case ( trim ( time_step_accuracy )) case ( \"none\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with ( \"conservative\" , 1. , 1. , . FALSE .) !call update_with(\"primitive\", 1. ,1., .FALSE.) !call update_laminar_variables_primitive(1. ,1., .FALSE.) !if(turbulence/='none')then !  call update_turbulent_variables_primitive(1. ,1., .FALSE.) !end if case ( \"RK4\" ) R_store = 0. U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(0.5, 1., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(0.5, 1., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 0.5 , 2. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(0.5, 2., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(0.5, 2., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 2. , . FALSE ., R_store , U_store ) !call update_laminar_variables_primitive(1.0, 2., .FALSE., .True., R_store, U_store) !call update_turbulent_variables_primitive(1.0, 2., .FALSE., .True., R_store, U_store) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1. / 6. , 1. , . TRUE . , R_store , U_store ) !call update_laminar_variables_primitive(1./6., 1., .TRUE., .FALSE., R_store, U_store) !call update_turbulent_variables_primitive(1./6., 1., .TRUE., .FALSE., R_store, U_store) case ( \"RK2\" ) R_store = 0. U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 0.5 , 1. , . FALSE ., R_store , U_store ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 0.5 , 1. , . TRUE ., R_store , U_store ) case ( \"TVDRK3\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = 0.75 * U_store + 0.25 * qp call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = ( 1. / 3. ) * U_store + ( 2. / 3. ) * qp case ( \"TVDRK2\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_with ( \"conservative\" , 1.0 , 1. ) call get_total_conservative_Residue () call update_with ( \"conservative\" , 1.0 , 1. ) qp = 0.5 * U_store + 0.5 * qp case ( \"TVDRK4\" ) U_store = qp call get_total_conservative_Residue () call compute_time_step () call update_laminar_variables_conservative ( 0.25 , un = U_store ) if ( turbulence /= 'none' ) then call update_turbulent_variables_conservative ( 1.0 , un = U_store ) end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 0.333333 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(0.333333, un=U_store) !end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 0.5 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(0.5, un=U_store) !end if call get_total_conservative_Residue () call update_laminar_variables_conservative ( 1.00 , un = U_store ) !if(turbulence/='none')then !  call update_turbulent_variables_conservative(1.00, un=U_store) !end if case ( \"implicit\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with_lusgs () case ( \"plusgs\" ) call get_total_conservative_Residue () call compute_time_step () ! has to be after get_..._Residue() call update_with_plusgs () case default Fatal_error end select end subroutine get_next_solution","tags":"","loc":"proc/get_next_solution.html","title":"get_next_solution – FEST-3D"},{"text":"private subroutine update_with(type, time_factor, store_factor, use, Rn, un) A generalized scheme to updat the solution explicitly using\n any RK method and even first order euler explicit. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: type real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use real, intent(inout), optional dimension(1:imx-1,1:jmx-1,1:kmx-1,1:n_var) :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Called by proc~~update_with~~CalledByGraph proc~update_with update_with proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_with proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_with Source Code subroutine update_with ( type , time_factor , store_factor , use , Rn , un ) !< A generalized scheme to updat the solution explicitly using !< any RK method and even first order euler explicit. implicit none character ( len =* ), intent ( in ) :: type real , intent ( in ), optional :: time_factor ! time factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ), optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional :: Rn real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor Logical :: TU = . FALSE . !to use or not real , dimension (:,:,:,:), pointer :: Quse integer :: i , j , k real :: KE = 0. real :: beta !sa variables real :: vort real :: fv1 real :: fv2 real :: fw real :: g real :: scap real :: rsa real :: kd2 real :: xi if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if select case ( type ) case ( 'primitive' ) !include \"update_primitive.inc\" !update primitive variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : n_var ) = Quse ( i , j , k , 1 : n_var ) ! finding primitive residue R ( 1 ) = mass_residue ( i , j , k ) R ( 2 ) = - 1 * ( u1 ( 2 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + x_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 3 ) = - 1 * ( u1 ( 3 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + y_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 4 ) = - 1 * ( u1 ( 4 ) / u1 ( 1 )) * mass_residue ( i , j , k ) + z_mom_residue ( i , j , k ) / u1 ( 1 ) R ( 5 ) = 0.5 * ( gm - 1. ) * ( sum ( u1 ( 2 : 4 ) ** 2 ) * mass_residue ( i , j , k )) & - ( gm - 1. ) * u1 ( 2 ) * x_mom_residue ( i , j , k ) & - ( gm - 1. ) * u1 ( 3 ) * y_mom_residue ( i , j , k ) & - ( gm - 1. ) * u1 ( 4 ) * z_mom_residue ( i , j , k ) & + ( gm - 1. ) * energy_residue ( i , j , k ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 5 ) = R ( 5 ) - ( gm - 1. ) * TKE_residue ( i , j , k ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue ( i , j , k ) / u1 ( 1 ) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 5 ) = R ( 5 ) - ( gm - 1. ) * TKE_residue ( i , j , k ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue ( i , j , k ) / u1 ( 1 ) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 (:) = u1 (:) - R (:) * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. ) then Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) case DEFAULT ! do nothing continue end select end if end do end do end do case ( 'conservative' ) !include \"update_conservative.inc\" !update conservative variable do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) select case ( turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u1(6) case ( 'sa' , 'saBC' ) KE = 0.0 case DEFAULT KE = 0. end select u1 ( 5 ) = ( u1 ( 5 ) / ( gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) + KE ! get R R ( 1 : n_var ) = residue ( i , j , k , 1 : n_var ) ! point implicit destruction term select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) case ( 'kkl' ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) case ( 'sa' , 'saBC' ) vort = sqrt ( (( gradw_y ( i , j , k ) - gradv_z ( i , j , k )) ** 2 & + ( gradu_z ( i , j , k ) - gradw_x ( i , j , k )) ** 2 & + ( gradv_x ( i , j , k ) - gradu_y ( i , j , k )) ** 2 & )& ) kd2 = ( kappa_sa * dist ( i , j , k )) ** 2 xi = U1 ( 6 ) * density ( i , j , k ) / mu ( i , j , k ) fv1 = xi ** 3 / ( xi ** 3 + cv1 ** 3 ) fv2 = 1.0 - xi / ( 1 + xi * fv1 ) scap = vort + U1 ( 6 ) * fv2 / ( kd2 ) rsa = min ( U1 ( 6 ) / ( Scap * kd2 ), 1 0.0 ) g = rsa + cw2 * ( rsa ** 6 - rsa ) fw = g * ( ( 1.0 + cw3 ** 6 ) / ( g ** 6 + cw3 ** 6 ) ) ** ( 1.0 / 6.0 ) R ( 6 ) = R ( 6 ) / ( 1. + (( - 1.0 * u1 ( 1 ) * cb1 * scap ) + ( 2.0 * u1 ( 1 ) * cw1 * fw * u1 ( 6 ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k )) case DEFAULT Fatal_error end select !check if user want to store residue if ( present ( Rn )) then Rn ( i , j , k , 1 : n_var ) = Rn ( i , j , k , 1 : n_var ) + SF * R ( 1 : n_var ) if ( TU ) R (:) = Rn ( i , j , k ,:) end if !update u2 ( 1 : n_var ) = u1 ( 1 : n_var ) - R ( 1 : n_var ) * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) select case ( turbulence ) case ( 'sst' , 'sst2003' , 'kkl' ) KE = 0.0 !u2(6) case ( 'sa' , 'saBC' ) !u2(6) = u2(6)*u2(1) KE = 0.0 case DEFAULT KE = 0. end select u2 ( 5 ) = ( gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) - KE ) !check solution for non pyhysical results if (( u2 ( 1 ) < 0. ) . or . ( u2 ( 5 )) < 0. . or . any ( isnan ( u2 ))) then print * , u2 (:) print * , \"R: \" , R print * , \"old \" , U1 Fatal_error else !update qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kkl' ) if ( u2 ( 6 ) >= 0. ) then qp ( i , j , k , 6 ) = u2 ( 6 ) else !  qp(i,j,k,6) = tk_inf !  qp(i,j,k,6) = (max(qp(i-1,j,k,6),0.) + max(qp(i+1,j,k,6),0.) & !                +max(qp(i,j-1,k,6),0.) + max(qp(i,j+1,k,6),0.) & !                )/4 !  qp(i,j,k,6) = 1.e-3*maxval(qp(i-1:i+1,j-1:j+1,k-1:k+1,6)) end if if ( u2 ( 7 ) >= 0. ) then qp ( i , j , k , 7 ) = u2 ( 7 ) else !  qp(i,j,k,7) = tkl_inf !  qp(i,j,k,7) = (max(qp(i-1,j,k,7),0.) + max(qp(i+1,j,k,7),0.) & !                +max(qp(i,j-1,k,7),0.) + max(qp(i,j+1,k,7),0.) & !                )/4 end if case ( 'sa' , 'saBC' ) qp ( i , j , k , 6 ) = max ( u2 ( 6 ), 1.e-12 ) case DEFAULT ! do nothing continue end select end if !print*, i,j, R(1:n_var) end do end do end do case DEFAULT Fatal_error end select end subroutine update_with","tags":"","loc":"proc/update_with.html","title":"update_with – FEST-3D"},{"text":"private subroutine get_total_conservative_Residue() Main loop of whole code. Find residual For each iteration it apply boundary conditions,\n use higher order method to reconstruct state at\n face, evalute fluxes at each face, calculate \n inviscid residual, and introuduce additional \n residual due to  viscosity, turbulence and source\n terms. Arguments None Calls proc~~get_total_conservative_residue~~CallsGraph proc~get_total_conservative_residue get_total_conservative_Residue proc~evaluate_all_gradients evaluate_all_gradients proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~compute_viscous_fluxes compute_viscous_fluxes proc~get_total_conservative_residue->proc~compute_viscous_fluxes proc~calculate_viscosity calculate_viscosity proc~get_total_conservative_residue->proc~calculate_viscosity compute_fluxes compute_fluxes proc~get_total_conservative_residue->compute_fluxes proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~add_source_term_residue add_source_term_residue proc~get_total_conservative_residue->proc~add_source_term_residue proc~apply_interface apply_interface proc~get_total_conservative_residue->proc~apply_interface compute_face_interpolant compute_face_interpolant proc~get_total_conservative_residue->compute_face_interpolant compute_residue compute_residue proc~get_total_conservative_residue->compute_residue proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~apply_gradient_bc apply_gradient_bc proc~evaluate_all_gradients->proc~apply_gradient_bc proc~compute_gradient_g compute_gradient_G proc~evaluate_all_gradients->proc~compute_gradient_g proc~compute_gradient_t compute_gradient_T proc~evaluate_all_gradients->proc~compute_gradient_t proc~dmsg dmsg proc~evaluate_all_gradients->proc~dmsg proc~compute_viscous_fluxes_laminar compute_viscous_fluxes_laminar proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_laminar proc~compute_viscous_fluxes_sst compute_viscous_fluxes_sst proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sst proc~compute_viscous_fluxes_kkl compute_viscous_fluxes_kkl proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_kkl proc~compute_viscous_fluxes_lctm2015 compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_lctm2015 proc~compute_viscous_fluxes_sa compute_viscous_fluxes_sa proc~compute_viscous_fluxes->proc~compute_viscous_fluxes_sa proc~reconstruct_imax reconstruct_imax proc~reconstruct_boundary_state->proc~reconstruct_imax proc~reconstruct_jmin reconstruct_jmin proc~reconstruct_boundary_state->proc~reconstruct_jmin proc~reconstruct_jmax reconstruct_jmax proc~reconstruct_boundary_state->proc~reconstruct_jmax proc~reconstruct_kmin reconstruct_kmin proc~reconstruct_boundary_state->proc~reconstruct_kmin proc~reconstruct_boundary_state->proc~dmsg proc~reconstruct_imin reconstruct_imin proc~reconstruct_boundary_state->proc~reconstruct_imin proc~reconstruct_kmax reconstruct_kmax proc~reconstruct_boundary_state->proc~reconstruct_kmax proc~add_sst_bc_source add_sst_bc_source proc~add_source_term_residue->proc~add_sst_bc_source proc~add_sabc_source add_saBC_source proc~add_source_term_residue->proc~add_sabc_source proc~add_kkl_source add_kkl_source proc~add_source_term_residue->proc~add_kkl_source proc~add_sst_source add_sst_source proc~add_source_term_residue->proc~add_sst_source proc~add_source_term_residue->proc~dmsg proc~add_sst_source_lctm2015 add_sst_source_lctm2015 proc~add_source_term_residue->proc~add_sst_source_lctm2015 proc~add_sa_source add_sa_source proc~add_source_term_residue->proc~add_sa_source mpi_sendrecv mpi_sendrecv proc~apply_interface->mpi_sendrecv proc~apply_interface->proc~dmsg proc~apply_periodic_bc apply_periodic_bc proc~apply_interface->proc~apply_periodic_bc proc~total_pressure total_pressure proc~populate_ghost_primitive->proc~total_pressure proc~supersonic_inlet supersonic_inlet proc~populate_ghost_primitive->proc~supersonic_inlet proc~subsonic_outlet subsonic_outlet proc~populate_ghost_primitive->proc~subsonic_outlet proc~far_field far_field proc~populate_ghost_primitive->proc~far_field proc~wall wall proc~populate_ghost_primitive->proc~wall proc~pole pole proc~populate_ghost_primitive->proc~pole proc~slip_wall slip_wall proc~populate_ghost_primitive->proc~slip_wall proc~supersonic_outlet supersonic_outlet proc~populate_ghost_primitive->proc~supersonic_outlet proc~subsonic_inlet subsonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~periodic_bc periodic_bc proc~populate_ghost_primitive->proc~periodic_bc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_total_conservative_residue~~CalledByGraph proc~get_total_conservative_residue get_total_conservative_Residue proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_total_conservative_Residue Source Code subroutine get_total_conservative_Residue () !< Main loop of whole code. Find residual !< !< For each iteration it apply boundary conditions, !< use higher order method to reconstruct state at !< face, evalute fluxes at each face, calculate !< inviscid residual, and introuduce additional !< residual due to  viscosity, turbulence and source !< terms. implicit none !        call send_recv(3) ! parallel call-argument:no of layers call apply_interface () call populate_ghost_primitive () call compute_face_interpolant () call reconstruct_boundary_state ( interpolant ) call compute_fluxes () if ( mu_ref /= 0.0 ) then call evaluate_all_gradients () call calculate_viscosity () call compute_viscous_fluxes ( F_p , G_p , H_p ) !          call compute_turbulent_fluxes(F_p, G_p, H_p) end if call compute_residue () call add_source_term_residue () end subroutine get_total_conservative_Residue","tags":"","loc":"proc/get_total_conservative_residue.html","title":"get_total_conservative_Residue – FEST-3D"},{"text":"private subroutine update_laminar_variables_primitive(time_factor, store_factor, use, tostore, Rn, un) Update first five primitive variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Contents Source Code update_laminar_variables_primitive Source Code subroutine update_laminar_variables_primitive ( time_factor , store_factor , use , tostore , Rn , un ) !< Update first five primitive variables in time implicit none real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore real , dimension ( 5 ) :: Res real :: t1 !temp variable 1/density integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : 5 ) = Quse ( i , j , k , 1 : 5 ) t1 = 1.0 / u1 ( 1 ) Res ( 1 : 5 ) = Residue ( i , j , k , 1 : 5 ) ! finding primitive residue R ( 1 ) = Res ( 1 ) R ( 2 ) = ( - 1 * ( u1 ( 2 ) * Res ( 1 )) + Res ( 2 )) * t1 R ( 3 ) = ( - 1 * ( u1 ( 3 ) * Res ( 1 )) + Res ( 3 )) * t1 R ( 4 ) = ( - 1 * ( u1 ( 4 ) * Res ( 1 )) + Res ( 4 )) * t1 R ( 5 ) = 0.5 * ( gm - 1. ) * ( u1 ( 2 ) * u1 ( 2 ) + u1 ( 3 ) * u1 ( 3 ) + u1 ( 4 ) * u1 ( 4 )) * Res ( 1 ) & - ( gm - 1. ) * u1 ( 2 ) * Res ( 2 ) & - ( gm - 1. ) * u1 ( 3 ) * Res ( 3 ) & - ( gm - 1. ) * u1 ( 4 ) * Res ( 4 ) & + ( gm - 1. ) * Res ( 5 ) !store residue aux ( i , j , k , 1 : 5 ) = R ( 1 : 5 ) !update u2 ( 1 : 5 ) = u1 ( 1 : 5 ) - ( SFU * R ( 1 : 5 ) + R_switch * Rstore ( i , j , k , 1 : 5 ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) end do end do end do if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) end if if ( any ( qp (:,:,:, 1 ) < 0. ) . and . any ( qp (:,:,:, 5 ) < 0 )) then Fatal_error end if nullify ( Rstore ) nullify ( Quse ) end subroutine update_laminar_variables_primitive","tags":"","loc":"proc/update_laminar_variables_primitive.html","title":"update_laminar_variables_primitive – FEST-3D"},{"text":"private subroutine update_laminar_variables_conservative(time_factor, store_factor, use, tostore, Rn, un) Update first five conservative variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Called by proc~~update_laminar_variables_conservative~~CalledByGraph proc~update_laminar_variables_conservative update_laminar_variables_conservative proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_laminar_variables_conservative proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_laminar_variables_conservative Source Code subroutine update_laminar_variables_conservative ( time_factor , store_factor , use , tostore , Rn , un ) !< Update first five conservative variables in time implicit none real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! getting conservative variable u1 ( 1 ) = Quse ( i , j , k , 1 ) u1 ( 2 :) = Quse ( i , j , k , 2 :) * u1 ( 1 ) u1 ( 5 ) = ( u1 ( 5 ) / ( gm - 1. ) + 0.5 * sum ( u1 ( 2 : 4 ) ** 2 )) / u1 ( 1 ) ! get R R ( 1 : 5 ) = residue ( i , j , k , 1 : 5 ) !store conservative variables aux ( i , j , k , 1 : n_var ) = u1 ( 1 : n_var ) !update u2 ( 1 : 5 ) = u1 ( 1 : 5 ) - ( SFU * R ( 1 : 5 ) + R_switch * Rstore ( i , j , k , 1 : 5 ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) ! getting primitve variable back variable u2 ( 1 ) = u2 ( 1 ) u2 ( 2 :) = u2 ( 2 :) / u2 ( 1 ) u2 ( 5 ) = ( gm - 1. ) * u2 ( 1 ) * ( u2 ( 5 ) - ( 0.5 * sum ( u2 ( 2 : 4 ) ** 2 )) ) qp ( i , j , k , 1 : 5 ) = u2 ( 1 : 5 ) end do end do end do if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : 5 ) end if if ( any ( qp (:,:,:, 1 ) < 0. ) . and . any ( qp (:,:,:, 5 ) < 0 )) then Fatal_error end if nullify ( Rstore ) nullify ( Quse ) end subroutine update_laminar_variables_conservative","tags":"","loc":"proc/update_laminar_variables_conservative.html","title":"update_laminar_variables_conservative – FEST-3D"},{"text":"private subroutine update_turbulent_variables_primitive(time_factor, store_factor, use, tostore, Rn, un) Update primitive turbulence variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Contents Source Code update_turbulent_variables_primitive Source Code subroutine update_turbulent_variables_primitive ( time_factor , store_factor , use , tostore , Rn , un ) !< Update primitive turbulence variables in time implicit none !arguments real , intent ( in ), optional :: time_factor ! time factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use in ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore integer :: i , j , k real :: beta if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 !update primitive variable u1 ( 6 : n_var ) = Quse ( i , j , k , 6 : n_var ) beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + bstar * u1 ( 6 ) * delta_t ( i , j , k ))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + 2. * beta * u1 ( 6 ) * delta_t ( i , j , k ))) * omega_residue ( i , j , k ) / u1 ( 1 ) !store residue aux ( i , j , k , 6 : n_var ) = R ( 6 : n_var ) !update qp ( i , j , k , 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var ) + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) end do end do end do case ( 'kkl' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 6 : n_var ) = Quse ( i , j , k , 6 : n_var ) eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = - ( u1 ( 6 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * u1 ( 1 ) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )))) * TKE_residue ( i , j , k ) / u1 ( 1 ) R ( 7 ) = - ( u1 ( 7 ) / u1 ( 1 )) * mass_residue ( i , j , k )& + ( 1. / ( 1. + ( 6 * mu ( i , j , k ) * fphi / dist ( i , j , k ) ** 2 ) * delta_t ( i , j , k ))) * kl_residue ( i , j , k ) / u1 ( 1 ) !store residue aux ( i , j , k , 6 : n_var ) = R ( 6 : n_var ) !update qp ( i , j , k , 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var ) + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 6 : n_var ) = max ( 1 e - 10 , qp ( i , j , k , 6 : n_var )) end do end do end do case DEFAULT Fatal_error end select !--- end update ---! if ( present ( Rn ) . and . TS ) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) & + SF * aux ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) end if !if(any(qp(:,:,:,6)<0.) .and. any(qp(:,:,:,n_var)<0))then !  Fatal_error !end if nullify ( Rstore ) end subroutine update_turbulent_variables_primitive","tags":"","loc":"proc/update_turbulent_variables_primitive.html","title":"update_turbulent_variables_primitive – FEST-3D"},{"text":"private subroutine update_turbulent_variables_conservative(time_factor, store_factor, use, tostore, Rn, un) Update conservative turbulence variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un Called by proc~~update_turbulent_variables_conservative~~CalledByGraph proc~update_turbulent_variables_conservative update_turbulent_variables_conservative proc~get_next_solution get_next_solution proc~get_next_solution->proc~update_turbulent_variables_conservative proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code update_turbulent_variables_conservative Source Code subroutine update_turbulent_variables_conservative ( time_factor , store_factor , use , tostore , Rn , un ) !< Update conservative turbulence variables in time implicit none !arguments real , intent ( in ), optional :: time_factor real , intent ( in ), optional :: store_factor logical , intent ( in ), optional :: use logical , intent ( in ), optional :: tostore real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ), intent ( in ) , optional , target :: un real , dimension ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ), intent ( inout ), optional , target :: Rn !local variables real :: TF = 1.0 !time factor real :: SF = 1.0 !store factor real :: SFU = 1.0 !store factor to use inside ijk loop integer :: R_switch = 0 !R_store use switch based on TU Logical :: TU = . FALSE . !to use R_store or not Logical :: TS = . FALSE . !to store R_store or not real , dimension (:,:,:,:), pointer :: Quse real , dimension (:,:,:,:), pointer :: Rstore real :: beta integer :: i , j , k if ( present ( time_factor )) TF = time_factor if ( present ( store_factor )) SF = store_factor if ( present ( use )) TU = use if ( present ( tostore )) TS = tostore if ( TU ) then R_switch = 1 SFU = SF else R_switch = 0 SFU = 1.0 end if !check if user want to update from particular solution if ( present ( un )) then Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => un (:,:,:,:) else Quse ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 , 1 : n_var ) => qp (:,:,:,:) end if if ( present ( Rn )) then Rstore => Rn else Rstore => aux !making it point to junk values R_switch = 0 !but never used as switch is zero end if !--- Start update---! select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sst' , 'sst2003' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 1 : n_var ) = aux ( i , j , k , 1 : n_var ) !get R R ( 6 : n_var ) = residue ( i , j , k , 6 : n_var ) !point implicit beta = beta1 * sst_F1 ( i , j , k ) + ( 1. - sst_F1 ( i , j , k )) * beta2 R ( 6 ) = R ( 6 ) / ( 1 + ( beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1 + ( 2 * beta * qp ( i , j , k , 7 ) * delta_t ( i , j , k ))) !update u2 ( 6 : n_var ) = u1 ( 6 : n_var ) - ( SFU * R ( 6 : n_var )& + R_switch * Rstore ( i , j , k , 6 : n_var ))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) if ( u2 ( 6 ) > 0. ) qp ( i , j , k , 6 ) = u2 ( 6 ) / aux ( i , j , k , 1 ) if ( u2 ( 7 ) > 0. ) qp ( i , j , k , 7 ) = u2 ( 7 ) / aux ( i , j , k , 1 ) end do end do end do case ( 'kkl' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 u1 ( 6 : n_var ) = aux ( i , j , k , 6 : n_var ) !get R R ( 6 : n_var ) = residue ( i , j , k , 6 : n_var ) !point implicit eta = u1 ( 1 ) * dist ( i , j , k ) * ( sqrt ( 0.3 * u1 ( 6 )) / ( 20 * mu ( i , j , k ))) fphi = ( 1 + cd1 * eta ) / ( 1 + eta ** 4 ) R ( 6 ) = R ( 6 ) / ( 1. + (( 2.5 * (( cmu ** 0.75 ) * sqrt ( u1 ( 1 )) * ( u1 ( 6 ) ** 1.5 ) / max ( u1 ( 7 ), 1.e-20 ))& + ( 2 * mu ( i , j , k ) / ( dist ( i , j , k ) ** 2 ))) * delta_t ( i , j , k ))) R ( 7 ) = R ( 7 ) / ( 1. + ( 6 * mu ( i , j , k ) * fphi / ( dist ( i , j , k ) ** 2 )) * delta_t ( i , j , k )) !update u2 ( 6 : n_var ) = u1 ( 6 : n_var ) - ( R ( 6 : n_var ) + ( R_switch * SF * Rstore ( i , j , k , 6 : n_var )))& * ( TF * delta_t ( i , j , k ) / volume ( i , j , k )) qp ( i , j , k , 6 : n_var ) = max ( 1.e-10 , u2 ( 6 : n_var ) / aux ( i , j , k , 1 )) end do end do end do case DEFAULT Fatal_error end select !--- end update ---! if ( present ( Rn )) then Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) = Rn ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) & + SF * residue ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) end if if ( any ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 6 : n_var ) < 0. )) then Fatal_error end if nullify ( Rstore ) end subroutine update_turbulent_variables_conservative","tags":"","loc":"proc/update_turbulent_variables_conservative.html","title":"update_turbulent_variables_conservative – FEST-3D"},{"text":"private function vol_tetrahedron(p1, p2, p3, p4) Compute the volume of a tetrahedron, given 4 points which\n are 1-D arrays\n Since we know that the determinant is to be evaluated of \n a 3x3 matrix, we write the expression itself Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: p1 real, intent(in), dimension(:) :: p2 real, intent(in), dimension(:) :: p3 real, intent(in), dimension(:) :: p4 Return Value real Called by proc~~vol_tetrahedron~~CalledByGraph proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron vol_hexahedron proc~vol_hexahedron->proc~vol_tetrahedron proc~compute_volumes compute_volumes proc~compute_volumes->proc~vol_hexahedron proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_volumes proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocvol_tetrahedronCalledByGraph = svgPanZoom('#procvol_tetrahedronCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code vol_tetrahedron Source Code function vol_tetrahedron ( p1 , p2 , p3 , p4 ) !< Compute the volume of a tetrahedron, given 4 points which !< are 1-D arrays !< Since we know that the determinant is to be evaluated of !< a 3x3 matrix, we write the expression itself !----------------------------------------------------------- implicit none real , dimension (:), intent ( in ) :: p1 , p2 , p3 , p4 real , dimension ( 1 : 3 , 1 : 3 ) :: A real :: vol_tetrahedron A (:, 1 ) = p1 - p4 A (:, 2 ) = p2 - p4 A (:, 3 ) = p3 - p4 !vol_tetrahedron = A(1,1) * (A(2,2)*A(3,3) - A(2,3)*A(3,2)) + & !                  A(1,2) * (A(2,3)*A(3,1) - A(2,1)*A(3,3)) + & !                  A(1,3) * (A(2,1)*A(3,2) - A(2,2)*A(3,1)) vol_tetrahedron = ( p4 ( 1 ) - p1 ( 1 )) * (( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 3 ) - p1 ( 3 )) - ( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 2 ) - p1 ( 2 ))) & + ( p4 ( 2 ) - p1 ( 2 )) * (( p2 ( 3 ) - p1 ( 3 )) * ( p3 ( 1 ) - p1 ( 1 )) - ( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 3 ) - p1 ( 3 ))) & + ( p4 ( 3 ) - p1 ( 3 )) * (( p2 ( 1 ) - p1 ( 1 )) * ( p3 ( 2 ) - p1 ( 2 )) - ( p2 ( 2 ) - p1 ( 2 )) * ( p3 ( 1 ) - p1 ( 1 ))) vol_tetrahedron = - vol_tetrahedron / 6. end function vol_tetrahedron","tags":"","loc":"proc/vol_tetrahedron.html","title":"vol_tetrahedron – FEST-3D"},{"text":"private function vol_hexahedron(p_list) Compute the volume of a hexahedron, given a list of points Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:3, 1:8) :: p_list Return Value real Calls proc~~vol_hexahedron~~CallsGraph proc~vol_hexahedron vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~vol_hexahedron~~CalledByGraph proc~vol_hexahedron vol_hexahedron proc~compute_volumes compute_volumes proc~compute_volumes->proc~vol_hexahedron proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_volumes proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocvol_hexahedronCalledByGraph = svgPanZoom('#procvol_hexahedronCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code vol_hexahedron Source Code function vol_hexahedron ( p_list ) !< Compute the volume of a hexahedron, given a list of points ! The points are arranged in a specific order. For the ! element i,j,k, the order of nodes required are: ! i,j,k ! i+1, j, k ! i+1, j+1, k ! i, j+1, k ! i, j, k+1 ! i+1, j, k+1 ! i+1, j+1, k+1 ! i, j+1, k+1 ! ! The hexahedron is to be split into 5 tetrahedrons. ! Source: Split hex into 5 tetrahedron: ! No assumptions about planarity seem to be made. All cuts ! were made with a plane containing only 3 vertices at a time. ! https://ieeexplore.ieee.org/ieee_pilot/articles/06/ttg2009061587/assets/img/article_1/fig_6/large.gif ! ! The indices of the 5 split tetrahedra can be visualised from ! the above link. But since the volume of each tetrahedron ! depends on the determinant calculated, it is IMPERATIVE to ! ensure that a \"correct\" order is followed for the 4 points. ! ! The logic to get the \"correct\" order is explained as ! follows (Refer wiki article on parallelepiped): ! The determinant is taken of a matrix of pi - p4, i = 1, 2, 3. ! Graphically it denotes the sides with p4 as common vertex, ! with direction outward from p4, i.e., directed from ! p4 to pi, i = 1, 2, 3 ! Hence, if you ensure that  cross(p1-p4, p2-p4) is along ! p3-p4, then the determinant will be positive. ! ! From the above link, a set of 5 tetrahedra was obtained. ! Each tetrahedra has 4 points, and in the function calls ! below, care was taken to ensure that the order is observed ! while passing parameters into the vol_tetrahedron function !----------------------------------------------------------- implicit none real , dimension ( 1 : 3 , 1 : 8 ), intent ( in ) :: p_list real :: vol_hexahedron real :: vol_hexahedron1 vol_hexahedron1 = 0. vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 5 ), & p_list (:, 8 ), p_list (:, 6 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 8 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 4 ), & p_list (:, 1 ), p_list (:, 3 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 6 ), p_list (:, 1 ), & p_list (:, 3 ), p_list (:, 8 )) vol_hexahedron1 = vol_hexahedron1 + & vol_tetrahedron ( p_list (:, 1 ), p_list (:, 2 ), & p_list (:, 6 ), p_list (:, 3 )) vol_hexahedron = 0. vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 6 ), & p_list (:, 5 ), p_list (:, 7 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 8 ), p_list (:, 5 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 5 ), p_list (:, 1 ), & p_list (:, 2 ), p_list (:, 4 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 7 ), p_list (:, 2 ), & p_list (:, 4 ), p_list (:, 5 )) vol_hexahedron = vol_hexahedron + & vol_tetrahedron ( p_list (:, 2 ), p_list (:, 3 ), & p_list (:, 7 ), p_list (:, 4 )) vol_hexahedron = max ( vol_hexahedron , vol_hexahedron1 ) end function vol_hexahedron","tags":"","loc":"proc/vol_hexahedron.html","title":"vol_hexahedron – FEST-3D"},{"text":"private subroutine allocate_memory_volumes() Allocate memory for the volume variables. Arguments None Calls proc~~allocate_memory_volumes~~CallsGraph proc~allocate_memory_volumes allocate_memory_volumes interface~alloc alloc proc~allocate_memory_volumes->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory_volumes~~CalledByGraph proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_volumes proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~3 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocallocate_memory_volumesCalledByGraph = svgPanZoom('#procallocate_memory_volumesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory_volumes Source Code subroutine allocate_memory_volumes () !< Allocate memory for the volume variables. !----------------------------------------------------------- implicit none call alloc ( volume , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for volume.' ) end subroutine allocate_memory_volumes","tags":"","loc":"proc/allocate_memory_volumes.html","title":"allocate_memory_volumes – FEST-3D"},{"text":"private subroutine allocate_memory_areas() Allocate memory for the area variables. Arguments None Calls proc~~allocate_memory_areas~~CallsGraph proc~allocate_memory_areas allocate_memory_areas interface~alloc alloc proc~allocate_memory_areas->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory_areas~~CalledByGraph proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_areas proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~3 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocallocate_memory_areasCalledByGraph = svgPanZoom('#procallocate_memory_areasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory_areas Source Code subroutine allocate_memory_areas () !< Allocate memory for the area variables. !----------------------------------------------------------- implicit none call alloc ( xA , - 2 , imx + 3 , - 2 , jmx + 2 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for xA.' ) call alloc ( yA , - 2 , imx + 2 , - 2 , jmx + 3 , - 2 , kmx + 2 , & errmsg = 'Error: Unable to allocate memory for yA.' ) call alloc ( zA , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 3 , & errmsg = 'Error: Unable to allocate memory for yA.' ) end subroutine allocate_memory_areas","tags":"","loc":"proc/allocate_memory_areas.html","title":"allocate_memory_areas – FEST-3D"},{"text":"private subroutine allocate_memory_normals() Allocate memory for the normal variables. Arguments None Calls proc~~allocate_memory_normals~~CallsGraph proc~allocate_memory_normals allocate_memory_normals interface~alloc alloc proc~allocate_memory_normals->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory_normals~~CalledByGraph proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~3 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocallocate_memory_normalsCalledByGraph = svgPanZoom('#procallocate_memory_normalsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory_normals Source Code subroutine allocate_memory_normals () !< Allocate memory for the normal variables. !----------------------------------------------------------- implicit none call alloc ( xn , - 2 , imx + 3 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for xnx.' ) call alloc ( yn , - 2 , imx + 2 , - 2 , jmx + 3 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for ynx.' ) call alloc ( zn , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 3 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for ynx.' ) xnx ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 1 ) xny ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 2 ) xnz ( - 2 : imx + 3 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => xn (:,:,:, 3 ) ynx ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 1 ) yny ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 2 ) ynz ( - 2 : imx + 2 , - 2 : jmx + 3 , - 2 : kmx + 2 ) => yn (:,:,:, 3 ) znx ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 1 ) zny ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 2 ) znz ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 3 ) => zn (:,:,:, 3 ) end subroutine allocate_memory_normals","tags":"","loc":"proc/allocate_memory_normals.html","title":"allocate_memory_normals – FEST-3D"},{"text":"private subroutine allocate_memory_ghost_centroids() Allocate memory for centroids of ghost cells Arguments None Calls proc~~allocate_memory_ghost_centroids~~CallsGraph proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids interface~alloc alloc proc~allocate_memory_ghost_centroids->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory_ghost_centroids~~CalledByGraph proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~3 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocallocate_memory_ghost_centroidsCalledByGraph = svgPanZoom('#procallocate_memory_ghost_centroidsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory_ghost_centroids Source Code subroutine allocate_memory_ghost_centroids () !< Allocate memory for centroids of ghost cells !----------------------------------------------------------- implicit none call alloc ( CellCenter , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , 3 , & errmsg = 'Error: Unable to allocate memory for volume.' ) ! !            call alloc(left_ghost_centroid, 1, jmx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for left_ghost_centroid') !            call alloc(right_ghost_centroid, 1, jmx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for right_ghost_centroid') !            call alloc(front_ghost_centroid, 1, imx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for front_ghost_centroid') !            call alloc(back_ghost_centroid, 1, imx-1, 1, kmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for back_ghost_centroid') !            call alloc(top_ghost_centroid, 1, imx-1, 1, jmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for top_ghost_centroid') !            call alloc(bottom_ghost_centroid, 1, imx-1, 1, jmx-1, 1, 3, & !                    errmsg='Error: Unable to allocate memory for bottom_ghost_centroid') end subroutine allocate_memory_ghost_centroids","tags":"","loc":"proc/allocate_memory_ghost_centroids.html","title":"allocate_memory_ghost_centroids – FEST-3D"},{"text":"private subroutine allocate_memory() Allocate memory for the required variables. Arguments None Calls proc~~allocate_memory~3~~CallsGraph proc~allocate_memory~3 allocate_memory proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory~3->proc~allocate_memory_areas proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_normals proc~dmsg dmsg proc~allocate_memory~3->proc~dmsg proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_volumes interface~alloc alloc proc~allocate_memory_areas->interface~alloc proc~allocate_memory_normals->interface~alloc proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~3~~CalledByGraph proc~allocate_memory~3 allocate_memory proc~setup_geometry setup_geometry proc~setup_geometry->proc~allocate_memory~3 proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocate memory for the required variables. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'allocate_memory' ) call allocate_memory_normals () call allocate_memory_areas () call allocate_memory_volumes () call allocate_memory_ghost_centroids () end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~3.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine deallocate_memory() Deallocate the memoery used by the geometry variables Arguments None Calls proc~~deallocate_memory~2~~CallsGraph proc~deallocate_memory~2 deallocate_memory interface~dealloc dealloc proc~deallocate_memory~2->interface~dealloc proc~dmsg dmsg proc~deallocate_memory~2->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~deallocate_memory~2~~CalledByGraph proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_all destroy_all proc~destroy_all->proc~destroy_geometry proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_geometry proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code deallocate_memory Source Code subroutine deallocate_memory () !< Deallocate the memoery used by the geometry variables implicit none call dmsg ( 1 , 'geometry' , 'deallocate_memory' ) call dealloc ( xn ) call dealloc ( yn ) call dealloc ( zn ) call dealloc ( xA ) call dealloc ( yA ) call dealloc ( zA ) call dealloc ( volume ) call dealloc ( CellCenter ) !            call dealloc(left_ghost_centroid) !            call dealloc(right_ghost_centroid) !            call dealloc(front_ghost_centroid) !            call dealloc(back_ghost_centroid) !            call dealloc(top_ghost_centroid) !            call dealloc(bottom_ghost_centroid) end subroutine deallocate_memory","tags":"","loc":"proc/deallocate_memory~2.html","title":"deallocate_memory – FEST-3D"},{"text":"private subroutine normalize_face_normals() Normalize the face normal vectors computed to get unit\n vectors Arguments None Called by proc~~normalize_face_normals~~CalledByGraph proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocnormalize_face_normalsCalledByGraph = svgPanZoom('#procnormalize_face_normalsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code normalize_face_normals Source Code subroutine normalize_face_normals () !< Normalize the face normal vectors computed to get unit !< vectors !----------------------------------------------------------- implicit none integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 if ( xA ( i , j , k ) /= 0. ) then xnx ( i , j , k ) = xnx ( i , j , k ) / xA ( i , j , k ) xny ( i , j , k ) = xny ( i , j , k ) / xA ( i , j , k ) xnz ( i , j , k ) = xnz ( i , j , k ) / xA ( i , j , k ) end if end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 if ( yA ( i , j , k ) /= 0. ) then ynx ( i , j , k ) = ynx ( i , j , k ) / yA ( i , j , k ) yny ( i , j , k ) = yny ( i , j , k ) / yA ( i , j , k ) ynz ( i , j , k ) = ynz ( i , j , k ) / yA ( i , j , k ) end if end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 if ( zA ( i , j , k ) /= 0. ) then znx ( i , j , k ) = znx ( i , j , k ) / zA ( i , j , k ) zny ( i , j , k ) = zny ( i , j , k ) / zA ( i , j , k ) znz ( i , j , k ) = znz ( i , j , k ) / zA ( i , j , k ) end if end do end do end do ! pole boundary condition if ( imin_id ==- 7 ) then xn ( 1 ,:,:,:) = xn ( 2 ,:,:,:) xn ( 0 ,:,:,:) = xn ( 2 ,:,:,:) xn ( - 1 ,:,:,:) = xn ( 2 ,:,:,:) xn ( - 2 ,:,:,:) = xn ( 2 ,:,:,:) end if if ( imax_id ==- 7 ) then xn ( imx + 0 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 1 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 2 ,:,:,:) = xn ( imx - 1 ,:,:,:) xn ( imx + 3 ,:,:,:) = xn ( imx - 1 ,:,:,:) end if if ( jmin_id ==- 7 ) then yn (:, 1 ,:,:) = yn (:, 2 ,:,:) yn (:, 0 ,:,:) = yn (:, 2 ,:,:) yn (:, - 1 ,:,:) = yn (:, 2 ,:,:) yn (:, - 2 ,:,:) = yn (:, 2 ,:,:) end if if ( jmax_id ==- 7 ) then yn (:, jmx + 0 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 1 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 2 ,:,:) = yn (:, jmx - 1 ,:,:) yn (:, jmx + 3 ,:,:) = yn (:, jmx - 1 ,:,:) end if if ( kmin_id ==- 7 ) then zn (:,:, 1 ,:) = zn (:,:, 2 ,:) zn (:,:, 0 ,:) = zn (:,:, 2 ,:) zn (:,:, - 1 ,:) = zn (:,:, 2 ,:) zn (:,:, - 2 ,:) = zn (:,:, 2 ,:) end if if ( kmax_id ==- 7 ) then zn (:,:, kmx + 0 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 1 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 2 ,:) = zn (:,:, kmx - 1 ,:) zn (:,:, kmx + 3 ,:) = zn (:,:, kmx - 1 ,:) end if end subroutine normalize_face_normals","tags":"","loc":"proc/normalize_face_normals.html","title":"normalize_face_normals – FEST-3D"},{"text":"private subroutine compute_face_areas() Compute face areas based on area vectors The face areas are computed using the face area vectors. \n Prior to using this subroutine, the face area vectors must\n computed and placed in the face normal variables. Since the area is given by abs(d1 x d2), the areas are\n calculated using the normal vectors calculated in \n compute_face_area_vectors, but before normalising them Arguments None Called by proc~~compute_face_areas~~CalledByGraph proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~compute_face_areas proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_face_areasCalledByGraph = svgPanZoom('#proccompute_face_areasCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_areas Source Code subroutine compute_face_areas () !< Compute face areas based on area vectors !< !< The face areas are computed using the face area vectors. !< Prior to using this subroutine, the face area vectors must !< computed and placed in the face normal variables. !< !< Since the area is given by abs(d1 x d2), the areas are !< calculated using the normal vectors calculated in !< compute_face_area_vectors, but before normalising them !----------------------------------------------------------- implicit none xA (:, :, :) = sqrt (( xnx (:, :, :)) ** 2. + ( xny (:, :, :)) ** 2. + & ( xnz (:, :, :)) ** 2. ) yA (:, :, :) = sqrt (( ynx (:, :, :)) ** 2. + ( yny (:, :, :)) ** 2. + & ( ynz (:, :, :)) ** 2. ) zA (:, :, :) = sqrt (( znx (:, :, :)) ** 2. + ( zny (:, :, :)) ** 2. + & ( znz (:, :, :)) ** 2. ) ! Pole boundary conditions ! making sure face area is exactly equal zero if ( imin_id ==- 7 ) xA ( - 2 : 1 , :, :) = 0. if ( imax_id ==- 7 ) xA ( imx : imx + 3 , :, :) = 0. if ( jmin_id ==- 7 ) yA ( :, - 2 : 1 , :) = 0. if ( jmax_id ==- 7 ) yA ( :, jmx : jmx + 3 , :) = 0. if ( kmin_id ==- 7 ) zA ( :, :, - 2 : 1 ) = 0. if ( kmax_id ==- 7 ) zA ( :, :, kmx : kmx + 3 ) = 0. end subroutine compute_face_areas","tags":"","loc":"proc/compute_face_areas.html","title":"compute_face_areas – FEST-3D"},{"text":"private subroutine compute_face_area_vectors() Compute face area vectors The face area vectors denote the face area both in \n magnitude and direction. They are placed in the face \n normal variables for further calculation. The face normal is given by d1 x d2, where d1 and d2 are\n the diagonals of a face Arguments None Called by proc~~compute_face_area_vectors~~CalledByGraph proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_face_area_vectorsCalledByGraph = svgPanZoom('#proccompute_face_area_vectorsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_area_vectors Source Code subroutine compute_face_area_vectors () !< Compute face area vectors !< !< The face area vectors denote the face area both in !< magnitude and direction. They are placed in the face !< normal variables for further calculation. !< !< The face normal is given by d1 x d2, where d1 and d2 are !< the diagonals of a face !----------------------------------------------------------- implicit none real :: d1x , d2x , d1y , d2y , d1z , d2z integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 3 d1x = grid_x ( i , j + 1 , k + 1 ) - grid_x ( i , j , k ) d1y = grid_y ( i , j + 1 , k + 1 ) - grid_y ( i , j , k ) d1z = grid_z ( i , j + 1 , k + 1 ) - grid_z ( i , j , k ) d2x = grid_x ( i , j , k + 1 ) - grid_x ( i , j + 1 , k ) d2y = grid_y ( i , j , k + 1 ) - grid_y ( i , j + 1 , k ) d2z = grid_z ( i , j , k + 1 ) - grid_z ( i , j + 1 , k ) xnx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) xny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) xnz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 2 do j = - 2 , jmx + 3 do i = - 2 , imx + 2 d1x = grid_x ( i + 1 , j , k + 1 ) - grid_x ( i , j , k ) d1y = grid_y ( i + 1 , j , k + 1 ) - grid_y ( i , j , k ) d1z = grid_z ( i + 1 , j , k + 1 ) - grid_z ( i , j , k ) d2x = grid_x ( i + 1 , j , k ) - grid_x ( i , j , k + 1 ) d2y = grid_y ( i + 1 , j , k ) - grid_y ( i , j , k + 1 ) d2z = grid_z ( i + 1 , j , k ) - grid_z ( i , j , k + 1 ) ynx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) yny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) ynz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do do k = - 2 , kmx + 3 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 d1x = grid_x ( i + 1 , j + 1 , k ) - grid_x ( i , j , k ) d1y = grid_y ( i + 1 , j + 1 , k ) - grid_y ( i , j , k ) d1z = grid_z ( i + 1 , j + 1 , k ) - grid_z ( i , j , k ) d2x = grid_x ( i , j + 1 , k ) - grid_x ( i + 1 , j , k ) d2y = grid_y ( i , j + 1 , k ) - grid_y ( i + 1 , j , k ) d2z = grid_z ( i , j + 1 , k ) - grid_z ( i + 1 , j , k ) znx ( i , j , k ) = 0.5 * ( d1y * d2z - d1z * d2y ) zny ( i , j , k ) = 0.5 * ( d1z * d2x - d1x * d2z ) znz ( i , j , k ) = 0.5 * ( d1x * d2y - d1y * d2x ) end do end do end do end subroutine compute_face_area_vectors","tags":"","loc":"proc/compute_face_area_vectors.html","title":"compute_face_area_vectors – FEST-3D"},{"text":"private subroutine compute_face_areas_and_normals() Compute the face areas and normals This is the 2-dimensional version. In this case, the face \n areas default to edge lengths. Arguments None Calls proc~~compute_face_areas_and_normals~~CallsGraph proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals->proc~compute_face_areas proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_areas_and_normals~~CalledByGraph proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_face_areas_and_normalsCalledByGraph = svgPanZoom('#proccompute_face_areas_and_normalsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_areas_and_normals Source Code subroutine compute_face_areas_and_normals () !< Compute the face areas and normals !< !< This is the 2-dimensional version. In this case, the face !< areas default to edge lengths. !----------------------------------------------------------- implicit none call compute_face_area_vectors () call compute_face_areas () call normalize_face_normals () end subroutine compute_face_areas_and_normals","tags":"","loc":"proc/compute_face_areas_and_normals.html","title":"compute_face_areas_and_normals – FEST-3D"},{"text":"private subroutine compute_volumes() Compute the grid cell volumes\n Each grid is a hexahedron, whose volume is calculated by\n splitting it into 5 tetrahedrons, whose volume is known Arguments None Calls proc~~compute_volumes~~CallsGraph proc~compute_volumes compute_volumes proc~vol_hexahedron vol_hexahedron proc~compute_volumes->proc~vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_volumes~~CalledByGraph proc~compute_volumes compute_volumes proc~compute_geometric_parameters compute_geometric_parameters proc~compute_geometric_parameters->proc~compute_volumes proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproccompute_volumesCalledByGraph = svgPanZoom('#proccompute_volumesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_volumes Source Code subroutine compute_volumes () !< Compute the grid cell volumes !< Each grid is a hexahedron, whose volume is calculated by !< splitting it into 5 tetrahedrons, whose volume is known !----------------------------------------------------------- implicit none integer :: i , j , k real , dimension ( 1 : 3 , 1 : 8 ) :: p_list volume = 1. do k = 0 , kmx + 0 do j = 0 , jmx + 0 do i = 0 , imx + 0 p_list (:, :) = 0. p_list (:, 1 ) = ( / grid_x ( i , j , k ), grid_y ( i , j , k ), grid_z ( i , j , k ) / ) p_list (:, 2 ) = ( / grid_x ( i + 1 , j , k ), grid_y ( i + 1 , j , k ), grid_z ( i + 1 , j , k ) / ) p_list (:, 3 ) = ( / grid_x ( i + 1 , j + 1 , k ), grid_y ( i + 1 , j + 1 , k ), grid_z ( i + 1 , j + 1 , k ) / ) p_list (:, 4 ) = ( / grid_x ( i , j + 1 , k ), grid_y ( i , j + 1 , k ), grid_z ( i , j + 1 , k ) / ) p_list (:, 5 ) = ( / grid_x ( i , j , k + 1 ), grid_y ( i , j , k + 1 ), grid_z ( i , j , k + 1 ) / ) p_list (:, 6 ) = ( / grid_x ( i + 1 , j , k + 1 ), grid_y ( i + 1 , j , k + 1 ), grid_z ( i + 1 , j , k + 1 ) / ) p_list (:, 7 ) = ( / grid_x ( i + 1 , j + 1 , k + 1 ), grid_y ( i + 1 , j + 1 , k + 1 ), grid_z ( i + 1 , j + 1 , k + 1 ) / ) p_list (:, 8 ) = ( / grid_x ( i , j + 1 , k + 1 ), grid_y ( i , j + 1 , k + 1 ), grid_z ( i , j + 1 , k + 1 ) / ) volume ( i , j , k ) = ( vol_hexahedron ( p_list )) if ( volume ( i , j , k ) <= 0.0 ) then if ( i == 0 . or . i == imx . or . j == 0 . or . j == jmx . or . k == 0 . or . k == kmx ) then !print*, \"Ghost Cell volume negative\" volume ( i , j , k ) = abs ( vol_hexahedron ( p_list )) else print * , process_id , i , j , k print * , \"negative volume :\" , ( vol_hexahedron ( p_list )) STOP end if end if end do end do end do if ( any ( volume == 0.0 )) then Fatal_error end if if ( any (( volume ) < 0.0 )) then Fatal_error end if end subroutine compute_volumes","tags":"","loc":"proc/compute_volumes.html","title":"compute_volumes – FEST-3D"},{"text":"private subroutine compute_geometric_parameters() Compute the geometric parameters based on the grid points The geometric parameters include the face normals and \n areas and the cell volumes. Arguments None Calls proc~~compute_geometric_parameters~~CallsGraph proc~compute_geometric_parameters compute_geometric_parameters proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~dmsg dmsg proc~compute_geometric_parameters->proc~dmsg proc~compute_volumes compute_volumes proc~compute_geometric_parameters->proc~compute_volumes proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals->proc~compute_face_areas proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals proc~vol_hexahedron vol_hexahedron proc~compute_volumes->proc~vol_hexahedron proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron var panproccompute_geometric_parametersCallsGraph = svgPanZoom('#proccompute_geometric_parametersCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_geometric_parameters~~CalledByGraph proc~compute_geometric_parameters compute_geometric_parameters proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_geometric_parameters proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_geometric_parameters Source Code subroutine compute_geometric_parameters () !< Compute the geometric parameters based on the grid points !< !< The geometric parameters include the face normals and !< areas and the cell volumes. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'compute_geometric_parameters' ) call compute_face_areas_and_normals () call compute_volumes () end subroutine compute_geometric_parameters","tags":"","loc":"proc/compute_geometric_parameters.html","title":"compute_geometric_parameters – FEST-3D"},{"text":"private subroutine compute_ghost_cell_centroid() Compute cell center of all cell including ghost cells Arguments None Called by proc~~compute_ghost_cell_centroid~~CalledByGraph proc~compute_ghost_cell_centroid compute_ghost_cell_centroid proc~setup_geometry setup_geometry proc~setup_geometry->proc~compute_ghost_cell_centroid proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_ghost_cell_centroid Source Code subroutine compute_ghost_cell_centroid () !< Compute cell center of all cell including ghost cells implicit none integer :: i , j , k do k = - 2 , kmx + 2 do j = - 2 , jmx + 2 do i = - 2 , imx + 2 CellCenter ( i , j , k , 1 ) = 0.125 * ( grid_x ( i , j , k ) & + grid_x ( i + 1 , j , k ) & + grid_x ( i + 1 , j + 1 , k ) & + grid_x ( i + 1 , j + 1 , k + 1 ) & + grid_x ( i + 1 , j , k + 1 ) & + grid_x ( i , j + 1 , k ) & + grid_x ( i , j + 1 , k + 1 ) & + grid_x ( i , j , k + 1 ) & ) CellCenter ( i , j , k , 2 ) = 0.125 * ( grid_y ( i , j , k ) & + grid_y ( i + 1 , j , k ) & + grid_y ( i + 1 , j + 1 , k ) & + grid_y ( i + 1 , j + 1 , k + 1 ) & + grid_y ( i + 1 , j , k + 1 ) & + grid_y ( i , j + 1 , k ) & + grid_y ( i , j + 1 , k + 1 ) & + grid_y ( i , j , k + 1 ) & ) CellCenter ( i , j , k , 3 ) = 0.125 * ( grid_z ( i , j , k ) & + grid_z ( i + 1 , j , k ) & + grid_z ( i + 1 , j + 1 , k ) & + grid_z ( i + 1 , j + 1 , k + 1 ) & + grid_z ( i + 1 , j , k + 1 ) & + grid_z ( i , j + 1 , k ) & + grid_z ( i , j + 1 , k + 1 ) & + grid_z ( i , j , k + 1 ) & ) end do end do end do end subroutine compute_ghost_cell_centroid","tags":"","loc":"proc/compute_ghost_cell_centroid.html","title":"compute_ghost_cell_centroid – FEST-3D"},{"text":"public subroutine setup_geometry() Make the geometry module useful Allocates memory to the variables and initializes them. Arguments None Calls proc~~setup_geometry~~CallsGraph proc~setup_geometry setup_geometry proc~dmsg dmsg proc~setup_geometry->proc~dmsg proc~compute_ghost_cell_centroid compute_ghost_cell_centroid proc~setup_geometry->proc~compute_ghost_cell_centroid proc~allocate_memory~3 allocate_memory proc~setup_geometry->proc~allocate_memory~3 proc~compute_geometric_parameters compute_geometric_parameters proc~setup_geometry->proc~compute_geometric_parameters proc~allocate_memory~3->proc~dmsg proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory~3->proc~allocate_memory_areas proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_normals proc~compute_geometric_parameters->proc~dmsg proc~compute_face_areas_and_normals compute_face_areas_and_normals proc~compute_geometric_parameters->proc~compute_face_areas_and_normals proc~compute_volumes compute_volumes proc~compute_geometric_parameters->proc~compute_volumes proc~compute_face_area_vectors compute_face_area_vectors proc~compute_face_areas_and_normals->proc~compute_face_area_vectors proc~compute_face_areas compute_face_areas proc~compute_face_areas_and_normals->proc~compute_face_areas proc~normalize_face_normals normalize_face_normals proc~compute_face_areas_and_normals->proc~normalize_face_normals interface~alloc alloc proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes->interface~alloc proc~vol_hexahedron vol_hexahedron proc~compute_volumes->proc~vol_hexahedron proc~allocate_memory_areas->interface~alloc proc~allocate_memory_normals->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~vol_tetrahedron vol_tetrahedron proc~vol_hexahedron->proc~vol_tetrahedron var panprocsetup_geometryCallsGraph = svgPanZoom('#procsetup_geometryCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_geometry~~CalledByGraph proc~setup_geometry setup_geometry proc~setup_solver setup_solver proc~setup_solver->proc~setup_geometry proc~setup_all setup_all proc~setup_all->proc~setup_geometry proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_geometry Source Code subroutine setup_geometry () !< Make the geometry module useful !< !< Allocates memory to the variables and initializes them. !----------------------------------------------------------- implicit none call dmsg ( 1 , 'geometry' , 'setup_geometry' ) call allocate_memory () call compute_geometric_parameters () call compute_ghost_cell_centroid () end subroutine setup_geometry","tags":"","loc":"proc/setup_geometry.html","title":"setup_geometry – FEST-3D"},{"text":"public subroutine destroy_geometry() Nullify all the face normal pionter Arguments None Calls proc~~destroy_geometry~~CallsGraph proc~destroy_geometry destroy_geometry proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry->proc~deallocate_memory~2 proc~dmsg dmsg proc~destroy_geometry->proc~dmsg proc~deallocate_memory~2->proc~dmsg interface~dealloc dealloc proc~deallocate_memory~2->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_geometry~~CalledByGraph proc~destroy_geometry destroy_geometry proc~destroy_all destroy_all proc~destroy_all->proc~destroy_geometry proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_geometry proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_geometry Source Code subroutine destroy_geometry () !< Nullify all the face normal pionter implicit none call dmsg ( 1 , 'geometry' , 'destroy_geometry' ) nullify ( xnx ) nullify ( xny ) nullify ( xnz ) nullify ( ynx ) nullify ( yny ) nullify ( ynz ) nullify ( znx ) nullify ( zny ) nullify ( znz ) call deallocate_memory () end subroutine destroy_geometry","tags":"","loc":"proc/destroy_geometry.html","title":"destroy_geometry – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~~CallsGraph proc~setup_scheme setup_scheme interface~alloc alloc proc~setup_scheme->interface~alloc proc~dmsg dmsg proc~setup_scheme->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'van_leer' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - van_leer.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - van_leer.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - van_leer.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - van_leer.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~~CallsGraph proc~destroy_scheme destroy_scheme interface~dealloc dealloc proc~destroy_scheme->interface~dealloc proc~dmsg dmsg proc~destroy_scheme->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'van_leer' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~~CallsGraph proc~compute_flux compute_flux proc~dmsg dmsg proc~compute_flux->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~~CalledByGraph proc~compute_flux compute_flux proc~compute_fluxes compute_fluxes proc~compute_fluxes->proc~compute_flux Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds call dmsg ( 1 , 'van_leer' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'van_leer' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! First construct the F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! First construct the F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~~CallsGraph proc~compute_fluxes compute_fluxes proc~dmsg dmsg proc~compute_fluxes->proc~dmsg proc~compute_flux compute_flux proc~compute_fluxes->proc~compute_flux proc~compute_flux->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'van_leer' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if call compute_flux ( 'z' ) if ( any ( isnan ( H ))) then call dmsg ( 5 , 'van_leer' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue using the Van-Leer scheme Arguments None Calls proc~~get_residue~~CallsGraph proc~get_residue get_residue proc~dmsg dmsg proc~get_residue->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue using the Van-Leer scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'van_leer' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = F ( i + 1 , j , k , l ) - F ( i , j , k , l ) & + G ( i , j + 1 , k , l ) - G ( i , j , k , l ) & + H ( i , j , k + 1 , l ) - H ( i , j , k , l ) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~2~~CallsGraph proc~setup_scheme~2 setup_scheme interface~alloc alloc proc~setup_scheme~2->interface~alloc proc~dmsg dmsg proc~setup_scheme~2->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'slau' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - slau.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - slau.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - slau.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - slau.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~2.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~2~~CallsGraph proc~destroy_scheme~2 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~2->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~2->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'slau' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~2.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~2~~CallsGraph proc~compute_flux~2 compute_flux proc~dmsg dmsg proc~compute_flux~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~2~~CalledByGraph proc~compute_flux~2 compute_flux proc~compute_fluxes~2 compute_fluxes proc~compute_fluxes~2->proc~compute_flux~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: xi real :: vnabs real :: delp real :: delrho real :: fnG real :: pbar real :: Mcap real :: vtface real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: VnabsL , VnabsR call dmsg ( 1 , 'slau' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'slau' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- speed of sound ---- cL = sqrt ( gm * pL / rL ) cR = sqrt ( gm * pR / rR ) C = 0.5 * ( cL + cR ) ! ---- delta quantities ---- delp = pR - pL !pL - pR delrho = rR - rL !rL - rR ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0.0 , 1.0 - floor ( abs ( ML ))) alphaR = max ( 0.0 , 1.0 - floor ( abs ( MR ))) !Above two line of code is eqvivalent to following code !if(abs(ML)>=1.0) then !  alphaL = 0.0 !else !  alphaL=1.0 !end if !if(abs(MR)>=1.0) then !  alphaR=0.0 !else !  alphaR=1.0 !end if ! -- pressure factor -- betaL = ( 1.0 - alphaL ) * 0.5 * ( 1.0 + sign ( 1.0 , ML )) + ( alphaL ) * 0.25 * ( 2.0 - ML ) * (( ML + 1.0 ) ** 2 ) betaR = ( 1.0 - alphaR ) * 0.5 * ( 1.0 - sign ( 1.0 , MR )) + ( alphaR ) * 0.25 * ( 2.0 + MR ) * (( MR - 1.0 ) ** 2 ) ! -- xi calculation -- vtface = sqrt ( 0.5 * (( uL * uL ) + ( vL * vL ) + ( wL * wL ) + ( uR * uR ) + ( vR * vR ) + ( wR * wR ))) Mcap = min ( 1.0 , vtface / C ) Xi = ( 1.0 - Mcap ) ** 2 ! -- |Vn| -- Vnabs = ( rL * abs ( VnL ) + rR * abs ( VnR )) / ( rL + rR ) ! -- function G -- fnG = - 1.0 * max ( min ( ML , 0.0 ), - 1.0 ) * min ( max ( MR , 0.0 ), 1.0 ) ! -- Pressure -- pbar = 0.5 * (( pL + pR ) + ( betaL - betaR ) * ( pL - pR ) + ( 1.0 - xi ) * ( betaL + betaR - 1.0 ) * ( pL + pR )) ! -- mass -- !mass = 0.5*((rL*VnL + rR*VnR - Vnabs*delrho)*(1.0-fnG) - (Xi*delp/C)) VnabsL = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnL ) VnabsR = ( 1.0 - fnG ) * Vnabs + fnG * abs ( VnR ) mass = 0.5 * (( rL * ( VnL + VnabsL ) + rR * ( VnR - VnabsR )) - ( Xi * delp / C )) mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) ! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_P ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~2.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~2~~CallsGraph proc~compute_fluxes~2 compute_fluxes proc~compute_flux~2 compute_flux proc~compute_fluxes~2->proc~compute_flux~2 proc~dmsg dmsg proc~compute_fluxes~2->proc~dmsg proc~compute_flux~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'slau' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'slau' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~2.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue for the slau scheme Arguments None Calls proc~~get_residue~2~~CallsGraph proc~get_residue~2 get_residue proc~dmsg dmsg proc~get_residue~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue for the slau scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'slau' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue~2.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~3~~CallsGraph proc~setup_scheme~3 setup_scheme interface~alloc alloc proc~setup_scheme~3->interface~alloc proc~dmsg dmsg proc~setup_scheme~3->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'AUSM+-UP' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - AUSM+-UP.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - AUSM+-UP.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - AUSM+-UP.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - AUSM+-UP.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~3.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~3~~CallsGraph proc~destroy_scheme~3 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~3->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~3->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'AUSM+-UP' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~3.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~3~~CallsGraph proc~compute_flux~3 compute_flux proc~dmsg dmsg proc~compute_flux~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~3~~CalledByGraph proc~compute_flux~3 compute_flux proc~compute_fluxes~3 compute_fluxes proc~compute_fluxes~3->proc~compute_flux~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: pbar real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: FmL , FmR real :: Mface real :: Cs real :: Mb real :: Mo real :: fna real :: Pu real :: Mp real :: alfa real , parameter :: Kp = 0.25 real , parameter :: Ku = 0.75 real , parameter :: sigma = 1.0 call dmsg ( 1 , 'ausm+-UP' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'AUSM+-UP' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( gm + 1.0 )) cL = cs * cs / ( max ( cs , VnL )) cR = cs * cs / ( max ( cs , - VnR )) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C Mb = sqrt ( 0.5 * (( VnL * VnL ) + ( VnR * VnR )) / ( C * C )) ! ---- function at face ---- Mo = sqrt ( min ( 1.0 , max ( Mb * Mb , MInf * MInf ))) fna = Mo * ( 2.0 - Mo ) alfa = 3.0 * ( - 4.0 + ( 5.0 * fna * fna )) / 1 6.0 ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.125 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * alfa * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.125 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * alfa * (( MR ** 2 - 1.0 ) ** 2 ) * MR !AUSM+- modification Pu = - Ku * betaL * betaR * ( rL + rR ) * fna * C * ( VnR - VnL ) Mp = - 2.0 * Kp * max ( 1.0 - ( sigma * Mb * Mb ), 0.0 ) * ( pR - pL ) / ( fna * ( rL + rR ) * C * C ) if ( isnan ( Pu )) then print * , \"Nan:\" , f_qp_left ( i , j , k ,:), f_qp_right ( i , j , k ,:) end if ! mass coefficient Mface = FmL + FmR + Mp ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR + Pu ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_p ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~3.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~3~~CallsGraph proc~compute_fluxes~3 compute_fluxes proc~compute_flux~3 compute_flux proc~compute_fluxes~3->proc~compute_flux~3 proc~dmsg dmsg proc~compute_fluxes~3->proc~dmsg proc~compute_flux~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'AUSM+-UP' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ausmUP' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~3.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue for the ausm+-UP scheme Arguments None Calls proc~~get_residue~3~~CallsGraph proc~get_residue~3 get_residue proc~dmsg dmsg proc~get_residue~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue for the ausm+-UP scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'AUSM+-UP' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue~3.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~4~~CallsGraph proc~setup_scheme~4 setup_scheme interface~alloc alloc proc~setup_scheme~4->interface~alloc proc~dmsg dmsg proc~setup_scheme~4->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'AUSM+' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - AUSM+.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - AUSM+.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - AUSM+.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - AUSM+.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~4.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~4~~CallsGraph proc~destroy_scheme~4 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~4->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~4->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'AUSM+' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~4.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~4~~CallsGraph proc~compute_flux~4 compute_flux proc~dmsg dmsg proc~compute_flux~4->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~4~~CalledByGraph proc~compute_flux~4 compute_flux proc~compute_fluxes~4 compute_fluxes proc~compute_fluxes~4->proc~compute_flux~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k !< Integer for DO loop integer :: i_f , j_f , k_f !< Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz !< Pointer to the face area and normal real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus !< Right flux through the face real , dimension ( 1 : n_var ) :: F_minus !< Left flux through  the face real :: pbar real :: mass real :: HL , HR !< Enthalpy real :: uL , uR !< X-component of velocity real :: vL , vR !< Y-component of velocity real :: wL , wR !< Z-component of velocity real :: pL , pR !< Pressure real :: rL , rR !< Density real :: cL , cR !< Speed sound left/right real :: C !< Speed of sound at face real :: ML , MR !< Mach number left/right real :: VnL , VnR !< Face normal velocity left/right real :: betaL , betaR real :: alphaL , alphaR real :: FmL , FmR real :: Mface real :: Cs call dmsg ( 1 , 'AUSM+' , 'compute_flux ' // trim ( f_dir )) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'AUSM+' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f ! -- primitve face state assignment -- ! ---- left face quantities ---- rL = f_qp_left ( i , j , k , 1 ) uL = f_qp_left ( i , j , k , 2 ) vL = f_qp_left ( i , j , k , 3 ) wL = f_qp_left ( i , j , k , 4 ) pL = f_qp_left ( i , j , k , 5 ) ! ---- right face quantities ---- rR = f_qp_right ( i , j , k , 1 ) uR = f_qp_right ( i , j , k , 2 ) vR = f_qp_right ( i , j , k , 3 ) wR = f_qp_right ( i , j , k , 4 ) pR = f_qp_right ( i , j , k , 5 ) !-- calculated quntaties -- ! ---- total enthalpy ---- HL = ( 0.5 * ( uL * uL + vL * vL + wL * wL )) + (( gm / ( gm - 1. )) * pL / rL ) HR = ( 0.5 * ( uR * uR + vR * vR + wR * wR )) + (( gm / ( gm - 1. )) * pR / rR ) ! ---- face normal velocity ---- VnL = uL * nx ( i , j , k ) + vL * ny ( i , j , k ) + wL * nz ( i , j , k ) VnR = uR * nx ( i , j , k ) + vR * ny ( i , j , k ) + wR * nz ( i , j , k ) ! ---- speed of sound ---- cs = sqrt ( 2.0 * ( gm - 1.0 ) * ( 0.5 * ( HL + HR )) / ( gm + 1.0 )) cL = cs * cs / ( max ( cs , abs ( VnL ))) cR = cs * cs / ( max ( cs , abs ( VnR ))) C = min ( cL , CR ) ! ---- Mach at face ---- ML = VnL / C MR = VnR / C ! ---- switch for supersonic flow ---- alphaL = max ( 0 , 1 - floor ( abs ( ML ))) alphaR = max ( 0 , 1 - floor ( abs ( MR ))) ! Compute '+' direction quantities FmL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL ) * ML ) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) betaL = ( 0.5 * ( 1.0 + sign ( 1.0 , ML )) * ( 1.0 - alphaL )) + alphaL * 0.25 * (( 1.0 + ML ) ** 2 ) * ( 2.0 - ML ) ! Compute '-' direction quantities FmR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR ) * MR ) - alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) betaR = ( 0.5 * ( 1.0 - sign ( 1.0 , MR )) * ( 1.0 - alphaR )) + alphaR * 0.25 * (( 1.0 - MR ) ** 2 ) * ( 2.0 + MR ) !AUSM+modification ! Compute '+' direction quantities FmL = FmL + alphaL * 0.1250 * (( ML ** 2 - 1.0 ) ** 2 ) betaL = betaL + alphaL * 0.1875 * (( ML ** 2 - 1.0 ) ** 2 ) * ML ! Compute '-' direction quantities FmR = FmR - alphaR * 0.1250 * (( MR ** 2 - 1.0 ) ** 2 ) betaR = betaR - alphaR * 0.1875 * (( MR ** 2 - 1.0 ) ** 2 ) * MR ! mass coefficient Mface = FmL + FmR ! -- Pressure coeffient-- pbar = betaL * pL + betaR * pR ! -- mass -- if ( Mface > 0.0 ) then mass = Mface * C * rL else mass = Mface * c * rR end if mass = mass * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! F plus mass flux ! Construct other fluxes in terms of the F mass flux F_plus ( 1 ) = 0.5 * ( mass + abs ( mass )) F_plus ( 2 ) = ( F_plus ( 1 ) * uL ) F_plus ( 3 ) = ( F_plus ( 1 ) * vL ) F_plus ( 4 ) = ( F_plus ( 1 ) * wL ) F_plus ( 5 ) = ( F_plus ( 1 ) * HL ) ! F minus mass flux ! Construct other fluxes in terms of the F mass flux F_minus ( 1 ) = 0.5 * ( mass - abs ( mass )) F_minus ( 2 ) = ( F_minus ( 1 ) * uR ) F_minus ( 3 ) = ( F_minus ( 1 ) * vR ) F_minus ( 4 ) = ( F_minus ( 1 ) * wR ) F_minus ( 5 ) = ( F_minus ( 1 ) * HR ) !! -- Turbulence variables mass flux -- if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! total flux flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) ! Get the total flux for a face ! -- Pressure flux addition -- flux_p ( i , j , K , 2 ) = flux_p ( i , j , k , 2 ) + ( pbar * nx ( i , j , k )) flux_p ( i , j , K , 3 ) = flux_p ( i , j , k , 3 ) + ( pbar * ny ( i , j , k )) flux_p ( i , j , K , 4 ) = flux_p ( i , j , k , 4 ) + ( pbar * nz ( i , j , k )) flux_p ( i , j , k , :) = flux_p ( i , j , k , :) * fA ( i , j , k ) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~4.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~4~~CallsGraph proc~compute_fluxes~4 compute_fluxes proc~dmsg dmsg proc~compute_fluxes~4->proc~dmsg proc~compute_flux~4 compute_flux proc~compute_fluxes~4->proc~compute_flux~4 proc~compute_flux~4->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'AUSM+' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if if ( kmx == 2 ) then H = 0. else call compute_flux ( 'z' ) end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'AUSM+' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~4.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue for the AUSM+ scheme Arguments None Calls proc~~get_residue~4~~CallsGraph proc~get_residue~4 get_residue proc~dmsg dmsg proc~get_residue~4->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue for the AUSM+ scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'AUSM+' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue~4.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~5~~CallsGraph proc~setup_scheme~5 setup_scheme interface~alloc alloc proc~setup_scheme~5->interface~alloc proc~dmsg dmsg proc~setup_scheme~5->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'ausm' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - ausm.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - ausm.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - ausm.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - ausm.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~5.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~5~~CallsGraph proc~destroy_scheme~5 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~5->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~5->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'ausm' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~5.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~5~~CallsGraph proc~compute_flux~5 compute_flux proc~dmsg dmsg proc~compute_flux~5->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~5~~CalledByGraph proc~compute_flux~5 compute_flux proc~compute_fluxes~5 compute_fluxes proc~compute_fluxes~5->proc~compute_flux~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input-argument direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds real :: temp_c call dmsg ( 1 , 'ausm' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ausm' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! AUSM modification temp_c = c_plus + c_minus c_plus = max ( 0. , temp_c ) c_minus = min ( 0. , temp_c ) ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~5.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~5~~CallsGraph proc~compute_fluxes~5 compute_fluxes proc~dmsg dmsg proc~compute_fluxes~5->proc~dmsg proc~compute_flux~5 compute_flux proc~compute_fluxes~5->proc~compute_flux~5 proc~compute_flux~5->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'ausm' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if !if(kmx==2) then !  H = 0. !else call compute_flux ( 'z' ) !end if if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ausm' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~5.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue for the AUSM scheme Arguments None Calls proc~~get_residue~5~~CallsGraph proc~get_residue~5 get_residue proc~dmsg dmsg proc~get_residue~5->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue for the AUSM scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'ausm' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = ( F ( i + 1 , j , k , l ) - F ( i , j , k , l )) & + ( G ( i , j + 1 , k , l ) - G ( i , j , k , l )) & + ( H ( i , j , k + 1 , l ) - H ( i , j , k , l )) !print*, i, j, l, F(i+1, j,k,l), F(i,j,k,l), G(i,j+1,k,l)& !       , G(i,j,k,l), H(i,j,k+1,l), H(i,j,k,l) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue~5.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memory to the flux variables Arguments None Calls proc~~setup_scheme~6~~CallsGraph proc~setup_scheme~6 setup_scheme interface~alloc alloc proc~setup_scheme~6->interface~alloc proc~dmsg dmsg proc~setup_scheme~6->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memory to the flux variables implicit none call dmsg ( 1 , 'ldfss0' , 'setup_scheme' ) call alloc ( F , 1 , imx , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'F - ldfss0.' ) call alloc ( G , 1 , imx - 1 , 1 , jmx , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'G - ldfss0.' ) call alloc ( H , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'H - ldfss0.' ) call alloc ( residue , 1 , imx - 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'residue - ldfss0.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~6.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate memory Arguments None Calls proc~~destroy_scheme~6~~CallsGraph proc~destroy_scheme~6 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~6->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~6->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate memory implicit none call dmsg ( 1 , 'ldfss0' , 'destroy_scheme' ) call dealloc ( F ) call dealloc ( G ) call dealloc ( H ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~6.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_flux(f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store Calls proc~~compute_flux~6~~CallsGraph proc~compute_flux~6 compute_flux proc~dmsg dmsg proc~compute_flux~6->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_flux~6~~CalledByGraph proc~compute_flux~6 compute_flux proc~compute_fluxes~6 compute_fluxes proc~compute_fluxes~6->proc~compute_flux~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_flux Source Code subroutine compute_flux ( f_dir ) !< A generalized subroutine to calculate !< flux through the input direction, :x,y, or z !< which corresponds to the I,J, or K direction respectively !------------------------------------------------------------ implicit none character , intent ( in ) :: f_dir !< Input direction for which flux are calcuated and store integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :), pointer :: fA , nx , ny , nz real , dimension (:,:,:,:), pointer :: f_qp_left , f_qp_right real , dimension ( 1 : n_var ) :: F_plus , F_minus real :: M_perp_left , M_perp_right real :: alpha_plus , alpha_minus real :: beta_left , beta_right real :: M_plus , M_minus real :: D_plus , D_minus real :: c_plus , c_minus real :: scrD_plus , scrD_minus real :: sound_speed_avg , face_normal_speeds real :: M_ldfss , M_plus_ldfss , M_minus_ldfss call dmsg ( 1 , 'ldfss0' , 'compute_flux' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 flux_p => F fA => xA nx => xnx ny => xny nz => xnz f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 flux_p => G fA => yA nx => ynx ny => yny nz => ynz f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 flux_p => H fA => zA nx => znx ny => zny nz => znz f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ldfss0' , 'compute_flux' , & 'Direction not recognised' ) stop end select do k = 1 , kmx - 1 + k_f do j = 1 , jmx - 1 + j_f do i = 1 , imx - 1 + i_f sound_speed_avg = 0.5 * ( sqrt ( gm * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ) ) + & sqrt ( gm * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ) ) ) ! Compute '+' direction quantities face_normal_speeds = f_qp_left ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_left ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_left ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_left = face_normal_speeds / sound_speed_avg alpha_plus = 0.5 * ( 1.0 + sign ( 1.0 , M_perp_left )) beta_left = - max ( 0 , 1 - floor ( abs ( M_perp_left ))) M_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) D_plus = 0.25 * (( 1. + M_perp_left ) ** 2. ) * ( 2. - M_perp_left ) c_plus = ( alpha_plus * ( 1.0 + beta_left ) * M_perp_left ) - & beta_left * M_plus scrD_plus = ( alpha_plus * ( 1. + beta_left )) - & ( beta_left * D_plus ) ! Compute '-' direction quantities face_normal_speeds = f_qp_right ( i , j , k , 2 ) * nx ( i , j , k ) + & f_qp_right ( i , j , k , 3 ) * ny ( i , j , k ) + & f_qp_right ( i , j , k , 4 ) * nz ( i , j , k ) M_perp_right = face_normal_speeds / sound_speed_avg alpha_minus = 0.5 * ( 1.0 - sign ( 1.0 , M_perp_right )) beta_right = - max ( 0 , 1 - floor ( abs ( M_perp_right ))) M_minus = - 0.25 * (( 1. - M_perp_right ) ** 2. ) D_minus = 0.25 * (( 1. - M_perp_right ) ** 2. ) * ( 2. + M_perp_right ) c_minus = ( alpha_minus * ( 1.0 + beta_right ) * M_perp_right ) - & beta_right * M_minus scrD_minus = ( alpha_minus * ( 1. + beta_right )) - & ( beta_right * D_minus ) ! LDFSS0 modification M_ldfss = 0.25 * beta_left * beta_right * & ( sqrt (( M_perp_left ** 2 + M_perp_right ** 2 ) * 0.5 ) & - 1 ) ** 2 M_plus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_left ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) M_minus_ldfss = M_ldfss * & ( 1 - ( f_qp_left ( i , j , k , 5 ) - f_qp_right ( i , j , k , 5 )) / & ( 2 * f_qp_right ( i , j , k , 1 ) * ( sound_speed_avg ** 2 ))) c_plus = c_plus - M_plus_ldfss c_minus = c_minus + M_minus_ldfss ! F plus mass flux F_plus ( 1 ) = f_qp_left ( i , j , k , 1 ) * sound_speed_avg * c_plus ! F minus mass flux F_minus ( 1 ) = f_qp_right ( i , j , k , 1 ) * sound_speed_avg * c_minus F_plus ( 1 ) = F_plus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) F_minus ( 1 ) = F_minus ( 1 ) * ( i_f * make_F_flux_zero ( i ) & + j_f * make_G_flux_zero ( j ) & + k_f * make_H_flux_zero ( k )) ! Construct other fluxes in terms of the F mass flux F_plus ( 2 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 2 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nx ( i , j , k )) F_plus ( 3 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 3 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * ny ( i , j , k )) F_plus ( 4 ) = ( F_plus ( 1 ) * f_qp_left ( i , j , k , 4 )) + & ( scrD_plus * f_qp_left ( i , j , k , 5 ) * nz ( i , j , k )) F_plus ( 5 ) = F_plus ( 1 ) * & (( 0.5 * ( f_qp_left ( i , j , k , 2 ) ** 2. + & f_qp_left ( i , j , k , 3 ) ** 2. + & f_qp_left ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_left ( i , j , k , 5 ) / & f_qp_left ( i , j , k , 1 ))) ! Construct other fluxes in terms of the F mass flux F_minus ( 2 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 2 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nx ( i , j , k )) F_minus ( 3 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 3 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * ny ( i , j , k )) F_minus ( 4 ) = ( F_minus ( 1 ) * f_qp_right ( i , j , k , 4 )) + & ( scrD_minus * f_qp_right ( i , j , k , 5 ) * nz ( i , j , k )) F_minus ( 5 ) = F_minus ( 1 ) * & (( 0.5 * ( f_qp_right ( i , j , k , 2 ) ** 2. + & f_qp_right ( i , j , k , 3 ) ** 2. + & f_qp_right ( i , j , k , 4 ) ** 2. )) + & (( gm / ( gm - 1. )) * f_qp_right ( i , j , k , 5 ) / & f_qp_right ( i , j , k , 1 ))) !turbulent fluxes if ( n_var > 5 ) then F_plus ( 6 :) = F_Plus ( 1 ) * f_qp_left ( i , j , k , 6 :) F_minus ( 6 :) = F_minus ( 1 ) * f_qp_right ( i , j , k , 6 :) end if ! Multiply in the face areas F_plus (:) = F_plus (:) * fA ( i , j , k ) F_minus (:) = F_minus (:) * fA ( i , j , k ) ! Get the total flux for a face flux_p ( i , j , k , :) = F_plus (:) + F_minus (:) end do end do end do end subroutine compute_flux","tags":"","loc":"proc/compute_flux~6.html","title":"compute_flux – FEST-3D"},{"text":"public subroutine compute_fluxes() Call to compute fluxes throught faces in each direction Arguments None Calls proc~~compute_fluxes~6~~CallsGraph proc~compute_fluxes~6 compute_fluxes proc~dmsg dmsg proc~compute_fluxes~6->proc~dmsg proc~compute_flux~6 compute_flux proc~compute_fluxes~6->proc~compute_flux~6 proc~compute_flux~6->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_fluxes Source Code subroutine compute_fluxes () !< Call to compute fluxes throught faces in each direction implicit none call dmsg ( 1 , 'ldfss0' , 'compute_fluxes' ) call compute_flux ( 'x' ) if ( any ( isnan ( F ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: F flux Nan detected' ) stop end if call compute_flux ( 'y' ) if ( any ( isnan ( G ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: G flux Nan detected' ) stop end if call compute_flux ( 'z' ) if ( any ( isnan ( H ))) then call dmsg ( 5 , 'ldfss0' , 'compute_residue' , 'ERROR: H flux Nan detected' ) stop end if end subroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes~6.html","title":"compute_fluxes – FEST-3D"},{"text":"public subroutine get_residue() Compute the residue for the ldfss0 scheme Arguments None Calls proc~~get_residue~6~~CallsGraph proc~get_residue~6 get_residue proc~dmsg dmsg proc~get_residue~6->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_residue Source Code subroutine get_residue () !< Compute the residue for the ldfss0 scheme !----------------------------------------------------------- implicit none integer :: i , j , k , l call dmsg ( 1 , 'ldfss0' , 'compute_residue' ) do l = 1 , n_var do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 residue ( i , j , k , l ) = F ( i + 1 , j , k , l ) - F ( i , j , k , l ) & + G ( i , j + 1 , k , l ) - G ( i , j , k , l ) & + H ( i , j , k + 1 , l ) - H ( i , j , k , l ) end do end do end do end do end subroutine get_residue","tags":"","loc":"proc/get_residue~6.html","title":"get_residue – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memoery to all array which store state\n the face. Arguments None Calls proc~~setup_scheme~7~~CallsGraph proc~setup_scheme~7 setup_scheme interface~alloc alloc proc~setup_scheme~7->interface~alloc proc~dmsg dmsg proc~setup_scheme~7->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'muscl' , 'setup_muscl' ) phi = 1.0 kappa = 1. / 3. call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) call alloc ( pdif , 0 , imx , 0 , jmx , 0 , kmx , & errmsg = 'Error: Unable to allocate memory for' // & 'pdif' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~7.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate all the array used Arguments None Calls proc~~destroy_scheme~7~~CallsGraph proc~destroy_scheme~7 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~7->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~7->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'muscl' , 'destroy_muscl' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) call dealloc ( pdif ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~7.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine pressure_based_switching(f_dir) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Character can be x or y or z Calls proc~~pressure_based_switching~~CallsGraph proc~pressure_based_switching pressure_based_switching proc~dmsg dmsg proc~pressure_based_switching->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pressure_based_switching~~CalledByGraph proc~pressure_based_switching pressure_based_switching proc~compute_muscl_states compute_muscl_states proc~compute_muscl_states->proc~pressure_based_switching Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pressure_based_switching Source Code subroutine pressure_based_switching ( f_dir ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none character , intent ( in ) :: f_dir !< Character can be x or y or z integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real :: pd2 call dmsg ( 1 , 'muscl' , 'pressure_based_switching' ) select case ( f_dir ) case ( 'x' ) f_qp_left => x_qp_left f_qp_right => x_qp_right i_f = 1 j_f = 0 k_f = 0 i_end = imx j_end = jmx - 1 k_end = kmx - 1 case ( 'y' ) f_qp_left => y_qp_left f_qp_right => y_qp_right i_f = 0 j_f = 1 k_f = 0 i_end = imx - 1 j_end = jmx k_end = kmx - 1 case ( 'z' ) f_qp_left => z_qp_left f_qp_right => z_qp_right i_f = 0 j_f = 0 k_f = 1 i_end = imx - 1 j_end = jmx - 1 k_end = kmx case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 pd2 = abs ( pressure ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 ) - & pressure ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( kmx - 1 )) = & pdif ( 1 : imx - 1 - i_f * ( imx - 2 ), 1 : jmx - 1 - j_f * ( jmx - 2 ), & 1 : kmx - 1 - k_f * ( kmx - 2 )) pdif (( 1 - i_f * ( - imx + 1 )):( i_f ) + ( imx - 1 ), ( 1 - j_f * ( - jmx + 1 )):( j_f ) + ( jmx - 1 ), & ( 1 - k_f * ( - kmx + 1 )):( k_f ) + ( kmx - 1 )) = & pdif ( 1 + i_f * ( imx - 2 ): imx - 1 , 1 + j_f * ( jmx - 2 ): jmx - 1 , & 1 + k_f * ( kmx - 2 ): kmx - 1 ) ! Loop over faces do k = 1 , kmx - ( 1 - k_f ) do j = 1 , jmx - ( 1 - j_f ) do i = 1 , imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching","tags":"","loc":"proc/pressure_based_switching.html","title":"pressure_based_switching – FEST-3D"},{"text":"private subroutine compute_face_state(f_dir, lam_switch, turb_switch) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction x,y,or, z for which subroutine is called integer, intent(in) :: lam_switch Limiter switch for laminar variables integer, intent(in) :: turb_switch Limiter switch for turbulent variables Calls proc~~compute_face_state~~CallsGraph proc~compute_face_state compute_face_state proc~dmsg dmsg proc~compute_face_state->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_state~~CalledByGraph proc~compute_face_state compute_face_state proc~compute_muscl_states compute_muscl_states proc~compute_muscl_states->proc~compute_face_state Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_state Source Code subroutine compute_face_state ( f_dir , lam_switch , turb_switch ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none ! Character can be x or y or z character , intent ( in ) :: f_dir !< Input direction x,y,or, z for which subroutine is called integer , intent ( in ) :: lam_switch !< Limiter switch for laminar variables integer , intent ( in ) :: turb_switch !< Limiter switch for turbulent variables integer :: i , j , k , l !< integer used for DO loop integer :: ii , jj , kk !< Variable for ALFA family limiter real :: alpha !< Flags to determine face direction real :: psi1 , psi2 !< limiters real :: fd !< forward difference real :: bd !< backward difference real :: r !< ratio of differences real , dimension (:, :, :, :), pointer :: f_qp_left !< Generalized pointer for any I-J-K direction> f_qp_left can !< either point to x_qp_left, y_qp_left or z_qp_left real , dimension (:, :, :, :), pointer :: f_qp_right !< Generalized pointer for any I-J-K direction> f_qp_right can !< either point to x_qp_right, y_qp_right or z_qp_right call dmsg ( 1 , 'muscl' , 'compute_face_state' ) select case ( f_dir ) case ( 'x' ) f_qp_left ( 0 : imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) => x_qp_left f_qp_right ( 0 : imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) => x_qp_right ii = 1 jj = 0 kk = 0 case ( 'y' ) f_qp_left ( 1 : imx - 1 , 0 : jmx + 1 , 1 : kmx - 1 , 1 : n_var ) => y_qp_left f_qp_right ( 1 : imx - 1 , 0 : jmx + 1 , 1 : kmx - 1 , 1 : n_var ) => y_qp_right ii = 0 jj = 1 kk = 0 case ( 'z' ) f_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 0 : kmx + 1 , 1 : n_var ) => z_qp_left f_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 0 : kmx + 1 , 1 : n_var ) => z_qp_right ii = 0 jj = 0 kk = 1 case default call dmsg ( 5 , 'muscl' , 'compute_face_state' , & 'Direction not recognised' ) stop end select alpha = 2. / 3. !Koren limiter phi = 1.0 kappa = 1. / 3. switch_L = lam_switch do l = 1 , n_var if ( l >= 6 ) then switch_L = turb_switch end if do k = 1 - kk , kmx - 1 + kk do j = 1 - jj , jmx - 1 + jj do i = 1 - ii , imx - 1 + ii ! Cell based ! Koren limiter for now ! From paper: delta: forward difference 'fd' !             nabla: backward difference 'bd' fd = qp ( i + ii , j + jj , k + kk , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - ii , j - jj , k - kk , l ) r = fd / max ( bd , 1 e - 10 ) psi1 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !alpha limiter !                psi1 = max(0., min(2*r,1.), min(r,2.))    ! superbee !                psi1 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi1 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer r = bd / max ( fd , 1 e - 10 ) psi2 = max ( 0. , min ( 2 * r , alpha * ( r - 1.0 ) + 1.0 , 2. )) !                psi2 = max(0., min(2*r,1.), min(r,2.)) !                psi2 = ((r*r) + r)/((r*r) + 1.0)          ! Van-Albda !                psi2 = (abs(r) + r)/(abs(r) + 1.0)          ! Van-Leer psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) f_qp_left ( i + ii , j + jj , k + kk , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end subroutine compute_face_state","tags":"","loc":"proc/compute_face_state.html","title":"compute_face_state – FEST-3D"},{"text":"public subroutine compute_muscl_states() Implement MUSCL scheme to get left and right states at\n each face. The computation is done through all cells\n and first level ghost cells Arguments None Calls proc~~compute_muscl_states~~CallsGraph proc~compute_muscl_states compute_muscl_states proc~compute_face_state compute_face_state proc~compute_muscl_states->proc~compute_face_state proc~pressure_based_switching pressure_based_switching proc~compute_muscl_states->proc~pressure_based_switching proc~dmsg dmsg proc~compute_face_state->proc~dmsg proc~pressure_based_switching->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_muscl_states Source Code subroutine compute_muscl_states () !< Implement MUSCL scheme to get left and right states at !< each face. The computation is done through all cells !< and first level ghost cells !--------------------------------------------------------- !call compute_xi_face_states() call compute_face_state ( 'x' , ilimiter_switch , itlimiter_switch ) if ( iPB_switch == 1 ) then call pressure_based_switching ( 'x' ) end if !call compute_eta_face_states() call compute_face_state ( 'y' , jlimiter_switch , jtlimiter_switch ) if ( jPB_switch == 1 ) then call pressure_based_switching ( 'y' ) end if !call compute_zeta_face_states() call compute_face_state ( 'z' , klimiter_switch , ktlimiter_switch ) if ( kPB_switch == 1 ) then call pressure_based_switching ( 'z' ) end if end subroutine compute_muscl_states","tags":"","loc":"proc/compute_muscl_states.html","title":"compute_muscl_states – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memoery to all array which store state\n the face. Arguments None Calls proc~~setup_scheme~8~~CallsGraph proc~setup_scheme~8 setup_scheme interface~alloc alloc proc~setup_scheme~8->interface~alloc proc~dmsg dmsg proc~setup_scheme~8->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'weno' , 'setup_weno' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~8.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate all the array used Arguments None Calls proc~~destroy_scheme~8~~CallsGraph proc~destroy_scheme~8 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~8->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~8->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'weno' , 'destroy_weno' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~8.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_face_states(dir) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Called by proc~~compute_face_states~~CalledByGraph proc~compute_face_states compute_face_states proc~compute_weno_states compute_weno_states proc~compute_weno_states->proc~compute_face_states Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_states Source Code subroutine compute_face_states ( dir ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none character ( len =* ), intent ( in ) :: dir integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real , dimension ( 3 ) :: P !< polynomial approximation real , dimension ( 3 ) :: B !< smoothness factor real , dimension ( 3 ) :: w !< wieght real , dimension ( 3 ) :: g !< linear wieght real , dimension ( - 2 : 2 ) :: u !< state_variable real :: eps = 1 e - 6 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 select case ( dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right end select do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} P ( 1 ) = ( 2.0 * U ( - 2 ) - 7.0 * U ( - 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( - 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( 1 ) - 1.0 * U ( 2 )) / 6.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 2 ) - 2.0 * U ( - 1 ) + U ( 0 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 2 ) - 4.0 * U ( - 1 ) + 3.0 * U ( 0 )) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( U ( - 1 ) - 2.0 * U ( 0 ) + U ( 1 )) ** 2 + ( 1.0 / 4.0 ) * ( U ( - 1 ) - U ( 1 )) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( U ( 0 ) - 2.0 * U ( 1 ) + U ( 2 )) ** 2 + ( 1.0 / 4.0 ) * ( 3.0 * U ( 0 ) - 4.0 * U ( 1 ) + U ( 2 )) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 2.0 * U ( 2 ) - 7.0 * U ( 1 ) + 1 1.0 * U ( 0 )) / 6.0 P ( 2 ) = ( - 1.0 * U ( 1 ) + 5.0 * U ( 0 ) + 2.0 * U ( - 1 )) / 6.0 P ( 3 ) = ( 2.0 * U ( 0 ) + 5.0 * U ( - 1 ) - 1.0 * U ( - 2 )) / 6.0 !B(1) = (13.0/12.0)*(U( 2)-2.0*U( 1)+U( 0))**2 + (1.0/4.0)*(    U(2)-4.0*U( 1)+3.0*U( 0))**2 !B(2) = (13.0/12.0)*(U( 1)-2.0*U( 0)+U(-1))**2 + (1.0/4.0)*(    U(1)-              U(-1))**2 !B(3) = (13.0/12.0)*(U( 0)-2.0*U(-1)+U(-2))**2 + (1.0/4.0)*(3.0*U(0)-4.0*U(-1)+    U(-2))**2 w ( 1 ) = g ( 1 ) / ( eps + B ( 3 )) ** 2 w ( 2 ) = g ( 2 ) / ( eps + B ( 2 )) ** 2 w ( 3 ) = g ( 3 ) / ( eps + B ( 1 )) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states","tags":"","loc":"proc/compute_face_states.html","title":"compute_face_states – FEST-3D"},{"text":"public subroutine compute_weno_states() Call Weno scheme for all the three direction I,J, and K Arguments None Calls proc~~compute_weno_states~~CallsGraph proc~compute_weno_states compute_weno_states proc~compute_face_states compute_face_states proc~compute_weno_states->proc~compute_face_states Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_weno_states Source Code subroutine compute_weno_states () !< Call Weno scheme for all the three direction I,J, and K call compute_face_states ( 'x' ) call compute_face_states ( 'y' ) call compute_face_states ( 'z' ) end subroutine compute_weno_states","tags":"","loc":"proc/compute_weno_states.html","title":"compute_weno_states – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memoery to all array which store state\n the face. Arguments None Calls proc~~setup_scheme~9~~CallsGraph proc~setup_scheme~9 setup_scheme interface~alloc alloc proc~setup_scheme~9->interface~alloc proc~dmsg dmsg proc~setup_scheme~9->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'weno_NM' , 'setup_weno_NM' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~9.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate all the array used Arguments None Calls proc~~destroy_scheme~9~~CallsGraph proc~destroy_scheme~9 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~9->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~9->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'weno_NM' , 'destroy_weno_NM' ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~9.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_face_states(dir) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir Called by proc~~compute_face_states~2~~CalledByGraph proc~compute_face_states~2 compute_face_states proc~compute_weno_nm_states compute_weno_NM_states proc~compute_weno_nm_states->proc~compute_face_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_states Source Code subroutine compute_face_states ( dir ) !< Subroutine to calculate state at the face, generalized for !< all direction : I,J, and K. implicit none character ( len =* ), intent ( in ) :: dir integer :: i , j , k , l integer :: i_f = 0 , j_f = 0 , k_f = 0 real , dimension ( 3 ) :: P !< polynomial approximation real , dimension ( 3 ) :: B !< smoothness factor real , dimension ( 3 ) :: w !< wieght real , dimension ( 3 ) :: g !< linear wieght real , dimension ( - 2 : 2 ) :: u !<state_variable real :: eps = 1 e - 6 real :: alpha real , dimension ( - 2 : 2 ) :: vol real :: U11 real :: U00 real :: U21 real :: U10 real :: U01 real :: U12 real :: alpha12 real :: alpha01 real :: alpha10 real :: alpha21 g ( 1 ) = 1.0 / 1 0.0 g ( 2 ) = 6.0 / 1 0.0 g ( 3 ) = 3.0 / 1 0.0 select case ( dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right end select do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f U ( - 2 ) = qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , l ) !u_{i-2} U ( - 1 ) = qp ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f , l ) !u_{i-1} u ( 0 ) = qp ( i , j , k , l ) !u_{i} U ( 1 ) = qp ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f , l ) !u_{i+1} U ( 2 ) = qp ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f , l ) !u_{i+2} Vol ( - 2 ) = volume ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f ) !volume_{i-2} Vol ( - 1 ) = volume ( i - 1 * i_f , j - 1 * j_f , k - 1 * k_f ) !volume_{i-1} Vol ( 0 ) = volume ( i , j , k ) !volume_{i} Vol ( 1 ) = volume ( i + 1 * i_f , j + 1 * j_f , k + 1 * k_f ) !volume_{i+1} Vol ( 2 ) = volume ( i + 2 * i_f , j + 2 * j_f , k + 2 * k_f ) !volume_{i+2} alpha12 = Vol ( 2 ) / ( Vol ( 1 ) + Vol ( 2 )) alpha01 = Vol ( 1 ) / ( Vol ( 0 ) + Vol ( 1 )) alpha10 = Vol ( 0 ) / ( Vol ( - 1 ) + Vol ( 0 )) alpha21 = vol ( - 1 ) / ( Vol ( - 2 ) + Vol ( - 1 )) U01 = ( 1.0 - alpha01 ) * U ( 0 ) + alpha01 * U ( 1 ) U12 = ( 1.0 - alpha12 ) * U ( 1 ) + alpha12 * U ( 2 ) U10 = ( 1.0 - alpha10 ) * U ( - 1 ) + alpha10 * U ( 0 ) U21 = ( 1.0 - alpha21 ) * U ( - 2 ) + alpha21 * U ( - 1 ) U00 = U ( - 1 ) + ( 1.0 - alpha21 ) * ( U ( - 1 ) - U ( - 2 )) U11 = U ( 1 ) + alpha12 * ( U ( 1 ) - U ( 2 )) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U10 - 2.0 * U00 ) / 3.0 P ( 2 ) = ( - 1.0 * U10 + 2.0 * U ( 0 ) + 2.0 * U01 ) / 3.0 P ( 3 ) = ( 2.0 * U01 + 2.0 * U ( 1 ) - 1.0 * U12 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 2.0 * U00 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U10 - 2.0 * U00 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( 0 ) + 2 * U01 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u10 + 2.0 * U01 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 1 ) + 2 * U12 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U01 + 8.0 * U ( 1 ) - 2.0 * U12 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = SUM ( w * P ) / SUM ( w ) P ( 1 ) = ( 6.0 * U ( 0 ) - 1.0 * U01 - 2.0 * U11 ) / 3.0 P ( 2 ) = ( - 1.0 * U01 + 2.0 * U ( 0 ) + 2.0 * U10 ) / 3.0 P ( 3 ) = ( 2.0 * U10 + 2.0 * U ( - 1 ) - 1.0 * U21 ) / 3.0 B ( 1 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 2.0 * U11 ) ** 2 + ( 1.0 / 4.0 ) * ( 4 * U ( 0 ) - 2.0 * U01 - 2.0 * U11 ) ** 2 B ( 2 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U01 - 4.0 * U ( 0 ) + 2 * U10 ) ** 2 + ( 1.0 / 4.0 ) * ( - 2 * u01 + 2.0 * U10 ) ** 2 B ( 3 ) = ( 1 3.0 / 1 2.0 ) * ( 2 * U10 - 4.0 * U ( - 1 ) + 2 * U21 ) ** 2 + ( 1.0 / 4.0 ) * ( - 6 * U10 + 8.0 * U ( - 1 ) - 2.0 * U21 ) ** 2 w (:) = g (:) / ( eps + B (:)) ** 2 f_qp_right ( i , j , k , l ) = SUM ( w * P ) / SUM ( w ) end do end do end do end do end subroutine compute_face_states","tags":"","loc":"proc/compute_face_states~2.html","title":"compute_face_states – FEST-3D"},{"text":"public subroutine compute_weno_NM_states() Call Weno scheme for all the three direction I,J, and K Arguments None Calls proc~~compute_weno_nm_states~~CallsGraph proc~compute_weno_nm_states compute_weno_NM_states proc~compute_face_states~2 compute_face_states proc~compute_weno_nm_states->proc~compute_face_states~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_weno_NM_states Source Code subroutine compute_weno_NM_states () !< Call Weno scheme for all the three direction I,J, and K call compute_face_states ( 'x' ) call compute_face_states ( 'y' ) call compute_face_states ( 'z' ) end subroutine compute_weno_NM_states","tags":"","loc":"proc/compute_weno_nm_states.html","title":"compute_weno_NM_states – FEST-3D"},{"text":"public subroutine setup_scheme() Allocate memoery to all array which store state\n the face. Arguments None Calls proc~~setup_scheme~10~~CallsGraph proc~setup_scheme~10 setup_scheme interface~alloc alloc proc~setup_scheme~10->interface~alloc proc~dmsg dmsg proc~setup_scheme~10->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_scheme Source Code subroutine setup_scheme () !< Allocate memoery to all array which store state !< the face. implicit none call dmsg ( 1 , 'ppm' , 'setup_ppm' ) call alloc ( x_qp_face_estimate , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_face_estimate.' ) call alloc ( y_qp_face_estimate , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_face_estimate.' ) call alloc ( z_qp_face_estimate , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_face_estimate.' ) call alloc ( x_qp_left , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_left.' ) call alloc ( x_qp_right , 0 , imx + 1 , 1 , jmx - 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'x_qp_right.' ) call alloc ( y_qp_left , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_left.' ) call alloc ( y_qp_right , 1 , imx - 1 , 0 , jmx + 1 , 1 , kmx - 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'y_qp_right.' ) call alloc ( z_qp_left , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_left.' ) call alloc ( z_qp_right , 1 , imx - 1 , 1 , jmx - 1 , 0 , kmx + 1 , 1 , n_var , & errmsg = 'Error: Unable to allocate memory for ' // & 'z_qp_right.' ) call alloc ( pdif , 0 , imx , 0 , jmx , 0 , kmx , & errmsg = 'Error: Unable to allocate memory for' // & 'pdif' ) end subroutine setup_scheme","tags":"","loc":"proc/setup_scheme~10.html","title":"setup_scheme – FEST-3D"},{"text":"public subroutine destroy_scheme() Deallocate all the array used Arguments None Calls proc~~destroy_scheme~10~~CallsGraph proc~destroy_scheme~10 destroy_scheme interface~dealloc dealloc proc~destroy_scheme~10->interface~dealloc proc~dmsg dmsg proc~destroy_scheme~10->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_scheme Source Code subroutine destroy_scheme () !< Deallocate all the array used implicit none call dmsg ( 1 , 'ppm' , 'destroy_ppm' ) call dealloc ( x_qp_face_estimate ) call dealloc ( y_qp_face_estimate ) call dealloc ( z_qp_face_estimate ) call dealloc ( x_qp_left ) call dealloc ( x_qp_right ) call dealloc ( y_qp_left ) call dealloc ( y_qp_right ) call dealloc ( z_qp_left ) call dealloc ( z_qp_right ) call dealloc ( pdif ) end subroutine destroy_scheme","tags":"","loc":"proc/destroy_scheme~10.html","title":"destroy_scheme – FEST-3D"},{"text":"private subroutine compute_face_estimates(f_dir) Subroutine to calculate state at the face, generalized for Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Calls proc~~compute_face_estimates~~CallsGraph proc~compute_face_estimates compute_face_estimates proc~dmsg dmsg proc~compute_face_estimates->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~compute_face_estimates~~CalledByGraph proc~compute_face_estimates compute_face_estimates proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~compute_face_estimates Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_face_estimates Source Code subroutine compute_face_estimates ( f_dir ) !< Subroutine to calculate state at the face, generalized for implicit none character , intent ( in ) :: f_dir integer :: i , j , k integer :: i_f , j_f , k_f ! Flags to determine face direction real , dimension (:, :, :, :), pointer :: f_qp_estimate call dmsg ( 1 , 'ppm' , 'compute_face_estimates' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_estimate => x_qp_face_estimate case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_estimate => y_qp_face_estimate case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_estimate => z_qp_face_estimate case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select !TODO: Vectorize this?? ! Interior faces do k = ( 1 - k_f ), kmx - 1 + 2 * k_f do j = ( 1 - j_f ), jmx - 1 + 2 * j_f do i = ( 1 - i_f ), imx - 1 + 2 * i_f f_qp_estimate ( i , j , k , :) = ( 7. * ( qp ( i , j , k , :) + & qp ( i - i_f , j - j_f , k - k_f , :)) - ( qp ( i + i_f , j + j_f , k + k_f , :) + & qp ( i - 2 * i_f , j - 2 * j_f , k - 2 * k_f , :))) / 1 2. end do end do end do end subroutine compute_face_estimates","tags":"","loc":"proc/compute_face_estimates.html","title":"compute_face_estimates – FEST-3D"},{"text":"private subroutine remove_extrema(f_dir) Remove extrema from the state estimated. \n Limiting the value in case of PPM Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Calls proc~~remove_extrema~~CallsGraph proc~remove_extrema remove_extrema proc~dmsg dmsg proc~remove_extrema->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~remove_extrema~~CalledByGraph proc~remove_extrema remove_extrema proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~remove_extrema Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code remove_extrema Source Code subroutine remove_extrema ( f_dir ) !< Remove extrema from the state estimated. !< Limiting the value in case of PPM implicit none character , intent ( in ) :: f_dir integer :: i , j , k , l integer :: i_f , j_f , k_f ! Flags to determine face direction real :: dqrl , dq6 call dmsg ( 1 , 'ppm' , 'remove_extrema' ) select case ( f_dir ) case ( 'x' ) i_f = 1 j_f = 0 k_f = 0 f_qp_left => x_qp_left f_qp_right => x_qp_right case ( 'y' ) i_f = 0 j_f = 1 k_f = 0 f_qp_left => y_qp_left f_qp_right => y_qp_right case ( 'z' ) i_f = 0 j_f = 0 k_f = 1 f_qp_left => z_qp_left f_qp_right => z_qp_right case default call dmsg ( 5 , 'ppm' , 'remove_extrema' , & 'Direction not recognised' ) stop end select !TODO: Vectorize this? Or will it be ugly? ! Loop over cells (including ghost cells) do l = 1 , n_var do k = 1 - k_f , kmx - 1 + k_f do j = 1 - j_f , jmx - 1 + j_f do i = 1 - i_f , imx - 1 + i_f if (( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - qp ( i , j , k , l )) * & ( qp ( i , j , k , l ) - f_qp_right ( i , j , k , l )) <= 0 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = qp ( i , j , k , l ) f_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) else dqrl = f_qp_left ( i + i_f , j + j_f , k + k_f , l ) - f_qp_right ( i , j , k , l ) dq6 = 6. * ( qp ( i , j , k , l ) - 0.5 * ( f_qp_left ( i + i_f , j + j_f , k + k_f , l ) + & f_qp_right ( i , j , k , l ))) if ( dqrl * dq6 > dqrl * dqrl ) then f_qp_right ( i , j , k , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_left ( i + i_f , j + j_f , k + k_f , l ) else if ( - dqrl * dqrl > dqrl * dq6 ) then f_qp_left ( i + i_f , j + j_f , k + k_f , l ) = 3. * qp ( i , j , k , l ) - & 2. * f_qp_right ( i , j , k , l ) end if end if end do end do end do end do end subroutine remove_extrema","tags":"","loc":"proc/remove_extrema.html","title":"remove_extrema – FEST-3D"},{"text":"private subroutine pressure_based_switching(f_dir) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Calls proc~~pressure_based_switching~2~~CallsGraph proc~pressure_based_switching~2 pressure_based_switching proc~dmsg dmsg proc~pressure_based_switching~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pressure_based_switching~2~~CalledByGraph proc~pressure_based_switching~2 pressure_based_switching proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~pressure_based_switching~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pressure_based_switching Source Code subroutine pressure_based_switching ( f_dir ) !< Pressure based switching. !< User x,y, or z for I,J,or K face respectively !---------------------------------------------- implicit none ! Character can be x or y or z character , intent ( in ) :: f_dir integer :: i , j , k , i_end , j_end , k_end integer :: i_f , j_f , k_f ! Flags to determine face direction real :: pd2 call dmsg ( 1 , 'ppm' , 'pressure_based_switching' ) select case ( f_dir ) case ( 'x' ) f_qp_left => x_qp_left f_qp_right => x_qp_right i_f = 1 j_f = 0 k_f = 0 i_end = imx j_end = jmx - 1 k_end = kmx - 1 case ( 'y' ) f_qp_left => y_qp_left f_qp_right => y_qp_right i_f = 0 j_f = 1 k_f = 0 i_end = imx - 1 j_end = jmx k_end = kmx - 1 case ( 'z' ) f_qp_left => z_qp_left f_qp_right => z_qp_right i_f = 0 j_f = 0 k_f = 1 i_end = imx - 1 j_end = jmx - 1 k_end = kmx case default call dmsg ( 5 , 'ppm' , 'pressure_based_switching' , & 'Direction not recognised' ) stop end select ! i_end and j_end denote number of faces ! Total number of cells including ghost_cells is ! (i_end+1) * j_end for xi faces and i_end*(j_end+1) for ! eta faces. ! Loop over cells (physical) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 pd2 = abs ( pressure ( i + i_f * 1 , j + j_f * 1 , k + k_f * 1 ) - & pressure ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 )) pdif ( i , j , k ) = 1 - ( pd2 / ( pd2 + pressure_inf )) end do end do end do ! Update at ghost cells pdif (( 1 - i_f ):( 1 - i_f ) * ( imx - 1 ), ( 1 - j_f ):( 1 - j_f ) * ( jmx - 1 ), & ( 1 - k_f ):( 1 - k_f ) * ( kmx - 1 )) = & pdif ( 1 : imx - 1 - i_f * ( imx - 2 ), 1 : jmx - 1 - j_f * ( jmx - 2 ), & 1 : kmx - 1 - k_f * ( kmx - 2 )) pdif ((( imx - 1 ) * i_f ) + 1 : imx - 1 + i_f , & (( jmx - 1 ) * j_f ) + 1 : jmx - 1 + j_f , & (( kmx - 1 ) * k_f ) + 1 : kmx - 1 + k_f ) & = & pdif ( i_f * ( imx - 2 ) + 1 : imx - 1 , & j_f * ( jmx - 2 ) + 1 : jmx - 1 , & k_f * ( kmx - 2 ) + 1 : kmx - 1 ) ! Loop over faces do k = 1 , kmx - ( 1 - k_f ) do j = 1 , jmx - ( 1 - j_f ) do i = 1 , imx - ( 1 - i_f ) f_qp_left ( i , j , k , :) = qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :) + (& pdif ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 ) * ( & f_qp_left ( i , j , k , :) - qp ( i - i_f * 1 , j - j_f * 1 , k - k_f * 1 , :))) f_qp_right ( i , j , k , :) = qp ( i , j , k , :) - (& pdif ( i , j , k ) * ( & qp ( i , j , k , :) - f_qp_right ( i , j , k , :))) end do end do end do end subroutine pressure_based_switching","tags":"","loc":"proc/pressure_based_switching~2.html","title":"pressure_based_switching – FEST-3D"},{"text":"private subroutine init_left_and_right_xi_estimates() Initialize the left and right state at I direction face Arguments None Called by proc~~init_left_and_right_xi_estimates~~CalledByGraph proc~init_left_and_right_xi_estimates init_left_and_right_xi_estimates proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~init_left_and_right_xi_estimates Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_left_and_right_xi_estimates Source Code subroutine init_left_and_right_xi_estimates () !< Initialize the left and right state at I direction face implicit none ! x_qp_left and x_qp_right are stored at faces. x_qp_left = x_qp_face_estimate x_qp_right = x_qp_face_estimate end subroutine init_left_and_right_xi_estimates","tags":"","loc":"proc/init_left_and_right_xi_estimates.html","title":"init_left_and_right_xi_estimates – FEST-3D"},{"text":"private subroutine init_left_and_right_eta_estimates() Initialize the left and right state at J direction face Arguments None Called by proc~~init_left_and_right_eta_estimates~~CalledByGraph proc~init_left_and_right_eta_estimates init_left_and_right_eta_estimates proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~init_left_and_right_eta_estimates Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_left_and_right_eta_estimates Source Code subroutine init_left_and_right_eta_estimates () !< Initialize the left and right state at J direction face implicit none ! y_qp_left and y_qp_right are stored at faces. y_qp_left = y_qp_face_estimate y_qp_right = y_qp_face_estimate end subroutine init_left_and_right_eta_estimates","tags":"","loc":"proc/init_left_and_right_eta_estimates.html","title":"init_left_and_right_eta_estimates – FEST-3D"},{"text":"private subroutine init_left_and_right_zeta_estimates() Initialize the left and right state at K direction face Arguments None Called by proc~~init_left_and_right_zeta_estimates~~CalledByGraph proc~init_left_and_right_zeta_estimates init_left_and_right_zeta_estimates proc~compute_ppm_states compute_ppm_states proc~compute_ppm_states->proc~init_left_and_right_zeta_estimates Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_left_and_right_zeta_estimates Source Code subroutine init_left_and_right_zeta_estimates () !< Initialize the left and right state at K direction face implicit none ! y_qp_left and y_qp_right are stored at faces. z_qp_left = z_qp_face_estimate z_qp_right = z_qp_face_estimate end subroutine init_left_and_right_zeta_estimates","tags":"","loc":"proc/init_left_and_right_zeta_estimates.html","title":"init_left_and_right_zeta_estimates – FEST-3D"},{"text":"public subroutine compute_ppm_states() Call PPM face-state reconstruction for each face\n with optional call for remove extrema based on\n input limter switch and call pressure based switching\n based on input pressure based switch Arguments None Calls proc~~compute_ppm_states~~CallsGraph proc~compute_ppm_states compute_ppm_states proc~init_left_and_right_eta_estimates init_left_and_right_eta_estimates proc~compute_ppm_states->proc~init_left_and_right_eta_estimates proc~pressure_based_switching~2 pressure_based_switching proc~compute_ppm_states->proc~pressure_based_switching~2 proc~remove_extrema remove_extrema proc~compute_ppm_states->proc~remove_extrema proc~compute_face_estimates compute_face_estimates proc~compute_ppm_states->proc~compute_face_estimates proc~init_left_and_right_zeta_estimates init_left_and_right_zeta_estimates proc~compute_ppm_states->proc~init_left_and_right_zeta_estimates proc~init_left_and_right_xi_estimates init_left_and_right_xi_estimates proc~compute_ppm_states->proc~init_left_and_right_xi_estimates proc~dmsg dmsg proc~pressure_based_switching~2->proc~dmsg proc~remove_extrema->proc~dmsg proc~compute_face_estimates->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code compute_ppm_states Source Code subroutine compute_ppm_states () !< Call PPM face-state reconstruction for each face !< with optional call for remove extrema based on !< input limter switch and call pressure based switching !< based on input pressure based switch implicit none call compute_face_estimates ( 'x' ) call init_left_and_right_xi_estimates () if ( ilimiter_switch == 1 ) then call remove_extrema ( 'x' ) end if if ( iPB_switch == 1 ) then call pressure_based_switching ( 'x' ) end if call compute_face_estimates ( 'y' ) call init_left_and_right_eta_estimates () if ( jlimiter_switch == 1 ) then call remove_extrema ( 'y' ) end if if ( jPB_switch == 1 ) then call pressure_based_switching ( 'y' ) end if call compute_face_estimates ( 'z' ) call init_left_and_right_zeta_estimates () if ( klimiter_switch == 1 ) then call remove_extrema ( 'z' ) end if if ( kPB_switch == 1 ) then call pressure_based_switching ( 'z' ) end if end subroutine compute_ppm_states","tags":"","loc":"proc/compute_ppm_states.html","title":"compute_ppm_states – FEST-3D"},{"text":"public subroutine setup_bc() Initialization and allocate memory of boundary condition variables Arguments None Calls proc~~setup_bc~~CallsGraph proc~setup_bc setup_bc proc~read_fixed_values read_fixed_values proc~setup_bc->proc~read_fixed_values interface~alloc alloc proc~setup_bc->interface~alloc proc~get_fixed_values get_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~fill_fixed_values fill_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~set_value set_value proc~get_fixed_values->proc~set_value proc~fill_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_bc~~CalledByGraph proc~setup_bc setup_bc proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~setup_all setup_all proc~setup_all->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_bc Source Code subroutine setup_bc () !< Initialization and allocate memory of boundary condition variables implicit none !check for periodic bc if ( PbcId ( 1 ) >= 0 ) imin_id =- 10 if ( PbcId ( 2 ) >= 0 ) imax_id =- 10 if ( PbcId ( 3 ) >= 0 ) jmin_id =- 10 if ( PbcId ( 4 ) >= 0 ) jmax_id =- 10 if ( PbcId ( 5 ) >= 0 ) kmin_id =- 10 if ( PbcId ( 6 ) >= 0 ) kmax_id =- 10 ! assign name to each face face_names ( 1 ) = \"imin\" face_names ( 2 ) = \"imax\" face_names ( 3 ) = \"jmin\" face_names ( 4 ) = \"jmax\" face_names ( 5 ) = \"kmin\" face_names ( 6 ) = \"kmax\" id ( 1 ) = imin_id id ( 2 ) = imax_id id ( 3 ) = jmin_id id ( 4 ) = jmax_id id ( 5 ) = kmin_id id ( 6 ) = kmax_id c2 = 1 + accur c3 = 0.5 * accur c1 = c2 - c3 call read_fixed_values () call alloc ( make_F_flux_zero , 1 , imx ) call alloc ( make_G_flux_zero , 1 , jmx ) call alloc ( make_H_flux_zero , 1 , kmx ) make_F_flux_zero = 1 make_G_flux_zero = 1 make_H_flux_zero = 1 if ( imin_id ==- 5 . or . imin_id ==- 6 . or . imin_id ==- 7 ) make_F_flux_zero ( 1 ) = 0 if ( jmin_id ==- 5 . or . jmin_id ==- 6 . or . jmin_id ==- 7 ) make_G_flux_zero ( 1 ) = 0 if ( kmin_id ==- 5 . or . kmin_id ==- 6 . or . kmin_id ==- 7 ) make_H_flux_zero ( 1 ) = 0 if ( imax_id ==- 5 . or . imax_id ==- 6 . or . imax_id ==- 7 ) make_F_flux_zero ( imx ) = 0 if ( jmax_id ==- 5 . or . jmax_id ==- 6 . or . jmax_id ==- 7 ) make_G_flux_zero ( jmx ) = 0 if ( kmax_id ==- 5 . or . kmax_id ==- 6 . or . kmax_id ==- 7 ) make_H_flux_zero ( kmx ) = 0 end subroutine setup_bc","tags":"","loc":"proc/setup_bc.html","title":"setup_bc – FEST-3D"},{"text":"public subroutine destroy_bc() Deallocate memory from boundary condition variables Arguments None Calls proc~~destroy_bc~~CallsGraph proc~destroy_bc destroy_bc interface~dealloc dealloc proc~destroy_bc->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_bc~~CalledByGraph proc~destroy_bc destroy_bc proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_bc proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_bc Source Code subroutine destroy_bc () !< Deallocate memory from boundary condition variables implicit none call dealloc ( make_F_flux_zero ) call dealloc ( make_G_flux_zero ) call dealloc ( make_H_flux_zero ) end subroutine destroy_bc","tags":"","loc":"proc/destroy_bc.html","title":"destroy_bc – FEST-3D"},{"text":"public subroutine copy1(var, type, face) Copy 1 layer of interior cell to first ghost cell layer Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called Contents Source Code copy1 Source Code subroutine copy1 ( var , type , face ) !< Copy 1 layer of interior cell to first ghost cell layer implicit none character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real :: a2 = 1 select case ( type ) case ( \"anti\" ) a2 = - 1 case ( \"symm\" ) a2 = 1 case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = a2 * var ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , 1 , 1 : kmx - 1 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = a2 * var ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , 1 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 ) case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy1","tags":"","loc":"proc/copy1.html","title":"copy1 – FEST-3D"},{"text":"public subroutine copy3(var, type, face) Copy 3 layer of interior cell to three ghost cell layer Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called Called by proc~~copy3~~CalledByGraph proc~copy3 copy3 proc~subsonic_inlet subsonic_inlet proc~subsonic_inlet->proc~copy3 proc~wall wall proc~wall->proc~copy3 proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~no_slip no_slip proc~wall->proc~no_slip proc~total_pressure total_pressure proc~total_pressure->proc~copy3 proc~subsonic_outlet subsonic_outlet proc~subsonic_outlet->proc~copy3 proc~temp_based_density->proc~copy3 proc~supersonic_outlet supersonic_outlet proc~supersonic_outlet->proc~copy3 proc~no_slip->proc~copy3 proc~pole pole proc~pole->proc~copy3 proc~far_field far_field proc~far_field->proc~copy3 proc~slip_wall slip_wall proc~slip_wall->proc~copy3 proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_inlet proc~populate_ghost_primitive->proc~wall proc~populate_ghost_primitive->proc~total_pressure proc~populate_ghost_primitive->proc~subsonic_outlet proc~populate_ghost_primitive->proc~supersonic_outlet proc~populate_ghost_primitive->proc~pole proc~populate_ghost_primitive->proc~far_field proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccopy3CalledByGraph = svgPanZoom('#proccopy3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code copy3 Source Code subroutine copy3 ( var , type , face ) !< Copy 3 layer of interior cell to three ghost cell layer implicit none character ( len =* ), intent ( in ) :: face !< Face over which boundary condition is being called character ( len =* ), intent ( in ) :: type !< Type of copy: flat, symmetry, anti-symmetry real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ), intent ( inout ) :: var !< Varible over which these operation has to be performed real :: a1 = 1 real :: a2 = 1 real :: a3 = 0 integer :: i1 = 1 integer :: i2 = 2 integer :: i3 = 3 select case ( type ) case ( \"anti\" ) a1 = 1. ; i1 = 1 a2 = - 1. ; i2 = 2 a3 = 0. ; i3 = 3 case ( \"flat\" ) a1 = 1. ; i1 = 1 a2 = 1. ; i2 = 1 a3 = 0. ; i3 = 1 case ( \"symm\" ) a1 = c1 ; i1 = 1 a2 = c2 ; i2 = 2 a3 = c3 ; i3 = 3 ! do nothing ! use default value continue case DEFAULT print * , \"ERROR: Wrong boundary condition type\" end select select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i1 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i2 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( i3 + 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i1 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i1 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i2 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i2 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = ( a2 * var ( imx - i3 , 1 : jmx - 1 , 1 : kmx - 1 ) - a3 * var ( imx - i3 - 1 , 1 : jmx - 1 , 1 : kmx - 1 )) / a1 case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i1 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i2 + 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , i3 + 1 , 1 : kmx - 1 )) / a1 case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i1 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i1 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i2 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i2 - 1 , 1 : kmx - 1 )) / a1 var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = ( a2 * var ( 1 : imx - 1 , jmx - i3 , 1 : kmx - 1 ) - a3 * var ( 1 : imx - 1 , jmx - i3 - 1 , 1 : kmx - 1 )) / a1 case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i1 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i2 + 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , i3 + 1 )) / a1 case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i1 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i2 - 1 )) / a1 var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = ( a2 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 ) - a3 * var ( 1 : imx - 1 , 1 : jmx - 1 , kmx - i3 - 1 )) / a1 case DEFAULT print * , \"ERROR: wrong face for boundary condition\" end select end subroutine copy3","tags":"","loc":"proc/copy3.html","title":"copy3 – FEST-3D"},{"text":"public subroutine populate_ghost_primitive() Populate the state variables in the ghost cell\n with particular value based on the boundary conditio \n being applied at that face Arguments None Calls proc~~populate_ghost_primitive~~CallsGraph proc~populate_ghost_primitive populate_ghost_primitive proc~subsonic_inlet subsonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~wall wall proc~populate_ghost_primitive->proc~wall proc~total_pressure total_pressure proc~populate_ghost_primitive->proc~total_pressure proc~slip_wall slip_wall proc~populate_ghost_primitive->proc~slip_wall proc~supersonic_inlet supersonic_inlet proc~populate_ghost_primitive->proc~supersonic_inlet proc~supersonic_outlet supersonic_outlet proc~populate_ghost_primitive->proc~supersonic_outlet proc~subsonic_outlet subsonic_outlet proc~populate_ghost_primitive->proc~subsonic_outlet proc~pole pole proc~populate_ghost_primitive->proc~pole proc~far_field far_field proc~populate_ghost_primitive->proc~far_field proc~periodic_bc periodic_bc proc~populate_ghost_primitive->proc~periodic_bc proc~check_if_value_fixed check_if_value_fixed proc~subsonic_inlet->proc~check_if_value_fixed proc~copy3 copy3 proc~subsonic_inlet->proc~copy3 proc~fix fix proc~subsonic_inlet->proc~fix proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~wall->proc~copy3 proc~no_slip no_slip proc~wall->proc~no_slip proc~total_pressure->proc~check_if_value_fixed proc~total_pressure->proc~copy3 proc~total_pressure->proc~fix proc~slip_wall->proc~copy3 proc~flow_tangency flow_tangency proc~slip_wall->proc~flow_tangency proc~supersonic_inlet->proc~check_if_value_fixed proc~supersonic_inlet->proc~fix proc~supersonic_outlet->proc~copy3 proc~subsonic_outlet->proc~copy3 proc~subsonic_outlet->proc~fix proc~turbulence_read_error turbulence_read_error proc~pole->proc~turbulence_read_error proc~pole->proc~copy3 proc~far_field->proc~check_if_value_fixed proc~far_field->proc~copy3 proc~far_field->proc~fix proc~temp_based_density->proc~copy3 proc~no_slip->proc~copy3 proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~populate_ghost_primitive~~CalledByGraph proc~populate_ghost_primitive populate_ghost_primitive proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpopulate_ghost_primitiveCalledByGraph = svgPanZoom('#procpopulate_ghost_primitiveCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code populate_ghost_primitive Source Code subroutine populate_ghost_primitive () !< Populate the state variables in the ghost cell !< with particular value based on the boundary conditio !< being applied at that face implicit none integer :: i character ( len = 4 ) :: face do i = 1 , 6 face_num = i face = face_names ( face_num ) select case ( id ( face_num )) case ( - 1 ) call supersonic_inlet ( face ) case ( - 2 ) call supersonic_outlet ( face ) case ( - 3 ) call subsonic_inlet ( face ) case ( - 4 ) call subsonic_outlet ( face ) case ( - 5 ) call wall ( face ) case ( - 6 ) call slip_wall ( face ) case ( - 7 ) call pole ( face ) case ( - 8 ) call far_field ( face ) case ( - 9 ) call periodic_bc ( face ) case ( - 11 ) call total_pressure ( face ) case Default if ( id ( i ) >= 0 . or . id ( i ) ==- 10 ) then continue !interface boundary else print * , \" boundary condition not recognised -> id is :\" , id ( i ) end if end select end do !        qp(0,0,:,:) = 0.5*(qp(0,1,:,:)+qp(1,0,:,:)) !        qp(0,jmx,:,:) = 0.5*(qp(0,jmx-1,:,:)+qp(1,jmx,:,:)) !        qp(imx,0,:,:) = 0.5*(qp(imx,1,:,:)+qp(imx-1,0,:,:)) !        qp(imx,jmx,:,:) = 0.5*(qp(imx,jmx-1,:,:)+qp(imx-1,jmx,:,:)) !        qp(0,:,0,:) = 0.5*(qp(0,:,1,:)+qp(1,:,0,:)) !        qp(0,:,kmx,:) = 0.5*(qp(0,:,kmx-1,:)+qp(1,:,kmx,:)) !        qp(imx,:,0,:) = 0.5*(qp(imx,:,1,:)+qp(imx-1,:,0,:)) !        qp(imx,:,kmx,:) = 0.5*(qp(imx,:,jmx-1,:)+qp(imx-1,:,jmx,:)) qp (:, 0 , 0 ,:) = 0.33 * ( qp (:, 1 , 1 ,:) + qp (:, 0 , 1 ,:) + qp (:, 1 , 0 ,:)) qp (:, 0 , kmx ,:) = 0.33 * ( qp (:, 1 , kmx - 1 ,:) + qp (:, 0 , kmx - 1 ,:) + qp (:, 1 , kmx ,:)) qp (:, jmx , 0 ,:) = 0.33 * ( qp (:, jmx - 1 , 1 ,:) + qp (:, jmx , 1 ,:) + qp (:, jmx - 1 , 0 ,:)) qp (:, jmx , kmx ,:) = 0.33 * ( qp (:, jmx - 1 , kmx - 1 ,:) + qp (:, jmx , kmx - 1 ,:) + qp (:, jmx - 1 , kmx ,:)) qp ( imx , 0 ,:,:) = 0.33 * ( qp ( imx - 1 , 1 ,:,:) + qp ( imx - 1 , 0 ,:,:) + qp ( imx , 1 ,:,:)) qp ( 0 , 0 ,:,:) = 0.33 * ( qp ( 1 , 1 ,:,:) + qp ( 1 , 0 ,:,:) + qp ( 0 , 1 ,:,:)) qp ( 0 , jmx ,:,:) = 0.33 * ( qp ( 1 , jmx - 1 ,:,:) + qp ( 1 , jmx ,:,:) + qp ( 0 , jmx - 1 ,:,:)) qp ( imx , jmx ,:,:) = 0.33 * ( qp ( imx - 1 , jmx - 1 ,:,:) + qp ( imx - 1 , jmx ,:,:) + qp ( imx , jmx - 1 ,:,:)) qp ( 0 , 0 , 0 ,:) = 0.33 * ( qp ( 1 , 0 , 0 ,:) + qp ( 0 , 1 , 0 ,:) + qp ( 0 , 0 , 1 ,:)) qp ( imx , 0 , 0 ,:) = 0.33 * ( qp ( imx - 1 , 0 , 0 ,:) + qp ( imx , 1 , 0 ,:) + qp ( imx , 0 , 1 ,:)) qp ( 0 , jmx , 0 ,:) = 0.33 * ( qp ( 1 , jmx , 0 ,:) + qp ( 0 , jmx - 1 , 0 ,:) + qp ( 0 , jmx , 1 ,:)) qp ( 0 , 0 , kmx ,:) = 0.33 * ( qp ( 1 , 0 , kmx ,:) + qp ( 0 , 1 , kmx ,:) + qp ( 0 , 0 , kmx - 1 ,:)) qp ( imx , jmx , 0 ,:) = 0.33 * ( qp ( imx - 1 , jmx , 0 ,:) + qp ( imx , jmx - 1 , 0 ,:) + qp ( imx , jmx , 1 ,:)) qp ( imx , 0 , kmx ,:) = 0.33 * ( qp ( imx - 1 , 0 , kmx ,:) + qp ( imx , 1 , kmx ,:) + qp ( imx , 0 , kmx - 1 ,:)) qp ( 0 , jmx , kmx ,:) = 0.33 * ( qp ( 1 , jmx , kmx ,:) + qp ( 0 , jmx - 1 , kmx ,:) + qp ( 0 , jmx , kmx - 1 ,:)) qp ( imx , jmx , kmx ,:) = 0.33 * ( qp ( imx - 1 , jmx , kmx ,:) + qp ( imx , jmx - 1 , kmx ,:) + qp ( imx , jmx , kmx - 1 ,:)) end subroutine populate_ghost_primitive","tags":"","loc":"proc/populate_ghost_primitive.html","title":"populate_ghost_primitive – FEST-3D"},{"text":"private subroutine supersonic_inlet(face) Supersonic inlet boundary condition\n All the values of state variables are fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~supersonic_inlet~~CallsGraph proc~supersonic_inlet supersonic_inlet proc~check_if_value_fixed check_if_value_fixed proc~supersonic_inlet->proc~check_if_value_fixed proc~fix fix proc~supersonic_inlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~supersonic_inlet~~CalledByGraph proc~supersonic_inlet supersonic_inlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~supersonic_inlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsupersonic_inletCalledByGraph = svgPanZoom('#procsupersonic_inletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code supersonic_inlet Source Code subroutine supersonic_inlet ( face ) !< Supersonic inlet boundary condition !< All the values of state variables are fixed implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , fixed_density , face ) call fix ( x_speed , fixed_x_speed , face ) call fix ( y_speed , fixed_y_speed , face ) call fix ( z_speed , fixed_z_speed , face ) call fix ( pressure , fixed_pressure , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if end subroutine supersonic_inlet","tags":"","loc":"proc/supersonic_inlet.html","title":"supersonic_inlet – FEST-3D"},{"text":"private subroutine supersonic_outlet(face) Supersonic outlet boundary condition. \n All the values of state variables are copied \n from inside the domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~supersonic_outlet~~CallsGraph proc~supersonic_outlet supersonic_outlet proc~copy3 copy3 proc~supersonic_outlet->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~supersonic_outlet~~CalledByGraph proc~supersonic_outlet supersonic_outlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~supersonic_outlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsupersonic_outletCalledByGraph = svgPanZoom('#procsupersonic_outletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code supersonic_outlet Source Code subroutine supersonic_outlet ( face ) !< Supersonic outlet boundary condition. !< All the values of state variables are copied !< from inside the domain implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) call copy3 ( pressure , \"flat\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine supersonic_outlet","tags":"","loc":"proc/supersonic_outlet.html","title":"supersonic_outlet – FEST-3D"},{"text":"private subroutine subsonic_inlet(face) Subsonic inlet boundary condition. \n All the state variables's value expect pressure\n is fixed and pressure is copied from inside the \n domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~subsonic_inlet~~CallsGraph proc~subsonic_inlet subsonic_inlet proc~check_if_value_fixed check_if_value_fixed proc~subsonic_inlet->proc~check_if_value_fixed proc~copy3 copy3 proc~subsonic_inlet->proc~copy3 proc~fix fix proc~subsonic_inlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subsonic_inlet~~CalledByGraph proc~subsonic_inlet subsonic_inlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_inlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsubsonic_inletCalledByGraph = svgPanZoom('#procsubsonic_inletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subsonic_inlet Source Code subroutine subsonic_inlet ( face ) !< Subsonic inlet boundary condition. !< All the state variables's value expect pressure !< is fixed and pressure is copied from inside the !< domain implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called if ( current_iter <= 2 ) then call fix ( density , fixed_density , face ) call fix ( x_speed , fixed_x_speed , face ) call fix ( y_speed , fixed_y_speed , face ) call fix ( z_speed , fixed_z_speed , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tw , face ) case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if call copy3 ( pressure , \"flat\" , face ) end subroutine subsonic_inlet","tags":"","loc":"proc/subsonic_inlet.html","title":"subsonic_inlet – FEST-3D"},{"text":"private subroutine subsonic_outlet(face) Subsonic outlet boundary condition. \n All the state variables's value expect pressure\n is copied from the inside of the domain and pressure \n is fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~subsonic_outlet~~CallsGraph proc~subsonic_outlet subsonic_outlet proc~copy3 copy3 proc~subsonic_outlet->proc~copy3 proc~fix fix proc~subsonic_outlet->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~subsonic_outlet~~CalledByGraph proc~subsonic_outlet subsonic_outlet proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_outlet proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocsubsonic_outletCalledByGraph = svgPanZoom('#procsubsonic_outletCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code subsonic_outlet Source Code subroutine subsonic_outlet ( face ) !< Subsonic outlet boundary condition. !< All the state variables's value expect pressure !< is copied from the inside of the domain and pressure !< is fixed implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) if ( current_iter <= 2 ) then call fix ( pressure , fixed_pressure , face ) end if select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine subsonic_outlet","tags":"","loc":"proc/subsonic_outlet.html","title":"subsonic_outlet – FEST-3D"},{"text":"private subroutine wall(face) Adiabatic/Isothermal wall boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~wall~~CallsGraph proc~wall wall proc~no_slip no_slip proc~wall->proc~no_slip proc~temp_based_density temp_based_density proc~wall->proc~temp_based_density proc~copy3 copy3 proc~wall->proc~copy3 proc~no_slip->proc~copy3 proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall proc~temp_based_density->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~wall~~CalledByGraph proc~wall wall proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocwallCalledByGraph = svgPanZoom('#procwallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code wall Source Code subroutine wall ( face ) !< Adiabatic/Isothermal wall boundary condition implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( pressure , \"symm\" , face ) call temp_based_density ( fixed_wall_temperature , face ) call no_slip ( face ) end subroutine wall","tags":"","loc":"proc/wall.html","title":"wall – FEST-3D"},{"text":"private subroutine slip_wall(face) Slip wall boundary condition. \n Maintain flow tangency Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~slip_wall~~CallsGraph proc~slip_wall slip_wall proc~copy3 copy3 proc~slip_wall->proc~copy3 proc~flow_tangency flow_tangency proc~slip_wall->proc~flow_tangency Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~slip_wall~~CalledByGraph proc~slip_wall slip_wall proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocslip_wallCalledByGraph = svgPanZoom('#procslip_wallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code slip_wall Source Code subroutine slip_wall ( face ) !< Slip wall boundary condition. !< Maintain flow tangency implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"symm\" , face ) call copy3 ( pressure , \"symm\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"symm\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"symm\" , face ) call copy3 ( tw , \"symm\" , face ) case ( 'kkl' ) call copy3 ( tk , \"symm\" , face ) call copy3 ( tkl , \"symm\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select call flow_tangency ( face ) end subroutine slip_wall","tags":"","loc":"proc/slip_wall.html","title":"slip_wall – FEST-3D"},{"text":"private subroutine pole(face) Boundary condition for the block face\n with zero area; turning into a pole Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~pole~~CallsGraph proc~pole pole proc~turbulence_read_error turbulence_read_error proc~pole->proc~turbulence_read_error proc~copy3 copy3 proc~pole->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~pole~~CalledByGraph proc~pole pole proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~pole proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocpoleCalledByGraph = svgPanZoom('#procpoleCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code pole Source Code subroutine pole ( face ) !< Boundary condition for the block face !< with zero area; turning into a pole implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( density , \"flat\" , face ) call copy3 ( x_speed , \"flat\" , face ) call copy3 ( y_speed , \"flat\" , face ) call copy3 ( z_speed , \"flat\" , face ) call copy3 ( pressure , \"flat\" , face ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT call turbulence_read_error () end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine pole","tags":"","loc":"proc/pole.html","title":"pole – FEST-3D"},{"text":"private subroutine fix(var, fix_val, face) Generalized subroutine to fix particular value\n at particular face Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Variable of which values are being fixed in the ghost cell real, intent(in), dimension(1:6) :: fix_val Amount of value that need to be fixed. character(len=*), intent(in) :: face Name of the face at which boundary condition is called Called by proc~~fix~~CalledByGraph proc~fix fix proc~subsonic_outlet subsonic_outlet proc~subsonic_outlet->proc~fix proc~supersonic_inlet supersonic_inlet proc~supersonic_inlet->proc~fix proc~subsonic_inlet subsonic_inlet proc~subsonic_inlet->proc~fix proc~far_field far_field proc~far_field->proc~fix proc~total_pressure total_pressure proc~total_pressure->proc~fix proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~subsonic_outlet proc~populate_ghost_primitive->proc~supersonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~populate_ghost_primitive->proc~far_field proc~populate_ghost_primitive->proc~total_pressure proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfixCalledByGraph = svgPanZoom('#procfixCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fix Source Code subroutine fix ( var , fix_val , face ) !< Generalized subroutine to fix particular value !< at particular face implicit none real , dimension ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) , intent ( out ) :: var !< Variable of which values are being fixed in the ghost cell real , dimension ( 1 : 6 ) , intent ( in ) :: fix_val !< Amount of value that need to be fixed. character ( len =* ) , intent ( in ) :: face !< Name of the face at which boundary condition is called select case ( face ) case ( \"imin\" ) var ( 0 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) var ( - 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 1 ) case ( \"imax\" ) var ( imx , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 1 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) var ( imx + 2 , 1 : jmx - 1 , 1 : kmx - 1 ) = fix_val ( 2 ) case ( \"jmin\" ) var ( 1 : imx - 1 , 0 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 1 , 1 : kmx - 1 ) = fix_val ( 3 ) var ( 1 : imx - 1 , - 2 , 1 : kmx - 1 ) = fix_val ( 3 ) case ( \"jmax\" ) var ( 1 : imx - 1 , jmx , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 1 , 1 : kmx - 1 ) = fix_val ( 4 ) var ( 1 : imx - 1 , jmx + 2 , 1 : kmx - 1 ) = fix_val ( 4 ) case ( \"kmin\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , 0 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 1 ) = fix_val ( 5 ) var ( 1 : imx - 1 , 1 : jmx - 1 , - 2 ) = fix_val ( 5 ) case ( \"kmax\" ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 1 ) = fix_val ( 6 ) var ( 1 : imx - 1 , 1 : jmx - 1 , kmx + 2 ) = fix_val ( 6 ) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine fix","tags":"","loc":"proc/fix.html","title":"fix – FEST-3D"},{"text":"private subroutine no_slip(face) No-slip wall boundary condition. All the \n component of velocity throught face is zero Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called Calls proc~~no_slip~~CallsGraph proc~no_slip no_slip proc~set_omega_at_wall set_omega_at_wall proc~no_slip->proc~set_omega_at_wall proc~copy3 copy3 proc~no_slip->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~no_slip~~CalledByGraph proc~no_slip no_slip proc~wall wall proc~wall->proc~no_slip proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocno_slipCalledByGraph = svgPanZoom('#procno_slipCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code no_slip Source Code subroutine no_slip ( face ) !< No-slip wall boundary condition. All the !< component of velocity throught face is zero implicit none character ( len =* ), intent ( in ) :: face !< Name of the face at which boundary condition is called call copy3 ( x_speed , \"anti\" , face ) call copy3 ( y_speed , \"anti\" , face ) call copy3 ( z_speed , \"anti\" , face ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"anti\" , face ) case ( \"sst\" , 'sst2003' ) call copy3 ( tk , \"anti\" , face ) call set_omega_at_wall ( face ) case ( \"kkl\" ) call copy3 ( tk , \"anti\" , face ) call copy3 ( tkl , \"anti\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select end subroutine no_slip","tags":"","loc":"proc/no_slip.html","title":"no_slip – FEST-3D"},{"text":"private subroutine set_omega_at_wall(face) Set value of turbulence variable: omega (turbulenct dissipation rate). \n Value fixed is accourding to the SST turbulence model Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Called by proc~~set_omega_at_wall~~CalledByGraph proc~set_omega_at_wall set_omega_at_wall proc~no_slip no_slip proc~no_slip->proc~set_omega_at_wall proc~wall wall proc~wall->proc~no_slip proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocset_omega_at_wallCalledByGraph = svgPanZoom('#procset_omega_at_wallCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_omega_at_wall Source Code subroutine set_omega_at_wall ( face ) !< Set value of turbulence variable: omega (turbulenct dissipation rate). !< Value fixed is accourding to the SST turbulence model implicit none character ( len =* ), intent ( in ) :: face real :: T_face real :: mu real :: rho integer :: i , j , k , l select case ( face ) case ( \"imin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( 0 , j , k ) / density ( 0 , j , k )) + ( pressure ( 1 , j , k ) / density ( 1 , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( 0 , j , k ) + density ( 1 , j , k )) tw ( 1 - l , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( 1 , j , k )) ** 2 ) - tw ( l , j , k ) end do end do end do case ( \"imax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do j = 1 , jmx - 1 T_face = 0.5 * (( pressure ( imx - 1 , j , k ) / density ( imx - 1 , j , k )) + ( pressure ( imx , j , k ) / density ( imx , j , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( imx - 1 , j , k ) + density ( imx , j , k )) tw ( imx + l - 1 , j , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( imx - 1 , j , k )) ** 2 ) - tw ( imx - l , j , k ) end do end do end do case ( \"jmin\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , 0 , k ) / density ( i , 0 , k )) + ( pressure ( i , 1 , k ) / density ( i , 1 , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , 0 , k ) + density ( i , 1 , k )) tw ( i , 1 - l , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , 1 , k )) ** 2 ) - tw ( i , l , k ) end do end do end do case ( \"jmax\" ) do l = 1 , 3 do k = 1 , kmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , jmx - 1 , k ) / density ( i , jmx - 1 , k )) + ( pressure ( i , jmx , k ) / density ( i , jmx , k ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , jmx - 1 , k ) + density ( i , jmx , k )) tw ( i , jmx + l - 1 , k ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , jmx - 1 , k )) ** 2 ) - tw ( i , jmx - l , k ) end do end do end do case ( \"kmin\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , 0 ) / density ( i , j , 0 )) + ( pressure ( i , j , 1 ) / density ( i , j , 1 ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , 0 ) + density ( i , j , 1 )) tw ( i , j , 1 - l ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , 1 )) ** 2 ) - tw ( i , j , l ) end do end do end do case ( \"kmax\" ) do l = 1 , 3 do j = 1 , jmx - 1 do i = 1 , imx - 1 T_face = 0.5 * (( pressure ( i , j , kmx - 1 ) / density ( i , j , kmx - 1 )) + ( pressure ( i , j , kmx ) / density ( i , j , kmx ))) / R_gas mu = mu_ref * ( T_face / T_ref ) ** 1.5 * (( T_ref + Sutherland_temp ) / ( T_face + Sutherland_temp )) rho = 0.5 * ( density ( i , j , kmx - 1 ) + density ( i , j , kmx )) tw ( i , j , kmx + l - 1 ) = 120 * mu / ( rho * beta1 * ( 2 * dist ( i , j , kmx - 1 )) ** 2 ) - tw ( i , j , kmx - l ) end do end do end do end select end subroutine set_omega_at_wall","tags":"","loc":"proc/set_omega_at_wall.html","title":"set_omega_at_wall – FEST-3D"},{"text":"private subroutine check_if_value_fixed(model) A Fail-check subroutine which set the freestream\n as the fixed value in case not specified explicitly Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: model Called by proc~~check_if_value_fixed~~CalledByGraph proc~check_if_value_fixed check_if_value_fixed proc~supersonic_inlet supersonic_inlet proc~supersonic_inlet->proc~check_if_value_fixed proc~subsonic_inlet subsonic_inlet proc~subsonic_inlet->proc~check_if_value_fixed proc~far_field far_field proc~far_field->proc~check_if_value_fixed proc~total_pressure total_pressure proc~total_pressure->proc~check_if_value_fixed proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~supersonic_inlet proc~populate_ghost_primitive->proc~subsonic_inlet proc~populate_ghost_primitive->proc~far_field proc~populate_ghost_primitive->proc~total_pressure proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproccheck_if_value_fixedCalledByGraph = svgPanZoom('#proccheck_if_value_fixedCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code check_if_value_fixed Source Code subroutine check_if_value_fixed ( model ) !< A Fail-check subroutine which set the freestream !< as the fixed value in case not specified explicitly implicit none character ( len =* ), intent ( in ) :: model select case ( model ) case ( \"none\" , \"lctm2015\" ) !do nothing continue case ( \"sa\" , 'saBC' ) if ( fixed_tv ( face_num ) == 0.0 ) fixed_tv ( face_num ) = tv_inf case ( \"sst\" , 'sst2003' ) if ( fixed_tk ( face_num ) == 0. ) fixed_tk ( face_num ) = tk_inf if ( fixed_tw ( face_num ) == 0. ) fixed_tw ( face_num ) = tw_inf case ( \"kkl\" ) if ( fixed_tk ( face_num ) == 0. ) fixed_tk ( face_num ) = tk_inf if ( fixed_tkl ( face_num ) == 0. ) fixed_tkl ( face_num ) = tkl_inf case DEFAULT ! call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) if ( fixed_tgm ( face_num ) == 0.0 ) fixed_tgm ( face_num ) = tgm_inf Case DEFAULT continue end select end subroutine check_if_value_fixed","tags":"","loc":"proc/check_if_value_fixed.html","title":"check_if_value_fixed – FEST-3D"},{"text":"private subroutine far_field(face) Far-field Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*) :: face Calls proc~~far_field~~CallsGraph proc~far_field far_field proc~check_if_value_fixed check_if_value_fixed proc~far_field->proc~check_if_value_fixed proc~copy3 copy3 proc~far_field->proc~copy3 proc~fix fix proc~far_field->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~far_field~~CalledByGraph proc~far_field far_field proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~far_field proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocfar_fieldCalledByGraph = svgPanZoom('#procfar_fieldCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code far_field Source Code subroutine far_field ( face ) !< Far-field Riemann boundary condition implicit none character ( len =* ) :: face real :: cinf , cexp ! speed of sound real :: Rinf , Rexp ! Riemann invarient real :: Uninf , Unexp ! face normal speed real :: Unb ! normal velocity boundary real :: Cb ! speed of sound boundary real :: vel_diff real :: u , v , w real :: uf , vf , wf integer :: i , j , k real :: s integer , dimension ( 6 ) :: face_already_has_fixed_values = 0 !0=.no. face_already_has_fixed_values = 0 select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - xnx ( i , j , k )) + v * ( - xny ( i , j , k )) + w * ( - xnz ( i , j , k )) Uninf = uf * ( - xnx ( i , j , k )) + vf * ( - xny ( i , j , k )) + wf * ( - xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - xnz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 1 ) = 0 else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - xnz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i - 1 , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i - 1 , j , k ) = ( density ( i - 1 , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 1 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 1 ) = 1 end if end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( xnx ( i , j , k )) + v * ( xny ( i , j , k )) + w * ( xnz ( i , j , k )) Uninf = uf * ( xnx ( i , j , k )) + vf * ( xny ( i , j , k )) + wf * ( xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( xnz ( i , j , k )) s = pressure ( i - 1 , j , k ) / ( density ( i - 1 , j , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 2 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( xnz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 2 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 2 ) = 1 end if end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - ynx ( i , j , k )) + v * ( - yny ( i , j , k )) + w * ( - ynz ( i , j , k )) Uninf = uf * ( - ynx ( i , j , k )) + vf * ( - yny ( i , j , k )) + wf * ( - ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - ynz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 3 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - ynz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j - 1 , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j - 1 , k ) = ( density ( i , j - 1 , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 3 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 3 ) = 1 end if end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( ynx ( i , j , k )) + v * ( yny ( i , j , k )) + w * ( ynz ( i , j , k )) Uninf = uf * ( ynx ( i , j , k )) + vf * ( yny ( i , j , k )) + wf * ( ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( ynz ( i , j , k )) s = pressure ( i , j - 1 , k ) / ( density ( i , j - 1 , k ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 4 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( ynz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 4 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 4 ) = 1 end if end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - znx ( i , j , k )) + v * ( - zny ( i , j , k )) + w * ( - znz ( i , j , k )) Uninf = uf * ( - znx ( i , j , k )) + vf * ( - zny ( i , j , k )) + wf * ( - znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - znz ( i , j , k )) s = pressure ( i , j , k ) / ( density ( i , j , k ) ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 5 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - znz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k - 1 ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k - 1 ) = ( density ( i , j , k - 1 ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 5 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 5 ) = 1 end if end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( znx ( i , j , k )) + v * ( zny ( i , j , k )) + w * ( znz ( i , j , k )) Uninf = uf * ( znx ( i , j , k )) + vf * ( zny ( i , j , k )) + wf * ( znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( znz ( i , j , k )) s = pressure ( i , j , k - 1 ) / ( density ( i , j , k - 1 ) ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select face_already_has_fixed_values ( 6 ) = 0 else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( znz ( i , j , k )) s = pressure_inf / ( density_inf ** ( gm )) density ( i , j , k ) = ( Cb * Cb / ( gm * s )) ** ( 1. / ( gm - 1. )) pressure ( i , j , k ) = ( density ( i , j , k ) * Cb * Cb / gm ) if ( face_already_has_fixed_values ( 6 ) == 0 ) then select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if face_already_has_fixed_values ( 6 ) = 1 end if end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine far_field","tags":"","loc":"proc/far_field.html","title":"far_field – FEST-3D"},{"text":"private subroutine total_pressure(face) Total Pressure Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*) :: face Calls proc~~total_pressure~~CallsGraph proc~total_pressure total_pressure proc~check_if_value_fixed check_if_value_fixed proc~total_pressure->proc~check_if_value_fixed proc~copy3 copy3 proc~total_pressure->proc~copy3 proc~fix fix proc~total_pressure->proc~fix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~total_pressure~~CalledByGraph proc~total_pressure total_pressure proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~total_pressure proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproctotal_pressureCalledByGraph = svgPanZoom('#proctotal_pressureCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code total_pressure Source Code subroutine total_pressure ( face ) !< Total Pressure Riemann boundary condition implicit none character ( len =* ) :: face real :: cinf , cexp ! speed of sound real :: Rinf , Rexp ! Riemann invarient real :: Uninf , Unexp ! face normal speed real :: Unb ! normal velocity boundary real :: Cb ! speed of sound boundary real :: vel_diff real :: u , v , w real :: uf , vf , wf real :: Mb integer :: i , j , k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i-1,j,k) vf = y_speed_inf !y_speed(i-1,j,k) wf = z_speed_inf !z_speed(i-1,j,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i-1,j,k)/density(i-1,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - xnx ( i , j , k )) + v * ( - xny ( i , j , k )) + w * ( - xnz ( i , j , k )) Uninf = uf * ( - xnx ( i , j , k )) + vf * ( - xny ( i , j , k )) + wf * ( - xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i - 1 , j , k ) = x_speed ( i , j , k ) + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed ( i , j , k ) + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed ( i , j , k ) + vel_diff * ( - xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i - 1 , j , k ) = x_speed_inf + vel_diff * ( - xnx ( i , j , k )) y_speed ( i - 1 , j , k ) = y_speed_inf + vel_diff * ( - xny ( i , j , k )) z_speed ( i - 1 , j , k ) = z_speed_inf + vel_diff * ( - xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i - 1 , j , k ) ** 2 + y_speed ( i - 1 , j , k ) ** 2 + z_speed ( i - 1 , j , k ) ** 2 ) / Cb pressure ( i - 1 , j , k ) = fixed_Tpressure ( 1 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i - 1 , j , k ) = gm * pressure ( i - 1 , j , k ) / ( Cb * Cb ) end do end do end do qp ( - 1 ,:,:,:) = qp ( 0 ,:,:,:) qp ( - 2 ,:,:,:) = qp ( 0 ,:,:,:) case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx ! interior cell u = x_speed ( i - 1 , j , k ) v = y_speed ( i - 1 , j , k ) w = z_speed ( i - 1 , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i - 1 , j , k ) / density ( i - 1 , j , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( xnx ( i , j , k )) + v * ( xny ( i , j , k )) + w * ( xnz ( i , j , k )) Uninf = uf * ( xnx ( i , j , k )) + vf * ( xny ( i , j , k )) + wf * ( xnz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i - 1 , j , k ) + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i - 1 , j , k ) + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i - 1 , j , k ) + vel_diff * ( xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( xnx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( xny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( xnz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 2 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp ( imx + 1 ,:,:,:) = qp ( imx ,:,:,:) qp ( imx + 2 ,:,:,:) = qp ( imx ,:,:,:) case ( \"jmin\" ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j-1,k) vf = y_speed_inf !y_speed(i,j-1,k) wf = z_speed_inf !z_speed(i,j-1,k) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j-1,k)/density(i,j-1,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - ynx ( i , j , k )) + v * ( - yny ( i , j , k )) + w * ( - ynz ( i , j , k )) Uninf = uf * ( - ynx ( i , j , k )) + vf * ( - yny ( i , j , k )) + wf * ( - ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j - 1 , k ) = x_speed ( i , j , k ) + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed ( i , j , k ) + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed ( i , j , k ) + vel_diff * ( - ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j - 1 , k ) = x_speed_inf + vel_diff * ( - ynx ( i , j , k )) y_speed ( i , j - 1 , k ) = y_speed_inf + vel_diff * ( - yny ( i , j , k )) z_speed ( i , j - 1 , k ) = z_speed_inf + vel_diff * ( - ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j - 1 , k ) ** 2 + y_speed ( i , j - 1 , k ) ** 2 + z_speed ( i , j - 1 , k ) ** 2 ) / Cb pressure ( i , j - 1 , k ) = fixed_Tpressure ( 3 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j - 1 , k ) = gm * pressure ( i , j - 1 , k ) / ( Cb * Cb ) end do end do end do qp (:, - 1 ,:,:) = qp (:, 0 ,:,:) qp (:, - 2 ,:,:) = qp (:, 0 ,:,:) case ( \"jmax\" ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j - 1 , k ) v = y_speed ( i , j - 1 , k ) w = z_speed ( i , j - 1 , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j - 1 , k ) / density ( i , j - 1 , k )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( ynx ( i , j , k )) + v * ( yny ( i , j , k )) + w * ( ynz ( i , j , k )) Uninf = uf * ( ynx ( i , j , k )) + vf * ( yny ( i , j , k )) + wf * ( ynz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j - 1 , k ) + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j - 1 , k ) + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j - 1 , k ) + vel_diff * ( ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( ynx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( yny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( ynz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 4 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:, jmx + 1 ,:,:) = qp (:, jmx ,:,:) qp (:, jmx + 2 ,:,:) = qp (:, jmx ,:,:) case ( \"kmin\" ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k ) v = y_speed ( i , j , k ) w = z_speed ( i , j , k ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k-1) vf = y_speed_inf !y_speed(i,j,k-1) wf = z_speed_inf !z_speed(i,j,k-1) cexp = sqrt ( gm * pressure ( i , j , k ) / density ( i , j , k )) !cinf = sqrt(gm*pressure(i,j,k-1)/density(i,j,k-1)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( - znx ( i , j , k )) + v * ( - zny ( i , j , k )) + w * ( - znz ( i , j , k )) Uninf = uf * ( - znx ( i , j , k )) + vf * ( - zny ( i , j , k )) + wf * ( - znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k - 1 ) = x_speed ( i , j , k ) + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed ( i , j , k ) + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed ( i , j , k ) + vel_diff * ( - znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k - 1 ) = x_speed_inf + vel_diff * ( - znx ( i , j , k )) y_speed ( i , j , k - 1 ) = y_speed_inf + vel_diff * ( - zny ( i , j , k )) z_speed ( i , j , k - 1 ) = z_speed_inf + vel_diff * ( - znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k - 1 ) = fixed_Tpressure ( 5 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k - 1 ) = gm * pressure ( i , j , k - 1 ) / ( Cb * Cb ) end do end do end do qp (:,:, - 1 ,:) = qp (:,:, 0 ,:) qp (:,:, - 2 ,:) = qp (:,:, 0 ,:) case ( \"kmax\" ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 ! interior cell u = x_speed ( i , j , k - 1 ) v = y_speed ( i , j , k - 1 ) w = z_speed ( i , j , k - 1 ) ! ghost cell uf = x_speed_inf !x_speed(i,j,k) vf = y_speed_inf !y_speed(i,j,k) wf = z_speed_inf !z_speed(i,j,k) cexp = sqrt ( gm * pressure ( i , j , k - 1 ) / density ( i , j , k - 1 )) !cinf = sqrt(gm*pressure(i,j,k)/density(i,j,k)) cinf = sqrt ( gm * pressure_inf / density_inf ) Unexp = u * ( znx ( i , j , k )) + v * ( zny ( i , j , k )) + w * ( znz ( i , j , k )) Uninf = uf * ( znx ( i , j , k )) + vf * ( zny ( i , j , k )) + wf * ( znz ( i , j , k )) Rinf = Uninf - 2 * cinf / ( gm - 1. ) Rexp = Unexp + 2 * cexp / ( gm - 1. ) Unb = 0.5 * ( Rexp + Rinf ) Cb = 0.25 * ( gm - 1. ) * ( Rexp - Rinf ) if ( Unb > 0. ) then vel_diff = Unb - Unexp x_speed ( i , j , k ) = x_speed ( i , j , k - 1 ) + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed ( i , j , k - 1 ) + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed ( i , j , k - 1 ) + vel_diff * ( znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call copy3 ( tv , \"flat\" , face ) case ( 'sst' , 'sst2003' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tw , \"flat\" , face ) case ( 'kkl' ) call copy3 ( tk , \"flat\" , face ) call copy3 ( tkl , \"flat\" , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call copy3 ( tgm , \"flat\" , face ) case DEFAULT continue end select else vel_diff = Unb - Uninf x_speed ( i , j , k ) = x_speed_inf + vel_diff * ( znx ( i , j , k )) y_speed ( i , j , k ) = y_speed_inf + vel_diff * ( zny ( i , j , k )) z_speed ( i , j , k ) = z_speed_inf + vel_diff * ( znz ( i , j , k )) select case ( turbulence ) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call fix ( tv , fixed_tv , face ) case ( 'sst' , 'sst2003' ) call check_if_value_fixed ( \"sst\" ) call fix ( tk , fixed_tk , face ) call fix ( tw , fixed_tw , face ) case ( 'kkl' ) call check_if_value_fixed ( \"kkl\" ) call fix ( tk , fixed_tk , face ) call fix ( tkl , fixed_tkl , face ) case DEFAULT !call turbulence_read_error() Fatal_error end select select case ( trim ( transition )) case ( 'lctm2015' ) call check_if_value_fixed ( \"lctm2015\" ) call fix ( tgm , fixed_tgm , face ) case DEFAULT continue end select end if Mb = sqrt ( x_speed ( i , j , k ) ** 2 + y_speed ( i , j , k ) ** 2 + z_speed ( i , j , k ) ** 2 ) / Cb pressure ( i , j , k ) = fixed_Tpressure ( 6 ) / ((( 1 + 0.5 * ( gm - 1. ) * Mb * Mb )) ** ( gm / ( gm - 1. ))) density ( i , j , k ) = gm * pressure ( i , j , k ) / ( Cb * Cb ) end do end do end do qp (:,:, kmx + 1 ,:) = qp (:,:, kmx ,:) qp (:,:, kmx + 2 ,:) = qp (:,:, kmx ,:) case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine total_pressure","tags":"","loc":"proc/total_pressure.html","title":"total_pressure – FEST-3D"},{"text":"private subroutine temp_based_density(temperature, face) Specify the density in the ghost cell based on the\n temperature on the wall. Isothermal or adiabatic Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:6) :: temperature character(len=*), intent(in) :: face Calls proc~~temp_based_density~~CallsGraph proc~temp_based_density temp_based_density proc~copy3 copy3 proc~temp_based_density->proc~copy3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~temp_based_density~~CalledByGraph proc~temp_based_density temp_based_density proc~wall wall proc~wall->proc~temp_based_density proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panproctemp_based_densityCalledByGraph = svgPanZoom('#proctemp_based_densityCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code temp_based_density Source Code subroutine temp_based_density ( temperature , face ) !< Specify the density in the ghost cell based on the !< temperature on the wall. Isothermal or adiabatic implicit none real , dimension ( 1 : 6 ) , intent ( in ) :: temperature character ( len =* ) , intent ( in ) :: face real :: stag_temp integer :: i , j , k select case ( face ) case ( \"imin\" ) if ( temperature ( 1 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * stag_temp ) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * stag_temp ) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 1 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 density ( i - 1 , j , k ) = pressure ( i - 1 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 0 , j , k ) / ( R_gas * density ( i + 0 , j , k ))))) density ( i - 2 , j , k ) = pressure ( i - 2 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 1 , j , k ) / ( R_gas * density ( i + 1 , j , k ))))) density ( i - 3 , j , k ) = pressure ( i - 3 , j , k ) / ( R_gas * ( 2 * temperature ( 1 ) - ( pressure ( i + 2 , j , k ) / ( R_gas * density ( i + 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"imax\" ) if ( temperature ( 2 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * stag_temp ) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * stag_temp ) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 2 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 density ( i + 1 , j , k ) = pressure ( i + 1 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 0 , j , k ) / ( R_gas * density ( i - 0 , j , k ))))) density ( i + 2 , j , k ) = pressure ( i + 2 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k ))))) density ( i + 3 , j , k ) = pressure ( i + 3 , j , k ) / ( R_gas * ( 2 * temperature ( 2 ) - ( pressure ( i - 2 , j , k ) / ( R_gas * density ( i - 2 , j , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"jmin\" ) if ( temperature ( 3 ) < 0.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * stag_temp ) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * stag_temp ) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 3 ) > 1.0 ) then do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 density ( i , j - 1 , k ) = pressure ( i , j - 1 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 0 , k ) / ( R_gas * density ( i , j + 0 , k ))))) density ( i , j - 2 , k ) = pressure ( i , j - 2 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 1 , k ) / ( R_gas * density ( i , j + 1 , k ))))) density ( i , j - 3 , k ) = pressure ( i , j - 3 , k ) / ( R_gas * ( 2 * temperature ( 3 ) - ( pressure ( i , j + 2 , k ) / ( R_gas * density ( i , j + 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"jmax\" ) if ( temperature ( 4 ) < 0.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * stag_temp ) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * stag_temp ) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 4 ) > 1.0 ) then do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j + 1 , k ) = pressure ( i , j + 1 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 0 , k ) / ( R_gas * density ( i , j - 0 , k ))))) density ( i , j + 2 , k ) = pressure ( i , j + 2 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k ))))) density ( i , j + 3 , k ) = pressure ( i , j + 3 , k ) / ( R_gas * ( 2 * temperature ( 4 ) - ( pressure ( i , j - 2 , k ) / ( R_gas * density ( i , j - 2 , k ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"kmin\" ) if ( temperature ( 5 ) < 0.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * stag_temp ) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * stag_temp ) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 5 ) > 1.0 ) then do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k - 1 ) = pressure ( i , j , k - 1 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 0 ) / ( R_gas * density ( i , j , k + 0 ))))) density ( i , j , k - 2 ) = pressure ( i , j , k - 2 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 1 ) / ( R_gas * density ( i , j , k + 1 ))))) density ( i , j , k - 3 ) = pressure ( i , j , k - 3 ) / ( R_gas * ( 2 * temperature ( 5 ) - ( pressure ( i , j , k + 2 ) / ( R_gas * density ( i , j , k + 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case ( \"kmax\" ) if ( temperature ( 6 ) < 0.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 stag_temp = ( pressure ( i , j , k ) / ( R_gas * density ( i , j , k ))) * ( 1 + ( 0.5 * ( gm - 1. ) * gm * pressure ( i , j , k ) / density ( i , j , k ))) density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * stag_temp ) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * stag_temp ) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * stag_temp ) end do end do end do elseif ( temperature ( 6 ) > 1.0 ) then do k = kmx - 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 density ( i , j , k + 1 ) = pressure ( i , j , k + 1 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 0 ) / ( R_gas * density ( i , j , k - 0 ))))) density ( i , j , k + 2 ) = pressure ( i , j , k + 2 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 ))))) density ( i , j , k + 3 ) = pressure ( i , j , k + 3 ) / ( R_gas * ( 2 * temperature ( 6 ) - ( pressure ( i , j , k - 2 ) / ( R_gas * density ( i , j , k - 2 ))))) end do end do end do else call copy3 ( density , \"symm\" , face ) end if case DEFAULT !print*, \"ERROR: wrong face for boundary condition\" Fatal_error end select end subroutine temp_based_density","tags":"","loc":"proc/temp_based_density.html","title":"temp_based_density – FEST-3D"},{"text":"private subroutine periodic_bc(face) Single block periodic boundary condition.\n Not to be used for multiblock boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Called by proc~~periodic_bc~~CalledByGraph proc~periodic_bc periodic_bc proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~periodic_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocperiodic_bcCalledByGraph = svgPanZoom('#procperiodic_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code periodic_bc Source Code subroutine periodic_bc ( face ) !< Single block periodic boundary condition. !< Not to be used for multiblock boundary condition implicit none character ( len =* ), intent ( in ) :: face select case ( trim ( face )) case ( 'imin' ) qp ( - 2 : 0 ,:,:,:) = qp ( imx - 3 : imx - 1 ,:,:,:) case ( 'imax' ) qp ( imx : imx + 2 ,:,:,:) = qp ( 1 : 3 ,:,:,:) case ( 'jmin' ) qp (:, - 2 : 0 ,:,:) = qp (:, jmx - 3 : jmx - 1 ,:,:) case ( 'jmax' ) qp (:, jmx : jmx + 2 ,:,:) = qp (:, 1 : 3 ,:,:) case ( 'kmin' ) qp (:,:, - 2 : 0 ,:) = qp (:,:, kmx - 3 : kmx - 1 ,:) case ( 'kmax' ) qp (:,:, kmx : kmx + 2 ,:) = qp (:,:, 1 : 3 ,:) case Default Fatal_error end select end subroutine periodic_bc","tags":"","loc":"proc/periodic_bc.html","title":"periodic_bc – FEST-3D"},{"text":"public subroutine flow_tangency(face) Apply flow tangency boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Face over which flow tangency condition has to be applied Called by proc~~flow_tangency~~CalledByGraph proc~flow_tangency flow_tangency proc~slip_wall slip_wall proc~slip_wall->proc~flow_tangency proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~slip_wall proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocflow_tangencyCalledByGraph = svgPanZoom('#procflow_tangencyCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code flow_tangency Source Code subroutine flow_tangency ( face ) !< Apply flow tangency boundary condition implicit none character ( len =* ), intent ( in ) :: face !< Face over which flow tangency condition has to be applied real :: dot1 real :: dot2 real :: dot3 integer :: i integer :: j integer :: k select case ( face ) case ( \"imin\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 dot1 = sum ( qp ( 1 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) dot2 = sum ( qp ( 2 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) dot3 = sum ( qp ( 3 , j , k , 2 : 4 ) * xn ( 1 , j , k , 1 : 3 )) qp ( 0 , j , k , 2 : 4 ) = qp ( 1 , j , k , 2 : 4 ) - ( 2 * dot1 * xn ( 1 , j , k , 1 : 3 )) qp ( - 1 , j , k , 2 : 4 ) = qp ( 2 , j , k , 2 : 4 ) - ( 2 * dot2 * xn ( 1 , j , k , 1 : 3 )) qp ( - 2 , j , k , 2 : 4 ) = qp ( 3 , j , k , 2 : 4 ) - ( 2 * dot3 * xn ( 1 , j , k , 1 : 3 )) end do end do case ( \"imax\" ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 dot1 = sum ( qp ( imx - 1 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) dot2 = sum ( qp ( imx - 2 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) dot3 = sum ( qp ( imx - 3 , j , k , 2 : 4 ) * xn ( imx , j , k , 1 : 3 )) qp ( imx + 0 , j , k , 2 : 4 ) = qp ( imx - 1 , j , k , 2 : 4 ) - ( 2 * dot1 * xn ( imx , j , k , 1 : 3 )) qp ( imx + 1 , j , k , 2 : 4 ) = qp ( imx - 2 , j , k , 2 : 4 ) - ( 2 * dot2 * xn ( imx , j , k , 1 : 3 )) qp ( imx + 2 , j , k , 2 : 4 ) = qp ( imx - 3 , j , k , 2 : 4 ) - ( 2 * dot3 * xn ( imx , j , k , 1 : 3 )) end do end do case ( \"jmin\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , 1 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) dot2 = sum ( qp ( i , 2 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) dot3 = sum ( qp ( i , 3 , k , 2 : 4 ) * yn ( i , 1 , k , 1 : 3 )) qp ( i , 0 , k , 2 : 4 ) = qp ( i , 1 , k , 2 : 4 ) - ( 2 * dot1 * yn ( i , 1 , k , 1 : 3 )) qp ( i , - 1 , k , 2 : 4 ) = qp ( i , 2 , k , 2 : 4 ) - ( 2 * dot2 * yn ( i , 1 , k , 1 : 3 )) qp ( i , - 2 , k , 2 : 4 ) = qp ( i , 3 , k , 2 : 4 ) - ( 2 * dot3 * yn ( i , 1 , k , 1 : 3 )) end do end do case ( \"jmax\" ) do k = 1 , kmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , jmx - 1 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) dot2 = sum ( qp ( i , jmx - 2 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) dot3 = sum ( qp ( i , jmx - 3 , k , 2 : 4 ) * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 0 , k , 2 : 4 ) = qp ( i , jmx - 1 , k , 2 : 4 ) - ( 2 * dot1 * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 1 , k , 2 : 4 ) = qp ( i , jmx - 2 , k , 2 : 4 ) - ( 2 * dot2 * yn ( i , jmx , k , 1 : 3 )) qp ( i , jmx + 2 , k , 2 : 4 ) = qp ( i , jmx - 3 , k , 2 : 4 ) - ( 2 * dot3 * yn ( i , jmx , k , 1 : 3 )) end do end do case ( \"kmin\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , j , 1 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) dot2 = sum ( qp ( i , j , 2 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) dot3 = sum ( qp ( i , j , 3 , 2 : 4 ) * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , 0 , 2 : 4 ) = qp ( i , j , 1 , 2 : 4 ) - ( 2 * dot1 * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , - 1 , 2 : 4 ) = qp ( i , j , 2 , 2 : 4 ) - ( 2 * dot2 * zn ( i , j , 1 , 1 : 3 )) qp ( i , j , - 2 , 2 : 4 ) = qp ( i , j , 3 , 2 : 4 ) - ( 2 * dot3 * zn ( i , j , 1 , 1 : 3 )) end do end do case ( \"kmax\" ) do j = 1 , jmx - 1 do i = 1 , imx - 1 dot1 = sum ( qp ( i , j , kmx - 1 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) dot2 = sum ( qp ( i , j , kmx - 2 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) dot3 = sum ( qp ( i , j , kmx - 3 , 2 : 4 ) * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 0 , 2 : 4 ) = qp ( i , j , kmx - 1 , 2 : 4 ) - ( 2 * dot1 * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 1 , 2 : 4 ) = qp ( i , j , kmx - 2 , 2 : 4 ) - ( 2 * dot2 * zn ( i , j , kmx , 1 : 3 )) qp ( i , j , kmx + 2 , 2 : 4 ) = qp ( i , j , kmx - 3 , 2 : 4 ) - ( 2 * dot3 * zn ( i , j , kmx , 1 : 3 )) end do end do end select end subroutine flow_tangency","tags":"","loc":"proc/flow_tangency.html","title":"flow_tangency – FEST-3D"},{"text":"public subroutine read_fixed_values() Read fixed values for each block face Arguments None Calls proc~~read_fixed_values~~CallsGraph proc~read_fixed_values read_fixed_values proc~fill_fixed_values fill_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~get_fixed_values get_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~set_value set_value proc~fill_fixed_values->proc~set_value proc~get_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_fixed_values~~CalledByGraph proc~read_fixed_values read_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~setup_all setup_all proc~setup_all->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_fixed_values Source Code subroutine read_fixed_values () !< Read fixed values for each block face implicit none integer :: count = 0 call fill_fixed_values () open ( unit = BOUNDARY_CONDITIONS_FILE_UNIT , file = bc_file ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , * ) do while ( count < 6 ) read ( BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 1 ) == '#' ) then count = count + 1 call get_fixed_values ( count ) end if end do close ( BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine read_fixed_values","tags":"","loc":"proc/read_fixed_values.html","title":"read_fixed_values – FEST-3D"},{"text":"private subroutine get_fixed_values(count) Extract fixed value from the bc_**.md file Arguments Type Intent Optional Attributes Name integer, intent(in) :: count Calls proc~~get_fixed_values~~CallsGraph proc~get_fixed_values get_fixed_values proc~set_value set_value proc~get_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_fixed_values~~CalledByGraph proc~get_fixed_values get_fixed_values proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~setup_all setup_all proc~setup_all->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_fixed_values Source Code subroutine get_fixed_values ( count ) !< Extract fixed value from the bc_**.md file implicit none integer , intent ( in ) :: count real :: fix_val integer :: ios do while (. true .) read ( BOUNDARY_CONDITIONS_FILE_UNIT , \"(A)\" ) buf if ( buf ( 1 : 2 ) == '- ' ) then read ( buf ( index ( buf ( 3 :), ' ' ) + 3 :), * , iostat = ios ) fix_val select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_DENSITY\" ) call set_value ( fixed_density , fix_val , density_inf , count , ios ) case ( \"FIX_X_SPEED\" ) call set_value ( fixed_x_speed , fix_val , x_speed_inf , count , ios ) case ( \"FIX_Y_SPEED\" ) call set_value ( fixed_y_speed , fix_val , y_speed_inf , count , ios ) case ( \"FIX_Z_SPEED\" ) call set_value ( fixed_z_speed , fix_val , z_speed_inf , count , ios ) case ( \"FIX_PRESSURE\" ) call set_value ( fixed_pressure , fix_val , pressure_inf , count , ios ) case ( \"WALL_TEMPERATURE\" ) call set_value ( fixed_wall_temperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_TEMPERATURE\" ) call set_value ( fixed_Ttemperature , fix_val , 0.0 , count , ios ) case ( \"TOTAL_PRESSURE\" ) call set_value ( fixed_Tpressure , fix_val , 0.0 , count , ios ) end select select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( fixed_tk , fix_val , tk_inf , count , ios ) case ( \"FIX_tw\" ) call set_value ( fixed_tw , fix_val , tw_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"kkl\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tk\" ) call set_value ( fixed_tk , fix_val , tk_inf , count , ios ) case ( \"FIX_tkl\" ) call set_value ( fixed_tkl , fix_val , tkl_inf , count , ios ) case DEFAULT ! no a value to fix continue end select case ( \"sa\" , \"saBC\" ) select case ( buf ( 3 : index ( buf ( 3 :), \" \" ) + 1 )) case ( \"FIX_tv\" ) call set_value ( fixed_tk , fix_val , tv_inf , count , ios ) case DEFAULT ! no a value to fix continue end select end select else exit end if end do end subroutine get_fixed_values","tags":"","loc":"proc/get_fixed_values.html","title":"get_fixed_values – FEST-3D"},{"text":"private subroutine fill_fixed_values() Fill the Fixed_var array with with free-stream value\n or default values. Arguments None Calls proc~~fill_fixed_values~~CallsGraph proc~fill_fixed_values fill_fixed_values proc~set_value set_value proc~fill_fixed_values->proc~set_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~fill_fixed_values~~CalledByGraph proc~fill_fixed_values fill_fixed_values proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~setup_all setup_all proc~setup_all->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code fill_fixed_values Source Code subroutine fill_fixed_values () !< Fill the Fixed_var array with with free-stream value !< or default values. implicit none integer :: count integer :: ios =- 1 do count = 1 , 6 !case (\"FIX_DENSITY\") call set_value ( fixed_density , density_inf , density_inf , count , ios ) !case (\"FIX_X_SPEED\") call set_value ( fixed_x_speed , x_speed_inf , x_speed_inf , count , ios ) !case (\"FIX_Y_SPEED\") call set_value ( fixed_y_speed , y_speed_inf , y_speed_inf , count , ios ) !case (\"FIX_Z_SPEED\") call set_value ( fixed_z_speed , z_speed_inf , z_speed_inf , count , ios ) !case (\"FIX_PRESSURE\") call set_value ( fixed_pressure , pressure_inf , pressure_inf , count , ios ) !case (\"WALL_TEMPERATURE\") call set_value ( fixed_wall_temperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_TEMPERATURE\") call set_value ( fixed_Ttemperature , 0.0 , 0.0 , count , ios ) !case (\"TOTAL_PRESSURE\") call set_value ( fixed_Tpressure , 0.0 , 0.0 , count , ios ) select case ( turbulence ) case ( \"none\" ) !do nothing continue case ( \"sst\" , 'tw' , 'sst2003' ) !case (\"FIX_tk\") call set_value ( fixed_tk , tk_inf , tk_inf , count , ios ) !case (\"FIX_tw\") call set_value ( fixed_tw , tw_inf , tw_inf , count , ios ) case ( \"kkl\" ) !case (\"FIX_tk\") call set_value ( fixed_tk , tk_inf , tk_inf , count , ios ) !case (\"FIX_tkl\") call set_value ( fixed_tkl , tkl_inf , tkl_inf , count , ios ) case ( \"sa\" , \"saBC\" ) !case (\"FIX_tv\") call set_value ( fixed_tk , tv_inf , tv_inf , count , ios ) case DEFAULT Fatal_error end select end do end subroutine fill_fixed_values","tags":"","loc":"proc/fill_fixed_values.html","title":"fill_fixed_values – FEST-3D"},{"text":"private subroutine set_value(fixed_var, fix_val, inf_val, count, ios) Set particular value to the Fixed_var variable Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: fixed_var real, intent(in) :: fix_val real, intent(in) :: inf_val integer, intent(in) :: count integer, intent(in) :: ios Called by proc~~set_value~~CalledByGraph proc~set_value set_value proc~fill_fixed_values fill_fixed_values proc~fill_fixed_values->proc~set_value proc~get_fixed_values get_fixed_values proc~get_fixed_values->proc~set_value proc~read_fixed_values read_fixed_values proc~read_fixed_values->proc~fill_fixed_values proc~read_fixed_values->proc~get_fixed_values proc~setup_bc setup_bc proc~setup_bc->proc~read_fixed_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_bc proc~setup_all setup_all proc~setup_all->proc~setup_bc proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocset_valueCalledByGraph = svgPanZoom('#procset_valueCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_value Source Code subroutine set_value ( fixed_var , fix_val , inf_val , count , ios ) !< Set particular value to the Fixed_var variable implicit none integer , intent ( in ) :: ios integer , intent ( in ) :: count real , intent ( in ) :: fix_val real , intent ( in ) :: inf_val real , intent ( out ), dimension (:) :: fixed_var if ( ios == 0 ) then fixed_var ( count ) = fix_val else fixed_var ( count ) = inf_val end if end subroutine set_value","tags":"","loc":"proc/set_value.html","title":"set_value – FEST-3D"},{"text":"public subroutine apply_gradient_bc() Call same subroutine for all the face Arguments None Calls proc~~apply_gradient_bc~~CallsGraph proc~apply_gradient_bc apply_gradient_bc proc~dmsg dmsg proc~apply_gradient_bc->proc~dmsg proc~apply apply proc~apply_gradient_bc->proc~apply Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~apply_gradient_bc~~CalledByGraph proc~apply_gradient_bc apply_gradient_bc proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~apply_gradient_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapply_gradient_bcCalledByGraph = svgPanZoom('#procapply_gradient_bcCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply_gradient_bc Source Code subroutine apply_gradient_bc () !< Call same subroutine for all the face implicit none call dmsg ( 1 , 'ghost_gradients' , 'apply_gradient_bc' ) if ( imin_id < 0 ) then call apply ( 'imin' ) end if if ( imax_id < 0 ) then call apply ( 'imax' ) end if if ( jmin_id < 0 ) then call apply ( 'jmin' ) end if if ( jmax_id < 0 ) then call apply ( 'jmax' ) end if if ( kmin_id < 0 ) then call apply ( 'kmin' ) end if if ( kmax_id < 0 ) then call apply ( 'kmax' ) end if end subroutine apply_gradient_bc","tags":"","loc":"proc/apply_gradient_bc.html","title":"apply_gradient_bc – FEST-3D"},{"text":"public subroutine apply(face) Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name character(len=*) :: face Called by proc~~apply~~CalledByGraph proc~apply apply proc~apply_gradient_bc apply_gradient_bc proc~apply_gradient_bc->proc~apply proc~evaluate_all_gradients evaluate_all_gradients proc~evaluate_all_gradients->proc~apply_gradient_bc proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~evaluate_all_gradients proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocapplyCalledByGraph = svgPanZoom('#procapplyCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code apply Source Code subroutine apply ( face ) !< Apply/set value of all gradient in the ghost cells !< gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) !< volume_G = volume_I !----------------------------------------------------------- implicit none character ( len =* ) :: face real , dimension ( n_grad ) :: qp_I real , dimension ( n_grad ) :: qp_G real :: T_I real :: T_G real :: c_x real :: c_y real :: c_z integer :: n integer :: i , j , k , l real :: nx real :: ny real :: nz real :: dot !----------------------------------------------------------- ! gradqp_G = (qp_I - qp_G)*Area_W*unit_normal_G/(volume_G) ! volume_G = volume_I !----------------------------------------------------------- n = n_grad select case ( face ) case ( 'imin' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 nx = xnx ( i , j , k ) ny = xny ( i , j , k ) nz = xnz ( i , j , k ) c_x = xA ( i , j , k ) * nx / volume ( i , j , k ) c_y = xA ( i , j , k ) * ny / volume ( i , j , k ) c_z = xA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i - 1 , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i - 1 , j , k ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i - 1 , j , k , 4 ) = ( T_I - T_G ) * c_z if ( imin_id ==- 5 . and . ( fixed_wall_temperature ( 1 ) < 1. . and . fixed_wall_temperature ( 1 ) >= 0. )) then gradqp_x ( i - 1 , j , k , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i - 1 , j , k , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i - 1 , j , k , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i - 1 , j , k , l ) = gradqp_x ( i - 1 , j , k , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i - 1 , j , k , l ) = gradqp_y ( i - 1 , j , k , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i - 1 , j , k , l ) = gradqp_z ( i - 1 , j , k , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'imax' ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx , imx nx = xnx ( i , j , k ) ny = xny ( i , j , k ) nz = xnz ( i , j , k ) c_x = xA ( i , j , k ) * nx / volume ( i - 1 , j , k ) c_y = xA ( i , j , k ) * ny / volume ( i - 1 , j , k ) c_z = xA ( i , j , k ) * nz / volume ( i - 1 , j , k ) T_I = pressure ( i - 1 , j , k ) / ( R_gas * density ( i - 1 , j , k )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i - 1 , j , k , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( imax_id ==- 5 . and . ( fixed_wall_temperature ( 2 ) < 1. . and . fixed_wall_temperature ( 2 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i - 1 , j , k , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i - 1 , j , k , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i - 1 , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i - 1 , j , k , l ) * nx ) + ( gradqp_y ( i - 1 , j , k , l ) * ny ) + ( gradqp_z ( i - 1 , j , k , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i - 1 , j , k , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i - 1 , j , k , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i - 1 , j , k , l ) - dot * nz ) end do end do end do end do case ( 'jmin' ) do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 nx = ynx ( i , j , k ) ny = yny ( i , j , k ) nz = ynz ( i , j , k ) c_x = yA ( i , j , k ) * nx / volume ( i , j , k ) c_y = yA ( i , j , k ) * ny / volume ( i , j , k ) c_z = yA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i , j - 1 , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i , j - 1 , k ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i , j - 1 , k , 4 ) = ( T_I - T_G ) * c_z if ( jmin_id ==- 5 . and . ( fixed_wall_temperature ( 3 ) < 1. . and . fixed_wall_temperature ( 3 ) >= 0. )) then gradqp_x ( i , j - 1 , k , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i , j - 1 , k , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i , j - 1 , k , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i , j - 1 , k , l ) = gradqp_x ( i , j - 1 , k , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i , j - 1 , k , l ) = gradqp_y ( i , j - 1 , k , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i , j - 1 , k , l ) = gradqp_z ( i , j - 1 , k , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'jmax' ) do k = 1 , kmx - 1 do j = jmx , jmx do i = 1 , imx - 1 nx = ynx ( i , j , k ) ny = yny ( i , j , k ) nz = ynz ( i , j , k ) c_x = yA ( i , j , k ) * nx / volume ( i , j , k ) c_y = yA ( i , j , k ) * ny / volume ( i , j , k ) c_z = yA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j - 1 , k ) / ( R_gas * density ( i , j - 1 , k )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i , j - 1 , k , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( jmax_id ==- 5 . and . ( fixed_wall_temperature ( 4 ) < 1. . and . fixed_wall_temperature ( 4 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i , j - 1 , k , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i , j - 1 , k , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i , j - 1 , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j - 1 , k , l ) * nx ) + ( gradqp_y ( i , j - 1 , k , l ) * ny ) + ( gradqp_z ( i , j - 1 , k , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i , j - 1 , k , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i , j - 1 , k , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i , j - 1 , k , l ) - dot * nz ) end do end do end do end do case ( 'kmin' ) do k = 1 , 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 nx = znx ( i , j , k ) ny = zny ( i , j , k ) nz = znz ( i , j , k ) c_x = zA ( i , j , k ) * nx / volume ( i , j , k ) c_y = zA ( i , j , k ) * ny / volume ( i , j , k ) c_z = zA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) T_G = pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 )) qp_I = qp ( i , j , k , 2 : n_var ) qp_G = qp ( i , j , k - 1 , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k - 1 ,:) = ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_x gradqp_y ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_y gradqp_z ( i , j , k - 1 , 4 ) = ( T_I - T_G ) * c_z if ( kmin_id ==- 5 . and . ( fixed_wall_temperature ( 5 ) < 1. . and . fixed_wall_temperature ( 5 ) >= 0. )) then gradqp_x ( i , j , k - 1 , 4 ) = - gradqp_x ( i , j , k , 4 ) gradqp_y ( i , j , k - 1 , 4 ) = - gradqp_y ( i , j , k , 4 ) gradqp_z ( i , j , k - 1 , 4 ) = - gradqp_z ( i , j , k , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k , l ) * nx ) + ( gradqp_y ( i , j , k , l ) * ny ) + ( gradqp_z ( i , j , k , l ) * nz ) gradqp_x ( i , j , k - 1 , l ) = gradqp_x ( i , j , k - 1 , l ) + ( gradqp_x ( i , j , k , l ) - dot * nx ) gradqp_y ( i , j , k - 1 , l ) = gradqp_y ( i , j , k - 1 , l ) + ( gradqp_y ( i , j , k , l ) - dot * ny ) gradqp_z ( i , j , k - 1 , l ) = gradqp_z ( i , j , k - 1 , l ) + ( gradqp_z ( i , j , k , l ) - dot * nz ) end do end do end do end do case ( 'kmax' ) do k = kmx , kmx do j = 1 , jmx - 1 do i = 1 , imx - 1 nx = znx ( i , j , k ) ny = zny ( i , j , k ) nz = znz ( i , j , k ) c_x = zA ( i , j , k ) * nx / volume ( i , j , k ) c_y = zA ( i , j , k ) * ny / volume ( i , j , k ) c_z = zA ( i , j , k ) * nz / volume ( i , j , k ) T_I = pressure ( i , j , k - 1 ) / ( R_gas * density ( i , j , k - 1 )) T_G = pressure ( i , j , k ) / ( R_gas * density ( i , j , k )) qp_I = qp ( i , j , k - 1 , 2 : n_var ) qp_G = qp ( i , j , k , 2 : n_var ) ! normal component of gradient gradqp_x ( i , j , k ,:) = - ( qp_I - qp_G ) * c_x gradqp_y ( i , j , k ,:) = - ( qp_I - qp_G ) * c_y gradqp_z ( i , j , k ,:) = - ( qp_I - qp_G ) * c_z gradqp_x ( i , j , k , 4 ) = - ( T_I - T_G ) * c_x gradqp_y ( i , j , k , 4 ) = - ( T_I - T_G ) * c_y gradqp_z ( i , j , k , 4 ) = - ( T_I - T_G ) * c_z if ( kmax_id ==- 5 . and . ( fixed_wall_temperature ( 6 ) < 1. . and . fixed_wall_temperature ( 6 ) >= 0. )) then gradqp_x ( i , j , k , 4 ) = - gradqp_x ( i , j , k - 1 , 4 ) gradqp_y ( i , j , k , 4 ) = - gradqp_y ( i , j , k - 1 , 4 ) gradqp_z ( i , j , k , 4 ) = - gradqp_z ( i , j , k - 1 , 4 ) end if !parallel component of gradient do l = 1 , n dot = ( gradqp_x ( i , j , k - 1 , l ) * nx ) + ( gradqp_y ( i , j , k - 1 , l ) * ny ) + ( gradqp_z ( i , j , k - 1 , l ) * nz ) gradqp_x ( i , j , k , l ) = gradqp_x ( i , j , k , l ) + ( gradqp_x ( i , j , k - 1 , l ) - dot * nx ) gradqp_y ( i , j , k , l ) = gradqp_y ( i , j , k , l ) + ( gradqp_y ( i , j , k - 1 , l ) - dot * ny ) gradqp_z ( i , j , k , l ) = gradqp_z ( i , j , k , l ) + ( gradqp_z ( i , j , k - 1 , l ) - dot * nz ) end do end do end do end do case DEFAULT print * , \"Ghost gradients : Wrong face name string\" end select end subroutine apply","tags":"","loc":"proc/apply.html","title":"apply – FEST-3D"},{"text":"public subroutine reconstruct_boundary_state(interpolant) Call reconstruction based on the flag and boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolant Calls proc~~reconstruct_boundary_state~~CallsGraph proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_jmin reconstruct_jmin proc~reconstruct_boundary_state->proc~reconstruct_jmin proc~reconstruct_imax reconstruct_imax proc~reconstruct_boundary_state->proc~reconstruct_imax proc~dmsg dmsg proc~reconstruct_boundary_state->proc~dmsg proc~reconstruct_imin reconstruct_imin proc~reconstruct_boundary_state->proc~reconstruct_imin proc~reconstruct_jmax reconstruct_jmax proc~reconstruct_boundary_state->proc~reconstruct_jmax proc~reconstruct_kmin reconstruct_kmin proc~reconstruct_boundary_state->proc~reconstruct_kmin proc~reconstruct_kmax reconstruct_kmax proc~reconstruct_boundary_state->proc~reconstruct_kmax y_qp_left y_qp_left proc~reconstruct_jmin->y_qp_left y_qp_right y_qp_right proc~reconstruct_jmin->y_qp_right x_qp_right x_qp_right proc~reconstruct_imax->x_qp_right x_qp_left x_qp_left proc~reconstruct_imax->x_qp_left proc~reconstruct_imin->x_qp_right proc~reconstruct_imin->x_qp_left proc~reconstruct_jmax->y_qp_left proc~reconstruct_jmax->y_qp_right z_qp_left z_qp_left proc~reconstruct_kmin->z_qp_left z_qp_right z_qp_right proc~reconstruct_kmin->z_qp_right proc~reconstruct_kmax->z_qp_left proc~reconstruct_kmax->z_qp_right Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_boundary_state~~CalledByGraph proc~reconstruct_boundary_state reconstruct_boundary_state proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_boundary_stateCalledByGraph = svgPanZoom('#procreconstruct_boundary_stateCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_boundary_state Source Code subroutine reconstruct_boundary_state ( interpolant ) !< Call reconstruction based on the flag and boundary condition implicit none character ( len =* ), intent ( in ) :: interpolant call dmsg ( 1 , 'boundary_state_recons' , 'recons_boundary_state' ) if ( interpolant == 'ppm' . or . interpolant == 'weno' . or . interpolant == 'weno_NM' ) ppm_flag = 1 if ( imin_id ==- 7 . or . jmin_id ==- 7 . or . kmin_id ==- 7 ) ppm_flag = 1 if ( imax_id ==- 7 . or . jmax_id ==- 7 . or . kmax_id ==- 7 ) ppm_flag = 1 if ( interpolant /= 'none' ) then if ( imin_id < 0 . and . imin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'imin' ) call reconstruct_imin () end if if ( imax_id < 0 . and . imax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'imax' ) call reconstruct_imax () end if if ( jmin_id < 0 . and . jmin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'jmin' ) call reconstruct_jmin () end if if ( jmax_id < 0 . and . jmax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'jmax' ) call reconstruct_jmax () end if if ( kmin_id < 0 . and . kmin_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'kmin' ) call reconstruct_kmin () end if if ( kmax_id < 0 . and . kmax_id /=- 10 ) then call dmsg ( 1 , 'bndry_state_recons' , 'recons_bndry_state' , 'kmax' ) call reconstruct_kmax () end if end if end subroutine reconstruct_boundary_state","tags":"","loc":"proc/reconstruct_boundary_state.html","title":"reconstruct_boundary_state – FEST-3D"},{"text":"private subroutine reconstruct_imin() Reconstruct state at the IMIN boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_imin~~CallsGraph proc~reconstruct_imin reconstruct_imin x_qp_right x_qp_right proc~reconstruct_imin->x_qp_right x_qp_left x_qp_left proc~reconstruct_imin->x_qp_left Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_imin~~CalledByGraph proc~reconstruct_imin reconstruct_imin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_imin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_iminCalledByGraph = svgPanZoom('#procreconstruct_iminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_imin Source Code subroutine reconstruct_imin () !< Reconstruct state at the IMIN boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , 1 ! reconstruct first cell faces for ppm scheme fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right state of firsrt interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of first interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( imin_id ==- 8 . or . imin_id ==- 9 ) then x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else ! right face of first ghost cell x_qp_left ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 0 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imin","tags":"","loc":"proc/reconstruct_imin.html","title":"reconstruct_imin – FEST-3D"},{"text":"private subroutine reconstruct_imax() Reconstruct state at the IMAX boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_imax~~CallsGraph proc~reconstruct_imax reconstruct_imax x_qp_right x_qp_right proc~reconstruct_imax->x_qp_right x_qp_left x_qp_left proc~reconstruct_imax->x_qp_left Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_imax~~CalledByGraph proc~reconstruct_imax reconstruct_imax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_imax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_imaxCalledByGraph = svgPanZoom('#procreconstruct_imaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_imax Source Code subroutine reconstruct_imax () !< Reconstruct state at the IMAX boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = ilimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = itlimiter_switch do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = imx - 1 , imx - 1 fd = qp ( i + 1 , j , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i - 1 , j , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last interior cell x_qp_left ( i + 1 , j , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1. - kappa ) * psi1 * bd ) + (( 1. + kappa ) * psi2 * fd )) ! left face of last interior cell x_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1. + kappa ) * psi1 * bd ) + (( 1. - kappa ) * psi2 * fd )) end do end do end do end do end if if ( imax_id ==- 8 . or . imax_id ==- 9 ) then x_qp_left ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) else x_qp_right ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( imx - 1 , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( imx , 1 : jmx - 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_imax","tags":"","loc":"proc/reconstruct_imax.html","title":"reconstruct_imax – FEST-3D"},{"text":"private subroutine reconstruct_jmin() Reconstruct state at the JMIN boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_jmin~~CallsGraph proc~reconstruct_jmin reconstruct_jmin y_qp_left y_qp_left proc~reconstruct_jmin->y_qp_left y_qp_right y_qp_right proc~reconstruct_jmin->y_qp_right Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_jmin~~CalledByGraph proc~reconstruct_jmin reconstruct_jmin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_jmin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_jminCalledByGraph = svgPanZoom('#procreconstruct_jminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_jmin Source Code subroutine reconstruct_jmin () !< Reconstruct state at the JMIN boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = jtlimiter_switch do k = 1 , kmx - 1 do j = 1 , 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( jmin_id ==- 8 . or . jmin_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var ) else y_qp_left ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 0 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmin","tags":"","loc":"proc/reconstruct_jmin.html","title":"reconstruct_jmin – FEST-3D"},{"text":"private subroutine reconstruct_jmax() Reconstruct state at the JMAX boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_jmax~~CallsGraph proc~reconstruct_jmax reconstruct_jmax y_qp_left y_qp_left proc~reconstruct_jmax->y_qp_left y_qp_right y_qp_right proc~reconstruct_jmax->y_qp_right Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_jmax~~CalledByGraph proc~reconstruct_jmax reconstruct_jmax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_jmax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_jmaxCalledByGraph = svgPanZoom('#procreconstruct_jmaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_jmax Source Code subroutine reconstruct_jmax () !< Reconstruct state at the JMAX boundary face with MUSCL scheme implicit none integer :: i , j , k , l real :: psi1 , psi2 , fd , bd , r real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = jlimiter_switch if ( ppm_flag == 1 ) then do l = 1 , n_var if ( l >= 6 ) switch_L = jtlimiter_switch do k = 1 , kmx - 1 do j = jmx - 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j + 1 , k , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j - 1 , k , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last j cell y_qp_left ( i , j + 1 , k , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last j cell y_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( jmax_id ==- 8 . or . jmax_id ==- 9 ) then y_qp_left ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) else y_qp_right ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , jmx - 1 , 1 : kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , jmx , 1 : kmx - 1 , 1 : n_var )) end if end subroutine reconstruct_jmax","tags":"","loc":"proc/reconstruct_jmax.html","title":"reconstruct_jmax – FEST-3D"},{"text":"private subroutine reconstruct_kmin() Reconstruct state at the KMIN boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_kmin~~CallsGraph proc~reconstruct_kmin reconstruct_kmin z_qp_left z_qp_left proc~reconstruct_kmin->z_qp_left z_qp_right z_qp_right proc~reconstruct_kmin->z_qp_right Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_kmin~~CalledByGraph proc~reconstruct_kmin reconstruct_kmin proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_kmin proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_kminCalledByGraph = svgPanZoom('#procreconstruct_kminCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_kmin Source Code subroutine reconstruct_kmin () !< Reconstruct state at the KMIN boundary face with MUSCL scheme implicit none real :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = klimiter_switch if ( ppm_flag == 1 ) then do k = 1 , 1 do l = 1 , n_var if ( l >= 6 ) switch_L = ktlimiter_switch if ( l < 6 ) switch_L = klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of first k cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of first k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end do end do end do end do end if if ( kmin_id ==- 8 . or . kmin_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var ) else z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , 0 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , 1 , 1 : n_var )) end if end subroutine reconstruct_kmin","tags":"","loc":"proc/reconstruct_kmin.html","title":"reconstruct_kmin – FEST-3D"},{"text":"private subroutine reconstruct_kmax() Reconstruct state at the KMAX boundary face with MUSCL scheme Arguments None Calls proc~~reconstruct_kmax~~CallsGraph proc~reconstruct_kmax reconstruct_kmax z_qp_right z_qp_right proc~reconstruct_kmax->z_qp_right z_qp_left z_qp_left proc~reconstruct_kmax->z_qp_left Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reconstruct_kmax~~CalledByGraph proc~reconstruct_kmax reconstruct_kmax proc~reconstruct_boundary_state reconstruct_boundary_state proc~reconstruct_boundary_state->proc~reconstruct_kmax proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~reconstruct_boundary_state proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocreconstruct_kmaxCalledByGraph = svgPanZoom('#procreconstruct_kmaxCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code reconstruct_kmax Source Code subroutine reconstruct_kmax () !< Reconstruct state at the KMAX boundary face with MUSCL scheme implicit none real :: psi1 , psi2 , fd , bd , r integer :: i , j , k , l real :: kappa , phi phi = 1.0 kappa = 1. / 3. switch_L = klimiter_switch do k = kmx - 1 , kmx - 1 do l = 1 , n_var if ( l >= 6 ) switch_L = ktlimiter_switch if ( l < 6 ) switch_L = klimiter_switch do j = 1 , jmx - 1 do i = 1 , imx - 1 ! left face of kmx ghost cell z_qp_right ( i , j , k + 1 , l ) = 0.5 * ( qp ( i , j , k , l ) + qp ( i , j , k + 1 , l )) if ( ppm_flag == 1 ) then fd = qp ( i , j , k + 1 , l ) - qp ( i , j , k , l ) bd = qp ( i , j , k , l ) - qp ( i , j , k - 1 , l ) r = fd / bd psi1 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi1 = ( 1 - ( 1 - psi1 ) * switch_L ) r = bd / fd psi2 = max ( 0. , min ( 2 * r , ( 2 + r ) / 3. , 2. )) psi2 = ( 1 - ( 1 - psi2 ) * switch_L ) ! right face of last k interior cell z_qp_left ( i , j , k + 1 , l ) = qp ( i , j , k , l ) + 0.25 * phi * & ((( 1 - kappa ) * psi1 * bd ) + (( 1 + kappa ) * psi2 * fd )) ! left face of last k cell z_qp_right ( i , j , k , l ) = qp ( i , j , k , l ) - 0.25 * phi * & ((( 1 + kappa ) * psi1 * bd ) + (( 1 - kappa ) * psi2 * fd )) end if end do end do end do end do if ( kmax_id ==- 8 . or . kmax_id ==- 9 ) then z_qp_left ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) else z_qp_right ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var ) = 0.5 * ( qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx - 1 , 1 : n_var )& + qp ( 1 : imx - 1 , 1 : jmx - 1 , kmx , 1 : n_var )) end if end subroutine reconstruct_kmax","tags":"","loc":"proc/reconstruct_kmax.html","title":"reconstruct_kmax – FEST-3D"},{"text":"public function converged() result(c) Check if the solution seems to have converged\n The solution is said to have converged if the change in \n the residue norm is \"negligible\". Arguments None Return Value logical Called by proc~~converged~~CalledByGraph proc~converged converged program~main main program~main->proc~converged Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code converged Source Code function converged () result ( c ) !< Check if the solution seems to have converged !< The solution is said to have converged if the change in !< the residue norm is \"negligible\". !----------------------------------------------------------- implicit none logical :: c real :: check = 1 0. select case ( trim ( tolerance_type )) !include \"convergence_select.inc\" case ( 'Mass_abs' ) check = Res_abs ( 0 ) case ( 'Resnorm_abs' ) check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) case ( 'Viscous_abs' ) check = sqrt ( sum ( Res_abs ( 1 : 5 ) ** 2 )) case ( 'Turbulent_abs' ) check = sqrt ( sum ( Res_abs ( 6 :) ** 2 )) case ( 'Continuity_abs' ) check = Res_abs ( 1 ) case ( 'X-mom_abs' ) check = Res_abs ( 2 ) case ( 'Z-mom_abs' ) check = Res_abs ( 3 ) case ( 'Y-mom_abs' ) check = Res_abs ( 4 ) case ( 'Energy_abs' ) check = Res_abs ( 5 ) case ( 'Mass_rel' ) check = Res_rel ( 0 ) case ( 'Resnorm_rel' ) check = sqrt ( sum ( Res_rel ( 1 :) ** 2 )) case ( 'Viscous_rel' ) check = sqrt ( sum ( Res_rel ( 1 : 5 ) ** 2 )) case ( 'Turbulent_rel' ) check = sqrt ( sum ( Res_rel ( 6 :) ** 2 )) case ( 'Continuity_rel' ) check = Res_rel ( 1 ) case ( 'X-mom_rel' ) check = Res_rel ( 2 ) case ( 'Z-mom_rel' ) check = Res_rel ( 3 ) case ( 'Y-mom_rel' ) check = Res_rel ( 4 ) case ( 'Energy_rel' ) check = Res_rel ( 5 ) case ( 'TKE_abs' ) check = Res_abs ( 6 ) case ( 'tv_abs' ) check = Res_abs ( 6 ) case ( 'Dissipation_abs' ) check = Res_abs ( 7 ) case ( 'Omega_abs' ) check = Res_abs ( 7 ) case ( 'Kl_abs' ) check = Res_abs ( 7 ) case ( 'TKE_rel' ) check = Res_rel ( 6 ) case ( 'tv_rel' ) check = Res_rel ( 6 ) case ( 'Dissipation_rel' ) check = Res_rel ( 7 ) case ( 'Omega_rel' ) check = Res_rel ( 7 ) case ( 'Kl_rel' ) check = Res_rel ( 7 ) case DEFAULT ! making absolute resnorm default check = sqrt ( sum ( Res_abs ( 1 :) ** 2 )) Issue_warning end select if ( check < tolerance . and . current_iter > 10 ) then c = . TRUE . else c = . FALSE . end if end function converged","tags":"","loc":"proc/converged.html","title":"converged – FEST-3D"},{"text":"public subroutine setup_wall_dist() Allocate memory to the wall_distance variables\n and read the surface node file Arguments None Calls proc~~setup_wall_dist~~CallsGraph proc~setup_wall_dist setup_wall_dist proc~dmsg dmsg proc~setup_wall_dist->proc~dmsg interface~alloc alloc proc~setup_wall_dist->interface~alloc proc~read_destroy_nodefile read_destroy_nodefile proc~setup_wall_dist->proc~read_destroy_nodefile proc~setup_nodefile setup_nodefile proc~setup_wall_dist->proc~setup_nodefile proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~setup_nodefile->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_wall_dist~~CalledByGraph proc~setup_wall_dist setup_wall_dist proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~setup_all setup_all proc~setup_all->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_wall_dist Source Code subroutine setup_wall_dist () !< Allocate memory to the wall_distance variables !< and read the surface node file implicit none call dmsg ( 1 , 'wall_dist' , 'setup_wall_dist' ) call setup_nodefile () call alloc ( wall_x , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_y , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( wall_z , 1 , n_surfnodes ,& \"ERROR: unale to allocate memory to 'Dist' variable \" ) call alloc ( dist , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , & \"ERROR: unale to allocate memory to 'Dist' variable \" ) call read_destroy_nodefile end subroutine setup_wall_dist","tags":"","loc":"proc/setup_wall_dist.html","title":"setup_wall_dist – FEST-3D"},{"text":"public subroutine destroy_wall_dist() Deallocate the memory of wall_distance variable,\n wall_x, wall_y, and wall_z Arguments None Calls proc~~destroy_wall_dist~~CallsGraph proc~destroy_wall_dist destroy_wall_dist interface~dealloc dealloc proc~destroy_wall_dist->interface~dealloc proc~dmsg dmsg proc~destroy_wall_dist->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_wall_dist~~CalledByGraph proc~destroy_wall_dist destroy_wall_dist proc~destroy_all destroy_all proc~destroy_all->proc~destroy_wall_dist proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_wall_dist proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_wall_dist Source Code subroutine destroy_wall_dist () !< Deallocate the memory of wall_distance variable, !< wall_x, wall_y, and wall_z implicit none call dmsg ( 1 , 'wall_dist' , 'destroy_wall_dist' ) call dealloc ( wall_x ) call dealloc ( wall_y ) call dealloc ( wall_z ) call dealloc ( dist ) end subroutine destroy_wall_dist","tags":"","loc":"proc/destroy_wall_dist.html","title":"destroy_wall_dist – FEST-3D"},{"text":"private subroutine setup_nodefile() Open and read first line of surface_node_point file Arguments None Calls proc~~setup_nodefile~~CallsGraph proc~setup_nodefile setup_nodefile proc~dmsg dmsg proc~setup_nodefile->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_nodefile~~CalledByGraph proc~setup_nodefile setup_nodefile proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->proc~setup_nodefile proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~setup_all setup_all proc~setup_all->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_nodefile Source Code subroutine setup_nodefile () !< Open and read first line of surface_node_point file implicit none integer :: ios open ( NODESURF_FILE_UNIT , file = surface_node_points , status = 'old' , IOSTAT = ios ) if ( ios /= 0 ) then call dmsg ( 5 , 'wall_dist' , 'setup_nodefile' , & \"!!! -->file containg surface nodepoints not found\" ) end if read ( NODESURF_FILE_UNIT , * ) n_surfnodes end subroutine setup_nodefile","tags":"","loc":"proc/setup_nodefile.html","title":"setup_nodefile – FEST-3D"},{"text":"private subroutine read_destroy_nodefile() Read, and close surface_node_point file Arguments None Called by proc~~read_destroy_nodefile~~CalledByGraph proc~read_destroy_nodefile read_destroy_nodefile proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->proc~read_destroy_nodefile proc~setup_solver setup_solver proc~setup_solver->proc~setup_wall_dist proc~setup_all setup_all proc~setup_all->proc~setup_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_destroy_nodefile Source Code subroutine read_destroy_nodefile () !< Read, and close surface_node_point file implicit none integer :: i do i = 1 , n_surfnodes read ( NODESURF_FILE_UNIT , * ) wall_x ( i ), wall_y ( i ), wall_z ( i ) end do close ( NODESURF_FILE_UNIT ) end subroutine read_destroy_nodefile","tags":"","loc":"proc/read_destroy_nodefile.html","title":"read_destroy_nodefile – FEST-3D"},{"text":"public subroutine find_wall_dist() Determine the minimum wall distance from the wall surface node points Arguments None Calls proc~~find_wall_dist~~CallsGraph proc~find_wall_dist find_wall_dist interface~dealloc dealloc proc~find_wall_dist->interface~dealloc interface~alloc alloc proc~find_wall_dist->interface~alloc proc~dmsg dmsg proc~find_wall_dist->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~find_wall_dist~~CalledByGraph proc~find_wall_dist find_wall_dist proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_wall_dist Source Code subroutine find_wall_dist () !< Determine the minimum wall distance from the wall surface node points implicit none integer :: i , j , k , n real :: current_dist real , dimension (:,:,:), allocatable :: node_dist call dmsg ( 1 , 'wall_dist' , 'find_wall_dist' ) call alloc ( node_dist , - 2 , imx + 3 , - 2 , jmx + 3 , - 2 , kmx + 3 ) do k = - 2 , kmx + 3 do j = - 2 , jmx + 3 do i = - 2 , imx + 3 node_dist ( i , j , k ) = 1.e+20 do n = 1 , n_surfnodes current_dist = sqrt (( wall_x ( n ) - grid_x ( i , j , k )) ** 2 & + ( wall_y ( n ) - grid_y ( i , j , k )) ** 2 & + ( wall_z ( n ) - grid_z ( i , j , k )) ** 2 & ) node_dist ( i , j , k ) = min ( node_dist ( i , j , k ), current_dist ) end do end do end do end do do k =- 2 , kmx + 2 do j =- 2 , jmx + 2 do i =- 2 , imx + 2 dist ( i , j , k ) = 0.125 * ( node_dist ( i , j , k )& + node_dist ( i , j + 1 , k )& + node_dist ( i , j + 1 , k + 1 )& + node_dist ( i , j , k + 1 )& + node_dist ( i + 1 , j , k + 1 )& + node_dist ( i + 1 , j , k )& + node_dist ( i + 1 , j + 1 , k )& + node_dist ( i + 1 , j + 1 , k + 1 )& ) end do end do end do call dealloc ( node_dist ) call dmsg ( 1 , 'wall_dist' , 'find_wall_dist-> complete' ) end subroutine find_wall_dist","tags":"","loc":"proc/find_wall_dist.html","title":"find_wall_dist – FEST-3D"},{"text":"public subroutine write_surfnode() Extract and write the wall surface node points\n in a file shared by all the MPI processes Arguments None Calls proc~~write_surfnode~~CallsGraph proc~write_surfnode write_surfnode mpi_file_write_shared mpi_file_write_shared proc~write_surfnode->mpi_file_write_shared mpi_bcast mpi_bcast proc~write_surfnode->mpi_bcast mpi_type_commit mpi_type_commit proc~write_surfnode->mpi_type_commit mpi_barrier mpi_barrier proc~write_surfnode->mpi_barrier mpi_gather mpi_gather proc~write_surfnode->mpi_gather proc~destroy_surface destroy_surface proc~write_surfnode->proc~destroy_surface mpi_type_contiguous mpi_type_contiguous proc~write_surfnode->mpi_type_contiguous proc~setup_surface setup_surface proc~write_surfnode->proc~setup_surface proc~surface_points surface_points proc~write_surfnode->proc~surface_points proc~deallocate_memory~3 deallocate_memory proc~destroy_surface->proc~deallocate_memory~3 proc~dmsg dmsg proc~destroy_surface->proc~dmsg mpi_file_close mpi_file_close proc~destroy_surface->mpi_file_close proc~unlink_aliases unlink_aliases proc~destroy_surface->proc~unlink_aliases proc~setup_surface->mpi_barrier proc~find_wall find_wall proc~setup_surface->proc~find_wall proc~link_aliases link_aliases proc~setup_surface->proc~link_aliases proc~allocate_memory~4 allocate_memory proc~setup_surface->proc~allocate_memory~4 mpi_file_open mpi_file_open proc~setup_surface->mpi_file_open proc~setup_surface->proc~dmsg proc~surface_points->proc~dmsg proc~deallocate_memory~3->proc~dmsg interface~dealloc dealloc proc~deallocate_memory~3->interface~dealloc proc~link_aliases->proc~dmsg proc~allocate_memory~4->proc~dmsg interface~alloc alloc proc~allocate_memory~4->interface~alloc proc~unlink_aliases->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_surfnode~~CalledByGraph proc~write_surfnode write_surfnode proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_surfnode Source Code subroutine write_surfnode () !< Extract and write the wall surface node points !< in a file shared by all the MPI processes implicit none integer :: count integer :: i call setup_surface () call surface_points () call MPI_GATHER ( n_wall , 1 , MPI_Integer , n_wall_buf , 1 , & MPI_integer , 0 , MPI_COMM_WORLD , ierr ) total_n_wall = sum ( n_wall_buf (:)) call MPI_Bcast ( total_n_wall , 1 , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) call MPI_Bcast ( n_wall_buf , total_process , MPI_Integer , 0 , & MPI_COMM_WORLD , ierr ) write_flag = 0 count = 0 do i = 1 , total_process if ( n_wall_buf ( i ) > 0 ) then write_flag ( i ) = count count = count + 1 end if end do call MPI_TYPE_CONTIGUOUS ( maxlen , MPI_Character , new_type , ierr ) call MPI_TYPE_COMMIT ( new_type , ierr ) if ( process_id == 0 ) then write ( line , '(I0)' ) total_n_wall line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) if ( n_wall > 0 ) then do i = 1 , n_wall write ( line , '(3(ES18.10E3,4x))' ) wall_x ( i ), wall_y ( i ), wall_z ( i ) line ( len ( line ): len ( line )) = lf call MPI_FILE_WRITE_shared ( thisfile , line , 1 , & new_type , & MPI_STATUS_IGNORE , ierr ) end do end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call destroy_surface () end subroutine write_surfnode","tags":"","loc":"proc/write_surfnode.html","title":"write_surfnode – FEST-3D"},{"text":"private subroutine allocate_memory() Allocate memory to str and wallc variable array Arguments None Calls proc~~allocate_memory~4~~CallsGraph proc~allocate_memory~4 allocate_memory interface~alloc alloc proc~allocate_memory~4->interface~alloc proc~dmsg dmsg proc~allocate_memory~4->proc~dmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~4~~CalledByGraph proc~allocate_memory~4 allocate_memory proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocate memory to str and wallc variable array implicit none call dmsg ( 1 , 'wall_find' , 'setup_surface' ) n_wall = - 1 n_wall = (( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 1 )) & + ( jmx ) * ( kmx ) * ( NO_SLIP_flag ( 2 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 3 )) & + ( kmx ) * ( imx ) * ( NO_SLIP_flag ( 4 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 5 )) & + ( imx ) * ( jmx ) * ( NO_SLIP_flag ( 6 )) & ) allocate ( str ( 1 : n_wall )) call alloc ( wallc , 1 , n_wall , 1 , 3 ,& errmsg = 'Error: Unable to allocate memory for wallc' ) allocate ( n_wall_buf ( 1 : total_process )) allocate ( write_flag ( 1 : total_process )) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~4.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine link_aliases() Link pointers wall_x, wall_y, wall_z to wallc Arguments None Calls proc~~link_aliases~~CallsGraph proc~link_aliases link_aliases proc~dmsg dmsg proc~link_aliases->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~link_aliases~~CalledByGraph proc~link_aliases link_aliases proc~setup_surface setup_surface proc~setup_surface->proc~link_aliases proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code link_aliases Source Code subroutine link_aliases () !< Link pointers wall_x, wall_y, wall_z to wallc implicit none call dmsg ( 1 , 'wall_find' , 'link_aliases' ) wall_x ( 1 : n_wall ) => wallc ( 1 : n_wall , 1 ) wall_y ( 1 : n_wall ) => wallc ( 1 : n_wall , 2 ) wall_z ( 1 : n_wall ) => wallc ( 1 : n_wall , 3 ) end subroutine link_aliases","tags":"","loc":"proc/link_aliases.html","title":"link_aliases – FEST-3D"},{"text":"private subroutine unlink_aliases() Unlink all the pointer used in this module Arguments None Calls proc~~unlink_aliases~~CallsGraph proc~unlink_aliases unlink_aliases proc~dmsg dmsg proc~unlink_aliases->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unlink_aliases~~CalledByGraph proc~unlink_aliases unlink_aliases proc~destroy_surface destroy_surface proc~destroy_surface->proc~unlink_aliases proc~write_surfnode write_surfnode proc~write_surfnode->proc~destroy_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code unlink_aliases Source Code subroutine unlink_aliases () !< Unlink all the pointer used in this module implicit none call dmsg ( 1 , 'wall_find' , 'unlink_aliases' ) nullify ( wall_x ) nullify ( wall_y ) nullify ( wall_z ) end subroutine unlink_aliases","tags":"","loc":"proc/unlink_aliases.html","title":"unlink_aliases – FEST-3D"},{"text":"private subroutine deallocate_memory() Deallocate memory from the Wallc array Arguments None Calls proc~~deallocate_memory~3~~CallsGraph proc~deallocate_memory~3 deallocate_memory interface~dealloc dealloc proc~deallocate_memory~3->interface~dealloc proc~dmsg dmsg proc~deallocate_memory~3->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~deallocate_memory~3~~CalledByGraph proc~deallocate_memory~3 deallocate_memory proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~write_surfnode write_surfnode proc~write_surfnode->proc~destroy_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocdeallocate_memory3CalledByGraph = svgPanZoom('#procdeallocate_memory3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code deallocate_memory Source Code subroutine deallocate_memory () !< Deallocate memory from the Wallc array implicit none call dmsg ( 1 , 'wall_find' , 'dealloate_memory' ) call dealloc ( wallc ) end subroutine deallocate_memory","tags":"","loc":"proc/deallocate_memory~3.html","title":"deallocate_memory – FEST-3D"},{"text":"private subroutine setup_surface() Open MPI_shared write file, allocate memory and\n setup pointers Arguments None Calls proc~~setup_surface~~CallsGraph proc~setup_surface setup_surface proc~dmsg dmsg proc~setup_surface->proc~dmsg proc~link_aliases link_aliases proc~setup_surface->proc~link_aliases proc~allocate_memory~4 allocate_memory proc~setup_surface->proc~allocate_memory~4 mpi_file_open mpi_file_open proc~setup_surface->mpi_file_open mpi_barrier mpi_barrier proc~setup_surface->mpi_barrier proc~find_wall find_wall proc~setup_surface->proc~find_wall proc~link_aliases->proc~dmsg proc~allocate_memory~4->proc~dmsg interface~alloc alloc proc~allocate_memory~4->interface~alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_surface~~CalledByGraph proc~setup_surface setup_surface proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_surface Source Code subroutine setup_surface () !< Open MPI_shared write file, allocate memory and !< setup pointers implicit none integer :: stat call dmsg ( 1 , 'wall_find' , 'setup_surface' ) if ( process_id == 0 ) then open ( NODESURF_FILE_UNIT , file = surface_node_points , iostat = stat ) if ( stat == 0 ) close ( NODESURF_FILE_UNIT , status = 'delete' ) end if call mpi_barrier ( MPI_COMM_WORLD , ierr ) call MPI_FILE_OPEN ( MPI_COMM_WORLD , surface_node_points , & MPI_MODE_WRONLY + MPI_MODE_CREATE + MPI_MODE_EXCL , & MPI_INFO_NULL , thisfile , ierr ) call find_wall () call allocate_memory () call link_aliases () end subroutine setup_surface","tags":"","loc":"proc/setup_surface.html","title":"setup_surface – FEST-3D"},{"text":"private subroutine destroy_surface() Deallocate memory, unlink pointers, and close MPI_shared file Arguments None Calls proc~~destroy_surface~~CallsGraph proc~destroy_surface destroy_surface proc~deallocate_memory~3 deallocate_memory proc~destroy_surface->proc~deallocate_memory~3 mpi_file_close mpi_file_close proc~destroy_surface->mpi_file_close proc~dmsg dmsg proc~destroy_surface->proc~dmsg proc~unlink_aliases unlink_aliases proc~destroy_surface->proc~unlink_aliases proc~deallocate_memory~3->proc~dmsg interface~dealloc dealloc proc~deallocate_memory~3->interface~dealloc proc~unlink_aliases->proc~dmsg proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_surface~~CalledByGraph proc~destroy_surface destroy_surface proc~write_surfnode write_surfnode proc~write_surfnode->proc~destroy_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_surface Source Code subroutine destroy_surface () !< Deallocate memory, unlink pointers, and close MPI_shared file implicit none call dmsg ( 1 , 'wall_find' , 'destroy_surface' ) call deallocate_memory () call unlink_aliases () call MPI_FILE_CLOSE ( thisfile , ierr ) end subroutine destroy_surface","tags":"","loc":"proc/destroy_surface.html","title":"destroy_surface – FEST-3D"},{"text":"private subroutine find_wall() Setup wall flag for all six boundary of the block Arguments None Called by proc~~find_wall~~CalledByGraph proc~find_wall find_wall proc~setup_surface setup_surface proc~setup_surface->proc~find_wall proc~write_surfnode write_surfnode proc~write_surfnode->proc~setup_surface proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code find_wall Source Code subroutine find_wall () !< Setup wall flag for all six boundary of the block implicit none integer :: i NO_slip_flag = 0 do i = 1 , 6 if ( id ( i ) ==- 5 ) NO_SLIP_FLAG ( i ) = 1 end do end subroutine find_wall","tags":"","loc":"proc/find_wall.html","title":"find_wall – FEST-3D"},{"text":"private subroutine surface_points() Extract surface points and store them\n in a string vector str(ind) Arguments None Calls proc~~surface_points~~CallsGraph proc~surface_points surface_points proc~dmsg dmsg proc~surface_points->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~surface_points~~CalledByGraph proc~surface_points surface_points proc~write_surfnode write_surfnode proc~write_surfnode->proc~surface_points proc~setup_solver setup_solver proc~setup_solver->proc~write_surfnode proc~setup_all setup_all proc~setup_all->proc~write_surfnode proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code surface_points Source Code subroutine surface_points () !< Extract surface points and store them !< in a string vector str(ind) implicit none integer :: OL integer :: i , j , k , ind integer :: im = 1 , ix = 1 integer :: jm = 1 , jx = 1 integer :: km = 1 , kx = 1 call dmsg ( 1 , 'wall_find' , 'surface_points' ) ind = 0 do OL = 1 , 6 if ( NO_SLIP_flag ( OL ) == 1 ) then select case ( OL ) case ( 1 ) km = 1 jm = 1 im = 1 kx = kmx jx = jmx ix = 1 case ( 2 ) km = 1 jm = 1 im = imx kx = kmx jx = jmx ix = imx case ( 3 ) km = 1 jm = 1 im = 1 kx = kmx jx = 1 ix = imx case ( 4 ) km = 1 jm = jmx im = 1 kx = kmx jx = jmx ix = imx case ( 5 ) km = 1 jm = 1 im = 1 kx = 1 jx = jmx ix = imx case ( 6 ) km = kmx jm = 1 im = 1 kx = kmx jx = jmx ix = imx case DEFAULT call dmsg ( 5 , \"wall_find\" , 'Surface_points' , 'FATAL  ERROR: select case' ) km = 1 jm = 1 im = 1 kx = - 1 jx = - 1 ix = - 1 end select do k = km , kx do j = jm , jx do i = im , ix ind = ind + 1 wall_x ( ind ) = grid_x ( i , j , k ) wall_y ( ind ) = grid_y ( i , j , k ) wall_z ( ind ) = grid_z ( i , j , k ) write ( str ( ind ), '(3(f0.16, 4x))' ) wall_x ( ind ), wall_y ( ind ), wall_z ( ind ) end do end do end do end if end do end subroutine surface_points","tags":"","loc":"proc/surface_points.html","title":"surface_points – FEST-3D"},{"text":"public subroutine write_file() Write output file in the tecplot format with node data Arguments None Calls proc~~write_file~~CallsGraph proc~write_file write_file proc~write_scalar write_scalar proc~write_file->proc~write_scalar proc~write_header write_header proc~write_file->proc~write_header proc~write_grid write_grid proc~write_file->proc~write_grid proc~dmsg dmsg proc~write_scalar->proc~dmsg proc~write_header->proc~dmsg proc~write_grid->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file () !< Write output file in the tecplot format with node data implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) ! case('Wall_distance') !   call write_scalar(dist, \"Wall_dist\", 1) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) ! case('Mass_residue') !   call write_scalar(mass_residue, \"Mass_residue\", 1) ! case('X_mom_residue') !   call write_scalar(x_mom_residue, \"X_mom_residue\", 1) ! case('Y_mom_residue') !   call write_scalar(y_mom_residue, \"Y_mom_residue\", 1) ! case('Z_mom_residue') !   call write_scalar(z_mom_residue, \"Z_mom_residue\", 1) ! case('Energy_residue') !   call write_scalar(energy_residue, \"Energy_residue\", 1) case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header() Write the header in the output file Arguments None Calls proc~~write_header~~CallsGraph proc~write_header write_header proc~dmsg dmsg proc~write_header->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~~CalledByGraph proc~write_header write_header proc~write_file write_file proc~write_file->proc~write_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header () !< Write the header in the output file implicit none integer :: n integer :: total call dmsg ( 1 , 'write_output_vtk' , 'write_header' ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx - 1 , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=Nodal)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , checkpoint_iter_count end subroutine write_header","tags":"","loc":"proc/write_header.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid() Write grid information in the output file Arguments None Calls proc~~write_grid~~CallsGraph proc~write_grid write_grid proc~dmsg dmsg proc~write_grid->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~~CalledByGraph proc~write_grid write_grid proc~write_file write_file proc~write_file->proc~write_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid () !< Write grid information in the output file implicit none ! write grid point coordinates call dmsg ( 1 , 'write_output_tec_node' , 'write_grid' ) write ( OUT_FILE_UNIT , format ) ((( grid_x ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( grid_y ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) write ( OUT_FILE_UNIT , format ) ((( grid_z ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_grid","tags":"","loc":"proc/write_grid.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~~CallsGraph proc~write_scalar write_scalar proc~dmsg dmsg proc~write_scalar->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~~CalledByGraph proc~write_scalar write_scalar proc~write_file write_file proc~write_file->proc~write_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'write_output_tec_node' , trim ( name )) write ( OUT_FILE_UNIT , format ) ((( 0.25 * ( var ( i , j , k ) + var ( i - 1 , j , k )& + var ( i , j - 1 , k ) + var ( i - 1 , j - 1 , k ))& , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx - 1 ) end subroutine write_scalar","tags":"","loc":"proc/write_scalar.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine write_file() Write the header and variables in the file \"process_xx.dat\" Arguments None Calls proc~~write_file~2~~CallsGraph proc~write_file~2 write_file proc~write_grid~2 write_grid proc~write_file~2->proc~write_grid~2 proc~write_resnorm~2 write_resnorm proc~write_file~2->proc~write_resnorm~2 proc~write_scalar~2 write_scalar proc~write_file~2->proc~write_scalar~2 debugcall debugcall proc~write_file~2->debugcall proc~write_velocity write_velocity proc~write_file~2->proc~write_velocity proc~write_header~2 write_header proc~write_file~2->proc~write_header~2 proc~write_grid~2->debugcall proc~write_resnorm~2->debugcall proc~write_scalar~2->debugcall proc~write_velocity->debugcall proc~write_header~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file () !< Write the header and variables in the file \"process_xx.dat\" implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_velocity () case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Dissipation' ) call write_scalar ( te , \"Dissipation\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"dist\" , - 2 ) case ( 'Resnorm' ) call write_resnorm () case ( 'TKE_residue' ) call write_scalar ( TKE_residue , \"TKE_residue\" , 1 ) case ( 'Tv_residue' ) call write_scalar ( Tv_residue , \"Tv_residue\" , 1 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'y-mom-residue' ) call write_scalar ( y_mom_residue , 'Y_mom_residue' , 1 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) case ( 'extravar1' ) if ( allocated ( ExtraVar1 )) then call write_scalar ( ExtraVar1 , \"ExtraVar1\" , - 2 ) else Issue_warning end if case ( 'extravar2' ) if ( allocated ( ExtraVar2 )) then call write_scalar ( ExtraVar2 , \"ExtraVar2\" , - 2 ) else Issue_warning end if case ( 'extravar3' ) if ( allocated ( ExtraVar3 )) then call write_scalar ( ExtraVar3 , \"ExtraVar3\" , - 2 ) else Issue_warning end if case ( 'extravar4' ) if ( allocated ( ExtraVar4 )) then call write_scalar ( ExtraVar4 , \"ExtraVar4\" , - 2 ) else Issue_warning end if case ( 'extravar5' ) if ( allocated ( ExtraVar5 )) then call write_scalar ( ExtraVar5 , \"ExtraVar5\" , - 2 ) else Issue_warning end if case ( 'do not write' ) ! do nothing continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file~2.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header() Write the header in the output file in the tecplot format Arguments None Calls proc~~write_header~2~~CallsGraph proc~write_header~2 write_header debugcall debugcall proc~write_header~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~2~~CalledByGraph proc~write_header~2 write_header proc~write_file~2 write_file proc~write_file~2->proc~write_header~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header () !< Write the header in the output file in the tecplot format implicit none DebugCall ( \"write_header\" ) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a)' ) '# vtk DataFile Version 3.1' write ( OUT_FILE_UNIT , '(a)' ) 'cfd-iitm output' ! comment line write ( OUT_FILE_UNIT , '(a)' ) trim ( Write_data_format ) write ( OUT_FILE_UNIT , '(a)' ) 'DATASET STRUCTURED_GRID' !write(OUT_FILE_UNIT, *) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) '# vtk DataFile Version 3.1' // newline write ( OUT_FILE_UNIT ) 'cfd-iitm output' // newline write ( OUT_FILE_UNIT ) trim ( Write_data_format ) // newline write ( OUT_FILE_UNIT ) 'DATASET STRUCTURED_GRID' // newline write ( OUT_FILE_UNIT ) newline end if end subroutine write_header","tags":"","loc":"proc/write_header~2.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid() Write the grid information in the output file Arguments None Calls proc~~write_grid~2~~CallsGraph proc~write_grid~2 write_grid debugcall debugcall proc~write_grid~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~2~~CalledByGraph proc~write_grid~2 write_grid proc~write_file~2 write_file proc~write_file~2->proc~write_grid~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid () !< Write the grid information in the output file implicit none ! write grid point coordinates DebugCall ( \"write_grid\" ) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a, i0, a, i0, a, i0)' ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT , fmt = '(a, i0, a)' ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT , fmt = '(f0.16, a, f0.16, a, f0.16)' ) & grid_x ( i , j , k ), ' ' , grid_y ( i , j , k ), ' ' , grid_z ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) & 'DIMENSIONS ' , imx , ' ' , jmx , ' ' , kmx write ( OUT_FILE_UNIT ) & 'POINTS ' , imx * jmx * kmx , ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx write ( OUT_FILE_UNIT ) & grid_x ( i , j , k ), ' ' , grid_y ( i , j , k ), ' ' , grid_z ( i , j , k ), newline end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_grid","tags":"","loc":"proc/write_grid~2.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_velocity() Write the velocity vector in the output file Arguments None Calls proc~~write_velocity~~CallsGraph proc~write_velocity write_velocity debugcall debugcall proc~write_velocity->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_velocity~~CalledByGraph proc~write_velocity write_velocity proc~write_file~2 write_file proc~write_file~2->proc~write_velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_velocity Source Code subroutine write_velocity () !< Write the velocity vector in the output file implicit none DebugCall ( \"write_velocity\" ) ! Cell data ! Writing Velocity if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , fmt = '(a, i0)' ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT , '(a)' ) 'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES27.16E4, a, ES27.16E4, a, ES27.16E4)' ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'CELL_DATA ' , ( imx - 1 ) * ( jmx - 1 ) * ( kmx - 1 ) write ( OUT_FILE_UNIT ) 'VECTORS Velocity DOUBLE' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT ) & x_speed ( i , j , k ), ' ' , y_speed ( i , j , k ), ' ' , z_speed ( i , j , k ), newline end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_velocity","tags":"","loc":"proc/write_velocity.html","title":"write_velocity – FEST-3D"},{"text":"private subroutine write_resnorm() Write the residual information in the output file Arguments None Calls proc~~write_resnorm~2~~CallsGraph proc~write_resnorm~2 write_resnorm debugcall debugcall proc~write_resnorm~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_resnorm~2~~CalledByGraph proc~write_resnorm~2 write_resnorm proc~write_file~2 write_file proc~write_file~2->proc~write_resnorm~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_resnorm Source Code subroutine write_resnorm () !< Write the residual information in the output file implicit none DebugCall ( \"write_resnorm\" ) ! Writing resnorm for each cell if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS Resnorm FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' speed_inf = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 & + z_speed_inf ** 2 ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 energy_resnorm = ( & ( & energy_residue ( i , j , k ) / & ( density_inf * speed_inf * & (( 0.5 * speed_inf * speed_inf ) + & ( gm / ( gm - 1 ) * pressure_inf / density_inf )))& ) ** 2 & ) x_mom_resnorm = ( & ( x_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) y_mom_resnorm = ( & ( y_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) z_mom_resnorm = ( & ( z_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) cont_resnorm = ( & ( mass_residue ( i , j , k ) / & ( density_inf * speed_inf )) ** 2 & ) vis_resnorm = sqrt ( & cont_resnorm + & x_mom_resnorm + & y_mom_resnorm + & z_mom_resnorm + & energy_resnorm & ) write ( OUT_FILE_UNIT , fmt = '(f0.16)' ) vis_resnorm end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'SCALARS Resnorm DOUBLE' write ( OUT_FILE_UNIT ) 'LOOKUP_TABLE default' speed_inf = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 & + z_speed_inf ** 2 ) do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 energy_resnorm = ( & ( & energy_residue ( i , j , k ) / & ( density_inf * speed_inf * & (( 0.5 * speed_inf * speed_inf ) + & ( gm / ( gm - 1 ) * pressure_inf / density_inf )))& ) ** 2 & ) x_mom_resnorm = ( & ( x_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) y_mom_resnorm = ( & ( y_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) z_mom_resnorm = ( & ( z_mom_residue ( i , j , k ) / & ( density_inf * speed_inf ** 2 )) ** 2 & ) cont_resnorm = ( & ( mass_residue ( i , j , k ) / & ( density_inf * speed_inf )) ** 2 & ) vis_resnorm = sqrt ( & cont_resnorm + & x_mom_resnorm + & y_mom_resnorm + & z_mom_resnorm + & energy_resnorm & ) write ( OUT_FILE_UNIT ) vis_resnorm end do end do end do write ( OUT_FILE_UNIT ) end if end subroutine write_resnorm","tags":"","loc":"proc/write_resnorm~2.html","title":"write_resnorm – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~2~~CallsGraph proc~write_scalar~2 write_scalar debugcall debugcall proc~write_scalar~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~2~~CalledByGraph proc~write_scalar~2 write_scalar proc~write_file~2 write_file proc~write_file~2->proc~write_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name character ( len = 128 ) :: line DebugCall ( \"write_scalar: \" // trim ( name )) if ( Write_data_format == \"ASCII\" ) then write ( OUT_FILE_UNIT , '(a)' ) 'SCALARS ' // trim ( name ) // ' FLOAT' write ( OUT_FILE_UNIT , '(a)' ) 'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( OUT_FILE_UNIT , fmt = '(ES25.16E4)' ) var ( i , j , k ) end do end do end do write ( OUT_FILE_UNIT , * ) elseif ( write_data_format == 'BINARY' ) then write ( OUT_FILE_UNIT ) 'SCALARS ' // trim ( name ) // ' FLOAT' // newline write ( OUT_FILE_UNIT ) 'LOOKUP_TABLE default' // newline do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 write ( line , \"(ES28.16E4)\" ) var ( i , j , k ) write ( OUT_FILE_UNIT ) trim ( line ) // newline end do end do end do write ( OUT_FILE_UNIT ) newline end if end subroutine write_scalar","tags":"","loc":"proc/write_scalar~2.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine write_file() Write the header and variables in the file \"process_xx.dat\". Arguments None Calls proc~~write_file~3~~CallsGraph proc~write_file~3 write_file proc~write_scalar~3 write_scalar proc~write_file~3->proc~write_scalar~3 proc~write_grid~3 write_grid proc~write_file~3->proc~write_grid~3 proc~write_header~3 write_header proc~write_file~3->proc~write_header~3 debugcall debugcall proc~write_file~3->debugcall proc~write_scalar~3->debugcall proc~write_grid~3->debugcall proc~write_header~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file () !< Write the header and variables in the file \"process_xx.dat\". implicit none integer :: n character ( len =* ), parameter :: err = \"Write error: Asked to write non-existing variable- \" DebugCall ( \"write_file\" ) call write_header () call write_grid () do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) call write_scalar ( x_speed , \"u\" , - 2 ) call write_scalar ( y_speed , \"v\" , - 2 ) call write_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call write_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call write_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'Mu' ) call write_scalar ( mu , \"Mu\" , - 2 ) case ( 'Mu_t' ) call write_scalar ( mu_t , \"Mu_t\" , - 2 ) case ( 'TKE' ) call write_scalar ( tk , \"TKE\" , - 2 ) case ( 'Omega' ) call write_scalar ( tw , \"Omega\" , - 2 ) case ( 'Kl' ) call write_scalar ( tkl , \"Kl\" , - 2 ) case ( 'tv' ) call write_scalar ( tv , \"tv\" , - 2 ) case ( 'tgm' ) call write_scalar ( tgm , \"tgm\" , - 2 ) case ( 'Wall_distance' ) call write_scalar ( dist , \"Wall_dist\" , - 2 ) case ( 'F1' ) call write_scalar ( sst_F1 , \"F1\" , - 2 ) case ( 'Dudx' ) call write_scalar ( gradu_x , \"dudx \" , 0 ) case ( 'Dudy' ) call write_scalar ( gradu_y , \"dudy \" , 0 ) case ( 'Dudz' ) call write_scalar ( gradu_z , \"dudz \" , 0 ) case ( 'Dvdx' ) call write_scalar ( gradv_x , \"dvdx \" , 0 ) case ( 'Dvdy' ) call write_scalar ( gradv_y , \"dvdy \" , 0 ) case ( 'Dvdz' ) call write_scalar ( gradv_z , \"dvdz \" , 0 ) case ( 'Dwdx' ) call write_scalar ( gradw_x , \"dwdx \" , 0 ) case ( 'Dwdy' ) call write_scalar ( gradw_y , \"dwdy \" , 0 ) case ( 'Dwdz' ) call write_scalar ( gradw_z , \"dwdz \" , 0 ) case ( 'DTdx' ) call write_scalar ( gradT_x , \"dTdx \" , 0 ) case ( 'DTdy' ) call write_scalar ( gradT_y , \"dTdy \" , 0 ) case ( 'DTdz' ) call write_scalar ( gradT_z , \"dTdz \" , 0 ) case ( 'Dtkdx' ) call write_scalar ( gradtk_x , \"dtkdx\" , 0 ) case ( 'Dtkdy' ) call write_scalar ( gradtk_y , \"dtkdy\" , 0 ) case ( 'Dtkdz' ) call write_scalar ( gradtk_z , \"dtkdz\" , 0 ) case ( 'Dtwdx' ) call write_scalar ( gradtw_x , \"dtwdx\" , 0 ) case ( 'Dtwdy' ) call write_scalar ( gradtw_y , \"dtwdy\" , 0 ) case ( 'Dtwdz' ) call write_scalar ( gradtw_z , \"dtwdz\" , 0 ) case ( 'Mass_residue' ) call write_scalar ( mass_residue , \"Mass_residue\" , 1 ) case ( 'X_mom_residue' ) call write_scalar ( x_mom_residue , \"X_mom_residue\" , 1 ) case ( 'Y_mom_residue' ) call write_scalar ( y_mom_residue , \"Y_mom_residue\" , 1 ) case ( 'Z_mom_residue' ) call write_scalar ( z_mom_residue , \"Z_mom_residue\" , 1 ) case ( 'Energy_residue' ) call write_scalar ( energy_residue , \"Energy_residue\" , 1 ) case ( 'TKE_residue' ) call write_scalar ( tke_residue , \"TKE_residue\" , 1 ) case ( 'Omega_residue' ) call write_scalar ( omega_residue , \"Omega_residue\" , 1 ) case ( 'Tv_residue' ) call write_scalar ( tv_residue , \"Tv_residue\" , 1 ) case ( 'Intermittency' ) call write_scalar ( intermittency , \"Intermittency\" , - 2 ) case ( 'extravar1' ) if ( allocated ( ExtraVar1 )) then call write_scalar ( ExtraVar1 , \"ExtraVar1\" , - 2 ) else Issue_warning end if case ( 'extravar2' ) if ( allocated ( ExtraVar2 )) then call write_scalar ( ExtraVar2 , \"ExtraVar2\" , - 2 ) else Issue_warning end if case ( 'extravar3' ) if ( allocated ( ExtraVar3 )) then call write_scalar ( ExtraVar3 , \"ExtraVar3\" , - 2 ) else Issue_warning end if case ( 'extravar4' ) if ( allocated ( ExtraVar4 )) then call write_scalar ( ExtraVar4 , \"ExtraVar4\" , - 2 ) else Issue_warning end if case ( 'extravar5' ) if ( allocated ( ExtraVar5 )) then call write_scalar ( ExtraVar5 , \"ExtraVar5\" , - 2 ) else Issue_warning end if case ( 'do not write' ) ! do not write continue case Default print * , err // trim ( w_list ( n )) // \" to file\" end select end do end subroutine write_file","tags":"","loc":"proc/write_file~3.html","title":"write_file – FEST-3D"},{"text":"private subroutine write_header() Write the header in the output file in the tecplot format Arguments None Calls proc~~write_header~3~~CallsGraph proc~write_header~3 write_header debugcall debugcall proc~write_header~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_header~3~~CalledByGraph proc~write_header~3 write_header proc~write_file~3 write_file proc~write_file~3->proc~write_header~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_header Source Code subroutine write_header () !< Write the header in the output file in the tecplot format implicit none integer :: n integer :: total DebugCall ( \"write_header\" ) write ( OUT_FILE_UNIT , '(a)' ) \"variables = x y z \" total = 3 do n = 1 , w_count select case ( trim ( w_list ( n ))) case ( 'Velocity' ) write ( OUT_FILE_UNIT , '(a)' ) \" u v w \" total = total + 3 case ( 'do not write' ) !skip continue case Default write ( OUT_FILE_UNIT , '(a)' ) trim ( w_list ( n )) // \" \" total = total + 1 end select end do write ( OUT_FILE_UNIT , '(a,i4.4,3(a,i5.5),a)' ) \"zone T=block\" , process_id , \"  i=\" , imx , \" j=\" , jmx , \" k=\" , kmx , \" Datapacking=Block\" write ( OUT_FILE_UNIT , * ) \"Varlocation=([1-3]=Nodal)\" write ( OUT_FILE_UNIT , '(a,i2.2,a)' ) \"Varlocation=([4-\" , total , \"]=CELLCENTERED)\" write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"STRANDID=\" , 1 write ( OUT_FILE_UNIT , \"(a,i4.4)\" ) \"SOLUTIONTIME=\" , checkpoint_iter_count end subroutine write_header","tags":"","loc":"proc/write_header~3.html","title":"write_header – FEST-3D"},{"text":"private subroutine write_grid() Write the grid information in the output file Arguments None Calls proc~~write_grid~3~~CallsGraph proc~write_grid~3 write_grid debugcall debugcall proc~write_grid~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_grid~3~~CalledByGraph proc~write_grid~3 write_grid proc~write_file~3 write_file proc~write_file~3->proc~write_grid~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_grid Source Code subroutine write_grid () !< Write the grid information in the output file implicit none ! write grid point coordinates DebugCall ( \"write_grid\" ) write ( OUT_FILE_UNIT , format ) ((( grid_x ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( grid_y ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) write ( OUT_FILE_UNIT , format ) ((( grid_z ( i , j , k ), i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine write_grid","tags":"","loc":"proc/write_grid~3.html","title":"write_grid – FEST-3D"},{"text":"private subroutine write_scalar(var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~write_scalar~3~~CallsGraph proc~write_scalar~3 write_scalar debugcall debugcall proc~write_scalar~3->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_scalar~3~~CalledByGraph proc~write_scalar~3 write_scalar proc~write_file~3 write_file proc~write_file~3->proc~write_scalar~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_scalar Source Code subroutine write_scalar ( var , name , index ) !< Write the scalar variable in the output file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( in ) :: var character ( len =* ), intent ( in ) :: name DebugCall ( \"write_scalar: \" // trim ( name )) write ( OUT_FILE_UNIT , format ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine write_scalar","tags":"","loc":"proc/write_scalar~3.html","title":"write_scalar – FEST-3D"},{"text":"public subroutine checkpoint() Create a checkpoint dump file if the time has come Arguments None Calls proc~~checkpoint~~CallsGraph proc~checkpoint checkpoint proc~dump_data dump_data proc~checkpoint->proc~dump_data proc~purge_dump_dir purge_dump_dir proc~checkpoint->proc~purge_dump_dir proc~dmsg dmsg proc~checkpoint->proc~dmsg proc~make_dump_dir make_dump_dir proc~checkpoint->proc~make_dump_dir proc~dump_data->proc~dmsg proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory proc~create_directory create_directory proc~make_dump_dir->proc~create_directory proc~write_restart_log->proc~dmsg proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm proc~write_file~4->proc~dmsg proc~close_file close_file proc~write_file~4->proc~close_file write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec proc~close_file->proc~dmsg proc~open_file->proc~dmsg proc~setup_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~checkpoint~~CalledByGraph proc~checkpoint checkpoint proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code checkpoint Source Code subroutine checkpoint () !< Create a checkpoint dump file if the time has come !----------------------------------------------------------- implicit none if ( checkpoint_iter . ne . 0 ) then if ( mod ( current_iter , checkpoint_iter ) == 0 & . or . current_iter == max_iters ) then call make_dump_dir () call dump_data () print * , \"writing data at: \" , current_iter , checkpoint_iter_count call purge_dump_dir () checkpoint_iter_count = checkpoint_iter_count + 1 call dmsg ( 3 , 'dump_solution' , 'checkpoint' , & 'Checkpoint created at iteration: ' + current_iter ) end if end if end subroutine checkpoint","tags":"","loc":"proc/checkpoint.html","title":"checkpoint – FEST-3D"},{"text":"private subroutine create_directory(dirname) Create a directory to keep the solution files from all the processor Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Called by proc~~create_directory~~CalledByGraph proc~create_directory create_directory proc~make_dump_dir make_dump_dir proc~make_dump_dir->proc~create_directory proc~checkpoint checkpoint proc~checkpoint->proc~make_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panproccreate_directoryCalledByGraph = svgPanZoom('#proccreate_directoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code create_directory Source Code subroutine create_directory ( dirname ) !< Create a directory to keep the solution files from all the processor implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: mkdircmd mkdircmd = 'mkdir -p ' // trim ( dirname ) call system ( mkdircmd ) end subroutine create_directory","tags":"","loc":"proc/create_directory.html","title":"create_directory – FEST-3D"},{"text":"private subroutine remove_directory(dirname) Remove a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname Called by proc~~remove_directory~~CalledByGraph proc~remove_directory remove_directory proc~purge_dump_dir purge_dump_dir proc~purge_dump_dir->proc~remove_directory proc~checkpoint checkpoint proc~checkpoint->proc~purge_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocremove_directoryCalledByGraph = svgPanZoom('#procremove_directoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code remove_directory Source Code subroutine remove_directory ( dirname ) !< Remove a directory implicit none character ( len =* ), intent ( in ) :: dirname character ( len = FILE_NAME_LENGTH ) :: rmdircmd rmdircmd = 'rm -rf ' // trim ( dirname ) call system ( rmdircmd ) end subroutine remove_directory","tags":"","loc":"proc/remove_directory.html","title":"remove_directory – FEST-3D"},{"text":"private subroutine purge_dump_dir() Purge the directory based on the input Arguments None Calls proc~~purge_dump_dir~~CallsGraph proc~purge_dump_dir purge_dump_dir proc~remove_directory remove_directory proc~purge_dump_dir->proc~remove_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~purge_dump_dir~~CalledByGraph proc~purge_dump_dir purge_dump_dir proc~checkpoint checkpoint proc~checkpoint->proc~purge_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code purge_dump_dir Source Code subroutine purge_dump_dir () !< Purge the directory based on the input implicit none integer :: purge_num purge_num = checkpoint_iter_count - purge_write if ( purge_write /= 0 . and . purge_num > 0 ) then write ( purge_dirname , '(A,I4.4)' ) 'time_directories/' , purge_num call remove_directory ( purge_dirname ) end if end subroutine purge_dump_dir","tags":"","loc":"proc/purge_dump_dir.html","title":"purge_dump_dir – FEST-3D"},{"text":"private subroutine make_dump_dir() Solution directory and sub-directory in created with particular number Arguments None Calls proc~~make_dump_dir~~CallsGraph proc~make_dump_dir make_dump_dir proc~create_directory create_directory proc~make_dump_dir->proc~create_directory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~make_dump_dir~~CalledByGraph proc~make_dump_dir make_dump_dir proc~checkpoint checkpoint proc~checkpoint->proc~make_dump_dir proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code make_dump_dir Source Code subroutine make_dump_dir () !< Solution directory and sub-directory in created with particular number implicit none write ( dump_dirname , '(A,I4.4)' ) 'time_directories/' , checkpoint_iter_count call create_directory ( dump_dirname ) call create_directory ( trim ( dump_dirname ) // '/restart' ) end subroutine make_dump_dir","tags":"","loc":"proc/make_dump_dir.html","title":"make_dump_dir – FEST-3D"},{"text":"private subroutine dump_data() Call to write save files in the directory Arguments None Calls proc~~dump_data~~CallsGraph proc~dump_data dump_data proc~dmsg dmsg proc~dump_data->proc~dmsg proc~write_restart_log write_restart_log proc~dump_data->proc~write_restart_log proc~write_file~4 write_file proc~dump_data->proc~write_file~4 proc~write_restart_log->proc~dmsg proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm proc~write_file~4->proc~dmsg proc~close_file close_file proc~write_file~4->proc~close_file write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec proc~close_file->proc~dmsg proc~open_file->proc~dmsg proc~setup_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~dump_data~~CalledByGraph proc~dump_data dump_data proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dump_data Source Code subroutine dump_data () !< Call to write save files in the directory implicit none !      character(len=FILE_NAME_LENGTH) :: filename call dmsg ( 1 , 'dump_solution' , 'dump_data' ) write ( restartfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/restart/process_' , process_id write ( outfile , '(A,I2.2)' ) trim ( dump_dirname ) // '/process_' , process_id call write_restart_log () call write_file () end subroutine dump_data","tags":"","loc":"proc/dump_data.html","title":"dump_data – FEST-3D"},{"text":"private subroutine write_restart_log() Call to write log file in the subdirectory \"restart\". \n It is useful information while restarting the solver Arguments None Calls proc~~write_restart_log~~CallsGraph proc~write_restart_log write_restart_log proc~dmsg dmsg proc~write_restart_log->proc~dmsg proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log->proc~write_initial_resnorm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_restart_log~~CalledByGraph proc~write_restart_log write_restart_log proc~dump_data dump_data proc~dump_data->proc~write_restart_log proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocwrite_restart_logCalledByGraph = svgPanZoom('#procwrite_restart_logCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_restart_log Source Code subroutine write_restart_log () !< Call to write log file in the subdirectory \"restart\". !< It is useful information while restarting the solver implicit none open ( RESTART_FILE_UNIT , file = restartfile ) select case ( turbulence ) case ( 'none' ) write ( RESTART_FILE_UNIT , '(A)' ) 'viscous' case ( 'sst' , 'sst2003' , 'kkl' , 'ke' , 'kw' , 'sa' , 'saBC' , 'des-sst' ) write ( RESTART_FILE_UNIT , '(A)' ) trim ( turbulence ) case DEFAULT call dmsg ( 5 , 'dump_solution' , 'write_restart_log' ,& 'ERROR: Turbulence model not recognised' ) end select call write_initial_resnorm () close ( RESTART_FILE_UNIT ) end subroutine write_restart_log","tags":"","loc":"proc/write_restart_log.html","title":"write_restart_log – FEST-3D"},{"text":"private subroutine write_initial_resnorm() Writing Initial resnorom in the log file to \n maintian continuity of resnorm while restrarting Arguments None Called by proc~~write_initial_resnorm~~CalledByGraph proc~write_initial_resnorm write_initial_resnorm proc~write_restart_log write_restart_log proc~write_restart_log->proc~write_initial_resnorm proc~dump_data dump_data proc~dump_data->proc~write_restart_log proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocwrite_initial_resnormCalledByGraph = svgPanZoom('#procwrite_initial_resnormCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_initial_resnorm Source Code subroutine write_initial_resnorm () !< Writing Initial resnorom in the log file to !< maintian continuity of resnorm while restrarting implicit none write ( RESTART_FILE_UNIT , '(I0)' ) current_iter + last_iter write ( RESTART_FILE_UNIT , '(f0.16)' ) resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) vis_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) turb_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) cont_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) x_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) y_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) z_mom_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) energy_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) TKE_resnorm_0 write ( RESTART_FILE_UNIT , '(f0.16)' ) omega_resnorm_0 end subroutine write_initial_resnorm","tags":"","loc":"proc/write_initial_resnorm.html","title":"write_initial_resnorm – FEST-3D"},{"text":"private subroutine setup_file() Setup the file type based on the input Arguments None Calls proc~~setup_file~2~~CallsGraph proc~setup_file~2 setup_file proc~dmsg dmsg proc~setup_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_file~2~~CalledByGraph proc~setup_file~2 setup_file proc~write_file~4 write_file proc~write_file~4->proc~setup_file~2 proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocsetup_file2CalledByGraph = svgPanZoom('#procsetup_file2CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file () !< Setup the file type based on the input implicit none call dmsg ( 1 , 'write_output_vtk' , 'setup_file' ) if ( write_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( write_file_format == \"tecplot\" . or . write_file_format == \"tecplot_nodal\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk', 'tecplot' and 'tecplot_nodal' \" end if if ( write_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( write_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if end subroutine setup_file","tags":"","loc":"proc/setup_file~2.html","title":"setup_file – FEST-3D"},{"text":"private subroutine open_file(filename) Open the file to write the solution Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Calls proc~~open_file~~CallsGraph proc~open_file open_file proc~dmsg dmsg proc~open_file->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_file~~CalledByGraph proc~open_file open_file proc~write_file~4 write_file proc~write_file~4->proc~open_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocopen_fileCalledByGraph = svgPanZoom('#procopen_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_file Source Code subroutine open_file ( filename ) !< Open the file to write the solution implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'write_output_vtk' , 'open_file' ) open ( OUT_FILE_UNIT , file = trim ( filename ) // trim ( file_format ) + '.part' , form = trim ( data_format )) end subroutine open_file","tags":"","loc":"proc/open_file.html","title":"open_file – FEST-3D"},{"text":"private subroutine close_file(filename) Close the file after writing solution. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Calls proc~~close_file~~CallsGraph proc~close_file close_file proc~dmsg dmsg proc~close_file->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_file~~CalledByGraph proc~close_file close_file proc~write_file~4 write_file proc~write_file~4->proc~close_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver var panprocclose_fileCalledByGraph = svgPanZoom('#procclose_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_file Source Code subroutine close_file ( filename ) !< Close the file after writing solution. implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'write_output_vtk' , 'close_file' ) call rename ( trim ( filename ) // trim ( file_format ) + '.part' , trim ( filename ) // trim ( file_format )) close ( OUT_FILE_UNIT ) end subroutine close_file","tags":"","loc":"proc/close_file.html","title":"close_file – FEST-3D"},{"text":"public subroutine write_file() Writing output in the file according to the input file type Arguments None Calls proc~~write_file~4~~CallsGraph proc~write_file~4 write_file proc~close_file close_file proc~write_file~4->proc~close_file proc~dmsg dmsg proc~write_file~4->proc~dmsg write_file_tec_nodal write_file_tec_nodal proc~write_file~4->write_file_tec_nodal proc~open_file open_file proc~write_file~4->proc~open_file proc~setup_file~2 setup_file proc~write_file~4->proc~setup_file~2 write_file_vtk write_file_vtk proc~write_file~4->write_file_vtk write_file_tec write_file_tec proc~write_file~4->write_file_tec proc~close_file->proc~dmsg proc~open_file->proc~dmsg proc~setup_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~write_file~4~~CalledByGraph proc~write_file~4 write_file proc~dump_data dump_data proc~dump_data->proc~write_file~4 proc~checkpoint checkpoint proc~checkpoint->proc~dump_data proc~setup_solver setup_solver proc~setup_solver->proc~checkpoint proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~checkpoint program~main main program~main->proc~iterate_one_more_time_step proc~start_run start_run program~main->proc~start_run proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code write_file Source Code subroutine write_file () !< Writing output in the file according to the input file type implicit none call setup_file () call open_file ( outfile ) select case ( write_file_format ) case ( 'vtk' ) call write_file_vtk () case ( 'tecplot' ) call write_file_tec () case ( 'tecplot_nodal' ) call write_file_tec_nodal () case DEFAULT call dmsg ( 5 , 'write_output' , 'write_file' ,& 'ERROR: write file format nor recognised. READ format -> ' // write_file_format ) end select call close_file ( outfile ) end subroutine write_file","tags":"","loc":"proc/write_file~4.html","title":"write_file – FEST-3D"},{"text":"public subroutine read_file() Read all the variable for the vtk restart file Arguments None Calls proc~~read_file~~CallsGraph proc~read_file read_file proc~read_scalar read_scalar proc~read_file->proc~read_scalar proc~read_header read_header proc~read_file->proc~read_header proc~read_velocity read_velocity proc~read_file->proc~read_velocity proc~skip_scalar skip_scalar proc~read_file->proc~skip_scalar proc~read_grid read_grid proc~read_file->proc~read_grid proc~dmsg dmsg proc~read_scalar->proc~dmsg proc~read_header->proc~dmsg proc~read_velocity->proc~dmsg proc~skip_scalar->proc~dmsg proc~read_grid->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file () !< Read all the variable for the vtk restart file implicit none integer :: n call read_header () call read_grid () do n = 1 , r_count select case ( trim ( r_list ( n ))) case ( 'Velocity' ) call read_velocity () case ( 'Density' ) call read_scalar ( density , 'Density' , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , 'Pressure' , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'Intermittecny' ) call read_scalar ( intermittency , 'Intermittecny' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( r_list ( n )) end select end do end subroutine read_file","tags":"","loc":"proc/read_file.html","title":"read_file – FEST-3D"},{"text":"private subroutine read_header() Skip read the header in the vtk file Arguments None Calls proc~~read_header~~CallsGraph proc~read_header read_header proc~dmsg dmsg proc~read_header->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_header~~CalledByGraph proc~read_header read_header proc~read_file read_file proc~read_file->proc~read_header Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_header Source Code subroutine read_header () !< Skip read the header in the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , 'read_header' ) read ( IN_FILE_UNIT , * ) !'# vtk DataFile Version 3.1' read ( IN_FILE_UNIT , * ) !'cfd-iitm output'   ! comment line read ( IN_FILE_UNIT , * ) !trim(read_data_format) read ( IN_FILE_UNIT , * ) !'DATASET STRUCTURED_GRID' !read(IN_FILE_UNIT, *) end subroutine read_header","tags":"","loc":"proc/read_header.html","title":"read_header – FEST-3D"},{"text":"private subroutine read_grid() Skip the grid read in the restart file Arguments None Calls proc~~read_grid~~CallsGraph proc~read_grid read_grid proc~dmsg dmsg proc~read_grid->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_grid~~CalledByGraph proc~read_grid read_grid proc~read_file read_file proc~read_file->proc~read_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_grid Source Code subroutine read_grid () !< Skip the grid read in the restart file implicit none ! read grid point coordinates call dmsg ( 1 , 'read_output_vtk' , 'read_grid' ) read ( IN_FILE_UNIT , * ) !'DIMENSIONS ', imx, ' ', jmx, ' ', kmx read ( IN_FILE_UNIT , * ) !'POINTS ', imx*jmx*kmx, ' DOUBLE' do k = 1 , kmx do j = 1 , jmx do i = 1 , imx read ( IN_FILE_UNIT , * ) !grid_x(i, j, k), ' ', grid_y(i, j, k), ' ', grid_z(i, j, k) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_grid","tags":"","loc":"proc/read_grid.html","title":"read_grid – FEST-3D"},{"text":"private subroutine read_velocity() Read velocity vector from the vtk file Arguments None Calls proc~~read_velocity~~CallsGraph proc~read_velocity read_velocity proc~dmsg dmsg proc~read_velocity->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_velocity~~CalledByGraph proc~read_velocity read_velocity proc~read_file read_file proc~read_file->proc~read_velocity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_velocity Source Code subroutine read_velocity () !< Read velocity vector from the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , 'read_velocity' ) read ( IN_FILE_UNIT , * ) !'CELL_DATA ', (imx-1)*(jmx-1)*(kmx-1) read ( IN_FILE_UNIT , * ) !'VECTORS Velocity FLOAT' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) x_speed ( i , j , k ), y_speed ( i , j , k ), z_speed ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_velocity","tags":"","loc":"proc/read_velocity.html","title":"read_velocity – FEST-3D"},{"text":"private subroutine read_scalar(var, name, index) Read scalar from the vtk file Arguments Type Intent Optional Attributes Name real, intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~read_scalar~~CallsGraph proc~read_scalar read_scalar proc~dmsg dmsg proc~read_scalar->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scalar~~CalledByGraph proc~read_scalar read_scalar proc~read_file read_file proc~read_file->proc~read_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scalar Source Code subroutine read_scalar ( var , name , index ) !< Read scalar from the vtk file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'read_output_vtk' , trim ( name )) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) var ( i , j , k ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine read_scalar","tags":"","loc":"proc/read_scalar.html","title":"read_scalar – FEST-3D"},{"text":"private subroutine skip_scalar() Skip read scalar from the vtk file Arguments None Calls proc~~skip_scalar~~CallsGraph proc~skip_scalar skip_scalar proc~dmsg dmsg proc~skip_scalar->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~skip_scalar~~CalledByGraph proc~skip_scalar skip_scalar proc~read_file read_file proc~read_file->proc~skip_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code skip_scalar Source Code subroutine skip_scalar () !< Skip read scalar from the vtk file implicit none call dmsg ( 1 , 'read_output_vtk' , \"skip_scalar\" ) read ( IN_FILE_UNIT , * ) !'SCALARS '//trim(name)//' FLOAT' read ( IN_FILE_UNIT , * ) !'LOOKUP_TABLE default' do k = 1 , kmx - 1 do j = 1 , jmx - 1 do i = 1 , imx - 1 read ( IN_FILE_UNIT , * ) end do end do end do read ( IN_FILE_UNIT , * ) end subroutine skip_scalar","tags":"","loc":"proc/skip_scalar.html","title":"skip_scalar – FEST-3D"},{"text":"public subroutine read_file() Read all the variable for the tecplot restart file Arguments None Calls proc~~read_file~2~~CallsGraph proc~read_file~2 read_file proc~read_header~2 read_header proc~read_file~2->proc~read_header~2 proc~skip_scalar~2 skip_scalar proc~read_file~2->proc~skip_scalar~2 proc~read_grid~2 read_grid proc~read_file~2->proc~read_grid~2 proc~read_scalar~2 read_scalar proc~read_file~2->proc~read_scalar~2 proc~dmsg dmsg proc~read_header~2->proc~dmsg proc~skip_scalar~2->proc~dmsg proc~read_grid~2->proc~dmsg proc~read_scalar~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file () !< Read all the variable for the tecplot restart file implicit none integer :: n call read_header () call read_grid () do n = 1 , r_count select case ( trim ( r_list ( n ))) case ( 'Velocity' ) call read_scalar ( x_speed , \"u\" , - 2 ) call read_scalar ( y_speed , \"v\" , - 2 ) call read_scalar ( z_speed , \"w\" , - 2 ) case ( 'Density' ) call read_scalar ( density , \"Density\" , - 2 ) case ( 'Pressure' ) call read_scalar ( pressure , \"Pressure\" , - 2 ) case ( 'TKE' ) call read_scalar ( tk , 'TKE' , - 2 ) case ( 'Omega' ) call read_scalar ( tw , 'Omega' , - 2 ) case ( 'Kl' ) call read_scalar ( tkl , 'Kl' , - 2 ) case ( 'tv' ) call read_scalar ( tv , 'tv' , - 2 ) case ( 'tgm' ) call read_scalar ( tgm , 'tgm' , - 2 ) case ( 'Intermittency' ) call read_scalar ( intermittency , 'Intermittency' , - 2 ) case ( 'do not read' ) call skip_scalar () case Default Print * , \"read error: list var : \" // trim ( r_list ( n )) end select end do end subroutine read_file","tags":"","loc":"proc/read_file~2.html","title":"read_file – FEST-3D"},{"text":"private subroutine read_header() Skip read the header in the tecplot file Arguments None Calls proc~~read_header~2~~CallsGraph proc~read_header~2 read_header proc~dmsg dmsg proc~read_header~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_header~2~~CalledByGraph proc~read_header~2 read_header proc~read_file~2 read_file proc~read_file~2->proc~read_header~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_header Source Code subroutine read_header () !< Skip read the header in the tecplot file implicit none integer :: n call dmsg ( 1 , 'read_output_tec' , 'read_header' ) read ( IN_FILE_UNIT , * ) !\"variables = x y z \" do n = 1 , r_count read ( IN_FILE_UNIT , * ) !trim(w_list(n)) end do read ( IN_FILE_UNIT , * ) ! \"zone T=block\" ... read ( IN_FILE_UNIT , * ) !\"Varlocation=([1-3]=Nodal)\" read ( IN_FILE_UNIT , * ) !\"Varlocation=([4-\",total,\"]=CELLCENTERED)\" read ( IN_FILE_UNIT , * ) !\"STRANDID\" read ( IN_FILE_UNIT , * ) !\"SolutionTime\" end subroutine read_header","tags":"","loc":"proc/read_header~2.html","title":"read_header – FEST-3D"},{"text":"private subroutine read_grid() Skip the grid read in the restart file Arguments None Calls proc~~read_grid~2~~CallsGraph proc~read_grid~2 read_grid proc~dmsg dmsg proc~read_grid~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_grid~2~~CalledByGraph proc~read_grid~2 read_grid proc~read_file~2 read_file proc~read_file~2->proc~read_grid~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_grid Source Code subroutine read_grid () !< Skip the grid read in the restart file implicit none real :: dummy ! read grid point coordinates call dmsg ( 1 , 'read_output_tec' , 'read_grid' ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx ), j = 1 , jmx ), k = 1 , kmx ) end subroutine read_grid","tags":"","loc":"proc/read_grid~2.html","title":"read_grid – FEST-3D"},{"text":"private subroutine read_scalar(var, name, index) Read scalar from the tecplot file Arguments Type Intent Optional Attributes Name real, intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index Calls proc~~read_scalar~2~~CallsGraph proc~read_scalar~2 read_scalar proc~dmsg dmsg proc~read_scalar~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scalar~2~~CalledByGraph proc~read_scalar~2 read_scalar proc~read_file~2 read_file proc~read_file~2->proc~read_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scalar Source Code subroutine read_scalar ( var , name , index ) !< Read scalar from the tecplot file implicit none integer , intent ( in ) :: index real , dimension ( index : imx - index , index : jmx - index , index : kmx - index ), intent ( out ) :: var character ( len =* ), intent ( in ) :: name call dmsg ( 1 , 'read_output_tec' , trim ( name )) read ( IN_FILE_UNIT , * ) ((( var ( i , j , k ), i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine read_scalar","tags":"","loc":"proc/read_scalar~2.html","title":"read_scalar – FEST-3D"},{"text":"private subroutine skip_scalar() Skip read scalar from the tecplot file Arguments None Calls proc~~skip_scalar~2~~CallsGraph proc~skip_scalar~2 skip_scalar proc~dmsg dmsg proc~skip_scalar~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~skip_scalar~2~~CalledByGraph proc~skip_scalar~2 skip_scalar proc~read_file~2 read_file proc~read_file~2->proc~skip_scalar~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code skip_scalar Source Code subroutine skip_scalar () !< Skip read scalar from the tecplot file implicit none real :: dummy call dmsg ( 1 , 'read_output_tec' , \"skip_scalar\" ) read ( IN_FILE_UNIT , * ) ((( dummy , i = 1 , imx - 1 ), j = 1 , jmx - 1 ), k = 1 , kmx - 1 ) end subroutine skip_scalar","tags":"","loc":"proc/skip_scalar~2.html","title":"skip_scalar – FEST-3D"},{"text":"private function get_number_of_line(till, infile) result(number) Get number of lines till some character like \"#\" Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: till integer, intent(in) :: infile Return Value integer Called by proc~~get_number_of_line~~CalledByGraph proc~get_number_of_line get_number_of_line proc~read_res_list read_Res_list proc~read_res_list->proc~get_number_of_line proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~get_count_within_braces->proc~get_number_of_line proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_number_of_lineCalledByGraph = svgPanZoom('#procget_number_of_lineCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_number_of_line Source Code function get_number_of_line ( till , infile ) result ( number ) !< Get number of lines till some character like \"#\" implicit none integer , intent ( in ) :: infile character ( len = 1 ), intent ( in ) :: till character ( len = 64 ) :: buf integer :: ios integer :: number number = 0 do while (. true .) read ( infile , * , iostat = ios ) buf if ( trim ( buf ) == till ) EXIT if ( is_iostat_end ( ios )) EXIT number = number + 1 end do end function get_number_of_line","tags":"","loc":"proc/get_number_of_line.html","title":"get_number_of_line – FEST-3D"},{"text":"public subroutine read_input_and_controls() Read all the input control files Arguments None Calls proc~~read_input_and_controls~~CallsGraph proc~read_input_and_controls read_input_and_controls proc~read_output_control read_output_control proc~read_input_and_controls->proc~read_output_control proc~read_controls read_controls proc~read_input_and_controls->proc~read_controls proc~read_res_list read_Res_list proc~read_input_and_controls->proc~read_res_list proc~read_scheme read_scheme proc~read_input_and_controls->proc~read_scheme proc~read_flow read_flow proc~read_input_and_controls->proc~read_flow proc~get_rw_count get_rw_count proc~read_output_control->proc~get_rw_count proc~close_file~3 close_file proc~read_output_control->proc~close_file~3 debuginfo debuginfo proc~read_controls->debuginfo proc~get_next_token get_next_token proc~read_controls->proc~get_next_token debugcall debugcall proc~read_controls->debugcall proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~get_number_of_line get_number_of_line proc~read_res_list->proc~get_number_of_line proc~read_res_list->proc~close_file~3 proc~read_scheme->debuginfo proc~read_scheme->proc~get_next_token proc~read_scheme->debugcall proc~read_flow->debuginfo proc~read_flow->proc~get_next_token proc~read_flow->debugcall proc~get_rw_count->proc~close_file~3 proc~get_count_within_braces->proc~get_number_of_line proc~dmsg dmsg proc~get_next_token->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_input_and_controls~~CalledByGraph proc~read_input_and_controls read_input_and_controls proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_input_and_controls Source Code subroutine read_input_and_controls () !< Read all the input control files implicit none call read_controls () call read_scheme () call read_flow () call read_output_control () call read_Res_list () end subroutine read_input_and_controls","tags":"","loc":"proc/read_input_and_controls.html","title":"read_input_and_controls – FEST-3D"},{"text":"private subroutine get_next_token(token_file_unit, buf) Extract the next token from the config file Each token is on a separate line.\n There may be multiple comments (lines beginning with #) \n and blank lines in between.\n The purpose of this subroutine is to ignore all these \n lines and return the next \"useful\" line. Arguments Type Intent Optional Attributes Name integer, intent(in) :: token_file_unit character(len=STRING_BUFFER_LENGTH), intent(out) :: buf Calls proc~~get_next_token~~CallsGraph proc~get_next_token get_next_token proc~dmsg dmsg proc~get_next_token->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_next_token~~CalledByGraph proc~get_next_token get_next_token proc~read_controls read_controls proc~read_controls->proc~get_next_token proc~read_scheme read_scheme proc~read_scheme->proc~get_next_token proc~read_flow read_flow proc~read_flow->proc~get_next_token proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_controls proc~read_input_and_controls->proc~read_scheme proc~read_input_and_controls->proc~read_flow proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_next_tokenCalledByGraph = svgPanZoom('#procget_next_tokenCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_next_token Source Code subroutine get_next_token ( token_file_unit , buf ) !< Extract the next token from the config file !< !< Each token is on a separate line. !< There may be multiple comments (lines beginning with #) !< and blank lines in between. !< The purpose of this subroutine is to ignore all these !< lines and return the next \"useful\" line. !----------------------------------------------------------- implicit none integer , intent ( in ) :: token_file_unit character ( len = STRING_BUFFER_LENGTH ), intent ( out ) :: buf integer :: ios do read ( token_file_unit , '(A)' , iostat = ios ) buf if ( ios /= 0 ) then print * , 'Error while reading config file.' print * , 'Current buffer length is set to: ' , & STRING_BUFFER_LENGTH stop end if if ( index ( buf , '#' ) == 1 ) then ! The current line begins with a hash ! Ignore it continue else if ( len_trim ( buf ) == 0 ) then ! The current line is empty ! Ignore it continue else ! A new token has been found ! Break out exit end if end do call dmsg ( 0 , 'read' , 'get_next_token' , 'Returning: ' // trim ( buf )) end subroutine get_next_token","tags":"","loc":"proc/get_next_token.html","title":"get_next_token – FEST-3D"},{"text":"private subroutine read_controls() Read control.md file Arguments None Calls proc~~read_controls~~CallsGraph proc~read_controls read_controls debuginfo debuginfo proc~read_controls->debuginfo debugcall debugcall proc~read_controls->debugcall proc~get_next_token get_next_token proc~read_controls->proc~get_next_token proc~dmsg dmsg proc~get_next_token->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_controls~~CalledByGraph proc~read_controls read_controls proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_controls proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_controls Source Code subroutine read_controls () !< Read control.md file !--------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_controls' ) open ( CONTROL_FILE_UNIT , file = control_file , status = 'old' , action = 'read' ) !ignoring file header read ( CONTROL_FILE_UNIT , * ) read ( CONTROL_FILE_UNIT , * ) read ( CONTROL_FILE_UNIT , * ) ! READ CFL call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) CFL DebugInfo ( \"CFL = \" // trim ( buf )) ! READ start_from call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) start_from DebugInfo ( 'Start from  level = ' // trim ( buf )) ! READ max_iters call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) max_iters DebugInfo ( 'Stop at iteration = ' // trim ( buf )) ! READ checkpoint_iter call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) checkpoint_iter DebugInfo ( ' Solution write interval = ' // trim ( buf )) ! READ write_file_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_file_format DebugInfo ( 'Solution file format  = ' // trim ( buf )) ! READ write_data_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_data_format DebugInfo ( 'solution file data format = ' // trim ( buf )) ! READ read_file_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) read_file_format DebugInfo ( 'Restart file format  = ' // trim ( buf )) ! READ_read data_format call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) read_data_format DebugInfo ( 'Restart file data format = ' // trim ( buf )) ! READ write_percision call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) write_percision DebugInfo ( 'File write percision = ' // trim ( buf )) ! READ purge_write call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) purge_write DebugInfo ( 'Purge folder more then  = ' // trim ( buf )) ! READ res_write_interval call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) res_write_interval DebugInfo ( 'resnorm write interval  = ' // trim ( buf )) ! READ tolerance call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) tolerance , tolerance_type DebugInfo ( trim ( tolerance_type ) // ' Tolerance  = ' // trim ( buf )) ! READ DEBUG_LEVEL call get_next_token ( CONTROL_FILE_UNIT , buf ) read ( buf , * ) DEBUG_LEVEL DebugInfo ( 'DEBUG_LEVEL = ' // trim ( buf )) close ( CONTROL_FILE_UNIT ) end subroutine read_controls","tags":"","loc":"proc/read_controls.html","title":"read_controls – FEST-3D"},{"text":"private subroutine read_scheme() Read fvscheme.md control file Arguments None Calls proc~~read_scheme~~CallsGraph proc~read_scheme read_scheme debuginfo debuginfo proc~read_scheme->debuginfo debugcall debugcall proc~read_scheme->debugcall proc~get_next_token get_next_token proc~read_scheme->proc~get_next_token proc~dmsg dmsg proc~get_next_token->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_scheme~~CalledByGraph proc~read_scheme read_scheme proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_scheme proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_scheme Source Code subroutine read_scheme () !< Read fvscheme.md control file !-------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf integer :: ios DebugCall ( 'read_scheme' ) open ( SCHEME_FILE_UNIT , file = scheme_file , status = 'old' , action = 'read' ) ! ignoring file header read ( SCHEME_FILE_UNIT , * ) read ( SCHEME_FILE_UNIT , * ) read ( SCHEME_FILE_UNIT , * ) ! read scheme name call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) scheme_name DebugInfo ( 'scheme_name = ' // trim ( buf )) ! read interpolant call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) interpolant interpolant = trim ( interpolant ) DebugInfo ( 'interpolant = ' // trim ( buf )) ! read ilimiter and PB switch call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) ilimiter_switch , jlimiter_switch , klimiter_switch , & iPB_switch , jPB_switch , kPB_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) DebugInfo ( 'PB switch = ' // trim ( buf ) ) ! read turbulent limiter call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) itlimiter_switch , jtlimiter_switch , ktlimiter_switch DebugInfo ( 'ilimiter switch = ' // trim ( buf ) ) DebugInfo ( 'jlimiter switch = ' // trim ( buf ) ) DebugInfo ( 'klimiter switch = ' // trim ( buf ) ) ! read turbulence model call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) turbulence DebugInfo ( 'Turbulence Model = ' // trim ( buf )) ! read transition model call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) transition DebugInfo ( 'Transition Model = ' // trim ( buf )) ! read time stepping method call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * , iostat = ios ) time_stepping_method , global_time_step if ( ios /= 0 ) then read ( buf , * ) time_stepping_method global_time_step = - 1 end if DebugInfo ( 'time_stepping_method = ' // trim ( buf )) DebugInfo ( 'global_time_step = ' // trim ( buf )) ! read time integration method call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) time_step_accuracy DebugInfo ( 'time_step_accuracy  = ' // trim ( buf )) ! read higher order boundary call get_next_token ( SCHEME_FILE_UNIT , buf ) read ( buf , * ) accur DebugInfo ( 'higher order boundary  = ' // trim ( buf )) close ( SCHEME_FILE_UNIT ) end subroutine read_scheme","tags":"","loc":"proc/read_scheme.html","title":"read_scheme – FEST-3D"},{"text":"private subroutine read_flow() Read flow.md control file Arguments None Calls proc~~read_flow~~CallsGraph proc~read_flow read_flow debuginfo debuginfo proc~read_flow->debuginfo debugcall debugcall proc~read_flow->debugcall proc~get_next_token get_next_token proc~read_flow->proc~get_next_token proc~dmsg dmsg proc~get_next_token->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_flow~~CalledByGraph proc~read_flow read_flow proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_flow proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_flow Source Code subroutine read_flow () !< Read flow.md control file !-------------------------------------------- implicit none character ( len = STRING_BUFFER_LENGTH ) :: buf DebugCall ( 'read_flow' ) open ( FLOW_FILE_UNIT , file = flow_file , status = 'old' , action = 'read' ) ! ignoring file header read ( FLOW_FILE_UNIT , * ) read ( FLOW_FILE_UNIT , * ) read ( FLOW_FILE_UNIT , * ) ! read number of variable call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) n_var DebugInfo ( 'Number of variables = ' // trim ( buf )) ! read rho_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_density DebugInfo ( 'free_stream_density = ' // trim ( buf )) ! read u_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_x_speed DebugInfo ( 'free_stream_x_speed = ' // trim ( buf )) ! read v_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_y_speed DebugInfo ( 'free_stream_y_speed = ' // trim ( buf )) ! read w_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_z_speed DebugInfo ( 'free_stream_z_speed = ' // trim ( buf )) ! read P_inf call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_pressure DebugInfo ( 'free_stream_pressure = ' // trim ( buf )) ! read turbulence intensity in percentage call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_tu DebugInfo ( 'free_stream_Turb_intensity = ' // trim ( buf )) ! read viscosity ratio call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_ratio_inf DebugInfo ( 'free_stream_mu_ratio = ' // trim ( buf )) ! read intermittency call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) free_stream_tgm DebugInfo ( 'free_stream_Intermittency = ' // trim ( buf )) ! read reference viscosity call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_ref DebugInfo ( 'mu_reference = ' // trim ( buf )) ! Type of variation for viscosity call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) mu_variation DebugInfo ( 'mu_variation = ' // trim ( buf )) ! read T_red call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) T_ref DebugInfo ( 'T_reference = ' // trim ( buf )) ! read Sutherland temp call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) Sutherland_temp DebugInfo ( 'Sutherland temperature = ' // trim ( buf )) ! read prandtl number call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) Pr , tPr DebugInfo ( 'Prandtl Number = ' // trim ( buf )) ! read gamma call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) gm DebugInfo ( 'gamma = ' // trim ( buf )) ! read universal gas constant call get_next_token ( FLOW_FILE_UNIT , buf ) read ( buf , * ) R_gas DebugInfo ( 'R_gas = ' // trim ( buf )) close ( FLOW_FILE_UNIT ) end subroutine read_flow","tags":"","loc":"proc/read_flow.html","title":"read_flow – FEST-3D"},{"text":"private subroutine read_output_control() Read output_contorl.md file Arguments None Calls proc~~read_output_control~~CallsGraph proc~read_output_control read_output_control proc~get_rw_count get_rw_count proc~read_output_control->proc~get_rw_count proc~close_file~3 close_file proc~read_output_control->proc~close_file~3 proc~get_rw_count->proc~close_file~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_output_control~~CalledByGraph proc~read_output_control read_output_control proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_output_control proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_output_control Source Code subroutine read_output_control () !< Read output_contorl.md file implicit none integer :: i character ( len = 64 ) :: buf integer :: ios call get_rw_count () call close_file ( OUTIN_FILE_UNIT ) open ( OUTIN_FILE_UNIT , file = outin_file , status = 'old' , action = 'read' ) ! variables to write do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , w_count read ( OUTIN_FILE_UNIT , * ) buf read ( buf , * ) w_list ( i ) end do ! restart variables to read do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do do i = 1 , r_count read ( OUTIN_FILE_UNIT , * ) buf read ( buf , * ) r_list ( i ) end do if ( r_count == 0 ) r_list = w_list close ( OUTIN_FILE_UNIT ) end subroutine read_output_control","tags":"","loc":"proc/read_output_control.html","title":"read_output_control – FEST-3D"},{"text":"private subroutine get_rw_count() Get read/write count Arguments None Calls proc~~get_rw_count~~CallsGraph proc~get_rw_count get_rw_count proc~close_file~3 close_file proc~get_rw_count->proc~close_file~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_rw_count~~CalledByGraph proc~get_rw_count get_rw_count proc~read_output_control read_output_control proc~read_output_control->proc~get_rw_count proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_output_control proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_rw_countCalledByGraph = svgPanZoom('#procget_rw_countCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_rw_count Source Code subroutine get_rw_count () !< Get read/write count implicit none integer :: ios character ( len = 64 ) :: buf r_count = 0 w_count = 0 call close_file ( OUTIN_FILE_UNIT ) open ( OUTIN_FILE_UNIT , file = outin_file , status = 'old' , action = 'read' ) ! write list dimension do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do w_count = 0 do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT w_count = w_count + 1 end do if ( w_count > 0 ) then allocate ( w_list ( 1 : w_count )) else w_count = 3 allocate ( w_list ( 1 : w_count )) w_list ( 1 ) = \"Velocity\" w_list ( 2 ) = \"Density\" w_list ( 3 ) = \"Pressure\" end if ! read list dimesnion do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '{' ) EXIT if ( is_iostat_end ( ios )) EXIT end do r_count = 0 do while (. true .) read ( OUTIN_FILE_UNIT , * , iostat = ios ) buf if ( trim ( buf ) == '}' ) EXIT if ( is_iostat_end ( ios )) EXIT r_count = r_count + 1 end do if ( r_count == 0 ) then allocate ( r_list ( 1 : w_count )) else allocate ( r_list ( 1 : r_count )) end if close ( OUTIN_FILE_UNIT ) end subroutine get_rw_count","tags":"","loc":"proc/get_rw_count.html","title":"get_rw_count – FEST-3D"},{"text":"private subroutine get_count_within_braces(handler, count) Get number of variables between two curly braces Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler File handler from which list number is extracted integer, intent(out) :: count Extracted count Calls proc~~get_count_within_braces~~CallsGraph proc~get_count_within_braces get_count_within_braces proc~get_number_of_line get_number_of_line proc~get_count_within_braces->proc~get_number_of_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_count_within_braces~~CalledByGraph proc~get_count_within_braces get_count_within_braces proc~read_res_list read_Res_list proc~read_res_list->proc~get_count_within_braces proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocget_count_within_bracesCalledByGraph = svgPanZoom('#procget_count_within_bracesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_count_within_braces Source Code subroutine get_count_within_braces ( handler , count ) !< Get number of variables between two curly braces implicit none integer , intent ( in ) :: handler !< File handler from which list number is extracted integer , intent ( out ) :: count !< Extracted count integer :: skip ! skipping lines outside braces skip = get_number_of_line ( '{' , handler ) ! finding actual count if any count = get_number_of_line ( '}' , handler ) end subroutine get_count_within_braces","tags":"","loc":"proc/get_count_within_braces.html","title":"get_count_within_braces – FEST-3D"},{"text":"private subroutine read_Res_list() Read Residual file: res_control.md Arguments None Calls proc~~read_res_list~~CallsGraph proc~read_res_list read_Res_list proc~get_number_of_line get_number_of_line proc~read_res_list->proc~get_number_of_line proc~get_count_within_braces get_count_within_braces proc~read_res_list->proc~get_count_within_braces proc~close_file~3 close_file proc~read_res_list->proc~close_file~3 proc~get_count_within_braces->proc~get_number_of_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_res_list~~CalledByGraph proc~read_res_list read_Res_list proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_res_list proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_Res_list Source Code subroutine read_Res_list () !< Read Residual file: res_control.md implicit none integer :: i integer :: skip open ( RES_CONTROL_FILE_UNIT , file = res_control_file , status = 'old' , action = 'read' ) call get_count_within_braces ( RES_CONTROL_FILE_UNIT , Res_count ) call close_file ( RES_CONTROL_FILE_UNIT ) open ( RES_CONTROL_FILE_UNIT , file = res_control_file , status = 'old' , action = 'read' ) ! skipping line skip = get_number_of_line ( '{' , RES_CONTROL_FILE_UNIT ) !reading vaules if ( Res_count == 0 ) then allocate ( Res_list ( 1 : 2 )) Res_count = 2 Res_list ( 1 ) = \"Mass_abs\" Res_list ( 2 ) = \"Resnorm_abs\" else allocate ( Res_list ( 1 : Res_count )) end if do i = 1 , Res_count read ( RES_CONTROL_FILE_UNIT , * ) Res_list ( i ) end do call close_file ( RES_CONTROL_FILE_UNIT ) end subroutine read_Res_list","tags":"","loc":"proc/read_res_list.html","title":"read_Res_list – FEST-3D"},{"text":"public subroutine read_file() Read restart file Arguments None Calls proc~~read_file~3~~CallsGraph proc~read_file~3 read_file proc~dmsg dmsg proc~read_file~3->proc~dmsg proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~lcase lcase proc~verify_read_control->proc~lcase proc~open_file~2->proc~dmsg proc~close_file~2->proc~dmsg proc~setup_file~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~read_file~3~~CalledByGraph proc~read_file~3 read_file proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_file Source Code subroutine read_file () !< Read restart file implicit none call setup_file call open_file ( infile ) call read_restart_file () call verify_read_control () select case ( read_file_format ) case ( 'vtk' ) call read_file_vtk () case ( 'tecplot' ) call read_file_tec () case DEFAULT call dmsg ( 5 , 'read_output' , 'read_file' ,& 'ERROR: read file format not recognised. READ format -> ' // read_file_format ) end select call close_file () end subroutine read_file","tags":"","loc":"proc/read_file~3.html","title":"read_file – FEST-3D"},{"text":"private subroutine setup_file() Steup the file to read the restart state. Arguments None Calls proc~~setup_file~3~~CallsGraph proc~setup_file~3 setup_file proc~dmsg dmsg proc~setup_file~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_file~3~~CalledByGraph proc~setup_file~3 setup_file proc~read_file~3 read_file proc~read_file~3->proc~setup_file~3 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_file Source Code subroutine setup_file () !< Steup the file to read the restart state. implicit none call dmsg ( 1 , 'read_output_vtk' , 'setup_file' ) if ( read_file_format == \"vtk\" ) then file_format = \".vtk\" elseif ( read_file_format == \"tecplot\" ) then file_format = \".dat\" else print * , \"File format not recoganised. Accepted formats are\" print * , \"'vtk' and 'tecplot' \" end if if ( read_data_format == \"ASCII\" ) then data_format = \"formatted\" elseif ( read_data_format == \"BINARY\" ) then data_format = \"unformatted\" else print * , \"Data format not recoganised. Accepted formats are\" print * , \"'ASCII' and 'BINARY' \" end if !write(infile,'(a,i4.4,a,i2.2)') 'time_directories/',start_from,'process_',process_id end subroutine setup_file","tags":"","loc":"proc/setup_file~3.html","title":"setup_file – FEST-3D"},{"text":"private subroutine open_file(filename) Open file from the restart folder Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename Calls proc~~open_file~2~~CallsGraph proc~open_file~2 open_file proc~dmsg dmsg proc~open_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~open_file~2~~CalledByGraph proc~open_file~2 open_file proc~read_file~3 read_file proc~read_file~3->proc~open_file~2 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_file Source Code subroutine open_file ( filename ) !< Open file from the restart folder implicit none character ( len =* ), intent ( in ) :: filename call dmsg ( 1 , 'read_output_vtk' , 'open_file' ) write ( restartfile , '(A,I4.4,A,I2.2)' ) 'time_directories/' , start_from ,& '/restart/process_' , process_id open ( IN_FILE_UNIT , file = trim ( filename ) // trim ( file_format )) !, form=trim(data_format)) open ( RESTART_FILE_UNIT , file = restartfile , status = 'old' ) end subroutine open_file","tags":"","loc":"proc/open_file~2.html","title":"open_file – FEST-3D"},{"text":"private subroutine close_file() Close the file after reading Arguments None Calls proc~~close_file~2~~CallsGraph proc~close_file~2 close_file proc~dmsg dmsg proc~close_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_file~2~~CalledByGraph proc~close_file~2 close_file proc~read_file~3 read_file proc~read_file~3->proc~close_file~2 proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_file Source Code subroutine close_file () !< Close the file after reading implicit none call dmsg ( 1 , 'read_output_vtk' , 'close_files' ) close ( IN_FILE_UNIT ) close ( RESTART_FILE_UNIT ) end subroutine close_file","tags":"","loc":"proc/close_file~2.html","title":"close_file – FEST-3D"},{"text":"private subroutine read_restart_file() Read the sub-directory log file in the restart folder Arguments None Called by proc~~read_restart_file~~CalledByGraph proc~read_restart_file read_restart_file proc~read_file~3 read_file proc~read_file~3->proc~read_restart_file proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocread_restart_fileCalledByGraph = svgPanZoom('#procread_restart_fileCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code read_restart_file Source Code subroutine read_restart_file () !< Read the sub-directory log file in the restart folder implicit none read ( RESTART_FILE_UNIT , * ) previous_flow_type read ( RESTART_FILE_UNIT , * ) last_iter read ( RESTART_FILE_UNIT , * ) resnorm_0 read ( RESTART_FILE_UNIT , * ) vis_resnorm_0 read ( RESTART_FILE_UNIT , * ) turb_resnorm_0 read ( RESTART_FILE_UNIT , * ) cont_resnorm_0 read ( RESTART_FILE_UNIT , * ) x_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) y_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) z_mom_resnorm_0 read ( RESTART_FILE_UNIT , * ) energy_resnorm_0 read ( RESTART_FILE_UNIT , * ) TKE_resnorm_0 read ( RESTART_FILE_UNIT , * ) omega_resnorm_0 end subroutine read_restart_file","tags":"","loc":"proc/read_restart_file.html","title":"read_restart_file – FEST-3D"},{"text":"private subroutine alloc_rank1_real(var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank1_real~~CalledByGraph proc~alloc_rank1_real alloc_rank1_real interface~alloc alloc interface~alloc->proc~alloc_rank1_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank1_realCalledByGraph = svgPanZoom('#procalloc_rank1_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank1_real.html","title":"alloc_rank1_real – FEST-3D"},{"text":"private subroutine alloc_rank2_real(var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank2_real~~CalledByGraph proc~alloc_rank2_real alloc_rank2_real interface~alloc alloc interface~alloc->proc~alloc_rank2_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank2_realCalledByGraph = svgPanZoom('#procalloc_rank2_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank2_real.html","title":"alloc_rank2_real – FEST-3D"},{"text":"private subroutine alloc_rank3_real(var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank3_real~~CalledByGraph proc~alloc_rank3_real alloc_rank3_real interface~alloc alloc interface~alloc->proc~alloc_rank3_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank3_realCalledByGraph = svgPanZoom('#procalloc_rank3_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank3_real.html","title":"alloc_rank3_real – FEST-3D"},{"text":"private subroutine alloc_rank4_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank4_real~~CalledByGraph proc~alloc_rank4_real alloc_rank4_real interface~alloc alloc interface~alloc->proc~alloc_rank4_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank4_realCalledByGraph = svgPanZoom('#procalloc_rank4_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank4_real.html","title":"alloc_rank4_real – FEST-3D"},{"text":"private subroutine alloc_rank5_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank5_real~~CalledByGraph proc~alloc_rank5_real alloc_rank5_real interface~alloc alloc interface~alloc->proc~alloc_rank5_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank5_realCalledByGraph = svgPanZoom('#procalloc_rank5_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank5_real.html","title":"alloc_rank5_real – FEST-3D"},{"text":"private subroutine alloc_rank6_real(var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank6_real~~CalledByGraph proc~alloc_rank6_real alloc_rank6_real interface~alloc alloc interface~alloc->proc~alloc_rank6_real proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank6_realCalledByGraph = svgPanZoom('#procalloc_rank6_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank6_real.html","title":"alloc_rank6_real – FEST-3D"},{"text":"private subroutine alloc_rank1_integer(var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank1_integer~~CalledByGraph proc~alloc_rank1_integer alloc_rank1_integer interface~alloc alloc interface~alloc->proc~alloc_rank1_integer proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank1_integerCalledByGraph = svgPanZoom('#procalloc_rank1_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank1_integer.html","title":"alloc_rank1_integer – FEST-3D"},{"text":"private subroutine alloc_rank2_integer(var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank2_integer~~CalledByGraph proc~alloc_rank2_integer alloc_rank2_integer interface~alloc alloc interface~alloc->proc~alloc_rank2_integer proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank2_integerCalledByGraph = svgPanZoom('#procalloc_rank2_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank2_integer.html","title":"alloc_rank2_integer – FEST-3D"},{"text":"private subroutine alloc_rank3_integer(var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) Called by proc~~alloc_rank3_integer~~CalledByGraph proc~alloc_rank3_integer alloc_rank3_integer interface~alloc alloc interface~alloc->proc~alloc_rank3_integer proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocalloc_rank3_integerCalledByGraph = svgPanZoom('#procalloc_rank3_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/alloc_rank3_integer.html","title":"alloc_rank3_integer – FEST-3D"},{"text":"private subroutine dealloc_rank1_real(var) Deallcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank1_real~~CalledByGraph proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank1_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank1_realCalledByGraph = svgPanZoom('#procdealloc_rank1_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank1_real.html","title":"dealloc_rank1_real – FEST-3D"},{"text":"private subroutine dealloc_rank2_real(var) Deallcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank2_real~~CalledByGraph proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank2_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank2_realCalledByGraph = svgPanZoom('#procdealloc_rank2_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank2_real.html","title":"dealloc_rank2_real – FEST-3D"},{"text":"private subroutine dealloc_rank3_real(var) Deallcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank3_real~~CalledByGraph proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank3_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank3_realCalledByGraph = svgPanZoom('#procdealloc_rank3_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank3_real.html","title":"dealloc_rank3_real – FEST-3D"},{"text":"private subroutine dealloc_rank4_real(var) Deallcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank4_real~~CalledByGraph proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank4_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank4_realCalledByGraph = svgPanZoom('#procdealloc_rank4_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank4_real.html","title":"dealloc_rank4_real – FEST-3D"},{"text":"private subroutine dealloc_rank5_real(var) Deallcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank5_real~~CalledByGraph proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank5_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank5_realCalledByGraph = svgPanZoom('#procdealloc_rank5_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank5_real.html","title":"dealloc_rank5_real – FEST-3D"},{"text":"private subroutine dealloc_rank6_real(var) Deallcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank6_real~~CalledByGraph proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc dealloc interface~dealloc->proc~dealloc_rank6_real proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank6_realCalledByGraph = svgPanZoom('#procdealloc_rank6_realCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank6_real.html","title":"dealloc_rank6_real – FEST-3D"},{"text":"private subroutine dealloc_rank1_integer(var) Deallcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank1_integer~~CalledByGraph proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc dealloc interface~dealloc->proc~dealloc_rank1_integer proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank1_integerCalledByGraph = svgPanZoom('#procdealloc_rank1_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank1_integer.html","title":"dealloc_rank1_integer – FEST-3D"},{"text":"private subroutine dealloc_rank2_integer(var) Deallcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank2_integer~~CalledByGraph proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc dealloc interface~dealloc->proc~dealloc_rank2_integer proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank2_integerCalledByGraph = svgPanZoom('#procdealloc_rank2_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank2_integer.html","title":"dealloc_rank2_integer – FEST-3D"},{"text":"private subroutine dealloc_rank3_integer(var) Deallcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated Called by proc~~dealloc_rank3_integer~~CalledByGraph proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc dealloc interface~dealloc->proc~dealloc_rank3_integer proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var panprocdealloc_rank3_integerCalledByGraph = svgPanZoom('#procdealloc_rank3_integerCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/dealloc_rank3_integer.html","title":"dealloc_rank3_integer – FEST-3D"},{"text":"public subroutine dmsg(level, prog, method, msg) Based on the debug level input this\n soubroutine will output/print or skip the debug\n message. This subroutine is called in the\n starting of every other subrotune for debuging.\n This will be depricated in the later version. Arguments Type Intent Optional Attributes Name integer :: level The message's debug level character(len=*), optional :: prog Module or program name character(len=*), optional :: method Subroutine or function name character(len=*), optional :: msg Message to print Called by add_source_term_residue w dmsg w add_turbulent_time w w add_viscous_time w w allocate_memory w w allocate_memory w w allocate_memory w w apply_gradient_bc w w apply_interface w w apply_interface w w apply_interface w w apply_periodic_bc w w apply_periodic_bc w w apply_periodic_bc w w checkpoint w w close_file w w close_file w w compute_face_estimates w w compute_face_state w w compute_flux w w compute_flux w w compute_flux w w compute_flux w w compute_flux w w compute_flux w w compute_fluxes w w compute_fluxes w w compute_fluxes w w compute_fluxes w w compute_fluxes w w compute_fluxes w w compute_geometric_parameters w w compute_global_time_step w w compute_local_time_step w w compute_time_step w w deallocate_memory w w deallocate_memory w w destroy_all w w destroy_geometry w w destroy_grid w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_scheme w w destroy_solver w w destroy_surface w w destroy_time w w destroy_wall_dist w w dump_data w w evaluate_all_gradients w w extract_grid_point w w extract_grid_size w w find_wall_dist w w get_next_token w w get_next_token_parallel w w get_residue w w get_residue w w get_residue w w get_residue w w get_residue w w get_residue w w ghost_grid w w initmisc w w iterate_one_more_time_step w w link_aliases w w open_file w w open_file w w populate_grid_points w w pressure_based_switching w w pressure_based_switching w w read_file w w read_grid w w read_grid w w read_header w w read_header w w read_layout_file w w read_scalar w w read_scalar w w read_velocity w w reconstruct_boundary_state w w remove_extrema w w setup_all w w setup_file w w setup_file w w setup_geometry w w setup_grid w w setup_nodefile w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_scheme w w setup_solver w w setup_surface w w setup_time w w setup_wall_dist w w skip_scalar w w skip_scalar w w surface_points w w unlink_aliases w w write_file w w write_grid w w write_header w w write_restart_log w w write_scalar w w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code dmsg Source Code subroutine dmsg ( level , prog , method , msg ) !< Based on the debug level input this !< soubroutine will output/print or skip the debug !< message. This subroutine is called in the !< starting of every other subrotune for debuging. !< This will be depricated in the later version. !--------------------------------------------------------------- ! Print a DEBUG message ! ! Input arguments: !   level -> integer !       the message's debug level !   prog -> character !       module / program name !   method -> character !       subroutine / function name !   msg -> character !       message !--------------------------------------------------------------- implicit none character ( len =* ), optional :: prog !< Module or program name character ( len =* ), optional :: method !< Subroutine or function name character ( len =* ), optional :: msg !< Message to print character ( len = 256 ) :: ifmsg integer :: level !< The message's debug level !            if (process_id == 0) then if ( level < DEBUG_LEVEL ) then ! Don't print the message return end if ifmsg = \"\" if ( present ( msg )) then ifmsg = \" >--> \" // trim ( msg ) end if if (. not . present ( prog ) . and . . not . present ( method ) . and . & . not . present ( msg )) then print * , 'Please provide atleast one of the following:' print * , '- Module / program name' print * , '- Subroutine / function name' print * , '- A custom message' stop end if print '(A7,I1.1,A,I2,A2,A,A2,A,A,A1)' , 'Debug: ' , level , \" id - \" , process_id , ' (' , & trim ( prog ), ', ' , trim ( method ), trim ( ifmsg ), ')' !           end if end subroutine dmsg","tags":"","loc":"proc/dmsg.html","title":"dmsg – FEST-3D"},{"text":"public subroutine turbulence_read_error() Arguments None Called by proc~~turbulence_read_error~~CalledByGraph proc~turbulence_read_error turbulence_read_error proc~pole pole proc~pole->proc~turbulence_read_error proc~populate_ghost_primitive populate_ghost_primitive proc~populate_ghost_primitive->proc~pole proc~get_total_conservative_residue get_total_conservative_Residue proc~get_total_conservative_residue->proc~populate_ghost_primitive proc~get_next_solution get_next_solution proc~get_next_solution->proc~get_total_conservative_residue proc~iterate_one_more_time_step iterate_one_more_time_step proc~iterate_one_more_time_step->proc~get_next_solution program~main main program~main->proc~iterate_one_more_time_step var panprocturbulence_read_errorCalledByGraph = svgPanZoom('#procturbulence_read_errorCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code turbulence_read_error Source Code subroutine turbulence_read_error () print * , \"ERROR: Turbulence model not recognised\" STOP end subroutine turbulence_read_error","tags":"","loc":"proc/turbulence_read_error.html","title":"turbulence_read_error – FEST-3D"},{"text":"public interface alloc Calls interface~~alloc~~CallsGraph interface~alloc alloc proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~alloc~~CalledByGraph interface~alloc alloc proc~allocate_memory_normals allocate_memory_normals proc~allocate_memory_normals->interface~alloc proc~setup_scheme~8 setup_scheme proc~setup_scheme~8->interface~alloc proc~setup_scheme~9 setup_scheme proc~setup_scheme~9->interface~alloc proc~setup_scheme~2 setup_scheme proc~setup_scheme~2->interface~alloc proc~setup_scheme~3 setup_scheme proc~setup_scheme~3->interface~alloc proc~setup_scheme~4 setup_scheme proc~setup_scheme~4->interface~alloc proc~setup_scheme~5 setup_scheme proc~setup_scheme~5->interface~alloc proc~setup_scheme~6 setup_scheme proc~setup_scheme~6->interface~alloc proc~setup_scheme~7 setup_scheme proc~setup_scheme~7->interface~alloc proc~destroy_time destroy_time proc~destroy_time->interface~alloc proc~setup_time setup_time proc~setup_time->interface~alloc proc~setup_plusgs setup_plusgs proc~setup_plusgs->interface~alloc proc~allocate_memory~6 allocate_memory proc~allocate_memory~6->interface~alloc proc~allocate_memory~5 allocate_memory proc~allocate_memory~5->interface~alloc proc~allocate_memory~4 allocate_memory proc~allocate_memory~4->interface~alloc proc~allocate_memory~2 allocate_memory proc~allocate_memory~2->interface~alloc proc~setup_scheme~10 setup_scheme proc~setup_scheme~10->interface~alloc proc~setupcc setupCC proc~setupcc->interface~alloc proc~allocate_memory_ghost_centroids allocate_memory_ghost_centroids proc~allocate_memory_ghost_centroids->interface~alloc proc~allocate_memory_volumes allocate_memory_volumes proc~allocate_memory_volumes->interface~alloc proc~setup_scheme setup_scheme proc~setup_scheme->interface~alloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~alloc proc~setup_wall_dist setup_wall_dist proc~setup_wall_dist->interface~alloc proc~setup_lusgs setup_lusgs proc~setup_lusgs->interface~alloc proc~allocate_memory_areas allocate_memory_areas proc~allocate_memory_areas->interface~alloc proc~setup_interface setup_interface proc~setup_interface->interface~alloc proc~setup_bc setup_bc proc~setup_bc->interface~alloc proc~allocate_memory allocate_memory proc~allocate_memory->interface~alloc proc~setup_viscosity setup_viscosity proc~setup_viscosity->interface~alloc proc~setup_update setup_update proc~setup_update->interface~alloc proc~setup_update->proc~setup_plusgs proc~setup_update->proc~setup_lusgs proc~setup_solver setup_solver proc~setup_solver->proc~setup_time proc~setup_solver->proc~setupcc proc~setup_solver->proc~find_wall_dist proc~setup_solver->proc~setup_wall_dist proc~setup_solver->proc~setup_interface proc~setup_solver->proc~setup_bc proc~setup_solver->proc~setup_viscosity proc~setup_solver->proc~setup_update proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~setup_state->proc~allocate_memory~6 proc~setup_gradients->proc~allocate_memory~5 proc~allocate_memory~3 allocate_memory proc~allocate_memory~3->proc~allocate_memory_normals proc~allocate_memory~3->proc~allocate_memory_ghost_centroids proc~allocate_memory~3->proc~allocate_memory_volumes proc~allocate_memory~3->proc~allocate_memory_areas proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_time proc~setup_all setup_all proc~setup_all->proc~setup_time proc~setup_all->proc~find_wall_dist proc~setup_all->proc~setup_wall_dist proc~setup_all->proc~setup_bc proc~setup_all->proc~setup_state proc~setup_all->proc~setup_gradients proc~setup_all->proc~setup_grid proc~setup_all->proc~setup_geometry proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~setup_resnorm->proc~allocate_memory~2 proc~setup_surface setup_surface proc~setup_surface->proc~allocate_memory~4 proc~setup_grid->proc~allocate_memory proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~setup_geometry->proc~allocate_memory~3 proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~setup_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var paninterfaceallocCalledByGraph = svgPanZoom('#interfaceallocCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures alloc_rank1_real alloc_rank2_real alloc_rank3_real alloc_rank4_real alloc_rank5_real alloc_rank6_real alloc_rank1_integer alloc_rank2_integer alloc_rank3_integer Module Procedures private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful)","tags":"","loc":"interface/alloc.html","title":"alloc – FEST-3D"},{"text":"public interface dealloc Calls interface~~dealloc~~CallsGraph interface~dealloc dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~dealloc~~CalledByGraph interface~dealloc dealloc proc~destroy_lusgs destroy_lusgs proc~destroy_lusgs->interface~dealloc proc~destroy_scheme~4 destroy_scheme proc~destroy_scheme~4->interface~dealloc proc~destroy_update destroy_update proc~destroy_update->interface~dealloc proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_scheme~5 destroy_scheme proc~destroy_scheme~5->interface~dealloc proc~destroy_time destroy_time proc~destroy_time->interface~dealloc proc~destroy_scheme~7 destroy_scheme proc~destroy_scheme~7->interface~dealloc proc~destroy_scheme~6 destroy_scheme proc~destroy_scheme~6->interface~dealloc proc~destroy_scheme~3 destroy_scheme proc~destroy_scheme~3->interface~dealloc proc~destroy_scheme~2 destroy_scheme proc~destroy_scheme~2->interface~dealloc proc~destroy_scheme~9 destroy_scheme proc~destroy_scheme~9->interface~dealloc proc~destroy_scheme~8 destroy_scheme proc~destroy_scheme~8->interface~dealloc proc~destroy_scheme destroy_scheme proc~destroy_scheme->interface~dealloc proc~destroy_bc destroy_bc proc~destroy_bc->interface~dealloc proc~deallocate_memory~2 deallocate_memory proc~deallocate_memory~2->interface~dealloc proc~destroy_memory destroy_memory proc~destroy_memory->interface~dealloc proc~destroy_grid destroy_grid proc~destroy_grid->interface~dealloc proc~deallocate_memory~3 deallocate_memory proc~deallocate_memory~3->interface~dealloc proc~find_wall_dist find_wall_dist proc~find_wall_dist->interface~dealloc proc~destroy_wall_dist destroy_wall_dist proc~destroy_wall_dist->interface~dealloc proc~destroycc destroyCC proc~destroycc->interface~dealloc proc~deallocate_memory~4 deallocate_memory proc~deallocate_memory~4->interface~dealloc proc~deallocate_memory deallocate_memory proc~deallocate_memory->interface~dealloc proc~destroy_interface destroy_interface proc~destroy_interface->interface~dealloc proc~destroy_scheme~10 destroy_scheme proc~destroy_scheme~10->interface~dealloc proc~destroy_viscosity destroy_viscosity proc~destroy_viscosity->interface~dealloc proc~destroy_plusgs->interface~dealloc proc~setup_solver setup_solver proc~setup_solver->proc~find_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_update proc~destroy_solver->proc~destroy_time proc~destroy_solver->proc~destroy_bc proc~destroy_solver->proc~destroy_grid proc~destroy_solver->proc~destroy_wall_dist proc~destroy_solver->proc~destroycc proc~destroy_solver->proc~destroy_interface proc~destroy_solver->proc~destroy_viscosity proc~destroy_solver->proc~destroy_gradients proc~destroy_solver->proc~destroy_resnorm proc~destroy_solver->proc~destroy_state proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~setup_all setup_all proc~setup_all->proc~find_wall_dist proc~setup_all->proc~write_surfnode proc~destroy_all destroy_all proc~destroy_all->proc~destroy_time proc~destroy_all->proc~destroy_grid proc~destroy_all->proc~destroy_wall_dist proc~destroy_all->proc~destroy_gradients proc~destroy_all->proc~destroy_state proc~destroy_all->proc~destroy_geometry proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_surface destroy_surface proc~destroy_surface->proc~deallocate_memory~3 proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver proc~write_surfnode->proc~destroy_surface proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~finish_run program~main->proc~start_run var paninterfacedeallocCalledByGraph = svgPanZoom('#interfacedeallocCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures dealloc_rank1_real dealloc_rank2_real dealloc_rank3_real dealloc_rank4_real dealloc_rank5_real dealloc_rank6_real dealloc_rank1_integer dealloc_rank2_integer dealloc_rank3_integer Module Procedures private subroutine dealloc_rank1_real (var) Deallcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_real (var) Deallcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_real (var) Deallcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank4_real (var) Deallcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank5_real (var) Deallcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank6_real (var) Deallcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank1_integer (var) Deallcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_integer (var) Deallcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_integer (var) Deallcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated","tags":"","loc":"interface/dealloc.html","title":"dealloc – FEST-3D"},{"text":"public subroutine verify_write_control() Verify all the variable being asked to write in the output file. \n This is a fail-safe subroutine which do not allow to write the incorrect input variable Arguments None Calls proc~~verify_write_control~~CallsGraph proc~verify_write_control verify_write_control proc~lcase lcase proc~verify_write_control->proc~lcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~verify_write_control~~CalledByGraph proc~verify_write_control verify_write_control proc~initstate initstate proc~initstate->proc~verify_write_control proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code verify_write_control Source Code subroutine verify_write_control () !< Verify all the variable being asked to write in the output file. !< This is a fail-safe subroutine which do not allow to write the incorrect input variable implicit none integer :: n character ( len =* ), parameter :: err = \"Control Error: can't write variable - \" do n = 1 , w_count select case ( trim ( lcase ( w_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) w_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) w_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) w_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) if ( mu_ref /= 0.0 ) then w_list ( n ) = \"Mu\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) if ( turbulence /= 'none' ) then w_list ( n ) = \"Mu_t\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"TKE\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'omega' , 'tw' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'kl' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'tv' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) if ( turbulence /= \"none\" ) then w_list ( n ) = \"Wall_distance\" else print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end if case ( 'resnorm' ) w_list ( n ) = \"Resnorm\" case ( 'tke_residue' ) w_list ( n ) = \"TKE_residue\" case ( 'omega_residue' ) w_list ( n ) = \"Omega_residue\" case ( 'tv_residue' ) w_list ( n ) = \"Tv_residue\" case ( 'mass_residue' ) w_list ( n ) = \"Mass_residue\" case ( 'x_mom_residue' ) w_list ( n ) = \"X_mom_residue\" case ( 'y_mom_residue' ) w_list ( n ) = \"Y_mom_residue\" case ( 'z_mom_residue' ) w_list ( n ) = \"Z_mom_residue\" case ( 'energy_residue' ) w_list ( n ) = \"Energy_residue\" case ( 'f1' ) if ( trim ( turbulence ) == 'sst' . or . trim ( turbulence ) == 'sst2003' ) then w_list ( n ) = \"F1\" else w_list ( n ) = 'do not write' end if case ( 'dudx' ) w_list ( n ) = \"Dudx\" case ( 'dudy' ) w_list ( n ) = \"Dudy\" case ( 'dudz' ) w_list ( n ) = \"Dudz\" case ( 'dvdx' ) w_list ( n ) = \"Dvdx\" case ( 'dvdy' ) w_list ( n ) = \"Dvdy\" case ( 'dvdz' ) w_list ( n ) = \"Dvdz\" case ( 'dwdx' ) w_list ( n ) = \"Dwdx\" case ( 'dwdy' ) w_list ( n ) = \"Dwdy\" case ( 'dwdz' ) w_list ( n ) = \"Dwdz\" case ( 'dTdx' ) w_list ( n ) = \"DTdx\" case ( 'dTdy' ) w_list ( n ) = \"DTdy\" case ( 'dTdz' ) w_list ( n ) = \"DTdz\" case ( 'dtkdx' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkdy' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkdz' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) w_list ( n ) = \"Dtkdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdx' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdy' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtwdz' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) w_list ( n ) = \"Dtwdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedx' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedy' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtedz' ) select case ( trim ( turbulence )) case ( 'ke' ) w_list ( n ) = \"Dtedz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldx' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldy' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtkldz' ) select case ( trim ( turbulence )) case ( 'kkl' ) w_list ( n ) = \"Dtkldz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdx' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdx\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdy' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdy\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'dtvdz' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) w_list ( n ) = \"Dtvdz\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'intermittency' ) select case ( trim ( turbulence )) case ( 'saBC' ) w_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'tgm' ) select case ( trim ( transition )) case ( 'lctm2015' ) w_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) w_list ( n ) = trim ( lcase ( w_list ( n ))) case Default print * , err // trim ( w_list ( n )) // \" to file\" w_list ( n ) = \"do not write\" end select end do end subroutine verify_write_control","tags":"","loc":"proc/verify_write_control.html","title":"verify_write_control – FEST-3D"},{"text":"public subroutine verify_read_control() Verify all the variable being asked to read in the output file. \n This is a fail-safe subroutine which do not allow to read the incorrect input variable. \n Based on previous flow type some varible might be skipped Arguments None Calls proc~~verify_read_control~~CallsGraph proc~verify_read_control verify_read_control proc~lcase lcase proc~verify_read_control->proc~lcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~verify_read_control~~CalledByGraph proc~verify_read_control verify_read_control proc~read_file~3 read_file proc~read_file~3->proc~verify_read_control proc~initstate initstate proc~initstate->proc~read_file~3 proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocverify_read_controlCalledByGraph = svgPanZoom('#procverify_read_controlCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code verify_read_control Source Code subroutine verify_read_control () !< Verify all the variable being asked to read in the output file. !< This is a fail-safe subroutine which do not allow to read the incorrect input variable. !< Based on previous flow type some varible might be skipped implicit none integer :: n character ( len =* ), parameter :: err = \"Control Error: can't read variable - \" do n = 1 , r_count select case ( trim ( lcase ( r_list ( n )))) case ( 'velocity' , 'vel' , 'speed' , 'u' , 'v' ) r_list ( n ) = \"Velocity\" case ( 'density' , 'rho' ) r_list ( n ) = \"Density\" case ( 'pressure' , 'presssure' , 'p' ) r_list ( n ) = \"Pressure\" case ( 'mu' , 'viscosity' , 'mu_l' , 'laminar_viscosity' , 'muv' , 'mu_v' ) r_list ( n ) = \"do not read\" ! if (mu_ref/=0.0) then !   r_list(n) = \"Mu\" ! else !   print*, err//trim(r_list(n))//\" from file\" !   r_list(n) = \"do not read\" ! end if case ( 'mu_t' , 'turbulent_viscosity' , 'mut' ) r_list ( n ) = \"do not read\" !if (turbulence/='none') then !  r_list(n) = \"Mu_t\" !else !  print*, err//trim(r_list(n))//\" from file\" !  r_list(n) = \"do not read\" !end if case ( 'tke' , 'tk' , 'turbulent_kinetic_enrgy' , 'k' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'kkl' , 'ke' , 'des-sst' ) r_list ( n ) = \"TKE\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'omega' , 'tw' ) select case ( trim ( turbulence )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' , 'kw' , 'bsl' , 'des-sst' ) r_list ( n ) = \"Omega\" case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'dissipation' , 'te' , 'teps' , 'eps' ) select case ( trim ( turbulence )) case ( 'ke' ) select case ( trim ( previous_flow_type )) case ( 'ke' ) r_list ( n ) = \"Dissipation\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'kl' ) select case ( trim ( turbulence )) case ( 'kkl' ) select case ( trim ( previous_flow_type )) case ( 'kkl' ) r_list ( n ) = \"Kl\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'tv' ) select case ( trim ( turbulence )) case ( 'sa' , 'saBC' ) select case ( trim ( previous_flow_type )) case ( 'sa' , 'saBC' ) r_list ( n ) = \"tv\" case DEFAULT print * , err // trim ( w_list ( n )) // \" to file\" r_list ( n ) = \"do not write\" end select case DEFAULT print * , err // trim ( w_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select case ( 'wall_distance' , 'dist' , 'wall_dist' , 'wdist' ) r_list ( n ) = \"do not read\" !if(turbulence/=\"none\") then !  r_list(n) = \"Wall_distance\" !else !  print*, err//trim(r_list(n))//\" from file\" !  r_list(n) = \"do not read\" !end if case ( 'intermittency' ) select case ( trim ( turbulence )) case ( 'saBC' ) select case ( trim ( previous_flow_type )) case ( 'saBC' ) r_list ( n ) = \"Intermittency\" case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case ( 'tgm' ) select case ( trim ( transition )) case ( 'lctm2015' ) select case ( trim ( previous_flow_type )) case ( 'sst' , 'sst2003' ) r_list ( n ) = \"tgm\" case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case DEFAULT print * , err // trim ( r_list ( n )) // \" to file\" r_list ( n ) = \"do not read\" end select case ( 'resnorm' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Resnorm\" case ( 'tke_residue' ) r_list ( n ) = \"do not read\" !r_list(n) = \"TKE_residue\" case ( 'omega_residue' ) r_list ( n ) = \"do not read\" !w_list(n) = \"Omega_residue\" case ( 'f1' ) r_list ( n ) = \"do not read\" !r_list(n) = \"F1\" case ( 'dudx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudx\" case ( 'dudy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudy\" case ( 'dudz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dudz\" case ( 'dvdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdx\" case ( 'dvdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdy\" case ( 'dvdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dvdz\" case ( 'dwdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdx\" case ( 'dwdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdy\" case ( 'dwdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dwdz\" case ( 'dTdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdx\" case ( 'dTdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdy\" case ( 'dTdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"DTdz\" case ( 'dtkdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdx\" case ( 'dtkdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdy\" case ( 'dtkdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtkdz\" case ( 'dtwdx' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdx\" case ( 'dtwdy' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdy\" case ( 'dtwdz' ) r_list ( n ) = \"do not read\" !r_list(n) = \"Dtwdz\" case ( 'extravar1' , 'extravar2' , 'extravar3' , 'extravar4' , 'extravar5' ) r_list ( n ) = \"do not read\" !r_list(n) = trim(lcase(w_list(n))) case Default print * , err // trim ( r_list ( n )) // \" from file\" r_list ( n ) = \"do not read\" end select end do end subroutine verify_read_control","tags":"","loc":"proc/verify_read_control.html","title":"verify_read_control – FEST-3D"},{"text":"public function int4_and_int4(a, b) result(r) Bitwise 'AND' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) Called by proc~~int4_and_int4~~CalledByGraph proc~int4_and_int4 int4_and_int4 interface~operator(.and.) operator(.and.) interface~operator(.and.)->proc~int4_and_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_and_int4 Source Code function int4_and_int4 ( a , b ) result ( r ) !< Bitwise 'AND' over two integer of kind 4 implicit none integer ( kind = 4 ), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ) :: r r = iand ( a , b ) end function int4_and_int4","tags":"","loc":"proc/int4_and_int4.html","title":"int4_and_int4 – FEST-3D"},{"text":"public function int8_and_int8(a, b) result(r) Bitwise 'AND' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) Called by proc~~int8_and_int8~~CalledByGraph proc~int8_and_int8 int8_and_int8 interface~operator(.and.) operator(.and.) interface~operator(.and.)->proc~int8_and_int8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int8_and_int8 Source Code function int8_and_int8 ( a , b ) result ( r ) !< Bitwise 'AND' over two integer of kind 8 implicit none integer ( kind = 8 ), intent ( in ) :: a integer ( kind = 8 ), intent ( in ) :: b integer ( kind = 8 ) :: r r = iand ( a , b ) end function int8_and_int8","tags":"","loc":"proc/int8_and_int8.html","title":"int8_and_int8 – FEST-3D"},{"text":"public function int4_or_int4(a, b) result(r) Bitwise 'OR' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) Called by proc~~int4_or_int4~~CalledByGraph proc~int4_or_int4 int4_or_int4 interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int4_or_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_or_int4 Source Code function int4_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over two integer of kind 4 implicit none integer ( kind = 4 ), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ) :: r r = ior ( a , b ) end function int4_or_int4","tags":"","loc":"proc/int4_or_int4.html","title":"int4_or_int4 – FEST-3D"},{"text":"public function int4_1D_or_int4_1D(a, b) result(r) Bitwise 'OR' over two 1D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in), dimension(:) :: b Return Value integer(kind=4),\n  dimension(size(a)) Called by proc~~int4_1d_or_int4_1d~~CalledByGraph proc~int4_1d_or_int4_1d int4_1D_or_int4_1D interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int4_1d_or_int4_1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_1D_or_int4_1D Source Code function int4_1D_or_int4_1D ( a , b ) result ( r ) !< Bitwise 'OR' over two 1D integer array of kind 4 implicit none integer ( kind = 4 ), dimension (:), intent ( in ) :: a integer ( kind = 4 ), dimension (:), intent ( in ) :: b integer ( kind = 4 ), dimension ( size ( a )) :: r if ( size ( a ) /= size ( b )) then print * , \"Error: Sizes of arrays being 'or'ed should be the same.\" stop end if r = ior ( a , b ) end function int4_1D_or_int4_1D","tags":"","loc":"proc/int4_1d_or_int4_1d.html","title":"int4_1D_or_int4_1D – FEST-3D"},{"text":"public function int4_1D_or_int4(a, b) result(r) Bitwise 'OR' over one 1D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(size(a)) Called by proc~~int4_1d_or_int4~~CalledByGraph proc~int4_1d_or_int4 int4_1D_or_int4 interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int4_1d_or_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_1D_or_int4 Source Code function int4_1D_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over one 1D integer array and integer of kind 4 implicit none integer ( kind = 4 ), dimension (:), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ), dimension ( size ( a )) :: r integer :: i i = 1 do while ( i <= size ( a )) r ( i ) = ior ( a ( i ), b ) i = i + 1 end do end function int4_1D_or_int4","tags":"","loc":"proc/int4_1d_or_int4.html","title":"int4_1D_or_int4 – FEST-3D"},{"text":"public function int4_2D_or_int4_2D(a, b) result(r) Bitwise 'OR' over two 2D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in), dimension(:, :) :: b Return Value integer(kind=4),\n  dimension(:, :),allocatable Called by proc~~int4_2d_or_int4_2d~~CalledByGraph proc~int4_2d_or_int4_2d int4_2D_or_int4_2D interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int4_2d_or_int4_2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_2D_or_int4_2D Source Code function int4_2D_or_int4_2D ( a , b ) result ( r ) !< Bitwise 'OR' over two 2D integer array of kind 4 implicit none integer ( kind = 4 ), dimension (:, :), intent ( in ) :: a integer ( kind = 4 ), dimension (:, :), intent ( in ) :: b integer ( kind = 4 ), dimension ( 1 : 2 ) :: na , nb integer ( kind = 4 ), dimension (:, :), allocatable :: r na = shape ( a ) nb = shape ( b ) if (( na ( 1 ) /= nb ( 1 )) . or . ( na ( 2 ) /= nb ( 2 ))) then print * , \"Error: Sizes of arrays being 'or'ed should be the same.\" stop end if allocate ( r ( 1 : na ( 1 ), 1 : na ( 2 ))) r = ior ( a , b ) end function int4_2D_or_int4_2D","tags":"","loc":"proc/int4_2d_or_int4_2d.html","title":"int4_2D_or_int4_2D – FEST-3D"},{"text":"public function int4_2D_or_int4(a, b) result(r) Bitwise 'OR' over one 2D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(:, :),allocatable Called by proc~~int4_2d_or_int4~~CalledByGraph proc~int4_2d_or_int4 int4_2D_or_int4 interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int4_2d_or_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_2D_or_int4 Source Code function int4_2D_or_int4 ( a , b ) result ( r ) !< Bitwise 'OR' over one 2D integer array and integer of kind 4 implicit none integer ( kind = 4 ), dimension (:, :), intent ( in ) :: a integer ( kind = 4 ), intent ( in ) :: b integer ( kind = 4 ), dimension ( 1 : 2 ) :: n integer ( kind = 4 ), dimension (:, :), allocatable :: r integer :: i , j n = shape ( a ) allocate ( r ( 1 : n ( 1 ), 1 : n ( 2 ))) do j = 1 , n ( 2 ) do i = 1 , n ( 1 ) r ( i , j ) = ior ( a ( i , j ), b ) end do end do end function int4_2D_or_int4","tags":"","loc":"proc/int4_2d_or_int4.html","title":"int4_2D_or_int4 – FEST-3D"},{"text":"public function int8_or_int8(a, b) result(r) Bitwise 'OR' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) Called by proc~~int8_or_int8~~CalledByGraph proc~int8_or_int8 int8_or_int8 interface~operator(.or.) operator(.or.) interface~operator(.or.)->proc~int8_or_int8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int8_or_int8 Source Code function int8_or_int8 ( a , b ) result ( r ) !< Bitwise 'OR' over two integer of kind 8 implicit none integer ( kind = 8 ), intent ( in ) :: a integer ( kind = 8 ), intent ( in ) :: b integer ( kind = 8 ) :: r r = ior ( a , b ) end function int8_or_int8","tags":"","loc":"proc/int8_or_int8.html","title":"int8_or_int8 – FEST-3D"},{"text":"public subroutine bin_to_int4(r, binstr) String of binary number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: binstr Called by proc~~bin_to_int4~~CalledByGraph proc~bin_to_int4 bin_to_int4 interface~bin2int bin2int interface~bin2int->proc~bin_to_int4 proc~int4_from_string int4_from_string proc~int4_from_string->interface~bin2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~bin2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code bin_to_int4 Source Code subroutine bin_to_int4 ( r , binstr ) !< String of binary number converted to integer of kind 4 implicit none character ( len =* ) :: binstr integer ( kind = 4 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( binstr ) r = 0 do while ( i > 0 ) read ( binstr ( i : i ), * ) current_digit r = r + (( 2 ** ( len ( binstr ) - i )) * current_digit ) i = i - 1 end do end subroutine bin_to_int4","tags":"","loc":"proc/bin_to_int4.html","title":"bin_to_int4 – FEST-3D"},{"text":"public subroutine bin_to_int8(r, binstr) String of binary number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: binstr Called by proc~~bin_to_int8~~CalledByGraph proc~bin_to_int8 bin_to_int8 interface~bin2int bin2int interface~bin2int->proc~bin_to_int8 proc~int4_from_string int4_from_string proc~int4_from_string->interface~bin2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~bin2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code bin_to_int8 Source Code subroutine bin_to_int8 ( r , binstr ) !< String of binary number converted to integer of kind 8 implicit none character ( len =* ) :: binstr integer ( kind = 8 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( binstr ) r = 0 do while ( i > 0 ) read ( binstr ( i : i ), * ) current_digit r = r + (( 2 ** ( len ( binstr ) - i )) * current_digit ) i = i - 1 end do end subroutine bin_to_int8","tags":"","loc":"proc/bin_to_int8.html","title":"bin_to_int8 – FEST-3D"},{"text":"public subroutine oct_to_int4(r, octstr) String of octal number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: octstr Called by proc~~oct_to_int4~~CalledByGraph proc~oct_to_int4 oct_to_int4 interface~oct2int oct2int interface~oct2int->proc~oct_to_int4 proc~int4_from_string int4_from_string proc~int4_from_string->interface~oct2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~oct2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code oct_to_int4 Source Code subroutine oct_to_int4 ( r , octstr ) !< String of octal number converted to integer of kind 4 implicit none character ( len =* ) :: octstr integer ( kind = 4 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( octstr ) r = 0 do while ( i > 0 ) read ( octstr ( i : i ), * ) current_digit r = r + (( 8 ** ( len ( octstr ) - i )) * current_digit ) i = i - 1 end do end subroutine oct_to_int4","tags":"","loc":"proc/oct_to_int4.html","title":"oct_to_int4 – FEST-3D"},{"text":"public subroutine oct_to_int8(r, octstr) String of octal number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: octstr Called by proc~~oct_to_int8~~CalledByGraph proc~oct_to_int8 oct_to_int8 interface~oct2int oct2int interface~oct2int->proc~oct_to_int8 proc~int4_from_string int4_from_string proc~int4_from_string->interface~oct2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~oct2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code oct_to_int8 Source Code subroutine oct_to_int8 ( r , octstr ) !< String of octal number converted to integer of kind 8 implicit none character ( len =* ) :: octstr integer ( kind = 8 ), intent ( out ) :: r integer :: current_digit integer :: i i = len ( octstr ) r = 0 do while ( i > 0 ) read ( octstr ( i : i ), * ) current_digit r = r + (( 8 ** ( len ( octstr ) - i )) * current_digit ) i = i - 1 end do end subroutine oct_to_int8","tags":"","loc":"proc/oct_to_int8.html","title":"oct_to_int8 – FEST-3D"},{"text":"public subroutine int4_from_string(lhs, rhs) Get integer of kind 4 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: lhs character(len=*), intent(in) :: rhs Calls proc~~int4_from_string~~CallsGraph proc~int4_from_string int4_from_string interface~bin2int bin2int proc~int4_from_string->interface~bin2int interface~oct2int oct2int proc~int4_from_string->interface~oct2int proc~bin_to_int8 bin_to_int8 interface~bin2int->proc~bin_to_int8 proc~bin_to_int4 bin_to_int4 interface~bin2int->proc~bin_to_int4 proc~oct_to_int8 oct_to_int8 interface~oct2int->proc~oct_to_int8 proc~oct_to_int4 oct_to_int4 interface~oct2int->proc~oct_to_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~int4_from_string~~CalledByGraph proc~int4_from_string int4_from_string interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int4_from_string Source Code subroutine int4_from_string ( lhs , rhs ) !< Get integer of kind 4 from the string which might contain either octal or binary number implicit none integer ( kind = 4 ), intent ( out ) :: lhs character ( len =* ), intent ( in ) :: rhs character ( len = len ( rhs ) - 1 ) :: temp temp = rhs ( 2 :) if ( rhs ( 1 : 1 ) == 'b' ) then call bin2int ( lhs , temp ) else if ( rhs ( 1 : 1 ) == 'o' ) then call oct2int ( lhs , temp ) end if end subroutine int4_from_string","tags":"","loc":"proc/int4_from_string.html","title":"int4_from_string – FEST-3D"},{"text":"public subroutine int8_from_string(lhs, rhs) Get integer of kind 8 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: lhs character(len=*), intent(in) :: rhs Calls proc~~int8_from_string~~CallsGraph proc~int8_from_string int8_from_string interface~bin2int bin2int proc~int8_from_string->interface~bin2int interface~oct2int oct2int proc~int8_from_string->interface~oct2int proc~bin_to_int8 bin_to_int8 interface~bin2int->proc~bin_to_int8 proc~bin_to_int4 bin_to_int4 interface~bin2int->proc~bin_to_int4 proc~oct_to_int8 oct_to_int8 interface~oct2int->proc~oct_to_int8 proc~oct_to_int4 oct_to_int4 interface~oct2int->proc~oct_to_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~int8_from_string~~CalledByGraph proc~int8_from_string int8_from_string interface~assignment(=) assignment(=) interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code int8_from_string Source Code subroutine int8_from_string ( lhs , rhs ) !< Get integer of kind 8 from the string which might contain either octal or binary number implicit none integer ( kind = 8 ), intent ( out ) :: lhs character ( len =* ), intent ( in ) :: rhs character ( len = len ( rhs ) - 1 ) :: temp temp = rhs ( 2 :) if ( rhs ( 1 : 1 ) == 'b' ) then call bin2int ( lhs , temp ) else if ( rhs ( 1 : 1 ) == 'o' ) then call oct2int ( lhs , temp ) end if end subroutine int8_from_string","tags":"","loc":"proc/int8_from_string.html","title":"int8_from_string – FEST-3D"},{"text":"public interface operator(.and.) Calls interface~~operator(.and.)~~CallsGraph interface~operator(.and.) operator(.and.) proc~int4_and_int4 int4_and_int4 interface~operator(.and.)->proc~int4_and_int4 proc~int8_and_int8 int8_and_int8 interface~operator(.and.)->proc~int8_and_int8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures int4_and_int4 int8_and_int8 Module Procedures public function int4_and_int4 (a, b) result(r) Bitwise 'AND' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int8_and_int8 (a, b) result(r) Bitwise 'AND' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8)","tags":"","loc":"interface/operator(.and.).html","title":"operator(.and.) – FEST-3D"},{"text":"public interface operator(.or.) Calls interface~~operator(.or.)~~CallsGraph interface~operator(.or.) operator(.or.) proc~int4_or_int4 int4_or_int4 interface~operator(.or.)->proc~int4_or_int4 proc~int4_1d_or_int4 int4_1D_or_int4 interface~operator(.or.)->proc~int4_1d_or_int4 proc~int4_2d_or_int4_2d int4_2D_or_int4_2D interface~operator(.or.)->proc~int4_2d_or_int4_2d proc~int4_2d_or_int4 int4_2D_or_int4 interface~operator(.or.)->proc~int4_2d_or_int4 proc~int4_1d_or_int4_1d int4_1D_or_int4_1D interface~operator(.or.)->proc~int4_1d_or_int4_1d proc~int8_or_int8 int8_or_int8 interface~operator(.or.)->proc~int8_or_int8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures int4_or_int4 int4_1D_or_int4_1D int4_1D_or_int4 int4_2D_or_int4_2D int4_2D_or_int4 int8_or_int8 Module Procedures public function int4_or_int4 (a, b) result(r) Bitwise 'OR' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int4_1D_or_int4_1D (a, b) result(r) Bitwise 'OR' over two 1D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in), dimension(:) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_1D_or_int4 (a, b) result(r) Bitwise 'OR' over one 1D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_2D_or_int4_2D (a, b) result(r) Bitwise 'OR' over two 2D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in), dimension(:, :) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int4_2D_or_int4 (a, b) result(r) Bitwise 'OR' over one 2D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int8_or_int8 (a, b) result(r) Bitwise 'OR' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8)","tags":"","loc":"interface/operator(.or.).html","title":"operator(.or.) – FEST-3D"},{"text":"public interface assignment(=) Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~int4_from_string int4_from_string interface~assignment(=)->proc~int4_from_string proc~int8_from_string int8_from_string interface~assignment(=)->proc~int8_from_string interface~bin2int bin2int proc~int4_from_string->interface~bin2int interface~oct2int oct2int proc~int4_from_string->interface~oct2int proc~int8_from_string->interface~bin2int proc~int8_from_string->interface~oct2int proc~bin_to_int8 bin_to_int8 interface~bin2int->proc~bin_to_int8 proc~bin_to_int4 bin_to_int4 interface~bin2int->proc~bin_to_int4 proc~oct_to_int8 oct_to_int8 interface~oct2int->proc~oct_to_int8 proc~oct_to_int4 oct_to_int4 interface~oct2int->proc~oct_to_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures int4_from_string int8_from_string Module Procedures public subroutine int4_from_string (lhs, rhs) Get integer of kind 4 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: lhs character(len=*), intent(in) :: rhs public subroutine int8_from_string (lhs, rhs) Get integer of kind 8 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: lhs character(len=*), intent(in) :: rhs","tags":"","loc":"interface/assignment(=).html","title":"assignment(=) – FEST-3D"},{"text":"public interface bin2int Calls interface~~bin2int~~CallsGraph interface~bin2int bin2int proc~bin_to_int8 bin_to_int8 interface~bin2int->proc~bin_to_int8 proc~bin_to_int4 bin_to_int4 interface~bin2int->proc~bin_to_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~bin2int~~CalledByGraph interface~bin2int bin2int proc~int4_from_string int4_from_string proc~int4_from_string->interface~bin2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~bin2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures bin_to_int4 bin_to_int8 Module Procedures public subroutine bin_to_int4 (r, binstr) String of binary number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: binstr public subroutine bin_to_int8 (r, binstr) String of binary number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: binstr","tags":"","loc":"interface/bin2int.html","title":"bin2int – FEST-3D"},{"text":"public interface oct2int Calls interface~~oct2int~~CallsGraph interface~oct2int oct2int proc~oct_to_int8 oct_to_int8 interface~oct2int->proc~oct_to_int8 proc~oct_to_int4 oct_to_int4 interface~oct2int->proc~oct_to_int4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~oct2int~~CalledByGraph interface~oct2int oct2int proc~int4_from_string int4_from_string proc~int4_from_string->interface~oct2int proc~int8_from_string int8_from_string proc~int8_from_string->interface~oct2int interface~assignment(=) assignment(=) interface~assignment(=)->proc~int4_from_string interface~assignment(=)->proc~int8_from_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures oct_to_int4 oct_to_int8 Module Procedures public subroutine oct_to_int4 (r, octstr) String of octal number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: octstr public subroutine oct_to_int8 (r, octstr) String of octal number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: octstr","tags":"","loc":"interface/oct2int.html","title":"oct2int – FEST-3D"},{"text":"public function ucase(text) result(res) Mmake the whole string to upper case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of upper case Contents Source Code ucase Source Code function ucase ( text ) result ( res ) !<Mmake the whole string to upper case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of upper case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"abcdefghijklmnopqrstuvwxyz\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" ( C : C ) END DO end function ucase","tags":"","loc":"proc/ucase.html","title":"ucase – FEST-3D"},{"text":"public function lcase(text) result(res) Make the whole string to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of lower case Called by proc~~lcase~~CalledByGraph proc~lcase lcase proc~verify_write_control verify_write_control proc~verify_write_control->proc~lcase proc~verify_read_control verify_read_control proc~verify_read_control->proc~lcase proc~initstate initstate proc~initstate->proc~verify_write_control proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~read_file~3->proc~verify_read_control proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panproclcaseCalledByGraph = svgPanZoom('#proclcaseCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code lcase Source Code function lcase ( text ) result ( res ) !< Make the whole string to lower case CHARACTER ( len =* ), intent ( in ) :: text !< Input string of any case character ( len = STRING_BUFFER_LENGTH ) :: res !< Output string of lower case integer :: I , C res = text DO I = 1 , LEN ( TEXT ) C = INDEX ( \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , TEXT ( I : I )) IF ( C . GT . 0 ) res ( I : I ) = \"abcdefghijklmnopqrstuvwxyz\" ( C : C ) END DO end function lcase","tags":"","loc":"proc/lcase.html","title":"lcase – FEST-3D"},{"text":"public function int_to_str(i) result(a) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) Called by proc~~int_to_str~~CalledByGraph proc~int_to_str int_to_str interface~tostr tostr interface~tostr->proc~int_to_str proc~str_cat_real str_cat_real proc~str_cat_real->interface~tostr proc~intlen intlen proc~intlen->interface~tostr proc~real_cat_str real_cat_str proc~real_cat_str->interface~tostr interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_real interface~operator( + )->proc~real_cat_str interface~len len interface~len->proc~intlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/int_to_str.html","title":"int_to_str – FEST-3D"},{"text":"public function real_to_str(r) result(a) Convert real number to string Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) Called by proc~~real_to_str~~CalledByGraph proc~real_to_str real_to_str interface~tostr tostr interface~tostr->proc~real_to_str proc~reallen reallen proc~reallen->proc~real_to_str proc~str_cat_real str_cat_real proc~str_cat_real->interface~tostr proc~intlen intlen proc~intlen->interface~tostr proc~real_cat_str real_cat_str proc~real_cat_str->interface~tostr interface~len len interface~len->proc~reallen interface~len->proc~intlen interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_real interface~operator( + )->proc~real_cat_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/real_to_str.html","title":"real_to_str – FEST-3D"},{"text":"public function bool_to_str(b) result(a) Convert boolean variable to string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) Called by proc~~bool_to_str~~CalledByGraph proc~bool_to_str bool_to_str interface~tostr tostr interface~tostr->proc~bool_to_str proc~str_cat_real str_cat_real proc~str_cat_real->interface~tostr proc~intlen intlen proc~intlen->interface~tostr proc~real_cat_str real_cat_str proc~real_cat_str->interface~tostr interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_real interface~operator( + )->proc~real_cat_str interface~len len interface~len->proc~intlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bool_to_str.html","title":"bool_to_str – FEST-3D"},{"text":"public function str_cat_str(s1, s2) result(a) Join two string into one string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value character(len=MAX_STRING_LEN) Called by proc~~str_cat_str~~CalledByGraph proc~str_cat_str str_cat_str interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_cat_str.html","title":"str_cat_str – FEST-3D"},{"text":"public function str_cat_int(s, i) result(a) Join a string to a integer and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) Called by proc~~str_cat_int~~CalledByGraph proc~str_cat_int str_cat_int interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_cat_int.html","title":"str_cat_int – FEST-3D"},{"text":"public function int_cat_str(i, s) result(a) Join a integer to a string and gives result as a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) Called by proc~~int_cat_str~~CalledByGraph proc~int_cat_str int_cat_str interface~operator( + ) operator( + ) interface~operator( + )->proc~int_cat_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/int_cat_str.html","title":"int_cat_str – FEST-3D"},{"text":"public function str_cat_real(s, r) result(a) Join a string to a real number and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) Calls proc~~str_cat_real~~CallsGraph proc~str_cat_real str_cat_real interface~tostr tostr proc~str_cat_real->interface~tostr proc~real_to_str real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~str_cat_real~~CalledByGraph proc~str_cat_real str_cat_real interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_cat_real.html","title":"str_cat_real – FEST-3D"},{"text":"public function real_cat_str(r, s) result(a) Join a real number to a string and gives result as a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) Calls proc~~real_cat_str~~CallsGraph proc~real_cat_str real_cat_str interface~tostr tostr proc~real_cat_str->interface~tostr proc~real_to_str real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~real_cat_str~~CalledByGraph proc~real_cat_str real_cat_str interface~operator( + ) operator( + ) interface~operator( + )->proc~real_cat_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/real_cat_str.html","title":"real_cat_str – FEST-3D"},{"text":"public function str_cat_bool(s, b) result(a) Join a string to a boolean and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) Called by proc~~str_cat_bool~~CalledByGraph proc~str_cat_bool str_cat_bool interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_bool Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/str_cat_bool.html","title":"str_cat_bool – FEST-3D"},{"text":"public function bool_cat_str(b, s) result(a) Join a boolean to a string and gives result as a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) Called by proc~~bool_cat_str~~CalledByGraph proc~bool_cat_str bool_cat_str interface~operator( + ) operator( + ) interface~operator( + )->proc~bool_cat_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/bool_cat_str.html","title":"bool_cat_str – FEST-3D"},{"text":"public function intlen(i) result(l) Return the \"string length of an integer\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer Calls proc~~intlen~~CallsGraph proc~intlen intlen interface~tostr tostr proc~intlen->interface~tostr proc~real_to_str real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~intlen~~CalledByGraph proc~intlen intlen interface~len len interface~len->proc~intlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/intlen.html","title":"intlen – FEST-3D"},{"text":"public function reallen(r) result(l) Return the \"string length of a real\" Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value integer Calls proc~~reallen~~CallsGraph proc~reallen reallen proc~real_to_str real_to_str proc~reallen->proc~real_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~reallen~~CalledByGraph proc~reallen reallen interface~len len interface~len->proc~reallen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents None","tags":"","loc":"proc/reallen.html","title":"reallen – FEST-3D"},{"text":"public subroutine chfmt(d, e, f) Change format specifier for reals Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: d integer, intent(in), optional :: e character, intent(in), optional :: f Contents Source Code chfmt Source Code subroutine chfmt ( d , e , f ) !< Change format specifier for reals !----------------------------------------------------------- ! Change format specifier for reals ! ! Inputs: !   d -> integer, optional !       digits after decimal !   e -> integer, optional !       digits in exponent !       When this is set to -1, the exponent part is dropped !   f -> character, optional !       form !       Valid options: 'F' (decimal), 'E' (exponential), !           'S' (scientific), 'N' (engineering) !       If 'F' is specified, then the value for e is !           overridden and set to -1. ! ! If no arguments are passed, this function resets all the ! parameters to their default values (as provided in the ! following table. Else, only the passed arguments will be ! updated (the others will be left unchanged). ! ! This function is sticky; a format once set will continue ! to apply till either it is changed or the program ends. ! ! Default values: !   d (digits after decimal) --> 6 !   e (digits in exponent) --> -1 !   f (form) --> 'F' (decimal) ! !TODO: Add support for width also? !http://www.cs.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html !----------------------------------------------------------- implicit none integer , intent ( in ), optional :: d integer , intent ( in ), optional :: e character , intent ( in ), optional :: f if (. not . ( present ( d ) . or . present ( e ) . or . present ( f ))) then dec_ = 6 exp_ = 0 form_ = 'F' else if ( present ( d )) dec_ = d if ( present ( e )) exp_ = e if ( present ( f )) then if (. not . ( f . eq . 'F' . or . f . eq . 'E' . or . & f . eq . 'S' . or . f . eq . 'N' )) then print * , 'Error: Unknown kind specified.' stop end if form_ = f if ( form_ . eq . 'F' ) exp_ = - 1 end if end if end subroutine chfmt","tags":"","loc":"proc/chfmt.html","title":"chfmt – FEST-3D"},{"text":"public subroutine disp(s) Display the contents of the string Arguments Type Intent Optional Attributes Name character(len=MAX_STRING_LEN), intent(in) :: s Contents Source Code disp Source Code subroutine disp ( s ) !< Display the contents of the string ! ! This function trims the string before printing it. !----------------------------------------------------------- implicit none character ( len = MAX_STRING_LEN ), intent ( in ) :: s print * , trim ( s ) end subroutine disp","tags":"","loc":"proc/disp.html","title":"disp – FEST-3D"},{"text":"public interface tostr Calls interface~~tostr~~CallsGraph interface~tostr tostr proc~real_to_str real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by interface~~tostr~~CalledByGraph interface~tostr tostr proc~str_cat_real str_cat_real proc~str_cat_real->interface~tostr proc~intlen intlen proc~intlen->interface~tostr proc~real_cat_str real_cat_str proc~real_cat_str->interface~tostr interface~operator( + ) operator( + ) interface~operator( + )->proc~str_cat_real interface~operator( + )->proc~real_cat_str interface~len len interface~len->proc~intlen Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures int_to_str real_to_str bool_to_str Module Procedures public function int_to_str (i) result(a) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function real_to_str (r) result(a) Convert real number to string Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function bool_to_str (b) result(a) Convert boolean variable to string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN)","tags":"","loc":"interface/tostr.html","title":"tostr – FEST-3D"},{"text":"public interface operator( + ) Calls interface~~operator( + )~~CallsGraph interface~operator( + ) operator( + ) proc~str_cat_real str_cat_real interface~operator( + )->proc~str_cat_real proc~str_cat_bool str_cat_bool interface~operator( + )->proc~str_cat_bool proc~str_cat_str str_cat_str interface~operator( + )->proc~str_cat_str proc~int_cat_str int_cat_str interface~operator( + )->proc~int_cat_str proc~real_cat_str real_cat_str interface~operator( + )->proc~real_cat_str proc~str_cat_int str_cat_int interface~operator( + )->proc~str_cat_int proc~bool_cat_str bool_cat_str interface~operator( + )->proc~bool_cat_str interface~tostr tostr proc~str_cat_real->interface~tostr proc~real_cat_str->interface~tostr proc~real_to_str real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures str_cat_str str_cat_int int_cat_str str_cat_real real_cat_str str_cat_bool bool_cat_str Module Procedures public function str_cat_str (s1, s2) result(a) Join two string into one string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value character(len=MAX_STRING_LEN) public function str_cat_int (s, i) result(a) Join a string to a integer and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function int_cat_str (i, s) result(a) Join a integer to a string and gives result as a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_real (s, r) result(a) Join a string to a real number and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function real_cat_str (r, s) result(a) Join a real number to a string and gives result as a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_bool (s, b) result(a) Join a string to a boolean and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) public function bool_cat_str (b, s) result(a) Join a boolean to a string and gives result as a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN)","tags":"","loc":"interface/operator( + ).html","title":"operator( + ) – FEST-3D"},{"text":"public interface len Calls interface~~len~~CallsGraph interface~len len proc~intlen intlen interface~len->proc~intlen proc~reallen reallen interface~len->proc~reallen interface~tostr tostr proc~intlen->interface~tostr proc~real_to_str real_to_str proc~reallen->proc~real_to_str interface~tostr->proc~real_to_str proc~int_to_str int_to_str interface~tostr->proc~int_to_str proc~bool_to_str bool_to_str interface~tostr->proc~bool_to_str Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Module Procedures intlen reallen Module Procedures public function intlen (i) result(l) Return the \"string length of an integer\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer public function reallen (r) result(l) Return the \"string length of a real\" Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value integer","tags":"","loc":"interface/len.html","title":"len – FEST-3D"},{"text":"public subroutine open_file(handler) Open single file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler Calls proc~~open_file~3~~CallsGraph proc~open_file~3 open_file proc~close_file~3 close_file proc~open_file~3->proc~close_file~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code open_file Source Code subroutine open_file ( handler ) !< Open single file implicit none integer , intent ( in ) :: handler select case ( handler ) case ( 1 ) close_file ( handler ) open ( handler ,) case ( 2 ) end select end subroutine open_file","tags":"","loc":"proc/open_file~3.html","title":"open_file – FEST-3D"},{"text":"public subroutine abort_run() Aborting the solver Arguments None Calls proc~~abort_run~~CallsGraph proc~abort_run abort_run proc~close_all_files close_all_files proc~abort_run->proc~close_all_files proc~destroy_solver destroy_solver proc~abort_run->proc~destroy_solver mpi_finalize mpi_finalize proc~abort_run->mpi_finalize proc~close_file~3 close_file proc~close_all_files->proc~close_file~3 proc~destroycc destroyCC proc~destroy_solver->proc~destroycc proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time proc~destroy_update destroy_update proc~destroy_solver->proc~destroy_update proc~destroy_gradients destroy_gradients proc~destroy_solver->proc~destroy_gradients proc~destroy_grid destroy_grid proc~destroy_solver->proc~destroy_grid proc~destroy_resnorm destroy_resnorm proc~destroy_solver->proc~destroy_resnorm destroy_scheme destroy_scheme proc~destroy_solver->destroy_scheme proc~destroy_state destroy_state proc~destroy_solver->proc~destroy_state proc~destroy_interface destroy_interface proc~destroy_solver->proc~destroy_interface proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~destroy_viscosity destroy_viscosity proc~destroy_solver->proc~destroy_viscosity proc~dmsg dmsg proc~destroy_solver->proc~dmsg proc~destroy_wall_dist destroy_wall_dist proc~destroy_solver->proc~destroy_wall_dist proc~destroy_bc destroy_bc proc~destroy_solver->proc~destroy_bc proc~destroy_source destroy_source proc~destroy_solver->proc~destroy_source interface~dealloc dealloc proc~destroycc->interface~dealloc debugcall debugcall proc~destroycc->debugcall proc~destroy_time->proc~dmsg interface~alloc alloc proc~destroy_time->interface~alloc mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~destroy_time->interface~dealloc proc~write_time write_time proc~destroy_time->proc~write_time proc~destroy_lusgs destroy_lusgs proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_update->interface~dealloc proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_memory destroy_memory proc~destroy_gradients->proc~destroy_memory proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients->proc~destroy_kkl_grad proc~destroy_gradients->debugcall proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_grid->proc~dmsg proc~destroy_grid->interface~dealloc proc~destroy_resnorm->proc~close_file~3 proc~deallocate_memory deallocate_memory proc~destroy_resnorm->proc~deallocate_memory proc~deallocate_memory~4 deallocate_memory proc~destroy_state->proc~deallocate_memory~4 proc~destroy_state->debugcall proc~unlink_aliases~2 unlink_aliases proc~destroy_state->proc~unlink_aliases~2 proc~destroy_interface->interface~dealloc proc~destroy_geometry->proc~dmsg proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_viscosity->interface~dealloc proc~destroy_wall_dist->proc~dmsg proc~destroy_wall_dist->interface~dealloc proc~destroy_bc->interface~dealloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code abort_run Source Code subroutine abort_run () !< Aborting the solver implicit none integer :: ierr call close_all_files () call destroy_solver () call MPI_FINALIZE ( ierr ) stop end subroutine abort_run","tags":"","loc":"proc/abort_run.html","title":"abort_run – FEST-3D"},{"text":"public subroutine finish_run() Finishing the solution computation Arguments None Calls proc~~finish_run~~CallsGraph proc~finish_run finish_run proc~close_all_files close_all_files proc~finish_run->proc~close_all_files proc~destroy_solver destroy_solver proc~finish_run->proc~destroy_solver mpi_finalize mpi_finalize proc~finish_run->mpi_finalize proc~close_file~3 close_file proc~close_all_files->proc~close_file~3 proc~destroycc destroyCC proc~destroy_solver->proc~destroycc proc~destroy_time destroy_time proc~destroy_solver->proc~destroy_time proc~destroy_update destroy_update proc~destroy_solver->proc~destroy_update proc~destroy_gradients destroy_gradients proc~destroy_solver->proc~destroy_gradients proc~destroy_grid destroy_grid proc~destroy_solver->proc~destroy_grid proc~destroy_resnorm destroy_resnorm proc~destroy_solver->proc~destroy_resnorm destroy_scheme destroy_scheme proc~destroy_solver->destroy_scheme proc~destroy_state destroy_state proc~destroy_solver->proc~destroy_state proc~destroy_interface destroy_interface proc~destroy_solver->proc~destroy_interface proc~destroy_geometry destroy_geometry proc~destroy_solver->proc~destroy_geometry proc~destroy_viscosity destroy_viscosity proc~destroy_solver->proc~destroy_viscosity proc~dmsg dmsg proc~destroy_solver->proc~dmsg proc~destroy_wall_dist destroy_wall_dist proc~destroy_solver->proc~destroy_wall_dist proc~destroy_bc destroy_bc proc~destroy_solver->proc~destroy_bc proc~destroy_source destroy_source proc~destroy_solver->proc~destroy_source interface~dealloc dealloc proc~destroycc->interface~dealloc debugcall debugcall proc~destroycc->debugcall proc~destroy_time->proc~dmsg interface~alloc alloc proc~destroy_time->interface~alloc mpi_gather mpi_gather proc~destroy_time->mpi_gather proc~destroy_time->interface~dealloc proc~write_time write_time proc~destroy_time->proc~write_time proc~destroy_lusgs destroy_lusgs proc~destroy_update->proc~destroy_lusgs proc~destroy_plusgs destroy_plusgs proc~destroy_update->proc~destroy_plusgs proc~destroy_update->interface~dealloc proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_memory destroy_memory proc~destroy_gradients->proc~destroy_memory proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients->proc~destroy_kkl_grad proc~destroy_gradients->debugcall proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_grid->proc~dmsg proc~destroy_grid->interface~dealloc proc~destroy_resnorm->proc~close_file~3 proc~deallocate_memory deallocate_memory proc~destroy_resnorm->proc~deallocate_memory proc~deallocate_memory~4 deallocate_memory proc~destroy_state->proc~deallocate_memory~4 proc~destroy_state->debugcall proc~unlink_aliases~2 unlink_aliases proc~destroy_state->proc~unlink_aliases~2 proc~destroy_interface->interface~dealloc proc~destroy_geometry->proc~dmsg proc~deallocate_memory~2 deallocate_memory proc~destroy_geometry->proc~deallocate_memory~2 proc~destroy_viscosity->interface~dealloc proc~destroy_wall_dist->proc~dmsg proc~destroy_wall_dist->interface~dealloc proc~destroy_bc->interface~dealloc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~finish_run~~CalledByGraph proc~finish_run finish_run program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code finish_run Source Code subroutine finish_run () !< Finishing the solution computation implicit none integer :: ierr call close_all_files () call destroy_solver () call MPI_FINALIZE ( ierr ) end subroutine finish_run","tags":"","loc":"proc/finish_run.html","title":"finish_run – FEST-3D"},{"text":"public subroutine start_run() Starting the solver setup Arguments None Calls proc~~start_run~~CallsGraph proc~start_run start_run proc~setup_solver setup_solver proc~start_run->proc~setup_solver mpi_init mpi_init proc~start_run->mpi_init setup_scheme setup_scheme proc~setup_solver->setup_scheme proc~initmisc initmisc proc~setup_solver->proc~initmisc mpi_barrier mpi_barrier proc~setup_solver->mpi_barrier proc~setup_geometry setup_geometry proc~setup_solver->proc~setup_geometry proc~setup_time setup_time proc~setup_solver->proc~setup_time proc~setup_gradients setup_gradients proc~setup_solver->proc~setup_gradients proc~checkpoint checkpoint proc~setup_solver->proc~checkpoint proc~setupcc setupCC proc~setup_solver->proc~setupcc proc~setup_source Setup_source proc~setup_solver->proc~setup_source proc~setup_state setup_state proc~setup_solver->proc~setup_state proc~find_wall_dist find_wall_dist proc~setup_solver->proc~find_wall_dist proc~setup_wall_dist setup_wall_dist proc~setup_solver->proc~setup_wall_dist proc~write_surfnode write_surfnode proc~setup_solver->proc~write_surfnode proc~read_input_and_controls read_input_and_controls proc~setup_solver->proc~read_input_and_controls proc~dmsg dmsg proc~setup_solver->proc~dmsg proc~setup_interface setup_interface proc~setup_solver->proc~setup_interface proc~setup_bc setup_bc proc~setup_solver->proc~setup_bc proc~setup_resnorm setup_resnorm proc~setup_solver->proc~setup_resnorm proc~setup_viscosity setup_viscosity proc~setup_solver->proc~setup_viscosity proc~get_process_data get_process_data proc~setup_solver->proc~get_process_data proc~setup_update setup_update proc~setup_solver->proc~setup_update proc~read_layout_file read_layout_file proc~setup_solver->proc~read_layout_file proc~setup_grid setup_grid proc~setup_solver->proc~setup_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~start_run~~CalledByGraph proc~start_run start_run program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code start_run Source Code subroutine start_run () !< Starting the solver setup implicit none integer :: ierr call MPI_INIT ( ierr ) call setup_solver () end subroutine start_run","tags":"","loc":"proc/start_run.html","title":"start_run – FEST-3D"},{"text":"public subroutine close_all_files() Call to close all files Arguments None Calls proc~~close_all_files~~CallsGraph proc~close_all_files close_all_files proc~close_file~3 close_file proc~close_all_files->proc~close_file~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~close_all_files~~CalledByGraph proc~close_all_files close_all_files proc~finish_run finish_run proc~finish_run->proc~close_all_files proc~abort_run abort_run proc~abort_run->proc~close_all_files program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_all_files Source Code subroutine close_all_files !< Call to close all files implicit none call close_file ( CONFIG_FILE_UNIT ) call close_file ( GRID_FILE_UNIT ) call close_file ( STATE_FILE_UNIT ) call close_file ( IN_FILE_UNIT ) call close_file ( OUT_FILE_UNIT ) call close_file ( RESNORM_FILE_UNIT ) call close_file ( TEMP_NODE_FILE_UNIT ) call close_file ( LAYOUT_FILE_UNIT ) call close_file ( NODESURF_FILE_UNIT ) call close_file ( WALL_DIST_FILE_UNIT ) call close_file ( RES_CONTROL_FILE_UNIT ) call close_file ( INFO_FILE_UNIT ) call close_file ( CONTROL_FILE_UNIT ) call close_file ( SCHEME_FILE_UNIT ) call close_file ( FLOW_FILE_UNIT ) call close_file ( RESTART_FILE_UNIT ) call close_file ( OUTIN_FILE_UNIT ) call close_file ( STOP_FILE_UNIT ) call close_file ( BOUNDARY_CONDITIONS_FILE_UNIT ) end subroutine close_all_files","tags":"","loc":"proc/close_all_files.html","title":"close_all_files – FEST-3D"},{"text":"public subroutine close_file(handler) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler Called by proc~~close_file~3~~CalledByGraph proc~close_file~3 close_file proc~read_output_control read_output_control proc~read_output_control->proc~close_file~3 proc~get_rw_count get_rw_count proc~read_output_control->proc~get_rw_count proc~get_rw_count->proc~close_file~3 proc~close_all_files close_all_files proc~close_all_files->proc~close_file~3 proc~destroy_resnorm destroy_resnorm proc~destroy_resnorm->proc~close_file~3 proc~read_res_list read_Res_list proc~read_res_list->proc~close_file~3 proc~open_file~3 open_file proc~open_file~3->proc~close_file~3 proc~read_interface_map read_interface_map proc~read_interface_map->proc~close_file~3 proc~read_input_and_controls read_input_and_controls proc~read_input_and_controls->proc~read_output_control proc~read_input_and_controls->proc~read_res_list proc~setup_grid setup_grid proc~setup_grid->proc~read_interface_map proc~abort_run abort_run proc~abort_run->proc~close_all_files proc~destroy_solver destroy_solver proc~abort_run->proc~destroy_solver proc~finish_run finish_run proc~finish_run->proc~close_all_files proc~finish_run->proc~destroy_solver proc~destroy_solver->proc~destroy_resnorm proc~setup_solver setup_solver proc~setup_solver->proc~read_input_and_controls proc~setup_solver->proc~setup_grid program~main main program~main->proc~finish_run proc~start_run start_run program~main->proc~start_run proc~setup_all setup_all proc~setup_all->proc~read_input_and_controls proc~setup_all->proc~setup_grid proc~start_run->proc~setup_solver var panprocclose_file3CalledByGraph = svgPanZoom('#procclose_file3CalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code close_file Source Code subroutine close_file ( handler ) !Generalized subroutine to close single file implicit none integer , intent ( in ) :: handler logical :: ok inquire ( handler , opened = ok ) if ( ok ) close ( handler ) end subroutine close_file","tags":"","loc":"proc/close_file~3.html","title":"close_file – FEST-3D"},{"text":"public subroutine setup_sst_grad() Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None Calls proc~~setup_sst_grad~~CallsGraph proc~setup_sst_grad setup_sst_grad debugcall debugcall proc~setup_sst_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_sst_grad~~CalledByGraph proc~setup_sst_grad setup_sst_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~setup_sst_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_sst_grad Source Code subroutine setup_sst_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_sst_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) end subroutine setup_sst_grad","tags":"","loc":"proc/setup_sst_grad.html","title":"setup_sst_grad – FEST-3D"},{"text":"public subroutine destroy_sst_grad() Nullify all the gradient pointer setup for k-kL model Arguments None Calls proc~~destroy_sst_grad~~CallsGraph proc~destroy_sst_grad destroy_sst_grad debugcall debugcall proc~destroy_sst_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_sst_grad~~CalledByGraph proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_sst_grad Source Code subroutine destroy_sst_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_sst_grad' ) nullify ( gradtk_x ) nullify ( gradtw_x ) nullify ( gradtk_y ) nullify ( gradtw_y ) nullify ( gradtk_z ) nullify ( gradtw_z ) end subroutine destroy_sst_grad","tags":"","loc":"proc/destroy_sst_grad.html","title":"destroy_sst_grad – FEST-3D"},{"text":"public subroutine setup_laminar_grad() Setup pointer to the gradient of U, v, w, Temperature\n with respect to x, y, and z Arguments None Calls proc~~setup_laminar_grad~~CallsGraph proc~setup_laminar_grad setup_laminar_grad debugcall debugcall proc~setup_laminar_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_laminar_grad~~CalledByGraph proc~setup_laminar_grad setup_laminar_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~setup_laminar_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_laminar_grad Source Code subroutine setup_laminar_grad () !< Setup pointer to the gradient of U, v, w, Temperature !< with respect to x, y, and z implicit none DebugCall ( 'setup_laminar_grad' ) gradu_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 1 ) gradv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 2 ) gradw_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 3 ) gradT_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 4 ) gradu_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 1 ) gradv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 2 ) gradw_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 3 ) gradT_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 4 ) gradu_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 1 ) gradv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 2 ) gradw_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 3 ) gradT_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 4 ) end subroutine setup_laminar_grad","tags":"","loc":"proc/setup_laminar_grad.html","title":"setup_laminar_grad – FEST-3D"},{"text":"public subroutine destroy_laminar_grad() Unlink the laminar gradient pointers Arguments None Calls proc~~destroy_laminar_grad~~CallsGraph proc~destroy_laminar_grad destroy_laminar_grad debugcall debugcall proc~destroy_laminar_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_laminar_grad~~CalledByGraph proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_laminar_grad Source Code subroutine destroy_laminar_grad () !< Unlink the laminar gradient pointers implicit none DebugCall ( 'destroy_laminar_grad' ) nullify ( gradu_x ) nullify ( gradv_x ) nullify ( gradw_x ) nullify ( gradT_x ) nullify ( gradu_y ) nullify ( gradv_y ) nullify ( gradw_y ) nullify ( gradT_y ) nullify ( gradu_z ) nullify ( gradv_z ) nullify ( gradw_z ) nullify ( gradT_z ) end subroutine destroy_laminar_grad","tags":"","loc":"proc/destroy_laminar_grad.html","title":"destroy_laminar_grad – FEST-3D"},{"text":"public subroutine setup_gradients() Memoery allocation to the gradient variables and \n setup pointer to the slice to the main gradient variable\n based on the various models being used. Arguments None Calls proc~~setup_gradients~~CallsGraph proc~setup_gradients setup_gradients proc~setup_sa_grad setup_sa_grad proc~setup_gradients->proc~setup_sa_grad proc~setup_laminar_grad setup_laminar_grad proc~setup_gradients->proc~setup_laminar_grad proc~setup_sst_grad setup_sst_grad proc~setup_gradients->proc~setup_sst_grad proc~setup_lctm2015_grad setup_lctm2015_grad proc~setup_gradients->proc~setup_lctm2015_grad proc~allocate_memory~5 allocate_memory proc~setup_gradients->proc~allocate_memory~5 proc~setup_kkl_grad setup_kkl_grad proc~setup_gradients->proc~setup_kkl_grad debugcall debugcall proc~setup_gradients->debugcall proc~get_n_grad get_n_grad proc~setup_gradients->proc~get_n_grad proc~setup_sa_grad->debugcall proc~setup_laminar_grad->debugcall proc~setup_sst_grad->debugcall proc~setup_lctm2015_grad->debugcall proc~allocate_memory~5->debugcall interface~alloc alloc proc~allocate_memory~5->interface~alloc aerrmsg aerrmsg proc~allocate_memory~5->aerrmsg proc~setup_kkl_grad->debugcall proc~get_n_grad->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_gradients~~CalledByGraph proc~setup_gradients setup_gradients proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_gradients Source Code subroutine setup_gradients !< Memoery allocation to the gradient variables and !< setup pointer to the slice to the main gradient variable !< based on the various models being used. implicit none DebugCall ( \"setup_gradients\" ) if ( mu_ref /= 0 ) then call get_n_grad () call allocate_memory () ! Linking pointer to laminar gradients call setup_laminar_grad () ! Linking pointer to turbulent gradients select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call setup_sa_grad () case ( 'sst' , 'sst2003' ) call setup_sst_grad () case ( 'kkl' ) call setup_kkl_grad () case DEFAULT !call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) call setup_lctm2015_grad () case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine setup_gradients","tags":"","loc":"proc/setup_gradients.html","title":"setup_gradients – FEST-3D"},{"text":"public subroutine destroy_gradients() Deallocate memoery and nullify pointers\n to the gradient variables. Arguments None Calls proc~~destroy_gradients~~CallsGraph proc~destroy_gradients destroy_gradients proc~destroy_sst_grad destroy_sst_grad proc~destroy_gradients->proc~destroy_sst_grad proc~destroy_memory destroy_memory proc~destroy_gradients->proc~destroy_memory proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients->proc~destroy_kkl_grad debugcall debugcall proc~destroy_gradients->debugcall proc~destroy_laminar_grad destroy_laminar_grad proc~destroy_gradients->proc~destroy_laminar_grad proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_sst_grad->debugcall proc~destroy_memory->debugcall interface~dealloc dealloc proc~destroy_memory->interface~dealloc proc~destroy_sa_grad->debugcall proc~destroy_kkl_grad->debugcall proc~destroy_laminar_grad->debugcall proc~destroy_lctm2015_grad->debugcall proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_gradients~~CalledByGraph proc~destroy_gradients destroy_gradients proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_gradients Source Code subroutine destroy_gradients !< Deallocate memoery and nullify pointers !< to the gradient variables. implicit none DebugCall ( \"destroy_gradients\" ) if ( mu_ref /= 0 ) then call destroy_memory () ! unlink laminar grad pointer call destroy_laminar_grad () !unlink turublent grad pointer select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) call destroy_sa_grad () case ( 'sst' , 'sst2003' ) call destroy_sst_grad () case ( 'kkl' ) call destroy_kkl_grad () case DEFAULT ! call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) call destroy_lctm2015_grad () case ( 'none' , 'bc' ) !do nothing continue case DEFAULT Fatal_error end Select end if end subroutine destroy_gradients","tags":"","loc":"proc/destroy_gradients.html","title":"destroy_gradients – FEST-3D"},{"text":"private subroutine get_n_grad() Set number of variables for which\n gradient is required based on the\n being used Arguments None Calls proc~~get_n_grad~~CallsGraph proc~get_n_grad get_n_grad debugcall debugcall proc~get_n_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~get_n_grad~~CalledByGraph proc~get_n_grad get_n_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~get_n_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code get_n_grad Source Code subroutine get_n_grad () !< Set number of variables for which !< gradient is required based on the !< being used implicit none DebugCall ( \"get_n_grad\" ) select case ( trim ( turbulence )) case ( 'none' ) !do nothing continue case ( 'sa' , 'saBC' ) n_grad = 5 case ( 'sst' , 'sst2003' ) n_grad = 6 case ( 'kkl' ) n_grad = 6 case DEFAULT !call turbulence_read_error() Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) n_grad = n_grad + 1 case ( 'none' , 'bc' ) n_grad = n_grad + 0 case DEFAULT Fatal_error end Select end subroutine get_n_grad","tags":"","loc":"proc/get_n_grad.html","title":"get_n_grad – FEST-3D"},{"text":"private subroutine allocate_memory() Allocating memory to the gradient variable being used Arguments None Calls proc~~allocate_memory~5~~CallsGraph proc~allocate_memory~5 allocate_memory interface~alloc alloc proc~allocate_memory~5->interface~alloc debugcall debugcall proc~allocate_memory~5->debugcall aerrmsg aerrmsg proc~allocate_memory~5->aerrmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~5~~CalledByGraph proc~allocate_memory~5 allocate_memory proc~setup_gradients setup_gradients proc~setup_gradients->proc~allocate_memory~5 proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocating memory to the gradient variable being used implicit none DebugCall ( \"allocate_memory\" ) call alloc ( gradqp_x , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_x\" )) call alloc ( gradqp_y , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_y\" )) call alloc ( gradqp_z , 0 , imx , 0 , jmx , 0 , kmx , 1 , n_grad , AErrMsg ( \"gradqp_z\" )) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~5.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine destroy_memory() Deallocate memeory from the gradient variables Arguments None Calls proc~~destroy_memory~~CallsGraph proc~destroy_memory destroy_memory interface~dealloc dealloc proc~destroy_memory->interface~dealloc debugcall debugcall proc~destroy_memory->debugcall proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_memory~~CalledByGraph proc~destroy_memory destroy_memory proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_memory proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_memory Source Code subroutine destroy_memory () !< Deallocate memeory from the gradient variables implicit none DebugCall ( \"deallocate_memory\" ) call dealloc ( gradqp_x ) call dealloc ( gradqp_y ) call dealloc ( gradqp_z ) end subroutine destroy_memory","tags":"","loc":"proc/destroy_memory.html","title":"destroy_memory – FEST-3D"},{"text":"private function sound_speed_inf() result(a) Return the free stream speed of sound. Arguments None Return Value real Called by proc~~sound_speed_inf~~CalledByGraph proc~sound_speed_inf sound_speed_inf proc~init_infinity_values init_infinity_values proc~init_infinity_values->proc~sound_speed_inf proc~setup_state setup_state proc~setup_state->proc~init_infinity_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code sound_speed_inf Source Code function sound_speed_inf () result ( a ) !< Return the free stream speed of sound. !----------------------------------------------------------- implicit none real :: a a = sqrt ( gm * pressure_inf / density_inf ) end function sound_speed_inf","tags":"","loc":"proc/sound_speed_inf.html","title":"sound_speed_inf – FEST-3D"},{"text":"private subroutine link_aliases() Setup state variable pointers Arguments None Calls proc~~link_aliases~2~~CallsGraph proc~link_aliases~2 link_aliases debugcall debugcall proc~link_aliases~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~link_aliases~2~~CalledByGraph proc~link_aliases~2 link_aliases proc~setup_state setup_state proc~setup_state->proc~link_aliases~2 proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code link_aliases Source Code subroutine link_aliases () !< Setup state variable pointers implicit none DebugCall ( \"link_aliases\" ) density ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 1 ) x_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 2 ) y_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 3 ) z_speed ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 4 ) pressure ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 5 ) density_inf => qp_inf ( 1 ) x_speed_inf => qp_inf ( 2 ) y_speed_inf => qp_inf ( 3 ) z_speed_inf => qp_inf ( 4 ) pressure_inf => qp_inf ( 5 ) select case ( trim ( turbulence )) case ( \"none\" ) !include nothing continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"des-sst\" , \"kw\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tw ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) tw_inf => qp_inf ( 7 ) case ( \"kkl\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tkl ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) tkl_inf => qp_inf ( 7 ) case ( \"sa\" , \"saBC\" ) tv ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) tv_inf => qp_inf ( 6 ) case ( \"ke\" ) tk ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 6 ) te ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, 7 ) tk_inf => qp_inf ( 6 ) te_inf => qp_inf ( 7 ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select ! Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) tgm ( - 2 : imx + 2 , - 2 : jmx + 2 , - 2 : kmx + 2 ) => qp (:, :, :, n_var ) tgm_inf => qp_inf ( n_var ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine link_aliases","tags":"","loc":"proc/link_aliases~2.html","title":"link_aliases – FEST-3D"},{"text":"private subroutine unlink_aliases() Nullify the pointer link Arguments None Calls proc~~unlink_aliases~2~~CallsGraph proc~unlink_aliases~2 unlink_aliases debugcall debugcall proc~unlink_aliases~2->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~unlink_aliases~2~~CalledByGraph proc~unlink_aliases~2 unlink_aliases proc~destroy_state destroy_state proc~destroy_state->proc~unlink_aliases~2 proc~destroy_all destroy_all proc~destroy_all->proc~destroy_state proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_state proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code unlink_aliases Source Code subroutine unlink_aliases () !< Nullify the pointer link implicit none DebugCall ( \"unlink_aliases\" ) nullify ( density ) nullify ( x_speed ) nullify ( y_speed ) nullify ( z_speed ) nullify ( pressure ) nullify ( density_inf ) nullify ( x_speed_inf ) nullify ( y_speed_inf ) nullify ( z_speed_inf ) nullify ( pressure_inf ) select case ( trim ( turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" , \"kw\" , \"des-sst\" ) nullify ( tk ) nullify ( tw ) nullify ( tk_inf ) nullify ( tw_inf ) case ( \"kkl\" ) nullify ( tk ) nullify ( tkl ) nullify ( tk_inf ) nullify ( tkl_inf ) case ( \"sa\" , \"saBC\" ) nullify ( tv ) nullify ( tv_inf ) case ( \"ke\" ) nullify ( tk ) nullify ( te ) nullify ( tk_inf ) nullify ( te_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) nullify ( tgm ) nullify ( tgm_inf ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine unlink_aliases","tags":"","loc":"proc/unlink_aliases~2.html","title":"unlink_aliases – FEST-3D"},{"text":"private subroutine allocate_memory() Allocate memory to the state variables Arguments None Calls proc~~allocate_memory~6~~CallsGraph proc~allocate_memory~6 allocate_memory interface~alloc alloc proc~allocate_memory~6->interface~alloc debugcall debugcall proc~allocate_memory~6->debugcall aerrmsg aerrmsg proc~allocate_memory~6->aerrmsg proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~allocate_memory~6~~CalledByGraph proc~allocate_memory~6 allocate_memory proc~setup_state setup_state proc~setup_state->proc~allocate_memory~6 proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code allocate_memory Source Code subroutine allocate_memory () !< Allocate memory to the state variables !----------------------------------------------------------- implicit none DebugCall ( \"allocate_memory\" ) ! The state of the system is defined by the primitive ! variables (density, velocity and pressure) at the grid ! cell centers. call alloc ( qp , - 2 , imx + 2 , - 2 , jmx + 2 , - 2 , kmx + 2 , 1 , n_var , AErrMsg ( \"qp\" )) call alloc ( qp_inf , 1 , n_var , AErrMsg ( \"qp_inf\" )) end subroutine allocate_memory","tags":"","loc":"proc/allocate_memory~6.html","title":"allocate_memory – FEST-3D"},{"text":"private subroutine deallocate_memory() Deallocate memory from the state variable Arguments None Calls proc~~deallocate_memory~4~~CallsGraph proc~deallocate_memory~4 deallocate_memory interface~dealloc dealloc proc~deallocate_memory~4->interface~dealloc debugcall debugcall proc~deallocate_memory~4->debugcall proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~deallocate_memory~4~~CalledByGraph proc~deallocate_memory~4 deallocate_memory proc~destroy_state destroy_state proc~destroy_state->proc~deallocate_memory~4 proc~destroy_all destroy_all proc~destroy_all->proc~destroy_state proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_state proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code deallocate_memory Source Code subroutine deallocate_memory () !< Deallocate memory from the state variable implicit none DebugCall ( \"allocate_memory\" ) call dealloc ( qp ) end subroutine deallocate_memory","tags":"","loc":"proc/deallocate_memory~4.html","title":"deallocate_memory – FEST-3D"},{"text":"public subroutine setup_state() Setup the state module.\n This subroutine should be run before the state variables\n are initilized. This subroutine allocates the memory for \n state variables and sets up the aliases to refer to the \n components of the state Arguments None Calls proc~~setup_state~~CallsGraph proc~setup_state setup_state proc~init_infinity_values init_infinity_values proc~setup_state->proc~init_infinity_values proc~allocate_memory~6 allocate_memory proc~setup_state->proc~allocate_memory~6 proc~link_aliases~2 link_aliases proc~setup_state->proc~link_aliases~2 proc~initstate initstate proc~setup_state->proc~initstate debugcall debugcall proc~setup_state->debugcall proc~set_n_var_value set_n_var_value proc~setup_state->proc~set_n_var_value proc~init_infinity_values->debugcall proc~sound_speed_inf sound_speed_inf proc~init_infinity_values->proc~sound_speed_inf proc~allocate_memory~6->debugcall aerrmsg aerrmsg proc~allocate_memory~6->aerrmsg interface~alloc alloc proc~allocate_memory~6->interface~alloc proc~link_aliases~2->debugcall proc~initstate->debugcall proc~verify_write_control verify_write_control proc~initstate->proc~verify_write_control proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate->proc~init_state_with_infinity_values proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~set_n_var_value->debugcall proc~alloc_rank2_real alloc_rank2_real interface~alloc->proc~alloc_rank2_real proc~alloc_rank4_real alloc_rank4_real interface~alloc->proc~alloc_rank4_real proc~alloc_rank3_real alloc_rank3_real interface~alloc->proc~alloc_rank3_real proc~alloc_rank2_integer alloc_rank2_integer interface~alloc->proc~alloc_rank2_integer proc~alloc_rank1_integer alloc_rank1_integer interface~alloc->proc~alloc_rank1_integer proc~alloc_rank6_real alloc_rank6_real interface~alloc->proc~alloc_rank6_real proc~alloc_rank5_real alloc_rank5_real interface~alloc->proc~alloc_rank5_real proc~alloc_rank3_integer alloc_rank3_integer interface~alloc->proc~alloc_rank3_integer proc~alloc_rank1_real alloc_rank1_real interface~alloc->proc~alloc_rank1_real proc~lcase lcase proc~verify_write_control->proc~lcase proc~init_state_with_infinity_values->debugcall proc~dmsg dmsg proc~read_file~3->proc~dmsg proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~verify_read_control->proc~lcase proc~open_file~2->proc~dmsg proc~setup_file~3->proc~dmsg proc~close_file~2->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_state~~CalledByGraph proc~setup_state setup_state proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_state Source Code subroutine setup_state () !< Setup the state module. !< This subroutine should be run before the state variables !< are initilized. This subroutine allocates the memory for !< state variables and sets up the aliases to refer to the !< components of the state !----------------------------------------------------------- implicit none DebugCall ( \"setup_state\" ) call set_n_var_value () call allocate_memory () call link_aliases () call init_infinity_values () call initstate () end subroutine setup_state","tags":"","loc":"proc/setup_state.html","title":"setup_state – FEST-3D"},{"text":"public subroutine destroy_state() Destroy the state module.\n This subroutine destroys the state module which includes\n unlinking the aliases for the state components and \n deallocating the memory held by the state variables Arguments None Calls proc~~destroy_state~~CallsGraph proc~destroy_state destroy_state proc~unlink_aliases~2 unlink_aliases proc~destroy_state->proc~unlink_aliases~2 debugcall debugcall proc~destroy_state->debugcall proc~deallocate_memory~4 deallocate_memory proc~destroy_state->proc~deallocate_memory~4 proc~unlink_aliases~2->debugcall proc~deallocate_memory~4->debugcall interface~dealloc dealloc proc~deallocate_memory~4->interface~dealloc proc~dealloc_rank2_real dealloc_rank2_real interface~dealloc->proc~dealloc_rank2_real proc~dealloc_rank4_real dealloc_rank4_real interface~dealloc->proc~dealloc_rank4_real proc~dealloc_rank1_integer dealloc_rank1_integer interface~dealloc->proc~dealloc_rank1_integer proc~dealloc_rank2_integer dealloc_rank2_integer interface~dealloc->proc~dealloc_rank2_integer proc~dealloc_rank1_real dealloc_rank1_real interface~dealloc->proc~dealloc_rank1_real proc~dealloc_rank3_integer dealloc_rank3_integer interface~dealloc->proc~dealloc_rank3_integer proc~dealloc_rank3_real dealloc_rank3_real interface~dealloc->proc~dealloc_rank3_real proc~dealloc_rank5_real dealloc_rank5_real interface~dealloc->proc~dealloc_rank5_real proc~dealloc_rank6_real dealloc_rank6_real interface~dealloc->proc~dealloc_rank6_real Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_state~~CalledByGraph proc~destroy_state destroy_state proc~destroy_all destroy_all proc~destroy_all->proc~destroy_state proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_state proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_state Source Code subroutine destroy_state () !< Destroy the state module. !< This subroutine destroys the state module which includes !< unlinking the aliases for the state components and !< deallocating the memory held by the state variables !----------------------------------------------------------- implicit none DebugCall ( \"destroy_state\" ) call unlink_aliases () call deallocate_memory () end subroutine destroy_state","tags":"","loc":"proc/destroy_state.html","title":"destroy_state – FEST-3D"},{"text":"private subroutine init_infinity_values() Set the values of the infinity variables \"qp_inf\" Arguments None Calls proc~~init_infinity_values~~CallsGraph proc~init_infinity_values init_infinity_values proc~sound_speed_inf sound_speed_inf proc~init_infinity_values->proc~sound_speed_inf debugcall debugcall proc~init_infinity_values->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_infinity_values~~CalledByGraph proc~init_infinity_values init_infinity_values proc~setup_state setup_state proc~setup_state->proc~init_infinity_values proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_infinity_values Source Code subroutine init_infinity_values () !< Set the values of the infinity variables \"qp_inf\" !----------------------------------------------------------- implicit none DebugCall ( \"init_infinity_values\" ) density_inf = free_stream_density x_speed_inf = free_stream_x_speed y_speed_inf = free_stream_y_speed z_speed_inf = free_stream_z_speed pressure_inf = free_stream_pressure vel_mag = sqrt ( x_speed_inf ** 2 + y_speed_inf ** 2 + z_speed_inf ** 2 ) MInf = Vel_mag / sqrt ( gm * pressure_inf / density_inf ) Reynolds_number = density_inf * vel_mag * 1.0 / mu_ref Turb_intensity_inf = free_stream_tu / 100 select case ( trim ( turbulence )) case ( \"none\" ) continue case ( \"sst\" , \"sst2003\" , \"bsl\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"kkl\" ) tk_inf = 9 * ( 1 e - 9 ) * ( sound_speed_inf () ** 2 ) tkl_inf = 1.5589 * ( 1 e - 6 ) * ( mu_ref * sound_speed_inf ()) / density_inf case ( \"sa\" ) tv_inf = mu_ratio_inf * mu_ref / density_inf case ( \"saBC\" ) tv_inf = 0.005 * mu_ratio_inf * mu_ref / density_inf case ( \"kw\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"ke\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = 0.09 * density_inf * tk_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"des-sst\" ) tk_inf = 1.5 * (( Vel_mag * Turb_Intensity_inf ) ** 2 ) tw_inf = density_inf * tk_inf / ( mu_ref * mu_ratio_inf ) case ( \"les\" ) continue ! todo case DEFAULT Fatal_error end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) tgm_inf = free_stream_tgm case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine init_infinity_values","tags":"","loc":"proc/init_infinity_values.html","title":"init_infinity_values – FEST-3D"},{"text":"private subroutine initstate() Initialize the state.\n If load file(start_from) is 0, then the state should be \n set to the infinity values. Otherwise, read the state_file\n to get the state values Arguments None Calls proc~~initstate~~CallsGraph proc~initstate initstate proc~verify_write_control verify_write_control proc~initstate->proc~verify_write_control debugcall debugcall proc~initstate->debugcall proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate->proc~init_state_with_infinity_values proc~read_file~3 read_file proc~initstate->proc~read_file~3 proc~lcase lcase proc~verify_write_control->proc~lcase proc~init_state_with_infinity_values->debugcall proc~dmsg dmsg proc~read_file~3->proc~dmsg proc~verify_read_control verify_read_control proc~read_file~3->proc~verify_read_control read_file_tec read_file_tec proc~read_file~3->read_file_tec proc~open_file~2 open_file proc~read_file~3->proc~open_file~2 proc~read_restart_file read_restart_file proc~read_file~3->proc~read_restart_file proc~close_file~2 close_file proc~read_file~3->proc~close_file~2 read_file_vtk read_file_vtk proc~read_file~3->read_file_vtk proc~setup_file~3 setup_file proc~read_file~3->proc~setup_file~3 proc~verify_read_control->proc~lcase proc~open_file~2->proc~dmsg proc~close_file~2->proc~dmsg proc~setup_file~3->proc~dmsg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~initstate~~CalledByGraph proc~initstate initstate proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code initstate Source Code subroutine initstate () !< Initialize the state. !< If load file(start_from) is 0, then the state should be !< set to the infinity values. Otherwise, read the state_file !< to get the state values !----------------------------------------------------------- implicit none DebugCall ( \"initstate\" ) call verify_write_control () if ( start_from . eq . 0 ) then ! Set the state to the infinity values call init_state_with_infinity_values () !!---------------------------------------- !!following are added spefically for !! shock tube test case !!--------------------------------------- !if(process_id<2) then !  pressure = 1.0 !  density = 1.0 !  x_speed = 0.0 !  y_speed = 0.0 !  z_speed = 0.0 !else !  pressure = 0.1 !  density = 0.125 !  x_speed = 0.0 !  y_speed = 0.0 !  z_speed = 0.0 !end if !X_speed = 0.0 !Y_speed = 0.0 !Z_speed = 0.0 else write ( infile , '(a,i4.4,a,i2.2)' ) & \"time_directories/\" , start_from , \"/process_\" , process_id ! Set the state to the infinity values so if some ! variable are not restart variable they get free_stream value call init_state_with_infinity_values () call read_file () end if end subroutine initstate","tags":"","loc":"proc/initstate.html","title":"initstate – FEST-3D"},{"text":"private subroutine init_state_with_infinity_values() Initialize the state based on the infinity values Arguments None Calls proc~~init_state_with_infinity_values~~CallsGraph proc~init_state_with_infinity_values init_state_with_infinity_values debugcall debugcall proc~init_state_with_infinity_values->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~init_state_with_infinity_values~~CalledByGraph proc~init_state_with_infinity_values init_state_with_infinity_values proc~initstate initstate proc~initstate->proc~init_state_with_infinity_values proc~setup_state setup_state proc~setup_state->proc~initstate proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run var panprocinit_state_with_infinity_valuesCalledByGraph = svgPanZoom('#procinit_state_with_infinity_valuesCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code init_state_with_infinity_values Source Code subroutine init_state_with_infinity_values () !< Initialize the state based on the infinity values !----------------------------------------------------------- implicit none integer :: i DebugCall ( \"init_state_with_infinity_values\" ) do i = 1 , n_var qp (:, :, :, i ) = qp_inf ( i ) end do end subroutine init_state_with_infinity_values","tags":"","loc":"proc/init_state_with_infinity_values.html","title":"init_state_with_infinity_values – FEST-3D"},{"text":"private subroutine set_n_var_value() Set number of variable to solver for based on\n the tubulence and transition model being used Arguments None Calls proc~~set_n_var_value~~CallsGraph proc~set_n_var_value set_n_var_value debugcall debugcall proc~set_n_var_value->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~set_n_var_value~~CalledByGraph proc~set_n_var_value set_n_var_value proc~setup_state setup_state proc~setup_state->proc~set_n_var_value proc~setup_solver setup_solver proc~setup_solver->proc~setup_state proc~setup_all setup_all proc~setup_all->proc~setup_state proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code set_n_var_value Source Code subroutine set_n_var_value () !< Set number of variable to solver for based on !< the tubulence and transition model being used implicit none DebugCall ( \"set_n_var_value\" ) select case ( trim ( turbulence )) case ( 'none' ) n_var = 5 case ( 'sa' , 'saBC' ) n_var = 6 case ( 'sst' , \"sst2003\" , 'bsl' , 'kw' , 'ke' , 'kkl' , 'Des-kw' ) n_var = 7 case DEFAULT n_var = 5 end select !Transition modeling select case ( trim ( transition )) case ( 'lctm2015' ) n_var = n_var + 1 case ( 'bc' , 'none' ) n_var = n_var + 0 case DEFAULT Fatal_error end Select end subroutine set_n_var_value","tags":"","loc":"proc/set_n_var_value.html","title":"set_n_var_value – FEST-3D"},{"text":"public subroutine setup_lctm2015_grad() Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None Calls proc~~setup_lctm2015_grad~~CallsGraph proc~setup_lctm2015_grad setup_lctm2015_grad debugcall debugcall proc~setup_lctm2015_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_lctm2015_grad~~CalledByGraph proc~setup_lctm2015_grad setup_lctm2015_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~setup_lctm2015_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_lctm2015_grad Source Code subroutine setup_lctm2015_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_sst_grad' ) select case ( trim ( transition )) case ( 'lctm2015' ) gradtgm_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, n_grad ) gradtgm_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, n_grad ) gradtgm_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, n_grad ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine setup_lctm2015_grad","tags":"","loc":"proc/setup_lctm2015_grad.html","title":"setup_lctm2015_grad – FEST-3D"},{"text":"public subroutine destroy_lctm2015_grad() Nullify all the gradient pointer setup for k-kL model Arguments None Calls proc~~destroy_lctm2015_grad~~CallsGraph proc~destroy_lctm2015_grad destroy_lctm2015_grad debugcall debugcall proc~destroy_lctm2015_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_lctm2015_grad~~CalledByGraph proc~destroy_lctm2015_grad destroy_lctm2015_grad proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_lctm2015_grad proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_lctm2015_grad Source Code subroutine destroy_lctm2015_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_sst_grad' ) select case ( trim ( transition )) case ( 'lctm2015' ) nullify ( gradtgm_x ) nullify ( gradtgm_y ) nullify ( gradtgm_z ) case ( 'bc' , 'none' ) !do nothing continue case DEFAULT Fatal_error end Select end subroutine destroy_lctm2015_grad","tags":"","loc":"proc/destroy_lctm2015_grad.html","title":"destroy_lctm2015_grad – FEST-3D"},{"text":"public subroutine setup_kkl_grad() Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None Calls proc~~setup_kkl_grad~~CallsGraph proc~setup_kkl_grad setup_kkl_grad debugcall debugcall proc~setup_kkl_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_kkl_grad~~CalledByGraph proc~setup_kkl_grad setup_kkl_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~setup_kkl_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_kkl_grad Source Code subroutine setup_kkl_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( 'setup_kkl_grad' ) gradtk_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtkl_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 6 ) gradtk_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtkl_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 6 ) gradtk_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) gradtkl_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 6 ) end subroutine setup_kkl_grad","tags":"","loc":"proc/setup_kkl_grad.html","title":"setup_kkl_grad – FEST-3D"},{"text":"public subroutine destroy_kkl_grad() Nullify all the gradient pointer setup for k-kL model Arguments None Calls proc~~destroy_kkl_grad~~CallsGraph proc~destroy_kkl_grad destroy_kkl_grad debugcall debugcall proc~destroy_kkl_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_kkl_grad~~CalledByGraph proc~destroy_kkl_grad destroy_kkl_grad proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_kkl_grad proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_kkl_grad Source Code subroutine destroy_kkl_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( 'destroy_kkl_grad' ) nullify ( gradtk_x ) nullify ( gradtkl_x ) nullify ( gradtk_y ) nullify ( gradtkl_y ) nullify ( gradtk_z ) nullify ( gradtkl_z ) end subroutine destroy_kkl_grad","tags":"","loc":"proc/destroy_kkl_grad.html","title":"destroy_kkl_grad – FEST-3D"},{"text":"public subroutine setup_sa_grad() Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None Calls proc~~setup_sa_grad~~CallsGraph proc~setup_sa_grad setup_sa_grad debugcall debugcall proc~setup_sa_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~setup_sa_grad~~CalledByGraph proc~setup_sa_grad setup_sa_grad proc~setup_gradients setup_gradients proc~setup_gradients->proc~setup_sa_grad proc~setup_solver setup_solver proc~setup_solver->proc~setup_gradients proc~setup_all setup_all proc~setup_all->proc~setup_gradients proc~start_run start_run proc~start_run->proc~setup_solver program~main main program~main->proc~start_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code setup_sa_grad Source Code subroutine setup_sa_grad () !< Setup Pointer to the main array which stores gradient !< all variables with x, y, z implicit none DebugCall ( \"setup_sa_grad\" ) gradtv_x ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_x (:, :, :, 5 ) gradtv_y ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_y (:, :, :, 5 ) gradtv_z ( 0 : imx , 0 : jmx , 0 : kmx ) => gradqp_z (:, :, :, 5 ) end subroutine setup_sa_grad","tags":"","loc":"proc/setup_sa_grad.html","title":"setup_sa_grad – FEST-3D"},{"text":"public subroutine destroy_sa_grad() Nullify all the gradient pointer setup for k-kL model Arguments None Calls proc~~destroy_sa_grad~~CallsGraph proc~destroy_sa_grad destroy_sa_grad debugcall debugcall proc~destroy_sa_grad->debugcall Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Called by proc~~destroy_sa_grad~~CalledByGraph proc~destroy_sa_grad destroy_sa_grad proc~destroy_gradients destroy_gradients proc~destroy_gradients->proc~destroy_sa_grad proc~destroy_all destroy_all proc~destroy_all->proc~destroy_gradients proc~destroy_solver destroy_solver proc~destroy_solver->proc~destroy_gradients proc~finish_run finish_run proc~finish_run->proc~destroy_solver proc~abort_run abort_run proc~abort_run->proc~destroy_solver program~main main program~main->proc~finish_run Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code destroy_sa_grad Source Code subroutine destroy_sa_grad () !< Nullify all the gradient pointer setup for k-kL model implicit none DebugCall ( \"destroy_sa_grad\" ) nullify ( gradtv_x ) nullify ( gradtv_y ) nullify ( gradtv_z ) end subroutine destroy_sa_grad","tags":"","loc":"proc/destroy_sa_grad.html","title":"destroy_sa_grad – FEST-3D"},{"text":"This module handles the MPI Communication calls for interface boundary conditions Uses global_vars utils mapping module~~interface1~~UsesGraph module~interface1 interface1 module~utils utils module~interface1->module~utils module~global_vars global_vars module~interface1->module~global_vars module~mapping mapping module~interface1->module~mapping module~utils->module~global_vars module~global global module~global_vars->module~global module~mapping->module~utils module~mapping->module~global_vars module~mapping->module~global module~string string module~mapping->module~string module~fclose fclose module~mapping->module~fclose module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~interface1~~UsedByGraph module~interface1 interface1 module~solver solver module~solver->module~interface1 module~update update module~solver->module~update module~update->module~interface1 program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ibuf_size jbuf_size kbuf_size imin_send_buf jmin_send_buf kmin_send_buf imin_recv_buf jmin_recv_buf kmin_recv_buf imax_send_buf jmax_send_buf kmax_send_buf imax_recv_buf jmax_recv_buf kmax_recv_buf Subroutines setup_interface destroy_interface apply_interface apply_periodic_bc Variables Type Visibility Attributes Name Initial integer, private :: ibuf_size Size of the buffer for I face interface integer, private :: jbuf_size Size of the buffer for J face interface integer, private :: kbuf_size Size of the buffer for K face interface real, private, dimension(:), allocatable :: imin_send_buf Array to store data to send data for Imin face real, private, dimension(:), allocatable :: jmin_send_buf Array to store data to send data for Jmin face real, private, dimension(:), allocatable :: kmin_send_buf Array to store data to send data for Kmin face real, private, dimension(:), allocatable :: imin_recv_buf Array to store data to receive data for Imin face real, private, dimension(:), allocatable :: jmin_recv_buf Array to store data to receive data for Jmin face real, private, dimension(:), allocatable :: kmin_recv_buf Array to store data to receive data for Kmin face real, private, dimension(:), allocatable :: imax_send_buf Array to store data to send data for Imax face real, private, dimension(:), allocatable :: jmax_send_buf Array to store data to send data for Jmax face real, private, dimension(:), allocatable :: kmax_send_buf Array to store data to send data for Kmax face real, private, dimension(:), allocatable :: imax_recv_buf Array to store data to receive data for Imax face real, private, dimension(:), allocatable :: jmax_recv_buf Array to store data to receive data for Jmax face real, private, dimension(:), allocatable :: kmax_recv_buf Array to store data to receive data for Kmax face Subroutines public subroutine setup_interface () Allocate memory for the data communication between processors Arguments None public subroutine destroy_interface () Deallocate all the memory being used  for data communication between processors Arguments None public subroutine apply_interface () MPISEND_RECV call to exchange interface infromation between\n connected blocks. Arguments None private subroutine apply_periodic_bc () If a block is connected to another block in perodic\nfashion, this subroutine will take care of that boundary condition. Arguments None","tags":"","loc":"module/interface1.html","title":"interface1 – FEST-3D"},{"text":"Reference: Kitamura, K., Shima, E., Fujimoto, K. and Wang, Z.J.,\n Performance of low-dissipation Euler fluxes and preconditioned LU-SGS \n at low speeds, Communications in Computational Physics, vol. 10 no. 1, pp.90-119, 2011 Uses geometry utils mapping global_vars global_sst global_sa string global_kkl module~~plusgs~~UsesGraph module~plusgs plusgs module~mapping mapping module~plusgs->module~mapping module~global_kkl global_kkl module~plusgs->module~global_kkl module~global_sst global_sst module~plusgs->module~global_sst module~global_vars global_vars module~plusgs->module~global_vars module~string string module~plusgs->module~string module~utils utils module~plusgs->module~utils module~geometry geometry module~plusgs->module~geometry module~global_sa global_sa module~plusgs->module~global_sa module~mapping->module~global_vars module~mapping->module~string module~mapping->module~utils module~global global module~mapping->module~global module~fclose fclose module~mapping->module~fclose module~global_vars->module~global module~utils->module~global_vars module~geometry->module~global_vars module~geometry->module~utils module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~plusgs~~UsedByGraph module~plusgs plusgs module~update update module~update->module~plusgs module~solver solver module~solver->module~update program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables delQ delQstar dummy tmu mmu ibuf_size jbuf_size kbuf_size imin_send_buf jmin_send_buf kmin_send_buf imin_recv_buf jmin_recv_buf kmin_recv_buf imax_send_buf jmax_send_buf kmax_send_buf imax_recv_buf jmax_recv_buf kmax_recv_buf Functions Flux SpectralRadius SSTFlux SAFlux lctm2015flux Subroutines setup_plusgs destroy_plusgs update_with_plusgs update_laminar_variables update_SST_variables update_SA_variables update_lctm2015 apply_interface apply_periodic_bc Variables Type Visibility Attributes Name Initial real, public, dimension(:,:,:,:), allocatable :: delQ Change of state variable (solution) over one time-step real, public, dimension(:,:,:,:), allocatable :: delQstar Intermediate change of state variable over one time-step real, public, dimension(:,:,:), allocatable, target :: dummy Dummy variable real, public, dimension(:,:,:), pointer :: tmu Pointer to turbulent viscosity real, public, dimension(:,:,:), pointer :: mmu Pointer to molecular viscosity integer, public :: ibuf_size Size of the buffer for I face interface integer, public :: jbuf_size Size of the buffer for J face interface integer, public :: kbuf_size Size of the buffer for K face interface real, public, dimension(:), allocatable :: imin_send_buf Array to store data to send data for Imin face real, public, dimension(:), allocatable :: jmin_send_buf Array to store data to send data for Jmin face real, public, dimension(:), allocatable :: kmin_send_buf Array to store data to send data for Kmin face real, public, dimension(:), allocatable :: imin_recv_buf Array to store data to receive data for Imin face real, public, dimension(:), allocatable :: jmin_recv_buf Array to store data to receive data for Jmin face real, public, dimension(:), allocatable :: kmin_recv_buf Array to store data to receive data for Kmin face real, public, dimension(:), allocatable :: imax_send_buf Array to store data to send data for Imax face real, public, dimension(:), allocatable :: jmax_send_buf Array to store data to send data for Jmax face real, public, dimension(:), allocatable :: kmax_send_buf Array to store data to send data for Kmax face real, public, dimension(:), allocatable :: imax_recv_buf Array to store data to receive data for Imax face real, public, dimension(:), allocatable :: jmax_recv_buf Array to store data to receive data for Jmax face real, public, dimension(:), allocatable :: kmax_recv_buf Array to store data to receive data for Kmax face Functions public function Flux (ql, qr, du, inputs) Calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) public function SpectralRadius (ql, qr, inputs, c1, c2, eps) Calculated spectral radius Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:7) :: inputs real, intent(in), dimension(1:3) :: c1 real, intent(in), dimension(1:3) :: c2 real, intent(in) :: eps Return Value real public function SSTFlux (ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) public function SAFlux (ql, qr, du, inputs) Calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) public function lctm2015flux (ql, qr, du, inputs) Calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Subroutines public subroutine setup_plusgs () Allocate array memory for data communication Arguments None public subroutine destroy_plusgs () Unallocate the memory required by LU-SGS module Arguments None public subroutine update_with_plusgs () Time-integrate with LU_SGS method Arguments None public subroutine update_laminar_variables () Update laminar flow with LU-SGS scheme Arguments None public subroutine update_SST_variables () Update the RANS (SST) equation with LU-SGS Arguments None public subroutine update_SA_variables () Update the RANS (SA) equation with LU-SGS Arguments None public subroutine update_lctm2015 () Update the RANS/transition (LCTM2015) equation with LU-SGS Arguments None public subroutine apply_interface (qp, layers) Apply inter-block interface boundary condition Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers public subroutine apply_periodic_bc (qp, layers) Apply periodic boundary condition Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers","tags":"","loc":"module/plusgs.html","title":"plusgs – FEST-3D"},{"text":"The viscous module contains the viscous fluxes calculations Uses global_vars utils geometry global_sst global_sa string global_kkl global module~~viscous~~UsesGraph module~viscous viscous module~global global module~viscous->module~global module~global_kkl global_kkl module~viscous->module~global_kkl module~global_sst global_sst module~viscous->module~global_sst module~global_vars global_vars module~viscous->module~global_vars module~string string module~viscous->module~string module~utils utils module~viscous->module~utils module~geometry geometry module~viscous->module~geometry module~global_sa global_sa module~viscous->module~global_sa module~global_vars->module~global module~utils->module~global_vars module~geometry->module~global_vars module~geometry->module~utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~viscous~~UsedByGraph module~viscous viscous module~solver solver module~solver->module~viscous module~update update module~solver->module~update module~update->module~viscous program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines compute_viscous_fluxes compute_viscous_fluxes_laminar compute_viscous_fluxes_sst compute_viscous_fluxes_kkl compute_viscous_fluxes_sa compute_viscous_fluxes_lctm2015 Subroutines public subroutine compute_viscous_fluxes (F, G, H) Call to all viscous flux subroutine based on \n the drection and turbulence/transition model being\n used Arguments Type Intent Optional Attributes Name real, dimension(:, :, :, :), pointer :: F real, dimension(:, :, :, :), pointer :: G real, dimension(:, :, :, :), pointer :: H private subroutine compute_viscous_fluxes_laminar (F, direction) Compute viscous fluxes for first five Navier-Stokes equation Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction private subroutine compute_viscous_fluxes_sst (F, direction) Compute viscous fluxes for additianal equations due to SST turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F flux array character(len=*), intent(in) :: direction face direction private subroutine compute_viscous_fluxes_kkl (F, direction) Compute viscous fluxes for additianal equations due to k-kL turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction private subroutine compute_viscous_fluxes_sa (F, direction) Compute viscous fluxes for additianal equations due to SA turbulence model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction private subroutine compute_viscous_fluxes_lctm2015 (F, direction) Compute viscous fluxes for additianal equations due to LCTM2015 transition model Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), pointer :: F Flux array character(len=*), intent(in) :: direction Face direction","tags":"","loc":"module/viscous.html","title":"viscous – FEST-3D"},{"text":"Calculate the time step for the current iteration Uses global_vars utils geometry string face_interpolant read module~~time~~UsesGraph module~time time module~read read module~time->module~read module~utils utils module~time->module~utils module~global_vars global_vars module~time->module~global_vars module~string string module~time->module~string face_interpolant face_interpolant module~time->face_interpolant module~geometry geometry module~time->module~geometry module~read->module~utils module~read->module~global_vars module~read->module~string module~global global module~read->module~global module~fclose fclose module~read->module~fclose module~utils->module~global_vars module~global_vars->module~global module~geometry->module~utils module~geometry->module~global_vars module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~time~~UsedByGraph module~time time module~create_and_erase create_and_erase module~create_and_erase->module~time module~solver solver module~solver->module~time module~update update module~solver->module~update module~update->module~time program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables nb_ticks_initial nb_ticks_final nb_ticks_max nb_ticks_sec nb_ticks elapsed_time t1 t2 cpu_time_elapsed Functions write_time Subroutines setup_time destroy_time compute_local_time_step compute_global_time_step compute_time_step update_simulation_clock add_viscous_time add_turbulent_time Variables Type Visibility Attributes Name Initial integer, private :: nb_ticks_initial Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_final Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_max Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks_sec Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code integer, private :: nb_ticks Initial value of the clock tick counter\n Final value of the clock tick counter\n Maximum value of the clock counter\n Number of clock ticks per second\n Number of clock ticks of the code real, private :: elapsed_time Real time in seconds real, private :: t1 Start clock time real, private :: t2 Finish clock time real, private :: cpu_time_elapsed Functions private function write_time (time_in_seconds) result(string) Particular format to write time in output log file Arguments Type Intent Optional Attributes Name real, intent(in) :: time_in_seconds Time to output Return Value character(len=64) Time as string in particlar format Subroutines public subroutine setup_time () Allocate memeroy and setup initial clock Arguments None public subroutine destroy_time () Deallocate memory and find simulation time. Arguments None private subroutine compute_local_time_step () Compute the time step to be used at each cell center Read more… Arguments None private subroutine compute_global_time_step () Compute a common time step to be used at all cell centers Read more… Arguments None public subroutine compute_time_step () Compute the time step to be used Read more… Arguments None public subroutine update_simulation_clock () Update the simulation clock Read more… Arguments None private subroutine add_viscous_time () Addition to local time step due to viscous effects Arguments None private subroutine add_turbulent_time () Addition to local time step due to turbulence Arguments None","tags":"","loc":"module/time.html","title":"time – FEST-3D"},{"text":"In order to calculate pressure gradient in the transition model, two\n quantities are required: the distance of the cell-center from the wall \n andn the normal made by the distance vector field (from wall to cell-center).\n This module calucate both with gradient of V.n also. Uses global_vars utils module~~cc~~UsesGraph module~cc CC module~utils utils module~cc->module~utils module~global_vars global_vars module~cc->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~cc~~UsedByGraph module~cc CC module~source source module~source->module~cc module~solver solver module~solver->module~cc module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setupCC destroyCC find_CCnormal find_CCVn find_DCCVn compute_gradient Subroutines public subroutine setupCC () Allocate memory for the cell center variable only in case of transition model Arguments None public subroutine destroyCC () Deallocate memory from the cell-center variables Arguments None private subroutine find_CCnormal () Find the cell-center unit normal Arguments None private subroutine find_CCVn () Taking a dot product between Cell-center velocity and unit normal Arguments None public subroutine find_DCCVn () Find gradient of the dot product between cell velocity and unit normal Arguments None private subroutine compute_gradient (grad, var, dir) Generalized subroutine to calculate gradients Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: grad real, intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: var character(len=*), intent(in) :: dir","tags":"","loc":"module/cc.html","title":"CC – FEST-3D"},{"text":"Calculate gradients of any primitive variables and temperature Uses global_vars ghost_gradients utils string module~~summon_grad_evaluation~~UsesGraph module~summon_grad_evaluation summon_grad_evaluation module~utils utils module~summon_grad_evaluation->module~utils module~global_vars global_vars module~summon_grad_evaluation->module~global_vars module~ghost_gradients ghost_gradients module~summon_grad_evaluation->module~ghost_gradients module~string string module~summon_grad_evaluation->module~string module~utils->module~global_vars module~global global module~global_vars->module~global module~ghost_gradients->module~utils module~ghost_gradients->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~summon_grad_evaluation~~UsedByGraph module~summon_grad_evaluation summon_grad_evaluation module~solver solver module~solver->module~summon_grad_evaluation module~update update module~solver->module~update module~update->module~summon_grad_evaluation program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables T cell_T i j k Subroutines evaluate_all_gradients compute_gradient_G compute_gradient_T Variables Type Visibility Attributes Name Initial real, private, dimension(6) :: T Temperaure array for six neighbours real, private :: cell_T Temperature at cell center integer, private :: i integer for DO loop integer, private :: j integer for DO loop integer, private :: k integer for DO loop Subroutines public subroutine evaluate_all_gradients () Call to all the required gradients and \n apply boundary condition for ghost cell\n gradients Arguments None private subroutine compute_gradient_G (grad, var, dir) Compute gradient of any input scalar Arguments Type Intent Optional Attributes Name real, intent(out), dimension( 0:imx  , 0:jmx  , 0:kmx  ) :: grad Output variable storing the graident of var real, intent(in), dimension(-2:imx+2,-2:jmx+2,-2:kmx+2) :: var Input variable of which graident is required character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated private subroutine compute_gradient_T (grad, dir) Calculate gradient of temperature Arguments Type Intent Optional Attributes Name real, intent(out), dimension( 0:imx  , 0:jmx  , 0:kmx  ) :: grad Output gradient of termperature character(len=*), intent(in) :: dir Direction with respect to which gradients are calculated","tags":"","loc":"module/summon_grad_evaluation.html","title":"summon_grad_evaluation – FEST-3D"},{"text":"Add source's contribution to the residual Uses global_vars dump_solution global_sst CC global_sa string global_kkl layout utils module~~source~~UsesGraph module~source source module~layout layout module~source->module~layout module~global_sst global_sst module~source->module~global_sst module~global_vars global_vars module~source->module~global_vars module~string string module~source->module~string module~global_sa global_sa module~source->module~global_sa module~global_kkl global_kkl module~source->module~global_kkl module~cc CC module~source->module~cc module~utils utils module~source->module~utils module~dump_solution dump_solution module~source->module~dump_solution module~layout->module~global_vars module~layout->module~utils module~global global module~layout->module~global module~global_vars->module~global module~cc->module~global_vars module~cc->module~utils module~utils->module~global_vars module~dump_solution->module~layout module~dump_solution->module~global_vars module~dump_solution->module~string module~dump_solution->module~utils module~dump_solution->module~global module~write_output write_output module~dump_solution->module~write_output module~write_output->module~global_vars module~write_output->module~string module~write_output->module~utils module~write_output->module~global module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~write_output_tec_node->module~global_sst module~write_output_tec_node->module~global_vars module~write_output_tec_node->module~string module~write_output_tec_node->module~utils module~write_output_tec_node->module~global module~write_output_vtk->module~global_sst module~write_output_vtk->module~global_vars module~write_output_vtk->module~string module~write_output_vtk->module~utils module~write_output_vtk->module~global module~write_output_tec->module~global_sst module~write_output_tec->module~global_vars module~write_output_tec->module~string module~write_output_tec->module~utils module~write_output_tec->module~global var panmodulesourceUsesGraph = svgPanZoom('#modulesourceUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~source~~UsedByGraph module~source source module~create_and_erase create_and_erase module~create_and_erase->module~source module~solver solver module~solver->module~source module~update update module~solver->module~update module~update->module~source program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines add_source_term_residue Setup_source destroy_source add_sst_source add_sst_source_lctm2015 add_sst_bc_source add_kkl_source add_sa_source add_saBC_source Subroutines public subroutine add_source_term_residue () Call to add different source terms to the residual of different equations. Arguments None public subroutine Setup_source () Allcoate memory to the required by the variable Arguments None public subroutine destroy_source () deallocate memory before stoping the solver Arguments None private subroutine add_sst_source () Add residual due to source terms of the SST turbulence model Arguments None private subroutine add_sst_source_lctm2015 () Add residual due to source terms of the LCTM2015 transition model Arguments None private subroutine add_sst_bc_source () Add residual due to source terms of the SST-BC transition model Arguments None private subroutine add_kkl_source () Add residual due to source terms of the k-kL turbulence model Arguments None private subroutine add_sa_source () Add residual due to source terms of SA turbulence model Arguments None private subroutine add_saBC_source () Add residual due to source terms of SABC transition model Arguments None","tags":"","loc":"module/source.html","title":"source – FEST-3D"},{"text":"The grid module contains the grid definition (locations of the \n grid points) as well as procedures to load these from a file. Uses utils global_vars global mapping module~~grid~~UsesGraph module~grid grid module~utils utils module~grid->module~utils module~global_vars global_vars module~grid->module~global_vars module~global global module~grid->module~global module~mapping mapping module~grid->module~mapping module~utils->module~global_vars module~global_vars->module~global module~mapping->module~utils module~mapping->module~global_vars module~mapping->module~global module~string string module~mapping->module~string module~fclose fclose module~mapping->module~fclose module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~grid~~UsedByGraph module~grid grid module~solver solver module~solver->module~grid module~create_and_erase create_and_erase module~create_and_erase->module~grid program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines allocate_memory destroy_grid setup_grid extract_grid_size extract_grid_point populate_grid_points ghost_grid Subroutines private subroutine allocate_memory () Allocate memory to store the grid Arguments None public subroutine destroy_grid () Deallocate the memory allocated for the grid. Arguments None public subroutine setup_grid (gridfile) Read the grid file and initialize the grid Arguments Type Intent Optional Attributes Name character(len=64), intent(in) :: gridfile private subroutine extract_grid_size () Extract the grid size from the grid file header Arguments None private subroutine extract_grid_point (line, i, j, k) Extract a grid point from a line of the grid file. Arguments Type Intent Optional Attributes Name character(len=STRING_BUFFER_LENGTH), intent(in) :: line integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k private subroutine populate_grid_points () Use the grid file to populate the grid points. Arguments None private subroutine ghost_grid () generate ghost grid for the various operations later. Arguments None","tags":"","loc":"module/grid.html","title":"grid – FEST-3D"},{"text":"Create and destroy the solver setup Uses global_vars blending_function time utils geometry parallel source resnorm_ bc gradients grid global wall_dist string layout scheme wall read transport state module~~create_and_erase~~UsesGraph module~create_and_erase create_and_erase module~state state module~create_and_erase->module~state module~global global module~create_and_erase->module~global module~time time module~create_and_erase->module~time module~grid grid module~create_and_erase->module~grid module~source source module~create_and_erase->module~source module~utils utils module~create_and_erase->module~utils resnorm_ resnorm_ module~create_and_erase->resnorm_ module~read read module~create_and_erase->module~read parallel parallel module~create_and_erase->parallel module~global_vars global_vars module~create_and_erase->module~global_vars module~string string module~create_and_erase->module~string module~wall wall module~create_and_erase->module~wall module~gradients gradients module~create_and_erase->module~gradients module~layout layout module~create_and_erase->module~layout module~bc bc module~create_and_erase->module~bc scheme scheme module~create_and_erase->scheme blending_function blending_function module~create_and_erase->blending_function module~geometry geometry module~create_and_erase->module~geometry transport transport module~create_and_erase->transport module~wall_dist wall_dist module~create_and_erase->module~wall_dist module~state->module~global module~state->module~utils module~state->module~global_vars module~state->module~string module~state->module~layout module~read_output read_output module~state->module~read_output module~check_output_control check_output_control module~state->module~check_output_control module~time->module~utils module~time->module~read module~time->module~global_vars module~time->module~string module~time->module~geometry face_interpolant face_interpolant module~time->face_interpolant module~grid->module~global module~grid->module~utils module~grid->module~global_vars module~mapping mapping module~grid->module~mapping module~source->module~utils module~source->module~global_vars module~source->module~string module~source->module~layout module~global_kkl global_kkl module~source->module~global_kkl module~global_sst global_sst module~source->module~global_sst module~global_sa global_sa module~source->module~global_sa module~cc CC module~source->module~cc module~dump_solution dump_solution module~source->module~dump_solution module~utils->module~global_vars module~read->module~global module~read->module~utils module~read->module~global_vars module~read->module~string module~fclose fclose module~read->module~fclose module~global_vars->module~global module~wall->module~global module~wall->module~utils module~wall->module~global_vars module~wall->module~string module~bitwise bitwise module~wall->module~bitwise module~gradients->module~utils module~gradients->module~global_vars module~kkl_gradients kkl_gradients module~gradients->module~kkl_gradients module~sst_gradients sst_gradients module~gradients->module~sst_gradients module~laminar_gradients laminar_gradients module~gradients->module~laminar_gradients module~lctm2015_gradients lctm2015_gradients module~gradients->module~lctm2015_gradients module~sa_gradients sa_gradients module~gradients->module~sa_gradients module~layout->module~global module~layout->module~utils module~layout->module~global_vars module~bc->module~utils module~bc->module~global_vars module~read_bc read_bc module~bc->module~read_bc module~geometry->module~utils module~geometry->module~global_vars module~wall_dist->module~global module~wall_dist->module~utils module~wall_dist->module~global_vars module~kkl_gradients->module~utils module~kkl_gradients->module~global_vars module~mapping->module~global module~mapping->module~utils module~mapping->module~global_vars module~mapping->module~string module~mapping->module~fclose module~read_output->module~global module~read_output->module~utils module~read_output->module~global_vars module~read_output->module~string module~read_output->module~check_output_control module~read_output_vtk read_output_vtk module~read_output->module~read_output_vtk module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~sst_gradients->module~utils module~sst_gradients->module~global_vars module~check_output_control->module~global_vars module~str_case str_case module~check_output_control->module~str_case module~laminar_gradients->module~utils module~laminar_gradients->module~global_vars module~lctm2015_gradients->module~utils module~lctm2015_gradients->module~global_vars module~cc->module~utils module~cc->module~global_vars module~read_bc->module~global module~read_bc->module~global_vars module~read_bc->module~layout module~fclose->module~global module~dump_solution->module~global module~dump_solution->module~utils module~dump_solution->module~global_vars module~dump_solution->module~string module~dump_solution->module~layout module~write_output write_output module~dump_solution->module~write_output module~sa_gradients->module~utils module~sa_gradients->module~global_vars module~read_output_vtk->module~global module~read_output_vtk->module~utils module~read_output_vtk->module~global_vars module~read_output_vtk->module~string module~read_output_tec->module~global module~read_output_tec->module~utils module~read_output_tec->module~global_vars module~read_output_tec->module~string module~read_output_tec->module~global_sst module~write_output->module~global module~write_output->module~utils module~write_output->module~global_vars module~write_output->module~string module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~str_case->module~global module~write_output_tec_node->module~global module~write_output_tec_node->module~utils module~write_output_tec_node->module~global_vars module~write_output_tec_node->module~string module~write_output_tec_node->module~global_sst module~write_output_vtk->module~global module~write_output_vtk->module~utils module~write_output_vtk->module~global_vars module~write_output_vtk->module~string module~write_output_vtk->module~global_sst module~write_output_tec->module~global module~write_output_tec->module~utils module~write_output_tec->module~global_vars module~write_output_tec->module~string module~write_output_tec->module~global_sst var panmodulecreate_and_eraseUsesGraph = svgPanZoom('#modulecreate_and_eraseUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_all destroy_all Subroutines public subroutine setup_all () To setup, create, allocate memory, link pointer\n    (everything that is required before first iteration Arguments None public subroutine destroy_all () Free memory and free pointers Arguments None","tags":"","loc":"module/create_and_erase.html","title":"create_and_erase – FEST-3D"},{"text":"Reference: Sharov, D., Luo, H., Baum, J., and Loehner, R., \n “Implementation of unstructured grid GMRES+LU-SGS method on \n shared-memory, cache-based parallel computers,” \n 38th Aerospace Sciences Meeting and Exhibit, vol. 927, 2000, p. 2000. Uses geometry utils mapping global_vars global_sst global_sa string global_kkl module~~lusgs~~UsesGraph module~lusgs lusgs module~mapping mapping module~lusgs->module~mapping module~global_kkl global_kkl module~lusgs->module~global_kkl module~global_sst global_sst module~lusgs->module~global_sst module~global_vars global_vars module~lusgs->module~global_vars module~string string module~lusgs->module~string module~utils utils module~lusgs->module~utils module~geometry geometry module~lusgs->module~geometry module~global_sa global_sa module~lusgs->module~global_sa module~mapping->module~global_vars module~mapping->module~string module~mapping->module~utils module~global global module~mapping->module~global module~fclose fclose module~mapping->module~fclose module~global_vars->module~global module~utils->module~global_vars module~geometry->module~global_vars module~geometry->module~utils module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~lusgs~~UsedByGraph module~lusgs lusgs module~update update module~update->module~lusgs module~solver solver module~solver->module~update program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables delQ delQstar dummy tmu mmu ibuf_size jbuf_size kbuf_size imin_send_buf jmin_send_buf kmin_send_buf imin_recv_buf jmin_recv_buf kmin_recv_buf imax_send_buf jmax_send_buf kmax_send_buf imax_recv_buf jmax_recv_buf kmax_recv_buf Functions Flux SpectralRadius SSTFlux KKLFlux SAFlux lctm2015flux Subroutines setup_lusgs destroy_lusgs update_with_lusgs update_laminar_variables update_SST_variables update_KKL_variables update_SA_variables update_lctm2015 apply_interface apply_periodic_bc Variables Type Visibility Attributes Name Initial real, public, dimension(:,:,:,:), allocatable :: delQ change of state variable (solution) over one time-step real, public, dimension(:,:,:,:), allocatable :: delQstar Intermediate change of state variable over one time-step real, public, dimension(:,:,:), allocatable, target :: dummy dummy variable real, public, dimension(:,:,:), pointer :: tmu Pionter to turbulent viscosity real, public, dimension(:,:,:), pointer :: mmu Pointer to molecular viscosity integer, public :: ibuf_size size of the buffer for I face interface integer, public :: jbuf_size size of the buffer for J face interface integer, public :: kbuf_size size of the buffer for K face interface real, public, dimension(:), allocatable :: imin_send_buf Array to store data to send data for Imin face real, public, dimension(:), allocatable :: jmin_send_buf Array to store data to send data for Jmin face real, public, dimension(:), allocatable :: kmin_send_buf Array to store data to send data for Kmin face real, public, dimension(:), allocatable :: imin_recv_buf Array to store data to receive data for Imin face real, public, dimension(:), allocatable :: jmin_recv_buf Array to store data to receive data for Jmin face real, public, dimension(:), allocatable :: kmin_recv_buf Array to store data to receive data for Kmin face real, public, dimension(:), allocatable :: imax_send_buf Array to store data to send data for Imax face real, public, dimension(:), allocatable :: jmax_send_buf Array to store data to send data for Jmax face real, public, dimension(:), allocatable :: kmax_send_buf Array to store data to send data for Kmax face real, public, dimension(:), allocatable :: imax_recv_buf Array to store data to receive data for Imax face real, public, dimension(:), allocatable :: jmax_recv_buf Array to store data to receive data for Jmax face real, public, dimension(:), allocatable :: kmax_recv_buf Array to store data to receive data for Kmax face Functions public function Flux (ql, qr, du, inputs) calculate the total flux through face for laminar flow. Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) public function SpectralRadius (ql, qr, inputs, c1, c2) Calculate the spectral radius Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:7) :: inputs real, intent(in), dimension(1:3) :: c1 real, intent(in), dimension(1:3) :: c2 Return Value real public function SSTFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SST) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) public function KKLFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (k-kL) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) public function SAFlux (ql, qr, du, inputs) calculate the total flux through face for turbulent flow (SA) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:7) :: inputs Return Value real,\n  dimension(1:n_var) public function lctm2015flux (ql, qr, du, inputs) calculate the total flux through face for turbulent/transition flow (LCTM2015) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:n_var) :: ql real, intent(in), dimension(1:n_var) :: qr real, intent(in), dimension(1:n_var) :: du real, intent(in), dimension(1:8) :: inputs Return Value real,\n  dimension(1:n_var) Subroutines public subroutine setup_lusgs () allocate array memory for data communication Arguments None public subroutine destroy_lusgs () unallocate the memory required by LU-SGS module Arguments None public subroutine update_with_lusgs () Time-integrate with LU_SGS method Arguments None public subroutine update_laminar_variables () Update laminar flow with LU-SGS scheme Arguments None public subroutine update_SST_variables () Update the RANS (SST) equation with LU-SGS Arguments None public subroutine update_KKL_variables () Update the RANS (k-kL) equation with LU-SGS Arguments None public subroutine update_SA_variables () Update the RANS (SA) equation with LU-SGS Arguments None public subroutine update_lctm2015 () Update the RANS (LCTM2015 transition model with SST2003) equation with LU-SGS Arguments None public subroutine apply_interface (qp, layers) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers public subroutine apply_periodic_bc (qp, layers) Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(0:imx,0:jmx,0:kmx,1:n_var) :: qp integer, intent(in) :: layers","tags":"","loc":"module/lusgs.html","title":"lusgs – FEST-3D"},{"text":"This module contains subroutine that \n 1. check if time for resnorm dump is arrived\n 2. calculate resnorm\n 3. send those resnorm to processor number 0\n 4. Recalulate resnorm based on information \n    availble from all processors\n 5. Append the data to resnorm file Uses global_vars utils layout fclose string global module~~resnorm~~UsesGraph module~resnorm resnorm module~global global module~resnorm->module~global module~utils utils module~resnorm->module~utils module~global_vars global_vars module~resnorm->module~global_vars module~string string module~resnorm->module~string module~layout layout module~resnorm->module~layout module~fclose fclose module~resnorm->module~fclose module~utils->module~global_vars module~global_vars->module~global module~layout->module~global module~layout->module~utils module~layout->module~global_vars module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~resnorm~~UsedByGraph module~resnorm resnorm module~solver solver module~solver->module~resnorm program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables merror buffer Subroutines setup_resnorm find_resnorm destroy_resnorm setup_file allocate_memory deallocate_memory setup_scale get_absolute_resnorm collect_resnorm_from_all_blocks assemble_resnom_at_each_process get_relative_resnorm write_resnorm Variables Type Visibility Attributes Name Initial real, private :: merror real, private, dimension(:), allocatable :: buffer Subroutines public subroutine setup_resnorm () Allocate memory, setup scale and file to write Arguments None public subroutine find_resnorm () Find the normalized residual for each processor Arguments None public subroutine destroy_resnorm () Deallocate memory and close residual file Arguments None private subroutine setup_file () Open the residual file to write Arguments None private subroutine allocate_memory () Allocate memory to MPI Communication Arguments None private subroutine deallocate_memory () Deallocate memory required for MPI Communication Arguments None private subroutine setup_scale () Setup scale required for relative and absolute\n residual for writing in the file. Arguments None private subroutine get_absolute_resnorm () Get absolute residual for current process Arguments None private subroutine collect_resnorm_from_all_blocks () MPI Communication to gather residual from all processes Arguments None private subroutine assemble_resnom_at_each_process () Sum residual obtained from all the processes after MPI_Communication Arguments None private subroutine get_relative_resnorm () Get relative residual with respect to first iteration residual Arguments None private subroutine write_resnorm () Writing the residual in the file to save. Arguments None","tags":"","loc":"module/resnorm.html","title":"resnorm – FEST-3D"},{"text":"Setup, run, and destroy the solver\n allocate/deallcoate memory, initialize, iterate Uses utils boundary_state_reconstruction viscous summon_grad_evaluation Scheme read mapping state CC source global bc_primitive time layout global_vars geometry resnorm string viscosity bc interface1 dump_solution gradients grid update wall wall_dist module~~solver~~UsesGraph module~solver solver module~mapping mapping module~solver->module~mapping module~read read module~solver->module~read module~global_vars global_vars module~solver->module~global_vars module~viscosity viscosity module~solver->module~viscosity module~wall wall module~solver->module~wall module~bc_primitive bc_primitive module~solver->module~bc_primitive module~cc CC module~solver->module~cc module~bc bc module~solver->module~bc Scheme Scheme module~solver->Scheme module~geometry geometry module~solver->module~geometry module~wall_dist wall_dist module~solver->module~wall_dist module~source source module~solver->module~source module~utils utils module~solver->module~utils module~resnorm resnorm module~solver->module~resnorm module~update update module~solver->module~update module~interface1 interface1 module~solver->module~interface1 module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~state state module~solver->module~state module~layout layout module~solver->module~layout module~summon_grad_evaluation summon_grad_evaluation module~solver->module~summon_grad_evaluation module~string string module~solver->module~string module~gradients gradients module~solver->module~gradients module~boundary_state_reconstruction boundary_state_reconstruction module~solver->module~boundary_state_reconstruction module~dump_solution dump_solution module~solver->module~dump_solution module~global global module~solver->module~global module~grid grid module~solver->module~grid module~mapping->module~global_vars module~mapping->module~utils module~mapping->module~string module~mapping->module~global module~fclose fclose module~mapping->module~fclose module~read->module~global_vars module~read->module~utils module~read->module~string module~read->module~global module~read->module~fclose module~global_vars->module~global module~viscosity->module~global_vars module~viscosity->module~utils module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sst global_sst module~viscosity->module~global_sst module~global_kkl global_kkl module~viscosity->module~global_kkl module~global_sa global_sa module~viscosity->module~global_sa module~wall->module~global_vars module~wall->module~utils module~wall->module~string module~wall->module~global module~bitwise bitwise module~wall->module~bitwise module~bc_primitive->module~global_vars module~bc_primitive->module~utils module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~bc_primitive->module~copy_bc module~bc_primitive->module~global_sst module~read_bc read_bc module~bc_primitive->module~read_bc module~cc->module~global_vars module~cc->module~utils module~bc->module~global_vars module~bc->module~utils module~bc->module~read_bc module~geometry->module~global_vars module~geometry->module~utils module~wall_dist->module~global_vars module~wall_dist->module~utils module~wall_dist->module~global module~source->module~global_vars module~source->module~cc module~source->module~utils module~source->module~layout module~source->module~string module~source->module~dump_solution module~source->module~global_sst module~source->module~global_kkl module~source->module~global_sa module~utils->module~global_vars module~resnorm->module~global_vars module~resnorm->module~utils module~resnorm->module~layout module~resnorm->module~string module~resnorm->module~global module~resnorm->module~fclose module~update->module~global_vars module~update->module~viscosity module~update->module~bc_primitive module~update->module~geometry module~update->module~source module~update->module~utils module~update->module~interface1 module~update->module~time module~update->module~viscous module~update->module~summon_grad_evaluation module~update->module~string module~update->module~boundary_state_reconstruction module~lusgs lusgs module~update->module~lusgs module~plusgs plusgs module~update->module~plusgs module~update->module~global_sst module~update->module~global_kkl scheme scheme module~update->scheme face_interpolant face_interpolant module~update->face_interpolant module~update->module~global_sa module~interface1->module~mapping module~interface1->module~global_vars module~interface1->module~utils module~time->module~read module~time->module~global_vars module~time->module~geometry module~time->module~utils module~time->module~string module~time->face_interpolant module~viscous->module~global_vars module~viscous->module~geometry module~viscous->module~utils module~viscous->module~string module~viscous->module~global module~viscous->module~global_sst module~viscous->module~global_kkl module~viscous->module~global_sa module~state->module~global_vars module~state->module~utils module~state->module~layout module~state->module~string module~state->module~global module~check_output_control check_output_control module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~layout->module~global_vars module~layout->module~utils module~layout->module~global module~summon_grad_evaluation->module~global_vars module~summon_grad_evaluation->module~utils module~summon_grad_evaluation->module~string module~ghost_gradients ghost_gradients module~summon_grad_evaluation->module~ghost_gradients module~gradients->module~global_vars module~gradients->module~utils module~lctm2015_gradients lctm2015_gradients module~gradients->module~lctm2015_gradients module~sst_gradients sst_gradients module~gradients->module~sst_gradients module~laminar_gradients laminar_gradients module~gradients->module~laminar_gradients module~kkl_gradients kkl_gradients module~gradients->module~kkl_gradients module~sa_gradients sa_gradients module~gradients->module~sa_gradients module~boundary_state_reconstruction->module~global_vars module~boundary_state_reconstruction->module~utils module~boundary_state_reconstruction->face_interpolant module~dump_solution->module~global_vars module~dump_solution->module~utils module~dump_solution->module~layout module~dump_solution->module~string module~dump_solution->module~global module~write_output write_output module~dump_solution->module~write_output module~grid->module~mapping module~grid->module~global_vars module~grid->module~utils module~grid->module~global var panmodulesolverUsesGraph = svgPanZoom('#modulesolverUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~solver~~UsedByGraph module~solver solver program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_solver destroy_solver initmisc iterate_one_more_time_step Subroutines public subroutine setup_solver () Call to allocate memoery and initialize domain Arguments None public subroutine destroy_solver () Call to different modules to deallocate memory Arguments None private subroutine initmisc () Initilize miscellaneous variables Arguments None public subroutine iterate_one_more_time_step () Perform one time step iteration Arguments None","tags":"","loc":"module/solver.html","title":"solver – FEST-3D"},{"text":"Setup the indicies map at interface between two blocks Uses global_vars string global fclose utils module~~mapping~~UsesGraph module~mapping mapping module~utils utils module~mapping->module~utils module~global_vars global_vars module~mapping->module~global_vars module~string string module~mapping->module~string module~global global module~mapping->module~global module~fclose fclose module~mapping->module~fclose module~utils->module~global_vars module~global_vars->module~global module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~mapping~~UsedByGraph module~mapping mapping module~lusgs lusgs module~lusgs->module~mapping module~interface1 interface1 module~interface1->module~mapping module~solver solver module~solver->module~mapping module~solver->module~interface1 module~grid grid module~solver->module~grid module~update update module~solver->module~update module~plusgs plusgs module~plusgs->module~mapping module~grid->module~mapping module~create_and_erase create_and_erase module~create_and_erase->module~grid program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver module~update->module~lusgs module~update->module~interface1 module~update->module~plusgs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ilo jlo klo ihi jhi khi Pilo Pjlo Pklo Pihi Pjhi Pkhi PiDir PjDir PkDir Gilo Gjlo Gklo Gihi Gjhi Gkhi mpi_class Subroutines read_interface_map change_map_to_particular_range read_periodic_bc_file Variables Type Visibility Attributes Name Initial integer, private, dimension(6) :: ilo Read Lowest index of I direction integer, private, dimension(6) :: jlo Read Lowest index of J direction integer, private, dimension(6) :: klo Read Lowest index of K direction integer, private, dimension(6) :: ihi Read Highest index of I direction integer, private, dimension(6) :: jhi Read Highest index of J direction integer, private, dimension(6) :: khi Read Highest index of K direction integer, public, dimension(6) :: Pilo Modified lowest index of I direction integer, public, dimension(6) :: Pjlo Modified lowest index of J direction integer, public, dimension(6) :: Pklo Modified lowest index of K direction integer, public, dimension(6) :: Pihi Modified Highest index of I direction integer, public, dimension(6) :: Pjhi Modified Highest index of J direction integer, public, dimension(6) :: Pkhi Modified Highest index of K direction integer, public, dimension(6) :: PiDir Switch for communication direction from \n (low-high) to (hight-low) for I direction integer, public, dimension(6) :: PjDir Switch for communication direction from \n (low-high) to (hight-low) for J direction integer, public, dimension(6) :: PkDir Switch for communication direction from \n (low-high) to (hight-low) for K direction integer, public, dimension(6) :: Gilo Modified lowest index of I direction for Grid data exchange integer, public, dimension(6) :: Gjlo Modified lowest index of J direction for Grid data exchange integer, public, dimension(6) :: Gklo Modified lowest index of K direction for Grid data exchange integer, public, dimension(6) :: Gihi Modified highest index of I direction for Grid data exchange integer, public, dimension(6) :: Gjhi Modified highest index of J direction for Grid data exchange integer, public, dimension(6) :: Gkhi Modified highest index of K direction for Grid data exchange integer, public, dimension(6) :: mpi_class = -1 Class flag for master or slave Subroutines public subroutine read_interface_map () Read mapping file in the system/mesh/layout/mapping.txt Arguments None private subroutine change_map_to_particular_range () Modified the indicies for MPI communication Arguments None private subroutine read_periodic_bc_file () Read periodic.md file in the system/mesh/layout/periodic.md Arguments None","tags":"","loc":"module/mapping.html","title":"mapping – FEST-3D"},{"text":"Contains routine to load layout file and sets the layout variables\n and gets process id and total process Uses global_vars global utils module~~layout~~UsesGraph module~layout layout module~utils utils module~layout->module~utils module~global_vars global_vars module~layout->module~global_vars module~global global module~layout->module~global module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~layout~~UsedByGraph module~layout layout module~state state module~state->module~layout module~source source module~source->module~layout module~dump_solution dump_solution module~source->module~dump_solution module~resnorm resnorm module~resnorm->module~layout module~solver solver module~solver->module~layout module~solver->module~state module~solver->module~source module~solver->module~resnorm module~solver->module~dump_solution module~bc bc module~solver->module~bc module~update update module~solver->module~update module~bc_primitive bc_primitive module~solver->module~bc_primitive module~read_bc read_bc module~read_bc->module~layout module~create_and_erase create_and_erase module~create_and_erase->module~layout module~create_and_erase->module~state module~create_and_erase->module~source module~create_and_erase->module~bc module~dump_solution->module~layout program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~bc->module~read_bc module~start_finish->module~solver module~update->module~source module~update->module~bc_primitive module~bc_primitive->module~read_bc var panmodulelayoutUsedByGraph = svgPanZoom('#modulelayoutUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables grid_file_buf bc_file Subroutines get_process_data get_next_token_parallel read_layout_file Variables Type Visibility Attributes Name Initial character(len=FILE_NAME_LENGTH), public :: grid_file_buf Name of the gridfile to load character(len=FILE_NAME_LENGTH), public :: bc_file Name of the boundary condition file to load. Subroutines public subroutine get_process_data () Get Processor Id and total number of processors Arguments None public subroutine get_next_token_parallel (buf) Extract the next token from the layout file Read more… Arguments Type Intent Optional Attributes Name character(len=STRING_BUFFER_LENGTH), intent(out) :: buf public subroutine read_layout_file (process_id) Read the layout file for particular processor Arguments Type Intent Optional Attributes Name integer, intent(in) :: process_id Processor id for current block","tags":"","loc":"module/layout.html","title":"layout – FEST-3D"},{"text":"Setup, destroy, calculate molecular and turbulence viscosity Uses global_vars utils global_sst global_sa global_kkl copy_bc module~~viscosity~~UsesGraph module~viscosity viscosity module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sst global_sst module~viscosity->module~global_sst module~global_vars global_vars module~viscosity->module~global_vars module~utils utils module~viscosity->module~utils module~global_sa global_sa module~viscosity->module~global_sa module~copy_bc->module~global_vars module~global global module~global_vars->module~global module~utils->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~viscosity~~UsedByGraph module~viscosity viscosity module~solver solver module~solver->module~viscosity module~update update module~solver->module~update module~update->module~viscosity program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines calculate_viscosity setup_viscosity destroy_viscosity Subroutines public subroutine calculate_viscosity () Calculate molecular and turbulent viscosity Arguments None public subroutine setup_viscosity () Allocate and pointer for molecular and turbulent viscosity Arguments None public subroutine destroy_viscosity () Deallocate and nullify viscosity (turbulent/molecular) Arguments None","tags":"","loc":"module/viscosity.html","title":"viscosity – FEST-3D"},{"text":"This module march the solution is time. Uses geometry utils global_vars plusgs boundary_state_reconstruction summon_grad_evaluation global_sst bc_primitive time viscous global_sa lusgs string global_kkl scheme face_interpolant viscosity interface1 source module~~update~~UsesGraph module~update update module~global_sst global_sst module~update->module~global_sst module~source source module~update->module~source module~utils utils module~update->module~utils module~summon_grad_evaluation summon_grad_evaluation module~update->module~summon_grad_evaluation module~plusgs plusgs module~update->module~plusgs module~boundary_state_reconstruction boundary_state_reconstruction module~update->module~boundary_state_reconstruction module~viscous viscous module~update->module~viscous module~lusgs lusgs module~update->module~lusgs module~global_vars global_vars module~update->module~global_vars module~viscosity viscosity module~update->module~viscosity module~string string module~update->module~string module~bc_primitive bc_primitive module~update->module~bc_primitive module~global_kkl global_kkl module~update->module~global_kkl module~interface1 interface1 module~update->module~interface1 module~time time module~update->module~time scheme scheme module~update->scheme face_interpolant face_interpolant module~update->face_interpolant module~geometry geometry module~update->module~geometry module~global_sa global_sa module~update->module~global_sa module~source->module~global_sst module~source->module~utils module~source->module~global_vars module~source->module~string module~source->module~global_kkl module~source->module~global_sa module~layout layout module~source->module~layout module~cc CC module~source->module~cc module~dump_solution dump_solution module~source->module~dump_solution module~utils->module~global_vars module~summon_grad_evaluation->module~utils module~summon_grad_evaluation->module~global_vars module~summon_grad_evaluation->module~string module~ghost_gradients ghost_gradients module~summon_grad_evaluation->module~ghost_gradients module~plusgs->module~global_sst module~plusgs->module~utils module~plusgs->module~global_vars module~plusgs->module~string module~plusgs->module~global_kkl module~plusgs->module~geometry module~plusgs->module~global_sa module~mapping mapping module~plusgs->module~mapping module~boundary_state_reconstruction->module~utils module~boundary_state_reconstruction->module~global_vars module~boundary_state_reconstruction->face_interpolant module~viscous->module~global_sst module~viscous->module~utils module~viscous->module~global_vars module~viscous->module~string module~viscous->module~global_kkl module~viscous->module~geometry module~viscous->module~global_sa module~global global module~viscous->module~global module~lusgs->module~global_sst module~lusgs->module~utils module~lusgs->module~global_vars module~lusgs->module~string module~lusgs->module~global_kkl module~lusgs->module~geometry module~lusgs->module~global_sa module~lusgs->module~mapping module~global_vars->module~global module~viscosity->module~global_sst module~viscosity->module~utils module~viscosity->module~global_vars module~viscosity->module~global_kkl module~viscosity->module~global_sa module~copy_bc copy_bc module~viscosity->module~copy_bc module~bc_primitive->module~global_sst module~bc_primitive->module~utils module~bc_primitive->module~global_vars module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~bc_primitive->module~copy_bc module~read_bc read_bc module~bc_primitive->module~read_bc module~interface1->module~utils module~interface1->module~global_vars module~interface1->module~mapping module~time->module~utils module~time->module~global_vars module~time->module~string module~time->face_interpolant module~time->module~geometry module~read read module~time->module~read module~geometry->module~utils module~geometry->module~global_vars module~mapping->module~utils module~mapping->module~global_vars module~mapping->module~string module~mapping->module~global module~fclose fclose module~mapping->module~fclose module~read->module~utils module~read->module~global_vars module~read->module~string module~read->module~global module~read->module~fclose module~layout->module~utils module~layout->module~global_vars module~layout->module~global module~ft_bc->module~global_vars module~ft_bc->module~copy_bc module~copy_bc->module~global_vars module~ghost_gradients->module~utils module~ghost_gradients->module~global_vars module~cc->module~utils module~cc->module~global_vars module~read_bc->module~global_vars module~read_bc->module~layout module~read_bc->module~global module~dump_solution->module~utils module~dump_solution->module~global_vars module~dump_solution->module~string module~dump_solution->module~layout module~dump_solution->module~global module~write_output write_output module~dump_solution->module~write_output module~fclose->module~global module~write_output->module~utils module~write_output->module~global_vars module~write_output->module~string module~write_output->module~global module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~write_output_tec_node->module~global_sst module~write_output_tec_node->module~utils module~write_output_tec_node->module~global_vars module~write_output_tec_node->module~string module~write_output_tec_node->module~global module~write_output_vtk->module~global_sst module~write_output_vtk->module~utils module~write_output_vtk->module~global_vars module~write_output_vtk->module~string module~write_output_vtk->module~global module~write_output_tec->module~global_sst module~write_output_tec->module~utils module~write_output_tec->module~global_vars module~write_output_tec->module~string module~write_output_tec->module~global var panmoduleupdateUsesGraph = svgPanZoom('#moduleupdateUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~update~~UsedByGraph module~update update module~solver solver module~solver->module~update program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables U_store R_store aux u1 u2 R Subroutines setup_update destroy_update get_next_solution update_with get_total_conservative_Residue update_laminar_variables_primitive update_laminar_variables_conservative update_turbulent_variables_primitive update_turbulent_variables_conservative Variables Type Visibility Attributes Name Initial real, private, dimension(:,:,:,:), allocatable :: U_store Array to store the intermediate solution real, private, dimension(:,:,:,:), allocatable :: R_store Array to store the intermediate Residue real, private, dimension(:,:,:,:), allocatable, target :: aux Array to store some auxilary intermediate variables real, private, dimension(:), allocatable :: u1 Variable array old for each cell center real, private, dimension(:), allocatable :: u2 Variable array new for each cell center real, private, dimension(:), allocatable :: R Residue array for each cell center Subroutines public subroutine setup_update () Allocate memory to variables required based \n on the time-integration scheme. Arguments None public subroutine destroy_update () Dellocate memory from all variables Arguments None public subroutine get_next_solution () Get solution at next time-step using scheme\n given in the input file. Arguments None private subroutine update_with (type, time_factor, store_factor, use, Rn, un) A generalized scheme to updat the solution explicitly using\n any RK method and even first order euler explicit. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: type real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use real, intent(inout), optional dimension(1:imx-1,1:jmx-1,1:kmx-1,1:n_var) :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un private subroutine get_total_conservative_Residue () Main loop of whole code. Find residual Read more… Arguments None private subroutine update_laminar_variables_primitive (time_factor, store_factor, use, tostore, Rn, un) Update first five primitive variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un private subroutine update_laminar_variables_conservative (time_factor, store_factor, use, tostore, Rn, un) Update first five conservative variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un private subroutine update_turbulent_variables_primitive (time_factor, store_factor, use, tostore, Rn, un) Update primitive turbulence variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un private subroutine update_turbulent_variables_conservative (time_factor, store_factor, use, tostore, Rn, un) Update conservative turbulence variables in time Arguments Type Intent Optional Attributes Name real, intent(in), optional :: time_factor real, intent(in), optional :: store_factor logical, intent(in), optional :: use logical, intent(in), optional :: tostore real, intent(inout), optional dimension( 1:imx-1, 1:jmx-1, 1:kmx-1,1:n_var), target :: Rn real, intent(in), optional dimension(-2:imx+2,-2:jmx+2,-2:kmx+2,1:n_var), target :: un","tags":"","loc":"module/update.html","title":"update – FEST-3D"},{"text":"The geometry module calculates various geometrical quantities like \n face-normals, face-areas and cell-volumes to be used in computations. Uses global_vars utils module~~geometry~~UsesGraph module~geometry geometry module~utils utils module~geometry->module~utils module~global_vars global_vars module~geometry->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~geometry~~UsedByGraph module~geometry geometry module~lusgs lusgs module~lusgs->module~geometry module~create_and_erase create_and_erase module~create_and_erase->module~geometry module~time time module~create_and_erase->module~time module~plusgs plusgs module~plusgs->module~geometry module~solver solver module~solver->module~geometry module~update update module~solver->module~update module~solver->module~time module~viscous viscous module~solver->module~viscous module~update->module~geometry module~update->module~lusgs module~update->module~plusgs module~update->module~time module~update->module~viscous module~time->module~geometry module~viscous->module~geometry program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables CellCenter Functions vol_tetrahedron vol_hexahedron Subroutines allocate_memory_volumes allocate_memory_areas allocate_memory_normals allocate_memory_ghost_centroids allocate_memory deallocate_memory normalize_face_normals compute_face_areas compute_face_area_vectors compute_face_areas_and_normals compute_volumes compute_geometric_parameters compute_ghost_cell_centroid setup_geometry destroy_geometry Variables Type Visibility Attributes Name Initial real, public, dimension(:,:,:,:), allocatable :: CellCenter Store Cell-center location Functions private function vol_tetrahedron (p1, p2, p3, p4) Compute the volume of a tetrahedron, given 4 points which\n are 1-D arrays\n Since we know that the determinant is to be evaluated of \n a 3x3 matrix, we write the expression itself Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:) :: p1 real, intent(in), dimension(:) :: p2 real, intent(in), dimension(:) :: p3 real, intent(in), dimension(:) :: p4 Return Value real private function vol_hexahedron (p_list) Compute the volume of a hexahedron, given a list of points Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:3, 1:8) :: p_list Return Value real Subroutines private subroutine allocate_memory_volumes () Allocate memory for the volume variables. Arguments None private subroutine allocate_memory_areas () Allocate memory for the area variables. Arguments None private subroutine allocate_memory_normals () Allocate memory for the normal variables. Arguments None private subroutine allocate_memory_ghost_centroids () Allocate memory for centroids of ghost cells Arguments None private subroutine allocate_memory () Allocate memory for the required variables. Arguments None private subroutine deallocate_memory () Deallocate the memoery used by the geometry variables Arguments None private subroutine normalize_face_normals () Normalize the face normal vectors computed to get unit\n vectors Arguments None private subroutine compute_face_areas () Compute face areas based on area vectors Read more… Arguments None private subroutine compute_face_area_vectors () Compute face area vectors Read more… Arguments None private subroutine compute_face_areas_and_normals () Compute the face areas and normals Read more… Arguments None private subroutine compute_volumes () Compute the grid cell volumes\n Each grid is a hexahedron, whose volume is calculated by\n splitting it into 5 tetrahedrons, whose volume is known Arguments None private subroutine compute_geometric_parameters () Compute the geometric parameters based on the grid points Read more… Arguments None private subroutine compute_ghost_cell_centroid () Compute cell center of all cell including ghost cells Arguments None public subroutine setup_geometry () Make the geometry module useful Read more… Arguments None public subroutine destroy_geometry () Nullify all the face normal pionter Arguments None","tags":"","loc":"module/geometry.html","title":"geometry – FEST-3D"},{"text":"Reference: Van Leer, B., Flux-vector splitting for the Euler equation. \n In Upwind and High-Resolution Schemes, Springer, Berlin, Heidelberg, pp. 80-89, 1997 Uses global_vars face_interpolant utils module~~van_leer~~UsesGraph module~van_leer van_leer module~utils utils module~van_leer->module~utils module~global_vars global_vars module~van_leer->module~global_vars face_interpolant face_interpolant module~van_leer->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Array to store the flux through I, J, and K direction face and residue in the cell real, public, dimension(:, :, :, :), allocatable, target :: G Array to store the flux through I, J, and K direction face and residue in the cell real, public, dimension(:, :, :, :), allocatable, target :: H Array to store the flux through I, J, and K direction face and residue in the cell real, public, dimension(:, :, :, :), allocatable, target :: residue Array to store the flux through I, J, and K direction face and residue in the cell real, private, dimension(:, :, :, :), pointer :: flux_p A general flux pointer Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue using the Van-Leer scheme Arguments None","tags":"","loc":"module/van_leer.html","title":"van_leer – FEST-3D"},{"text":"Shima, E., and Kitamura, K., “Parameter-Free Simple\n Low-Dissipation AUSM-Family Scheme for All Speeds,” \n AIAA Journal, vol. 49, pp. 1693–1709, 2011 Uses global_vars face_interpolant utils module~~slau~~UsesGraph module~slau slau module~utils utils module~slau->module~utils module~global_vars global_vars module~slau->module~global_vars face_interpolant face_interpolant module~slau->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real, public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real, public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real, public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real, private, dimension(:, :, :, :), pointer :: flux_p Pointer/alias for the either F, G, or H Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue for the slau scheme Arguments None","tags":"","loc":"module/slau.html","title":"slau – FEST-3D"},{"text":"Reference: Liou, M. S., “A sequel to AUSM, Part II: \n AUSM+-up for all speeds,” Journal of Computational Physics, \n vol. 214, 2006, pp. 137–170 Uses global_vars face_interpolant utils module~~ausmup~~UsesGraph module~ausmup ausmUP module~utils utils module~ausmup->module~utils module~global_vars global_vars module~ausmup->module~global_vars face_interpolant face_interpolant module~ausmup->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real, public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real, public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real, public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real, private, dimension(:, :, :, :), pointer :: flux_p Pointer/alias for the either F, G, or H Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue for the ausm+-UP scheme Arguments None","tags":"","loc":"module/ausmup.html","title":"ausmUP – FEST-3D"},{"text":"Reference: Liou, M. S., “A sequel to AUSM: AUSM+,” \n Journal of Computational Physics, vol. 129, pp. 364–382, 1996 Uses global_vars face_interpolant utils module~~ausmp~~UsesGraph module~ausmp ausmP module~utils utils module~ausmp->module~utils module~global_vars global_vars module~ausmp->module~global_vars face_interpolant face_interpolant module~ausmp->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real, public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real, public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real, public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real, private, dimension(:, :, :, :), pointer :: flux_p Pointer/alias for the either F, G, or H Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue for the AUSM+ scheme Arguments None","tags":"","loc":"module/ausmp.html","title":"ausmP – FEST-3D"},{"text":"Reference: Liou, M.S. and Steffen Jr, C.J., A new flux splitting scheme, \n Journal of Computational physics, vol. 107, no. 1, pp.23-39, 1993 Uses global_vars face_interpolant utils module~~ausm~~UsesGraph module~ausm ausm module~utils utils module~ausm->module~utils module~global_vars global_vars module~ausm->module~global_vars face_interpolant face_interpolant module~ausm->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real, public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real, public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real, public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real, private, dimension(:, :, :, :), pointer :: flux_p Pointer/alias for the either F, G, or H Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input-argument direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue for the AUSM scheme Arguments None","tags":"","loc":"module/ausm.html","title":"ausm – FEST-3D"},{"text":"Reference: Edwards, J.R., A low-diffusion flux-splitting scheme \n for Navier-Stokes calculations, Computers & Fluids, vol. 26,\n no. 6, pp.635-659, 1997 Uses global_vars face_interpolant utils module~~ldfss0~~UsesGraph module~ldfss0 ldfss0 module~utils utils module~ldfss0->module~utils module~global_vars global_vars module~ldfss0->module~global_vars face_interpolant face_interpolant module~ldfss0->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables F G H residue flux_p Subroutines setup_scheme destroy_scheme compute_flux compute_fluxes get_residue Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: F Store fluxes throught the I faces real, public, dimension(:, :, :, :), allocatable, target :: G Store fluxes throught the J faces real, public, dimension(:, :, :, :), allocatable, target :: H Store fluxes throught the K faces real, public, dimension(:, :, :, :), allocatable, target :: residue Store residue at each cell-center real, private, dimension(:, :, :, :), pointer :: flux_p Pointer/alias for the either F, G, or H Subroutines public subroutine setup_scheme () Allocate memory to the flux variables Arguments None public subroutine destroy_scheme () Deallocate memory Arguments None private subroutine compute_flux (f_dir) A generalized subroutine to calculate\n flux through the input direction, :x,y, or z\n which corresponds to the I,J, or K direction respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction for which flux are calcuated and store public subroutine compute_fluxes () Call to compute fluxes throught faces in each direction Arguments None public subroutine get_residue () Compute the residue for the ldfss0 scheme Arguments None","tags":"","loc":"module/ldfss0.html","title":"ldfss0 – FEST-3D"},{"text":"Reference:Hirsch, C., Numerical computation of internal \nand external flows: The fundamentals of computational fluid \ndynamics, Elsevier, 2007 MUSCL (Monotone Upwing Schemes for Scalar Conservation Laws is\n a scheme which replaces the piecewise constant approximation by\n reconstructing the states at the left and right side of each face.\n This is a one parameter upwind scheme which results in at most 3rd\n order accuracy. Uses global_vars utils module~~muscl~~UsesGraph module~muscl muscl module~utils utils module~muscl->module~utils module~global_vars global_vars module~muscl->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_qp_left x_qp_right y_qp_left y_qp_right z_qp_left z_qp_right phi kappa f_qp_left f_qp_right pdif switch_L Subroutines setup_scheme destroy_scheme pressure_based_switching compute_face_state compute_muscl_states Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: x_qp_left Store primitive state at the I-face left side real, public, dimension(:, :, :, :), allocatable, target :: x_qp_right Store primitive state at the I-face right side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_left Store primitive state at the J-face left side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_right Store primitive state at the J-face right side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_left Store primitive state at the K-face left side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_right Store primitive state at the K-face right side real, private :: phi real, private :: kappa real, private, dimension(:, :, :, :), pointer :: f_qp_left Generalized pointer for any I-J-K direction> f_qp_left can \n either point to x_qp_left, y_qp_left or z_qp_left real, private, dimension(:, :, :, :), pointer :: f_qp_right Generalized pointer for any I-J-K direction> f_qp_right can \n either point to x_qp_right, y_qp_right or z_qp_right real, private, dimension(:, :, :), allocatable :: pdif Used for pressure based witch integer, private :: switch_L = 1 Limiter switch Subroutines public subroutine setup_scheme () Allocate memoery to all array which store state\n the face. Arguments None public subroutine destroy_scheme () Deallocate all the array used Arguments None private subroutine pressure_based_switching (f_dir) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Character can be x or y or z private subroutine compute_face_state (f_dir, lam_switch, turb_switch) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir Input direction x,y,or, z for which subroutine is called integer, intent(in) :: lam_switch Limiter switch for laminar variables integer, intent(in) :: turb_switch Limiter switch for turbulent variables public subroutine compute_muscl_states () Implement MUSCL scheme to get left and right states at\n each face. The computation is done through all cells\n and first level ghost cells Arguments None","tags":"","loc":"module/muscl.html","title":"muscl – FEST-3D"},{"text":"Reference: 1 Shu, C.-W., “High-order Finite Difference and Finite Volume \n WENO Schemes and Discontinuous Galerkin Methods for CFD,” \n International Journal of Computational Fluid Dynamics, vol. 17, 2003, pp. 107–118.\n Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., \n“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” \nActa Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. Uses global_vars utils module~~weno~~UsesGraph module~weno weno module~utils utils module~weno->module~utils module~global_vars global_vars module~weno->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_qp_left x_qp_right y_qp_left y_qp_right z_qp_left z_qp_right f_qp_left f_qp_right Subroutines setup_scheme destroy_scheme compute_face_states compute_weno_states Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: x_qp_left Store primitive state at the I-face left side real, public, dimension(:, :, :, :), allocatable, target :: x_qp_right Store primitive state at the I-face right side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_left Store primitive state at the J-face left side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_right Store primitive state at the J-face right side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_left Store primitive state at the K-face left side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_right Store primitive state at the K-face right side real, private, dimension(:, :, :, :), pointer :: f_qp_left Generalized pointer for any I-J-K direction> f_qp_left can \n either point to x_qp_left, y_qp_left or z_qp_left real, private, dimension(:, :, :, :), pointer :: f_qp_right Generalized pointer for any I-J-K direction> f_qp_right can \n either point to x_qp_right, y_qp_right or z_qp_right Subroutines public subroutine setup_scheme () Allocate memoery to all array which store state\n the face. Arguments None public subroutine destroy_scheme () Deallocate all the array used Arguments None private subroutine compute_face_states (dir) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir public subroutine compute_weno_states () Call Weno scheme for all the three direction I,J, and K Arguments None","tags":"","loc":"module/weno.html","title":"weno – FEST-3D"},{"text":"Reference: 2 Huang, W. F., Ren, Y. X., and Jiang, X., \n“A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” \nActa Mechanica Sinica/Lixue Xuebao, 2017, pp. 1–11. Uses global_vars utils module~~weno_nm~~UsesGraph module~weno_nm weno_NM module~utils utils module~weno_nm->module~utils module~global_vars global_vars module~weno_nm->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_qp_left x_qp_right y_qp_left y_qp_right z_qp_left z_qp_right f_qp_left f_qp_right Subroutines setup_scheme destroy_scheme compute_face_states compute_weno_NM_states Variables Type Visibility Attributes Name Initial real, public, dimension(:, :, :, :), allocatable, target :: x_qp_left Store primitive state at the I-face left side real, public, dimension(:, :, :, :), allocatable, target :: x_qp_right Store primitive state at the I-face right side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_left Store primitive state at the J-face left side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_right Store primitive state at the J-face right side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_left Store primitive state at the K-face left side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_right Store primitive state at the K-face right side real, private, dimension(:, :, :, :), pointer :: f_qp_left Generalized pointer for any I-J-K direction> f_qp_left can \n either point to x_qp_left, y_qp_left or z_qp_left real, private, dimension(:, :, :, :), pointer :: f_qp_right Generalized pointer for any I-J-K direction> f_qp_right can \n either point to x_qp_right, y_qp_right or z_qp_right Subroutines public subroutine setup_scheme () Allocate memoery to all array which store state\n the face. Arguments None public subroutine destroy_scheme () Deallocate all the array used Arguments None private subroutine compute_face_states (dir) Subroutine to calculate state at the face, generalized for\n all direction : I,J, and K. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir public subroutine compute_weno_NM_states () Call Weno scheme for all the three direction I,J, and K Arguments None","tags":"","loc":"module/weno_nm.html","title":"weno_NM – FEST-3D"},{"text":"Reference: Colella, P. and Woodward, P.R., The piecewise \nparabolic method (PPM) for gas-dynamical simulations, Journal\nof computational physics, vol. 54, no. 1, pp.174-201, 1984 Uses global_vars utils module~~ppm~~UsesGraph module~ppm ppm module~utils utils module~ppm->module~utils module~global_vars global_vars module~ppm->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables x_qp_face_estimate y_qp_face_estimate z_qp_face_estimate x_qp_left x_qp_right y_qp_left y_qp_right z_qp_left z_qp_right f_qp_left f_qp_right pdif Subroutines setup_scheme destroy_scheme compute_face_estimates remove_extrema pressure_based_switching init_left_and_right_xi_estimates init_left_and_right_eta_estimates init_left_and_right_zeta_estimates compute_ppm_states Variables Type Visibility Attributes Name Initial real, private, dimension(:, :, :, :), allocatable, target :: x_qp_face_estimate Store the I face estimate from 4th order reconstruction real, private, dimension(:, :, :, :), allocatable, target :: y_qp_face_estimate Store the J face estimate from 4th order reconstruction real, private, dimension(:, :, :, :), allocatable, target :: z_qp_face_estimate Store the K face estimate from 4th order reconstruction real, public, dimension(:, :, :, :), allocatable, target :: x_qp_left Store primitive state at the I-face left side real, public, dimension(:, :, :, :), allocatable, target :: x_qp_right Store primitive state at the I-face right side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_left Store primitive state at the J-face left side real, public, dimension(:, :, :, :), allocatable, target :: y_qp_right Store primitive state at the J-face right side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_left Store primitive state at the K-face left side real, public, dimension(:, :, :, :), allocatable, target :: z_qp_right Store primitive state at the K-face right side real, private, dimension(:, :, :, :), pointer :: f_qp_left Generalized pointer for any I-J-K direction> f_qp_left can \n either point to x_qp_left, y_qp_left or z_qp_left real, private, dimension(:, :, :, :), pointer :: f_qp_right Generalized pointer for any I-J-K direction> f_qp_right can \n either point to x_qp_right, y_qp_right or z_qp_right real, private, dimension(:, :, :), allocatable :: pdif Used for pressure based witch Subroutines public subroutine setup_scheme () Allocate memoery to all array which store state\n the face. Arguments None public subroutine destroy_scheme () Deallocate all the array used Arguments None private subroutine compute_face_estimates (f_dir) Subroutine to calculate state at the face, generalized for Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir private subroutine remove_extrema (f_dir) Remove extrema from the state estimated. \n Limiting the value in case of PPM Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir private subroutine pressure_based_switching (f_dir) Pressure based switching. \n User x,y, or z for I,J,or K face respectively Arguments Type Intent Optional Attributes Name character, intent(in) :: f_dir private subroutine init_left_and_right_xi_estimates () Initialize the left and right state at I direction face Arguments None private subroutine init_left_and_right_eta_estimates () Initialize the left and right state at J direction face Arguments None private subroutine init_left_and_right_zeta_estimates () Initialize the left and right state at K direction face Arguments None public subroutine compute_ppm_states () Call PPM face-state reconstruction for each face\n with optional call for remove extrema based on\n input limter switch and call pressure based switching\n based on input pressure based switch Arguments None","tags":"","loc":"module/ppm.html","title":"ppm – FEST-3D"},{"text":"Setup boundary condition for the domain Uses global_vars utils read_bc module~~bc~~UsesGraph module~bc bc module~utils utils module~bc->module~utils module~global_vars global_vars module~bc->module~global_vars module~read_bc read_bc module~bc->module~read_bc module~utils->module~global_vars module~global global module~global_vars->module~global module~read_bc->module~global_vars module~layout layout module~read_bc->module~layout module~read_bc->module~global module~layout->module~utils module~layout->module~global_vars module~layout->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bc~~UsedByGraph module~bc bc module~solver solver module~solver->module~bc module~create_and_erase create_and_erase module~create_and_erase->module~bc program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables face_num Subroutines setup_bc destroy_bc Variables Type Visibility Attributes Name Initial integer, private :: face_num Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax Subroutines public subroutine setup_bc () Initialization and allocate memory of boundary condition variables Arguments None public subroutine destroy_bc () Deallocate memory from boundary condition variables Arguments None","tags":"","loc":"module/bc.html","title":"bc – FEST-3D"},{"text":"A module contains generalized subroutine to copy variable in ghost cells Uses global_vars module~~copy_bc~~UsesGraph module~copy_bc copy_bc module~global_vars global_vars module~copy_bc->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~copy_bc~~UsedByGraph module~copy_bc copy_bc module~ft_bc FT_bc module~ft_bc->module~copy_bc module~viscosity viscosity module~viscosity->module~copy_bc module~bc_primitive bc_primitive module~bc_primitive->module~copy_bc module~bc_primitive->module~ft_bc module~solver solver module~solver->module~viscosity module~solver->module~bc_primitive module~update update module~solver->module~update module~update->module~viscosity module~update->module~bc_primitive program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines copy1 copy3 Subroutines public subroutine copy1 (var, type, face) Copy 1 layer of interior cell to first ghost cell layer Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called public subroutine copy3 (var, type, face) Copy 3 layer of interior cell to three ghost cell layer Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Varible over which these operation has to be performed character(len=*), intent(in) :: type Type of copy: flat, symmetry, anti-symmetry character(len=*), intent(in) :: face Face over which boundary condition is being called","tags":"","loc":"module/copy_bc.html","title":"copy_bc – FEST-3D"},{"text":"Apply boundary condition at every iteration Uses global_vars utils global_sst read_bc FT_bc copy_bc module~~bc_primitive~~UsesGraph module~bc_primitive bc_primitive module~utils utils module~bc_primitive->module~utils module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~copy_bc copy_bc module~bc_primitive->module~copy_bc module~global_sst global_sst module~bc_primitive->module~global_sst module~global_vars global_vars module~bc_primitive->module~global_vars module~read_bc read_bc module~bc_primitive->module~read_bc module~utils->module~global_vars module~ft_bc->module~copy_bc module~ft_bc->module~global_vars module~copy_bc->module~global_vars module~global global module~global_vars->module~global module~read_bc->module~global_vars module~layout layout module~read_bc->module~layout module~read_bc->module~global module~layout->module~utils module~layout->module~global_vars module~layout->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~bc_primitive~~UsedByGraph module~bc_primitive bc_primitive module~solver solver module~solver->module~bc_primitive module~update update module~solver->module~update module~update->module~bc_primitive program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables face_num Subroutines populate_ghost_primitive supersonic_inlet supersonic_outlet subsonic_inlet subsonic_outlet wall slip_wall pole fix no_slip set_omega_at_wall check_if_value_fixed far_field total_pressure temp_based_density periodic_bc Variables Type Visibility Attributes Name Initial integer, private :: face_num Number of the face : 1:imin, 2:imax, 3:jmin, 4:jmax, 5:kmin, 6:kmax Subroutines public subroutine populate_ghost_primitive () Populate the state variables in the ghost cell\n with particular value based on the boundary conditio \n being applied at that face Arguments None private subroutine supersonic_inlet (face) Supersonic inlet boundary condition\n All the values of state variables are fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine supersonic_outlet (face) Supersonic outlet boundary condition. \n All the values of state variables are copied \n from inside the domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine subsonic_inlet (face) Subsonic inlet boundary condition. \n All the state variables's value expect pressure\n is fixed and pressure is copied from inside the \n domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine subsonic_outlet (face) Subsonic outlet boundary condition. \n All the state variables's value expect pressure\n is copied from the inside of the domain and pressure \n is fixed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine wall (face) Adiabatic/Isothermal wall boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine slip_wall (face) Slip wall boundary condition. \n Maintain flow tangency Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine pole (face) Boundary condition for the block face\n with zero area; turning into a pole Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine fix (var, fix_val, face) Generalized subroutine to fix particular value\n at particular face Arguments Type Intent Optional Attributes Name real, intent(out), dimension(-2:imx+2, -2:jmx+2, -2:kmx+2) :: var Variable of which values are being fixed in the ghost cell real, intent(in), dimension(1:6) :: fix_val Amount of value that need to be fixed. character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine no_slip (face) No-slip wall boundary condition. All the \n component of velocity throught face is zero Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Name of the face at which boundary condition is called private subroutine set_omega_at_wall (face) Set value of turbulence variable: omega (turbulenct dissipation rate). \n Value fixed is accourding to the SST turbulence model Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face private subroutine check_if_value_fixed (model) A Fail-check subroutine which set the freestream\n as the fixed value in case not specified explicitly Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: model private subroutine far_field (face) Far-field Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*) :: face private subroutine total_pressure (face) Total Pressure Riemann boundary condition Arguments Type Intent Optional Attributes Name character(len=*) :: face private subroutine temp_based_density (temperature, face) Specify the density in the ghost cell based on the\n temperature on the wall. Isothermal or adiabatic Arguments Type Intent Optional Attributes Name real, intent(in), dimension(1:6) :: temperature character(len=*), intent(in) :: face private subroutine periodic_bc (face) Single block periodic boundary condition.\n Not to be used for multiblock boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face","tags":"","loc":"module/bc_primitive.html","title":"bc_primitive – FEST-3D"},{"text":"Apply flow tangency boundary condition Uses global_vars copy_bc module~~ft_bc~~UsesGraph module~ft_bc FT_bc module~global_vars global_vars module~ft_bc->module~global_vars module~copy_bc copy_bc module~ft_bc->module~copy_bc module~global global module~global_vars->module~global module~copy_bc->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ft_bc~~UsedByGraph module~ft_bc FT_bc module~bc_primitive bc_primitive module~bc_primitive->module~ft_bc module~solver solver module~solver->module~bc_primitive module~update update module~solver->module~update module~update->module~bc_primitive program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines flow_tangency Subroutines public subroutine flow_tangency (face) Apply flow tangency boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: face Face over which flow tangency condition has to be applied","tags":"","loc":"module/ft_bc.html","title":"FT_bc – FEST-3D"},{"text":"Get all the fixed values from the bc_**.md file Uses global_vars global layout module~~read_bc~~UsesGraph module~read_bc read_bc module~layout layout module~read_bc->module~layout module~global_vars global_vars module~read_bc->module~global_vars module~global global module~read_bc->module~global module~layout->module~global_vars module~layout->module~global module~utils utils module~layout->module~utils module~global_vars->module~global module~utils->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_bc~~UsedByGraph module~read_bc read_bc module~bc bc module~bc->module~read_bc module~bc_primitive bc_primitive module~bc_primitive->module~read_bc module~update update module~update->module~bc_primitive module~solver solver module~solver->module~bc module~solver->module~bc_primitive module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~bc program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables buf Subroutines read_fixed_values get_fixed_values fill_fixed_values set_value Variables Type Visibility Attributes Name Initial character(len=STRING_BUFFER_LENGTH), private :: buf String to extract single line from the file Subroutines public subroutine read_fixed_values () Read fixed values for each block face Arguments None private subroutine get_fixed_values (count) Extract fixed value from the bc_**.md file Arguments Type Intent Optional Attributes Name integer, intent(in) :: count private subroutine fill_fixed_values () Fill the Fixed_var array with with free-stream value\n or default values. Arguments None private subroutine set_value (fixed_var, fix_val, inf_val, count, ios) Set particular value to the Fixed_var variable Arguments Type Intent Optional Attributes Name real, intent(out), dimension(:) :: fixed_var real, intent(in) :: fix_val real, intent(in) :: inf_val integer, intent(in) :: count integer, intent(in) :: ios","tags":"","loc":"module/read_bc.html","title":"read_bc – FEST-3D"},{"text":"Set value gradients in the ghost cells Uses global_vars utils module~~ghost_gradients~~UsesGraph module~ghost_gradients ghost_gradients module~utils utils module~ghost_gradients->module~utils module~global_vars global_vars module~ghost_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~ghost_gradients~~UsedByGraph module~ghost_gradients ghost_gradients module~summon_grad_evaluation summon_grad_evaluation module~summon_grad_evaluation->module~ghost_gradients module~solver solver module~solver->module~summon_grad_evaluation module~update update module~solver->module~update module~update->module~summon_grad_evaluation program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines apply_gradient_bc apply Subroutines public subroutine apply_gradient_bc () Call same subroutine for all the face Arguments None public subroutine apply (face) Apply/set value of all gradient in the ghost cells\n gradqp_G = (qp_I - qp_G) Area_W unit_normal_G/(volume_G)\n volume_G = volume_I Arguments Type Intent Optional Attributes Name character(len=*) :: face","tags":"","loc":"module/ghost_gradients.html","title":"ghost_gradients – FEST-3D"},{"text":"Reconstruct the boundary face in case of 4th and 5th order higher order\n face state reconstruction method. Since the limited information\n is available at the boundaries, the boundary face is limiter to \n 3rd order accurate and is reconstructed using MUSCL Scheme even when\n rest of the domain is using WENO or PPM Uses global_vars face_interpolant utils module~~boundary_state_reconstruction~~UsesGraph module~boundary_state_reconstruction boundary_state_reconstruction module~utils utils module~boundary_state_reconstruction->module~utils module~global_vars global_vars module~boundary_state_reconstruction->module~global_vars face_interpolant face_interpolant module~boundary_state_reconstruction->face_interpolant module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~boundary_state_reconstruction~~UsedByGraph module~boundary_state_reconstruction boundary_state_reconstruction module~solver solver module~solver->module~boundary_state_reconstruction module~update update module~solver->module~update module~update->module~boundary_state_reconstruction program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ppm_flag switch_L Subroutines reconstruct_boundary_state reconstruct_imin reconstruct_imax reconstruct_jmin reconstruct_jmax reconstruct_kmin reconstruct_kmax Variables Type Visibility Attributes Name Initial integer, private :: ppm_flag = 0 Flag to check if reconstruction is required integer, private :: switch_L = 1 Limiter switch Subroutines public subroutine reconstruct_boundary_state (interpolant) Call reconstruction based on the flag and boundary condition Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: interpolant private subroutine reconstruct_imin () Reconstruct state at the IMIN boundary face with MUSCL scheme Arguments None private subroutine reconstruct_imax () Reconstruct state at the IMAX boundary face with MUSCL scheme Arguments None private subroutine reconstruct_jmin () Reconstruct state at the JMIN boundary face with MUSCL scheme Arguments None private subroutine reconstruct_jmax () Reconstruct state at the JMAX boundary face with MUSCL scheme Arguments None private subroutine reconstruct_kmin () Reconstruct state at the KMIN boundary face with MUSCL scheme Arguments None private subroutine reconstruct_kmax () Reconstruct state at the KMAX boundary face with MUSCL scheme Arguments None","tags":"","loc":"module/boundary_state_reconstruction.html","title":"boundary_state_reconstruction – FEST-3D"},{"text":"Check for solution's convergence Uses global_vars module~~convergence~~UsesGraph module~convergence convergence module~global_vars global_vars module~convergence->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~convergence~~UsedByGraph module~convergence convergence program~main main program~main->module~convergence Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions converged Functions public function converged () result(c) Check if the solution seems to have converged\n The solution is said to have converged if the change in \n the residue norm is \"negligible\". Arguments None Return Value logical","tags":"","loc":"module/convergence.html","title":"convergence – FEST-3D"},{"text":"Calculate the distance from the wall \n for each cell-center in the domain Uses global_vars global utils module~~wall_dist~~UsesGraph module~wall_dist wall_dist module~utils utils module~wall_dist->module~utils module~global_vars global_vars module~wall_dist->module~global_vars module~global global module~wall_dist->module~global module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~wall_dist~~UsedByGraph module~wall_dist wall_dist module~solver solver module~solver->module~wall_dist module~create_and_erase create_and_erase module~create_and_erase->module~wall_dist program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables n_surfnodes wall_x wall_y wall_z Subroutines setup_wall_dist destroy_wall_dist setup_nodefile read_destroy_nodefile find_wall_dist Variables Type Visibility Attributes Name Initial integer, private :: n_surfnodes Number of surfce node points real, private, dimension(:), allocatable :: wall_x X component of wall surface node point real, private, dimension(:), allocatable :: wall_y Y component of wall surface node point real, private, dimension(:), allocatable :: wall_z Z component of wall surface node point Subroutines public subroutine setup_wall_dist () Allocate memory to the wall_distance variables\n and read the surface node file Arguments None public subroutine destroy_wall_dist () Deallocate the memory of wall_distance variable,\n wall_x, wall_y, and wall_z Arguments None private subroutine setup_nodefile () Open and read first line of surface_node_point file Arguments None private subroutine read_destroy_nodefile () Read, and close surface_node_point file Arguments None public subroutine find_wall_dist () Determine the minimum wall distance from the wall surface node points Arguments None","tags":"","loc":"module/wall_dist.html","title":"wall_dist – FEST-3D"},{"text":"Detect all the grid points on the wall boundary condition\n and store them in a single file Uses utils global_vars global bitwise string module~~wall~~UsesGraph module~wall wall module~utils utils module~wall->module~utils module~global_vars global_vars module~wall->module~global_vars module~string string module~wall->module~string module~global global module~wall->module~global module~bitwise bitwise module~wall->module~bitwise module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~wall~~UsedByGraph module~wall wall module~solver solver module~solver->module~wall module~create_and_erase create_and_erase module~create_and_erase->module~wall program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables ierr buf BUFSIZE new_type thisfile maxlen wallc wall_x wall_y wall_z no_slip_flag n_wall total_n_wall str line lf n_wall_buf write_flag Subroutines write_surfnode allocate_memory link_aliases unlink_aliases deallocate_memory setup_surface destroy_surface find_wall surface_points Variables Type Visibility Attributes Name Initial integer, private :: ierr Integer to store error real, private :: buf integer, private :: BUFSIZE Size of buffer for mpi integer, private :: new_type Create new type for MPI integer, private :: thisfile File hadler integer, private, parameter :: maxlen = 70 Maximum length for string real, private, dimension(:, :), allocatable, target :: wallc Centre of wall surface real, private, dimension(:), pointer :: wall_x X coordiante of center of wall surface real, private, dimension(:), pointer :: wall_y Y coordiante of center of wall surface real, private, dimension(:), pointer :: wall_z Z coordiante of center of wall surface integer, private, dimension(6) :: no_slip_flag = 0 Flag to detect wall integer, public :: n_wall Number of points on the wall integer, public :: total_n_wall Total number of points on the block across all processes character(len=maxlen), private, dimension(:), allocatable :: str Store all wall corridnate of current process in a string vector character(len=maxlen), private :: line Line to write in output file character, private, parameter :: lf = Achar(10) End of line character integer, private, dimension(:), allocatable :: n_wall_buf Store n_wall points of all processors in a array form integer, private, dimension(:), allocatable :: write_flag Check if current processor has any wall points to write Subroutines public subroutine write_surfnode () Extract and write the wall surface node points\n in a file shared by all the MPI processes Arguments None private subroutine allocate_memory () Allocate memory to str and wallc variable array Arguments None private subroutine link_aliases () Link pointers wall_x, wall_y, wall_z to wallc Arguments None private subroutine unlink_aliases () Unlink all the pointer used in this module Arguments None private subroutine deallocate_memory () Deallocate memory from the Wallc array Arguments None private subroutine setup_surface () Open MPI_shared write file, allocate memory and\n setup pointers Arguments None private subroutine destroy_surface () Deallocate memory, unlink pointers, and close MPI_shared file Arguments None private subroutine find_wall () Setup wall flag for all six boundary of the block Arguments None private subroutine surface_points () Extract surface points and store them\n in a string vector str(ind) Arguments None","tags":"","loc":"module/wall.html","title":"wall – FEST-3D"},{"text":"Writing solution in the output file in tecplot format with\n node data instead of cell-center data. Uses utils global_vars string global global_sst module~~write_output_tec_node~~UsesGraph module~write_output_tec_node write_output_tec_node module~utils utils module~write_output_tec_node->module~utils module~global_vars global_vars module~write_output_tec_node->module~global_vars module~string string module~write_output_tec_node->module~string module~global global module~write_output_tec_node->module~global module~global_sst global_sst module~write_output_tec_node->module~global_sst module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_tec_node~~UsedByGraph module~write_output_tec_node write_output_tec_node module~write_output write_output module~write_output->module~write_output_tec_node module~dump_solution dump_solution module~dump_solution->module~write_output module~source source module~source->module~dump_solution module~solver solver module~solver->module~dump_solution module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish var panmodulewrite_output_tec_nodeUsedByGraph = svgPanZoom('#modulewrite_output_tec_nodeUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k speed_inf file_format data_format newline format Subroutines write_file write_header write_grid write_scalar Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k real, private :: speed_inf character(len=8), private :: file_format character(len=16), private :: data_format character, private :: newline = achar(10) character(len=*), private, parameter :: format = \"(35e25.15)\" Subroutines public subroutine write_file () Write output file in the tecplot format with node data Arguments None private subroutine write_header () Write the header in the output file Arguments None private subroutine write_grid () Write grid information in the output file Arguments None private subroutine write_scalar (var, name, index) Write scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_tec_node.html","title":"write_output_tec_node – FEST-3D"},{"text":"Vtk module to write the solution in the vtk format Uses utils global_vars string global global_sst module~~write_output_vtk~~UsesGraph module~write_output_vtk write_output_vtk module~utils utils module~write_output_vtk->module~utils module~global_vars global_vars module~write_output_vtk->module~global_vars module~string string module~write_output_vtk->module~string module~global global module~write_output_vtk->module~global module~global_sst global_sst module~write_output_vtk->module~global_sst module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_vtk~~UsedByGraph module~write_output_vtk write_output_vtk module~write_output write_output module~write_output->module~write_output_vtk module~dump_solution dump_solution module~dump_solution->module~write_output module~source source module~source->module~dump_solution module~solver solver module~solver->module~dump_solution module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish var panmodulewrite_output_vtkUsedByGraph = svgPanZoom('#modulewrite_output_vtkUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k speed_inf file_format data_format newline Subroutines write_file write_header write_grid write_velocity write_resnorm write_scalar Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k real, private :: speed_inf character(len=8), private :: file_format character(len=16), private :: data_format character, private :: newline = achar(10) Subroutines public subroutine write_file () Write the header and variables in the file \"process_xx.dat\" Arguments None private subroutine write_header () Write the header in the output file in the tecplot format Arguments None private subroutine write_grid () Write the grid information in the output file Arguments None private subroutine write_velocity () Write the velocity vector in the output file Arguments None private subroutine write_resnorm () Write the residual information in the output file Arguments None private subroutine write_scalar (var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_vtk.html","title":"write_output_vtk – FEST-3D"},{"text":"Tecplot module to write the solution in the tecplot format Uses utils global_vars string global global_sst module~~write_output_tec~~UsesGraph module~write_output_tec write_output_tec module~utils utils module~write_output_tec->module~utils module~global_vars global_vars module~write_output_tec->module~global_vars module~string string module~write_output_tec->module~string module~global global module~write_output_tec->module~global module~global_sst global_sst module~write_output_tec->module~global_sst module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output_tec~~UsedByGraph module~write_output_tec write_output_tec module~write_output write_output module~write_output->module~write_output_tec module~dump_solution dump_solution module~dump_solution->module~write_output module~source source module~source->module~dump_solution module~solver solver module~solver->module~dump_solution module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish var panmodulewrite_output_tecUsedByGraph = svgPanZoom('#modulewrite_output_tecUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k speed_inf file_format data_format newline format Subroutines write_file write_header write_grid write_scalar Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k real, private :: speed_inf character(len=8), private :: file_format character(len=16), private :: data_format character, private :: newline = achar(10) character(len=*), private, parameter :: format = \"(1ES28.15E4)\" Subroutines public subroutine write_file () Write the header and variables in the file \"process_xx.dat\". Arguments None private subroutine write_header () Write the header in the output file in the tecplot format Arguments None private subroutine write_grid () Write the grid information in the output file Arguments None private subroutine write_scalar (var, name, index) Write the scalar variable in the output file Arguments Type Intent Optional Attributes Name real, intent(in), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index","tags":"","loc":"module/write_output_tec.html","title":"write_output_tec – FEST-3D"},{"text":"This module contians subroutine that\n  1. check if point of dumping condition is arrived.\n  2. create particular folder for dump.\n  3. dump data in that folder.\n  4. purge folders if required. Uses global_vars utils write_output layout string global module~~dump_solution~~UsesGraph module~dump_solution dump_solution module~global global module~dump_solution->module~global module~utils utils module~dump_solution->module~utils module~global_vars global_vars module~dump_solution->module~global_vars module~string string module~dump_solution->module~string module~write_output write_output module~dump_solution->module~write_output module~layout layout module~dump_solution->module~layout module~utils->module~global_vars module~global_vars->module~global module~write_output->module~global module~write_output->module~utils module~write_output->module~global_vars module~write_output->module~string module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~layout->module~global module~layout->module~utils module~layout->module~global_vars module~write_output_tec_node->module~global module~write_output_tec_node->module~utils module~write_output_tec_node->module~global_vars module~write_output_tec_node->module~string module~global_sst global_sst module~write_output_tec_node->module~global_sst module~write_output_vtk->module~global module~write_output_vtk->module~utils module~write_output_vtk->module~global_vars module~write_output_vtk->module~string module~write_output_vtk->module~global_sst module~write_output_tec->module~global module~write_output_tec->module~utils module~write_output_tec->module~global_vars module~write_output_tec->module~string module~write_output_tec->module~global_sst var panmoduledump_solutionUsesGraph = svgPanZoom('#moduledump_solutionUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~dump_solution~~UsedByGraph module~dump_solution dump_solution module~source source module~source->module~dump_solution module~solver solver module~solver->module~dump_solution module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables dump_dirname purge_dirname Subroutines checkpoint create_directory remove_directory purge_dump_dir make_dump_dir dump_data write_restart_log write_initial_resnorm Variables Type Visibility Attributes Name Initial character(len=FILE_NAME_LENGTH), private :: dump_dirname Name(check point number) of the directory to create character(len=FILE_NAME_LENGTH), private :: purge_dirname Name(check point number) of the directory to remove Subroutines public subroutine checkpoint () Create a checkpoint dump file if the time has come Arguments None private subroutine create_directory (dirname) Create a directory to keep the solution files from all the processor Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname private subroutine remove_directory (dirname) Remove a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dirname private subroutine purge_dump_dir () Purge the directory based on the input Arguments None private subroutine make_dump_dir () Solution directory and sub-directory in created with particular number Arguments None private subroutine dump_data () Call to write save files in the directory Arguments None private subroutine write_restart_log () Call to write log file in the subdirectory \"restart\". \n It is useful information while restarting the solver Arguments None private subroutine write_initial_resnorm () Writing Initial resnorom in the log file to \n maintian continuity of resnorm while restrarting Arguments None","tags":"","loc":"module/dump_solution.html","title":"dump_solution – FEST-3D"},{"text":"Open/close and call other modules for writing solution\n based on the input: type of file, either vtk or tecplot\n modules are called Uses global_vars utils write_output_vtk write_output_tec global string write_output_tec_node module~~write_output~~UsesGraph module~write_output write_output module~global global module~write_output->module~global module~utils utils module~write_output->module~utils module~write_output_vtk write_output_vtk module~write_output->module~write_output_vtk module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~global_vars global_vars module~write_output->module~global_vars module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~string string module~write_output->module~string module~utils->module~global_vars module~write_output_vtk->module~global module~write_output_vtk->module~utils module~write_output_vtk->module~global_vars module~write_output_vtk->module~string module~global_sst global_sst module~write_output_vtk->module~global_sst module~write_output_tec->module~global module~write_output_tec->module~utils module~write_output_tec->module~global_vars module~write_output_tec->module~string module~write_output_tec->module~global_sst module~global_vars->module~global module~write_output_tec_node->module~global module~write_output_tec_node->module~utils module~write_output_tec_node->module~global_vars module~write_output_tec_node->module~string module~write_output_tec_node->module~global_sst Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~write_output~~UsedByGraph module~write_output write_output module~dump_solution dump_solution module~dump_solution->module~write_output module~source source module~source->module~dump_solution module~solver solver module~solver->module~dump_solution module~solver->module~source module~update update module~solver->module~update module~create_and_erase create_and_erase module~create_and_erase->module~source module~start_finish start_finish module~start_finish->module~solver module~update->module~source program~main main program~main->module~solver program~main->module~start_finish var panmodulewrite_outputUsedByGraph = svgPanZoom('#modulewrite_outputUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables data_format file_format Subroutines setup_file open_file close_file write_file Variables Type Visibility Attributes Name Initial character(len=16), private :: data_format character(len=16), private :: file_format Subroutines private subroutine setup_file () Setup the file type based on the input Arguments None private subroutine open_file (filename) Open the file to write the solution Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename private subroutine close_file (filename) Close the file after writing solution. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename public subroutine write_file () Writing output in the file according to the input file type Arguments None","tags":"","loc":"module/write_output.html","title":"write_output – FEST-3D"},{"text":"Read the restart file in the vtk format Uses global_vars string global utils module~~read_output_vtk~~UsesGraph module~read_output_vtk read_output_vtk module~utils utils module~read_output_vtk->module~utils module~global_vars global_vars module~read_output_vtk->module~global_vars module~string string module~read_output_vtk->module~string module~global global module~read_output_vtk->module~global module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output_vtk~~UsedByGraph module~read_output_vtk read_output_vtk module~read_output read_output module~read_output->module~read_output_vtk module~state state module~state->module~read_output module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k Subroutines read_file read_header read_grid read_velocity read_scalar skip_scalar Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k Subroutines public subroutine read_file () Read all the variable for the vtk restart file Arguments None private subroutine read_header () Skip read the header in the vtk file Arguments None private subroutine read_grid () Skip the grid read in the restart file Arguments None private subroutine read_velocity () Read velocity vector from the vtk file Arguments None private subroutine read_scalar (var, name, index) Read scalar from the vtk file Arguments Type Intent Optional Attributes Name real, intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index private subroutine skip_scalar () Skip read scalar from the vtk file Arguments None","tags":"","loc":"module/read_output_vtk.html","title":"read_output_vtk – FEST-3D"},{"text":"Read the restart file in the tecplot format Uses utils global_vars string global global_sst module~~read_output_tec~~UsesGraph module~read_output_tec read_output_tec module~utils utils module~read_output_tec->module~utils module~global_vars global_vars module~read_output_tec->module~global_vars module~string string module~read_output_tec->module~string module~global global module~read_output_tec->module~global module~global_sst global_sst module~read_output_tec->module~global_sst module~utils->module~global_vars module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output_tec~~UsedByGraph module~read_output_tec read_output_tec module~read_output read_output module~read_output->module~read_output_tec module~state state module~state->module~read_output module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k Subroutines read_file read_header read_grid read_scalar skip_scalar Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k Subroutines public subroutine read_file () Read all the variable for the tecplot restart file Arguments None private subroutine read_header () Skip read the header in the tecplot file Arguments None private subroutine read_grid () Skip the grid read in the restart file Arguments None private subroutine read_scalar (var, name, index) Read scalar from the tecplot file Arguments Type Intent Optional Attributes Name real, intent(out), dimension(index:imx-index,index:jmx-index,index:kmx-index) :: var character(len=*), intent(in) :: name integer, intent(in) :: index private subroutine skip_scalar () Skip read scalar from the tecplot file Arguments None","tags":"","loc":"module/read_output_tec.html","title":"read_output_tec – FEST-3D"},{"text":"This module read input control files which include:\n   1. control.md\n   2. fvscheme.md\n   3. flow.md\n   4. res_control.md\n   5. state_read_write_control.md Uses global_vars string global fclose utils module~~read~~UsesGraph module~read read module~utils utils module~read->module~utils module~global_vars global_vars module~read->module~global_vars module~string string module~read->module~string module~global global module~read->module~global module~fclose fclose module~read->module~fclose module~utils->module~global_vars module~global_vars->module~global module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read~~UsedByGraph module~read read module~time time module~time->module~read module~create_and_erase create_and_erase module~create_and_erase->module~read module~create_and_erase->module~time module~solver solver module~solver->module~read module~solver->module~time module~update update module~solver->module~update program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver module~update->module~time Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions get_number_of_line Subroutines read_input_and_controls get_next_token read_controls read_scheme read_flow read_output_control get_rw_count get_count_within_braces read_Res_list Functions private function get_number_of_line (till, infile) result(number) Get number of lines till some character like \"#\" Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: till integer, intent(in) :: infile Return Value integer Subroutines public subroutine read_input_and_controls () Read all the input control files Arguments None private subroutine get_next_token (token_file_unit, buf) Extract the next token from the config file Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: token_file_unit character(len=STRING_BUFFER_LENGTH), intent(out) :: buf private subroutine read_controls () Read control.md file Arguments None private subroutine read_scheme () Read fvscheme.md control file Arguments None private subroutine read_flow () Read flow.md control file Arguments None private subroutine read_output_control () Read output_contorl.md file Arguments None private subroutine get_rw_count () Get read/write count Arguments None private subroutine get_count_within_braces (handler, count) Get number of variables between two curly braces Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler File handler from which list number is extracted integer, intent(out) :: count Extracted count private subroutine read_Res_list () Read Residual file: res_control.md Arguments None","tags":"","loc":"module/read.html","title":"read – FEST-3D"},{"text":"Read output files from the restart folder Uses global_vars utils check_output_control read_output_vtk global string read_output_tec module~~read_output~~UsesGraph module~read_output read_output module~global global module~read_output->module~global module~utils utils module~read_output->module~utils module~check_output_control check_output_control module~read_output->module~check_output_control module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~global_vars global_vars module~read_output->module~global_vars module~string string module~read_output->module~string module~read_output_vtk read_output_vtk module~read_output->module~read_output_vtk module~utils->module~global_vars module~check_output_control->module~global_vars module~str_case str_case module~check_output_control->module~str_case module~read_output_tec->module~global module~read_output_tec->module~utils module~read_output_tec->module~global_vars module~read_output_tec->module~string module~global_sst global_sst module~read_output_tec->module~global_sst module~global_vars->module~global module~read_output_vtk->module~global module~read_output_vtk->module~utils module~read_output_vtk->module~global_vars module~read_output_vtk->module~string module~str_case->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~read_output~~UsedByGraph module~read_output read_output module~state state module~state->module~read_output module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables i j k speed_inf file_format data_format read_flow_type Subroutines read_file setup_file open_file close_file read_restart_file Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k real, private :: speed_inf Free-stream velocity magnitude character(len=8), private :: file_format Read file format character(len=16), private :: data_format Read file data type character(len=16), private :: read_flow_type Previous flow type Subroutines public subroutine read_file () Read restart file Arguments None private subroutine setup_file () Steup the file to read the restart state. Arguments None private subroutine open_file (filename) Open file from the restart folder Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename private subroutine close_file () Close the file after reading Arguments None private subroutine read_restart_file () Read the sub-directory log file in the restart folder Arguments None","tags":"","loc":"module/read_output.html","title":"read_output – FEST-3D"},{"text":"Utility module to allocate, deallocate and debug message Uses global_vars module~~utils~~UsesGraph module~utils utils module~global_vars global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~utils~~UsedByGraph module~utils utils module~mapping mapping module~mapping->module~utils module~read read module~read->module~utils module~sst_gradients sst_gradients module~sst_gradients->module~utils module~write_output_vtk write_output_vtk module~write_output_vtk->module~utils module~ghost_gradients ghost_gradients module~ghost_gradients->module~utils module~weno weno module~weno->module~utils module~wall wall module~wall->module~utils module~bc_primitive bc_primitive module~bc_primitive->module~utils module~sa_gradients sa_gradients module~sa_gradients->module~utils module~read_output_vtk read_output_vtk module~read_output_vtk->module~utils module~bc bc module~bc->module~utils module~weno_nm weno_NM module~weno_nm->module~utils module~geometry geometry module~geometry->module~utils module~wall_dist wall_dist module~wall_dist->module~utils module~van_leer van_leer module~van_leer->module~utils module~read_output_tec read_output_tec module~read_output_tec->module~utils module~source source module~source->module~utils module~resnorm resnorm module~resnorm->module~utils module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~utils module~update update module~update->module~utils module~interface1 interface1 module~interface1->module~utils module~time time module~time->module~utils module~create_and_erase create_and_erase module~create_and_erase->module~utils module~state state module~state->module~utils module~ausmp ausmP module~ausmp->module~utils module~ppm ppm module~ppm->module~utils module~layout layout module~layout->module~utils module~summon_grad_evaluation summon_grad_evaluation module~summon_grad_evaluation->module~utils module~plusgs plusgs module~plusgs->module~utils module~write_output_tec write_output_tec module~write_output_tec->module~utils module~solver solver module~solver->module~utils module~gradients gradients module~gradients->module~utils module~cc CC module~cc->module~utils module~ausmup ausmUP module~ausmup->module~utils module~slau slau module~slau->module~utils module~dump_solution dump_solution module~dump_solution->module~utils module~lctm2015_gradients lctm2015_gradients module~lctm2015_gradients->module~utils module~ausm ausm module~ausm->module~utils module~grid grid module~grid->module~utils module~muscl muscl module~muscl->module~utils module~write_output write_output module~write_output->module~utils module~lusgs lusgs module~lusgs->module~utils module~viscous viscous module~viscous->module~utils module~ldfss0 ldfss0 module~ldfss0->module~utils module~read_output read_output module~read_output->module~utils module~laminar_gradients laminar_gradients module~laminar_gradients->module~utils module~viscosity viscosity module~viscosity->module~utils module~kkl_gradients kkl_gradients module~kkl_gradients->module~utils module~boundary_state_reconstruction boundary_state_reconstruction module~boundary_state_reconstruction->module~utils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables DEBUG_LEVEL Interfaces alloc dealloc Subroutines alloc_rank1_real alloc_rank2_real alloc_rank3_real alloc_rank4_real alloc_rank5_real alloc_rank6_real alloc_rank1_integer alloc_rank2_integer alloc_rank3_integer dealloc_rank1_real dealloc_rank2_real dealloc_rank3_real dealloc_rank4_real dealloc_rank5_real dealloc_rank6_real dealloc_rank1_integer dealloc_rank2_integer dealloc_rank3_integer dmsg turbulence_read_error Variables Type Visibility Attributes Name Initial integer, public :: DEBUG_LEVEL = 1 Debug level is an input from the control file.\n 5-> important calls only, and, \n 1-> all the calls Interfaces public interface alloc private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) public interface dealloc private subroutine dealloc_rank1_real (var) Deallcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_real (var) Deallcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_real (var) Deallcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank4_real (var) Deallcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank5_real (var) Deallcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank6_real (var) Deallcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank1_integer (var) Deallcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_integer (var) Deallcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_integer (var) Deallcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated Subroutines private subroutine alloc_rank1_real (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_real (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_real (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank4_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, errmsg) Allcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank5_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, errmsg) Allcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank6_real (var, start1, stop1, start2, stop2, start3, stop3, start4, stop4, start5, stop5, start6, stop6, errmsg) Allcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :,:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension integer, intent(in) :: start4 Starting index of Var array's dimension integer, intent(in) :: stop4 Last index of Var array's dimension integer, intent(in) :: start5 Starting index of Var array's dimension integer, intent(in) :: stop5 Last index of Var array's dimension integer, intent(in) :: start6 Starting index of Var array's dimension integer, intent(in) :: stop6 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank1_integer (var, start1, stop1, errmsg) Allcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank2_integer (var, start1, stop1, start2, stop2, errmsg) Allcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine alloc_rank3_integer (var, start1, stop1, start2, stop2, start3, stop3, errmsg) Allcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memory is allocated integer, intent(in) :: start1 Starting index of Var array's dimension integer, intent(in) :: stop1 Last index of Var array's dimension integer, intent(in) :: start2 Starting index of Var array's dimension integer, intent(in) :: stop2 Last index of Var array's dimension integer, intent(in) :: start3 Starting index of Var array's dimension integer, intent(in) :: stop3 Last index of Var array's dimension character(len=*), intent(in), optional :: errmsg Error message to print if mem_stat is not 0(successful) private subroutine dealloc_rank1_real (var) Deallcoate 1-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_real (var) Deallcoate 2-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_real (var) Deallcoate 3-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank4_real (var) Deallcoate 4-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank5_real (var) Deallcoate 5-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank6_real (var) Deallcoate 6-Dimensional array of type: real Arguments Type Intent Optional Attributes Name real, intent(inout), dimension(:, :, :, :, :, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank1_integer (var) Deallcoate 1-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank2_integer (var) Deallcoate 2-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :), allocatable :: var Variable to which memeory is deallocated private subroutine dealloc_rank3_integer (var) Deallcoate 3-Dimensional array of type: integer Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(:, :, :), allocatable :: var Variable to which memeory is deallocated public subroutine dmsg (level, prog, method, msg) Based on the debug level input this\n soubroutine will output/print or skip the debug\n message. This subroutine is called in the\n starting of every other subrotune for debuging.\n This will be depricated in the later version. Arguments Type Intent Optional Attributes Name integer :: level The message's debug level character(len=*), optional :: prog Module or program name character(len=*), optional :: method Subroutine or function name character(len=*), optional :: msg Message to print public subroutine turbulence_read_error () Arguments None","tags":"","loc":"module/utils.html","title":"utils – FEST-3D"},{"text":"Check for the input from the output_control.md file Uses global_vars str_case module~~check_output_control~~UsesGraph module~check_output_control check_output_control module~str_case str_case module~check_output_control->module~str_case module~global_vars global_vars module~check_output_control->module~global_vars module~global global module~str_case->module~global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~check_output_control~~UsedByGraph module~check_output_control check_output_control module~state state module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~read_output->module~check_output_control module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver var panmodulecheck_output_controlUsedByGraph = svgPanZoom('#modulecheck_output_controlUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines verify_write_control verify_read_control Subroutines public subroutine verify_write_control () Verify all the variable being asked to write in the output file. \n This is a fail-safe subroutine which do not allow to write the incorrect input variable Arguments None public subroutine verify_read_control () Verify all the variable being asked to read in the output file. \n This is a fail-safe subroutine which do not allow to read the incorrect input variable. \n Based on previous flow type some varible might be skipped Arguments None","tags":"","loc":"module/check_output_control.html","title":"check_output_control – FEST-3D"},{"text":"To apply bitwise (and) and (or) to integer which represents the binary or oct number Used by module~~bitwise~~UsedByGraph module~bitwise bitwise module~wall wall module~wall->module~bitwise module~solver solver module~solver->module~wall module~create_and_erase create_and_erase module~create_and_erase->module~wall program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Interfaces operator(.and.) operator(.or.) assignment(=) bin2int oct2int Functions int4_and_int4 int8_and_int8 int4_or_int4 int4_1D_or_int4_1D int4_1D_or_int4 int4_2D_or_int4_2D int4_2D_or_int4 int8_or_int8 Subroutines bin_to_int4 bin_to_int8 oct_to_int4 oct_to_int8 int4_from_string int8_from_string Interfaces public interface operator(.and.) public function int4_and_int4 (a, b) result(r) Bitwise 'AND' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int8_and_int8 (a, b) result(r) Bitwise 'AND' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) public interface operator(.or.) public function int4_or_int4 (a, b) result(r) Bitwise 'OR' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int4_1D_or_int4_1D (a, b) result(r) Bitwise 'OR' over two 1D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in), dimension(:) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_1D_or_int4 (a, b) result(r) Bitwise 'OR' over one 1D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_2D_or_int4_2D (a, b) result(r) Bitwise 'OR' over two 2D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in), dimension(:, :) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int4_2D_or_int4 (a, b) result(r) Bitwise 'OR' over one 2D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int8_or_int8 (a, b) result(r) Bitwise 'OR' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) public interface assignment(=) public subroutine int4_from_string (lhs, rhs) Get integer of kind 4 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: lhs character(len=*), intent(in) :: rhs public subroutine int8_from_string (lhs, rhs) Get integer of kind 8 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: lhs character(len=*), intent(in) :: rhs public interface bin2int public subroutine bin_to_int4 (r, binstr) String of binary number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: binstr public subroutine bin_to_int8 (r, binstr) String of binary number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: binstr public interface oct2int public subroutine oct_to_int4 (r, octstr) String of octal number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: octstr public subroutine oct_to_int8 (r, octstr) String of octal number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: octstr Functions public function int4_and_int4 (a, b) result(r) Bitwise 'AND' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int8_and_int8 (a, b) result(r) Bitwise 'AND' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) public function int4_or_int4 (a, b) result(r) Bitwise 'OR' over two integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4) public function int4_1D_or_int4_1D (a, b) result(r) Bitwise 'OR' over two 1D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in), dimension(:) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_1D_or_int4 (a, b) result(r) Bitwise 'OR' over one 1D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(size(a)) public function int4_2D_or_int4_2D (a, b) result(r) Bitwise 'OR' over two 2D integer array of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in), dimension(:, :) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int4_2D_or_int4 (a, b) result(r) Bitwise 'OR' over one 2D integer array and integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(in), dimension(:, :) :: a integer(kind=4), intent(in) :: b Return Value integer(kind=4),\n  dimension(:, :), allocatable public function int8_or_int8 (a, b) result(r) Bitwise 'OR' over two integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(in) :: a integer(kind=8), intent(in) :: b Return Value integer(kind=8) Subroutines public subroutine bin_to_int4 (r, binstr) String of binary number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: binstr public subroutine bin_to_int8 (r, binstr) String of binary number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: binstr public subroutine oct_to_int4 (r, octstr) String of octal number converted to integer of kind 4 Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: r character(len=*) :: octstr public subroutine oct_to_int8 (r, octstr) String of octal number converted to integer of kind 8 Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: r character(len=*) :: octstr public subroutine int4_from_string (lhs, rhs) Get integer of kind 4 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=4), intent(out) :: lhs character(len=*), intent(in) :: rhs public subroutine int8_from_string (lhs, rhs) Get integer of kind 8 from the string which might contain either octal or binary number Arguments Type Intent Optional Attributes Name integer(kind=8), intent(out) :: lhs character(len=*), intent(in) :: rhs","tags":"","loc":"module/bitwise.html","title":"bitwise – FEST-3D"},{"text":"Change the full string to particular case: upper or lower. Uses global module~~str_case~~UsesGraph module~str_case str_case module~global global module~str_case->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~str_case~~UsedByGraph module~str_case str_case module~check_output_control check_output_control module~check_output_control->module~str_case module~state state module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~read_output->module~check_output_control module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver var panmodulestr_caseUsedByGraph = svgPanZoom('#modulestr_caseUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables res Functions ucase lcase Variables Type Visibility Attributes Name Initial character(len=STRING_BUFFER_LENGTH), private :: res Functions public function ucase (text) result(res) Mmake the whole string to upper case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of upper case public function lcase (text) result(res) Make the whole string to lower case Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: text Input string of any case Return Value character(len=STRING_BUFFER_LENGTH) Output string of lower case","tags":"","loc":"module/str_case.html","title":"str_case – FEST-3D"},{"text":"Module to convert int, real, or bool to string\n and concatenate int, real, bool, and string itself to string Used by module~~string~~UsedByGraph module~string string module~mapping mapping module~mapping->module~string module~read read module~read->module~string module~write_output_vtk write_output_vtk module~write_output_vtk->module~string module~wall wall module~wall->module~string module~write_output write_output module~write_output->module~string module~write_output->module~write_output_vtk module~write_output_tec_node write_output_tec_node module~write_output->module~write_output_tec_node module~write_output_tec write_output_tec module~write_output->module~write_output_tec module~read_output_vtk read_output_vtk module~read_output_vtk->module~string module~source source module~source->module~string module~dump_solution dump_solution module~source->module~dump_solution module~resnorm resnorm module~resnorm->module~string module~write_output_tec_node->module~string module~update update module~update->module~string module~update->module~source module~time time module~update->module~time module~viscous viscous module~update->module~viscous module~summon_grad_evaluation summon_grad_evaluation module~update->module~summon_grad_evaluation module~plusgs plusgs module~update->module~plusgs module~lusgs lusgs module~update->module~lusgs module~interface1 interface1 module~update->module~interface1 module~time->module~string module~time->module~read module~viscous->module~string module~state state module~state->module~string module~read_output read_output module~state->module~read_output module~summon_grad_evaluation->module~string module~plusgs->module~string module~plusgs->module~mapping module~write_output_tec->module~string module~solver solver module~solver->module~string module~solver->module~mapping module~solver->module~read module~solver->module~wall module~solver->module~source module~solver->module~resnorm module~solver->module~update module~solver->module~time module~solver->module~viscous module~solver->module~state module~solver->module~summon_grad_evaluation module~solver->module~dump_solution module~solver->module~interface1 module~grid grid module~solver->module~grid module~dump_solution->module~string module~dump_solution->module~write_output module~read_output->module~string module~read_output->module~read_output_vtk module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~lusgs->module~string module~lusgs->module~mapping module~create_and_erase create_and_erase module~create_and_erase->module~string module~create_and_erase->module~read module~create_and_erase->module~wall module~create_and_erase->module~source module~create_and_erase->module~time module~create_and_erase->module~state module~create_and_erase->module~grid module~read_output_tec->module~string module~interface1->module~mapping module~start_finish start_finish module~start_finish->module~solver module~grid->module~mapping program~main main program~main->module~solver program~main->module~start_finish var panmodulestringUsedByGraph = svgPanZoom('#modulestringUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables MAX_STRING_LEN dec_ exp_ form_ reset_flag Interfaces tostr operator( + ) len Functions int_to_str real_to_str bool_to_str str_cat_str str_cat_int int_cat_str str_cat_real real_cat_str str_cat_bool bool_cat_str intlen reallen Subroutines chfmt disp Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_STRING_LEN = 256 integer, private :: dec_ = 6 integer, private :: exp_ = -1 character, private :: form_ = 'F' logical, private :: reset_flag = .FALSE. Interfaces public interface tostr public function int_to_str (i) result(a) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function real_to_str (r) result(a) Convert real number to string Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function bool_to_str (b) result(a) Convert boolean variable to string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) public interface operator( + ) public function str_cat_str (s1, s2) result(a) Join two string into one string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value character(len=MAX_STRING_LEN) public function str_cat_int (s, i) result(a) Join a string to a integer and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function int_cat_str (i, s) result(a) Join a integer to a string and gives result as a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_real (s, r) result(a) Join a string to a real number and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function real_cat_str (r, s) result(a) Join a real number to a string and gives result as a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_bool (s, b) result(a) Join a string to a boolean and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) public function bool_cat_str (b, s) result(a) Join a boolean to a string and gives result as a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public interface len public function intlen (i) result(l) Return the \"string length of an integer\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer public function reallen (r) result(l) Return the \"string length of a real\" Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value integer Functions public function int_to_str (i) result(a) Convert integer to string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function real_to_str (r) result(a) Convert real number to string Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function bool_to_str (b) result(a) Convert boolean variable to string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) public function str_cat_str (s1, s2) result(a) Join two string into one string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 character(len=*), intent(in) :: s2 Return Value character(len=MAX_STRING_LEN) public function str_cat_int (s, i) result(a) Join a string to a integer and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: i Return Value character(len=MAX_STRING_LEN) public function int_cat_str (i, s) result(a) Join a integer to a string and gives result as a string Arguments Type Intent Optional Attributes Name integer, intent(in) :: i character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_real (s, r) result(a) Join a string to a real number and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: r Return Value character(len=MAX_STRING_LEN) public function real_cat_str (r, s) result(a) Join a real number to a string and gives result as a string Arguments Type Intent Optional Attributes Name real, intent(in) :: r character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function str_cat_bool (s, b) result(a) Join a string to a boolean and gives result as a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s logical, intent(in) :: b Return Value character(len=MAX_STRING_LEN) public function bool_cat_str (b, s) result(a) Join a boolean to a string and gives result as a string Arguments Type Intent Optional Attributes Name logical, intent(in) :: b character(len=*), intent(in) :: s Return Value character(len=MAX_STRING_LEN) public function intlen (i) result(l) Return the \"string length of an integer\" Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value integer public function reallen (r) result(l) Return the \"string length of a real\" Arguments Type Intent Optional Attributes Name real, intent(in) :: r Return Value integer Subroutines public subroutine chfmt (d, e, f) Change format specifier for reals Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: d integer, intent(in), optional :: e character, intent(in), optional :: f public subroutine disp (s) Display the contents of the string Arguments Type Intent Optional Attributes Name character(len=MAX_STRING_LEN), intent(in) :: s","tags":"","loc":"module/string.html","title":"string – FEST-3D"},{"text":"Open all files required by the solver. Input and auxillary file Uses global fclose module~~fopen~~UsesGraph module~fopen fopen module~global global module~fopen->module~global module~fclose fclose module~fopen->module~fclose module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines open_file Subroutines public subroutine open_file (handler) Open single file Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler","tags":"","loc":"module/fopen.html","title":"fopen – FEST-3D"},{"text":"Start and stop the solver Uses fclose solver module~~start_finish~~UsesGraph module~start_finish start_finish module~solver solver module~start_finish->module~solver module~fclose fclose module~start_finish->module~fclose module~mapping mapping module~solver->module~mapping module~read read module~solver->module~read module~global_vars global_vars module~solver->module~global_vars module~viscosity viscosity module~solver->module~viscosity module~wall wall module~solver->module~wall module~bc_primitive bc_primitive module~solver->module~bc_primitive module~cc CC module~solver->module~cc module~bc bc module~solver->module~bc Scheme Scheme module~solver->Scheme module~geometry geometry module~solver->module~geometry module~wall_dist wall_dist module~solver->module~wall_dist module~source source module~solver->module~source module~utils utils module~solver->module~utils module~resnorm resnorm module~solver->module~resnorm module~update update module~solver->module~update module~interface1 interface1 module~solver->module~interface1 module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~state state module~solver->module~state module~layout layout module~solver->module~layout module~summon_grad_evaluation summon_grad_evaluation module~solver->module~summon_grad_evaluation module~string string module~solver->module~string module~gradients gradients module~solver->module~gradients module~boundary_state_reconstruction boundary_state_reconstruction module~solver->module~boundary_state_reconstruction module~dump_solution dump_solution module~solver->module~dump_solution module~global global module~solver->module~global module~grid grid module~solver->module~grid module~fclose->module~global module~mapping->module~fclose module~mapping->module~global_vars module~mapping->module~utils module~mapping->module~string module~mapping->module~global module~read->module~fclose module~read->module~global_vars module~read->module~utils module~read->module~string module~read->module~global module~global_vars->module~global module~viscosity->module~global_vars module~viscosity->module~utils module~global_kkl global_kkl module~viscosity->module~global_kkl module~copy_bc copy_bc module~viscosity->module~copy_bc module~global_sst global_sst module~viscosity->module~global_sst module~global_sa global_sa module~viscosity->module~global_sa module~wall->module~global_vars module~wall->module~utils module~wall->module~string module~wall->module~global module~bitwise bitwise module~wall->module~bitwise module~bc_primitive->module~global_vars module~bc_primitive->module~utils module~ft_bc FT_bc module~bc_primitive->module~ft_bc module~bc_primitive->module~copy_bc module~bc_primitive->module~global_sst module~read_bc read_bc module~bc_primitive->module~read_bc module~cc->module~global_vars module~cc->module~utils module~bc->module~global_vars module~bc->module~utils module~bc->module~read_bc module~geometry->module~global_vars module~geometry->module~utils module~wall_dist->module~global_vars module~wall_dist->module~utils module~wall_dist->module~global module~source->module~global_vars module~source->module~cc module~source->module~utils module~source->module~layout module~source->module~string module~source->module~dump_solution module~source->module~global_kkl module~source->module~global_sst module~source->module~global_sa module~utils->module~global_vars module~resnorm->module~fclose module~resnorm->module~global_vars module~resnorm->module~utils module~resnorm->module~layout module~resnorm->module~string module~resnorm->module~global module~update->module~global_vars module~update->module~viscosity module~update->module~bc_primitive module~update->module~geometry module~update->module~source module~update->module~utils module~update->module~interface1 module~update->module~time module~update->module~viscous module~update->module~summon_grad_evaluation module~update->module~string module~update->module~boundary_state_reconstruction module~lusgs lusgs module~update->module~lusgs module~update->module~global_kkl module~plusgs plusgs module~update->module~plusgs module~update->module~global_sst scheme scheme module~update->scheme face_interpolant face_interpolant module~update->face_interpolant module~update->module~global_sa module~interface1->module~mapping module~interface1->module~global_vars module~interface1->module~utils module~time->module~read module~time->module~global_vars module~time->module~geometry module~time->module~utils module~time->module~string module~time->face_interpolant module~viscous->module~global_vars module~viscous->module~geometry module~viscous->module~utils module~viscous->module~string module~viscous->module~global module~viscous->module~global_kkl module~viscous->module~global_sst module~viscous->module~global_sa module~state->module~global_vars module~state->module~utils module~state->module~layout module~state->module~string module~state->module~global module~check_output_control check_output_control module~state->module~check_output_control module~read_output read_output module~state->module~read_output module~layout->module~global_vars module~layout->module~utils module~layout->module~global module~summon_grad_evaluation->module~global_vars module~summon_grad_evaluation->module~utils module~summon_grad_evaluation->module~string module~ghost_gradients ghost_gradients module~summon_grad_evaluation->module~ghost_gradients module~gradients->module~global_vars module~gradients->module~utils module~lctm2015_gradients lctm2015_gradients module~gradients->module~lctm2015_gradients module~sst_gradients sst_gradients module~gradients->module~sst_gradients module~laminar_gradients laminar_gradients module~gradients->module~laminar_gradients module~kkl_gradients kkl_gradients module~gradients->module~kkl_gradients module~sa_gradients sa_gradients module~gradients->module~sa_gradients module~boundary_state_reconstruction->module~global_vars module~boundary_state_reconstruction->module~utils module~boundary_state_reconstruction->face_interpolant module~dump_solution->module~global_vars module~dump_solution->module~utils module~dump_solution->module~layout module~dump_solution->module~string module~dump_solution->module~global module~write_output write_output module~dump_solution->module~write_output module~grid->module~mapping module~grid->module~global_vars module~grid->module~utils module~grid->module~global var panmodulestart_finishUsesGraph = svgPanZoom('#modulestart_finishUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~start_finish~~UsedByGraph module~start_finish start_finish program~main main program~main->module~start_finish Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines abort_run finish_run start_run Subroutines public subroutine abort_run () Aborting the solver Arguments None public subroutine finish_run () Finishing the solution computation Arguments None public subroutine start_run () Starting the solver setup Arguments None","tags":"","loc":"module/start_finish.html","title":"start_finish – FEST-3D"},{"text":"Close all the opened files Uses global module~~fclose~~UsesGraph module~fclose fclose module~global global module~fclose->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~fclose~~UsedByGraph module~fclose fclose module~resnorm resnorm module~resnorm->module~fclose module~fopen fopen module~fopen->module~fclose module~mapping mapping module~mapping->module~fclose module~start_finish start_finish module~start_finish->module~fclose module~solver solver module~start_finish->module~solver module~read read module~read->module~fclose module~grid grid module~grid->module~mapping module~lusgs lusgs module~lusgs->module~mapping module~plusgs plusgs module~plusgs->module~mapping module~solver->module~resnorm module~solver->module~mapping module~solver->module~read module~solver->module~grid module~interface1 interface1 module~solver->module~interface1 module~time time module~solver->module~time module~update update module~solver->module~update program~main main program~main->module~start_finish program~main->module~solver module~interface1->module~mapping module~time->module~read module~create_and_erase create_and_erase module~create_and_erase->module~read module~create_and_erase->module~grid module~create_and_erase->module~time module~update->module~lusgs module~update->module~plusgs module~update->module~interface1 module~update->module~time var panmodulefcloseUsedByGraph = svgPanZoom('#modulefcloseUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines close_all_files close_file Subroutines public subroutine close_all_files () Call to close all files Arguments None public subroutine close_file (handler) Arguments Type Intent Optional Attributes Name integer, intent(in) :: handler","tags":"","loc":"module/fclose.html","title":"fclose – FEST-3D"},{"text":"Setup and nullify pointers for SST model to the main array which stores gradient of all variables Uses global_vars utils module~~sst_gradients~~UsesGraph module~sst_gradients sst_gradients module~utils utils module~sst_gradients->module~utils module~global_vars global_vars module~sst_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sst_gradients~~UsedByGraph module~sst_gradients sst_gradients module~gradients gradients module~gradients->module~sst_gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_sst_grad destroy_sst_grad Subroutines public subroutine setup_sst_grad () Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None public subroutine destroy_sst_grad () Nullify all the gradient pointer setup for k-kL model Arguments None","tags":"","loc":"module/sst_gradients.html","title":"sst_gradients – FEST-3D"},{"text":"Link/Pointer to the gradient of u,v,w, and Temperature Uses global_vars utils module~~laminar_gradients~~UsesGraph module~laminar_gradients laminar_gradients module~utils utils module~laminar_gradients->module~utils module~global_vars global_vars module~laminar_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~laminar_gradients~~UsedByGraph module~laminar_gradients laminar_gradients module~gradients gradients module~gradients->module~laminar_gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_laminar_grad destroy_laminar_grad Subroutines public subroutine setup_laminar_grad () Setup pointer to the gradient of U, v, w, Temperature\n with respect to x, y, and z Arguments None public subroutine destroy_laminar_grad () Unlink the laminar gradient pointers Arguments None","tags":"","loc":"module/laminar_gradients.html","title":"laminar_gradients – FEST-3D"},{"text":"Allocate memory to laminar gradients if flow is viscous and\n allocate memory to tubulence gradients base upon the model being used Uses global_vars utils sa_gradients sst_gradients kkl_gradients laminar_gradients lctm2015_gradients module~~gradients~~UsesGraph module~gradients gradients module~sst_gradients sst_gradients module~gradients->module~sst_gradients module~utils utils module~gradients->module~utils module~laminar_gradients laminar_gradients module~gradients->module~laminar_gradients module~global_vars global_vars module~gradients->module~global_vars module~lctm2015_gradients lctm2015_gradients module~gradients->module~lctm2015_gradients module~sa_gradients sa_gradients module~gradients->module~sa_gradients module~kkl_gradients kkl_gradients module~gradients->module~kkl_gradients module~sst_gradients->module~utils module~sst_gradients->module~global_vars module~utils->module~global_vars module~laminar_gradients->module~utils module~laminar_gradients->module~global_vars module~global global module~global_vars->module~global module~lctm2015_gradients->module~utils module~lctm2015_gradients->module~global_vars module~sa_gradients->module~utils module~sa_gradients->module~global_vars module~kkl_gradients->module~utils module~kkl_gradients->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~gradients~~UsedByGraph module~gradients gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_gradients destroy_gradients get_n_grad allocate_memory destroy_memory Subroutines public subroutine setup_gradients () Memoery allocation to the gradient variables and \n setup pointer to the slice to the main gradient variable\n based on the various models being used. Arguments None public subroutine destroy_gradients () Deallocate memoery and nullify pointers\n to the gradient variables. Arguments None private subroutine get_n_grad () Set number of variables for which\n gradient is required based on the\n being used Arguments None private subroutine allocate_memory () Allocating memory to the gradient variable being used Arguments None private subroutine destroy_memory () Deallocate memeory from the gradient variables Arguments None","tags":"","loc":"module/gradients.html","title":"gradients – FEST-3D"},{"text":"Allocate memory to the state variables and initialize them\n The state of the system is defined using the density, velocity and\n pressure (primitive variables qp), and trubulent and transition\n variables at the cell-center points. Uses global_vars read_output check_output_control utils layout string global module~~state~~UsesGraph module~state state module~global global module~state->module~global module~read_output read_output module~state->module~read_output module~utils utils module~state->module~utils module~check_output_control check_output_control module~state->module~check_output_control module~global_vars global_vars module~state->module~global_vars module~string string module~state->module~string module~layout layout module~state->module~layout module~read_output->module~global module~read_output->module~utils module~read_output->module~check_output_control module~read_output->module~global_vars module~read_output->module~string module~read_output_vtk read_output_vtk module~read_output->module~read_output_vtk module~read_output_tec read_output_tec module~read_output->module~read_output_tec module~utils->module~global_vars module~check_output_control->module~global_vars module~str_case str_case module~check_output_control->module~str_case module~global_vars->module~global module~layout->module~global module~layout->module~utils module~layout->module~global_vars module~read_output_vtk->module~global module~read_output_vtk->module~utils module~read_output_vtk->module~global_vars module~read_output_vtk->module~string module~read_output_tec->module~global module~read_output_tec->module~utils module~read_output_tec->module~global_vars module~read_output_tec->module~string module~global_sst global_sst module~read_output_tec->module~global_sst module~str_case->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~state~~UsedByGraph module~state state module~solver solver module~solver->module~state module~create_and_erase create_and_erase module~create_and_erase->module~state program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Functions sound_speed_inf Subroutines link_aliases unlink_aliases allocate_memory deallocate_memory setup_state destroy_state init_infinity_values initstate init_state_with_infinity_values set_n_var_value Functions private function sound_speed_inf () result(a) Return the free stream speed of sound. Arguments None Return Value real Subroutines private subroutine link_aliases () Setup state variable pointers Arguments None private subroutine unlink_aliases () Nullify the pointer link Arguments None private subroutine allocate_memory () Allocate memory to the state variables Arguments None private subroutine deallocate_memory () Deallocate memory from the state variable Arguments None public subroutine setup_state () Setup the state module.\n This subroutine should be run before the state variables\n are initilized. This subroutine allocates the memory for \n state variables and sets up the aliases to refer to the \n components of the state Arguments None public subroutine destroy_state () Destroy the state module.\n This subroutine destroys the state module which includes\n unlinking the aliases for the state components and \n deallocating the memory held by the state variables Arguments None private subroutine init_infinity_values () Set the values of the infinity variables \"qp_inf\" Arguments None private subroutine initstate () Initialize the state.\n If load file(start_from) is 0, then the state should be \n set to the infinity values. Otherwise, read the state_file\n to get the state values Arguments None private subroutine init_state_with_infinity_values () Initialize the state based on the infinity values Arguments None private subroutine set_n_var_value () Set number of variable to solver for based on\n the tubulence and transition model being used Arguments None","tags":"","loc":"module/state.html","title":"state – FEST-3D"},{"text":"Setup and nullify pointers for LCTM2015 transition \nmodel to the main array which stores gradient of all variables Uses global_vars utils module~~lctm2015_gradients~~UsesGraph module~lctm2015_gradients lctm2015_gradients module~utils utils module~lctm2015_gradients->module~utils module~global_vars global_vars module~lctm2015_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~lctm2015_gradients~~UsedByGraph module~lctm2015_gradients lctm2015_gradients module~gradients gradients module~gradients->module~lctm2015_gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_lctm2015_grad destroy_lctm2015_grad Subroutines public subroutine setup_lctm2015_grad () Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None public subroutine destroy_lctm2015_grad () Nullify all the gradient pointer setup for k-kL model Arguments None","tags":"","loc":"module/lctm2015_gradients.html","title":"lctm2015_gradients – FEST-3D"},{"text":"Setup and nullify pointers for k-kL model to the main array which stores gradient of all variables Uses global_vars utils module~~kkl_gradients~~UsesGraph module~kkl_gradients kkl_gradients module~utils utils module~kkl_gradients->module~utils module~global_vars global_vars module~kkl_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~kkl_gradients~~UsedByGraph module~kkl_gradients kkl_gradients module~gradients gradients module~gradients->module~kkl_gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_kkl_grad destroy_kkl_grad Subroutines public subroutine setup_kkl_grad () Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None public subroutine destroy_kkl_grad () Nullify all the gradient pointer setup for k-kL model Arguments None","tags":"","loc":"module/kkl_gradients.html","title":"kkl_gradients – FEST-3D"},{"text":"Setup and nullify pointers for SA model to the main array which stores gradient of all variables Uses global_vars utils module~~sa_gradients~~UsesGraph module~sa_gradients sa_gradients module~utils utils module~sa_gradients->module~utils module~global_vars global_vars module~sa_gradients->module~global_vars module~utils->module~global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by module~~sa_gradients~~UsedByGraph module~sa_gradients sa_gradients module~gradients gradients module~gradients->module~sa_gradients module~solver solver module~solver->module~gradients module~create_and_erase create_and_erase module~create_and_erase->module~gradients program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Subroutines setup_sa_grad destroy_sa_grad Subroutines public subroutine setup_sa_grad () Setup Pointer to the main array which stores gradient \n all variables with x, y, z Arguments None public subroutine destroy_sa_grad () Nullify all the gradient pointer setup for k-kL model Arguments None","tags":"","loc":"module/sa_gradients.html","title":"sa_gradients – FEST-3D"},{"text":"Contains all the public/global variables used by more than one module Uses global module~~global_vars~~UsesGraph module~global_vars global_vars module~global global module~global_vars->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Used by global_vars w ausm w w ausmP w w ausmUP w w bc w w bc_primitive w w boundary_state_reconstruction w w CC w w check_output_control w w convergence w w copy_bc w w create_and_erase w w dump_solution w w FT_bc w w geometry w w ghost_gradients w w gradients w w grid w w interface1 w w kkl_gradients w w laminar_gradients w w layout w w lctm2015_gradients w w ldfss0 w w lusgs w w main w w mapping w w muscl w w plusgs w w ppm w w read w w read_bc w w read_output w w read_output_tec w w read_output_vtk w w resnorm w w sa_gradients w w slau w w solver w w source w w sst_gradients w w state w w summon_grad_evaluation w w time w w update w w utils w w van_leer w w viscosity w w viscous w w wall w w wall_dist w w weno w w weno_NM w w write_output w w write_output_tec w w write_output_tec_node w w write_output_vtk w Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables total_process total_entries process_id imin_id imax_id jmin_id jmax_id kmin_id kmax_id layers min_iter max_iters start_from checkpoint_iter checkpoint_iter_count current_iter r_count w_count res_write_interval purge_write last_iter write_percision write_data_format write_file_format read_data_format read_file_format outfile infile restartfile r_list w_list previous_flow_type CFL tolerance tolerance_type want_to_stop Halt time_stepping_method time_step_accuracy global_time_step delta_t sim_clock scheme_name interpolant qp_n dEdx_1 dEdx_2 dEdx_3 n_var qp qp_inf density x_speed y_speed z_speed pressure density_inf x_speed_inf y_speed_inf z_speed_inf pressure_inf MInf intermittency ExtraVar1 ExtraVar2 ExtraVar3 ExtraVar4 ExtraVar5 free_stream_density free_stream_x_speed free_stream_y_speed free_stream_z_speed free_stream_pressure free_stream_tk free_stream_tw free_stream_te free_stream_tv free_stream_tkl free_stream_tu free_stream_tgm vel_mag Reynolds_number mu_ratio_inf Turb_intensity_inf dist CCnormalX CCnormalY CCnormalZ CCVn DCCVnX DCCVnY DCCVnZ sst_n_var sst_n_grad tk tw te tv tkl tgm tk_inf tw_inf te_inf tv_inf tkl_inf tgm_inf F_p G_p H_p residue mass_residue x_mom_residue y_mom_residue z_mom_residue energy_residue TKE_residue omega_residue KL_residue dissipation_residue tv_residue gm R_gas mu_ref mu_variation T_ref Sutherland_temp Pr tPr supersonic_flag ilimiter_switch jlimiter_switch klimiter_switch itlimiter_switch jtlimiter_switch ktlimiter_switch iPB_switch jPB_switch kPB_switch turbulence transition mu mu_t sst_mu kkl_mu sa_mu Res_list Res_count Res_itr Res_abs Res_rel Res_save Res_scale resnorm vis_resnorm turb_resnorm cont_resnorm x_mom_resnorm y_mom_resnorm z_mom_resnorm energy_resnorm TKE_resnorm omega_resnorm resnorm_d1 vis_resnorm_d1 turb_resnorm_d1 cont_resnorm_d1 x_mom_resnorm_d1 y_mom_resnorm_d1 z_mom_resnorm_d1 energy_resnorm_d1 TKE_resnorm_d1 omega_resnorm_d1 resnorm_0 vis_resnorm_0 turb_resnorm_0 cont_resnorm_0 x_mom_resnorm_0 y_mom_resnorm_0 z_mom_resnorm_0 energy_resnorm_0 TKE_resnorm_0 omega_resnorm_0 resnorm_0s vis_resnorm_0s turb_resnorm_0s cont_resnorm_0s x_mom_resnorm_0s y_mom_resnorm_0s z_mom_resnorm_0s energy_resnorm_0s TKE_resnorm_0s omega_resnorm_0s imx jmx kmx imn jmn kmn grid_x grid_y grid_z xn yn zn xnx xny xnz ynx yny ynz znx zny znz xA yA zA volume left_ghost_centroid right_ghost_centroid front_ghost_centroid back_ghost_centroid top_ghost_centroid bottom_ghost_centroid n_grad gradqp_x gradqp_y gradqp_z gradu_x gradu_y gradu_z gradv_x gradv_y gradv_z gradw_x gradw_y gradw_z gradT_x gradT_y gradT_z gradtk_x gradtk_y gradtk_z gradtw_x gradtw_y gradtw_z gradtkl_x gradtkl_y gradtkl_z gradte_x gradte_y gradte_z gradtv_x gradtv_y gradtv_z gradtgm_x gradtgm_y gradtgm_z accur face_names id c1 c2 c3 fixed_density fixed_pressure fixed_x_speed fixed_y_speed fixed_z_speed fixed_tk fixed_tw fixed_te fixed_tv fixed_tkl fixed_tgm fixed_wall_temperature fixed_Tpressure fixed_Ttemperature N_blocks I_blocks J_blocks K_blocks imin imax jmin jmax kmin kmax ilo ihi jlo jhi klo khi dir_switch otherface make_F_flux_zero make_G_flux_zero make_H_flux_zero PbcId Variables Type Visibility Attributes Name Initial integer, public :: total_process Total number of process to be used for computation integer, public :: total_entries Total enteries in layout.md for each processor integer, public :: process_id Id no. of each processor assinged by MPICH library integer, public :: imin_id Boundary condition number/ID at imin for particulat processor integer, public :: imax_id Boundary condition number/ID at imax for particulat processor integer, public :: jmin_id Boundary condition number/ID at jmin for particulat processor integer, public :: jmax_id Boundary condition number/ID at jmax for particulat processor integer, public :: kmin_id Boundary condition number/ID at kmin for particulat processor integer, public :: kmax_id Boundary condition number/ID at kmax for particulat processor integer, public :: layers = 3 Number of ghost cell layers to transfer with mpi integer, public :: min_iter = 1 Minimum iteration value, starting iteration value integer, public :: max_iters = 1 Maximum iteration value, stop after these many iteration integer, public :: start_from = 0 Number of the folder (in time_directories) to load stored state from to restart computation integer, public :: checkpoint_iter = 0 Write interval for output file. Number of iteration after which solver will dump/store a state in a folder in time_directories integer, public :: checkpoint_iter_count = 0 Counter of folder number to write in time_directories/ integer, public :: current_iter = 0 Current iteration number integer, public :: r_count = 0 Number of variable to read from the restart file integer, public :: w_count = 0 Number of variable to write in the output file integer, public :: res_write_interval Write resnorm after every \"res_write_interval\" iteration integer, public :: purge_write Remove unwanted folder. If Purge_write=2, latest two folder in time_direcotires are kept and 0=no purge integer, public :: last_iter = 0 Last iteration that is stored in the restart file integer, public :: write_percision = 6 Number of place after decimal. Only used for resnorm file character(len=FORMAT_LENGTH), public :: write_data_format write data type. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: write_file_format Write file type. Either vtk or tecplot character(len=FORMAT_LENGTH), public :: read_data_format = 'ASCII' Read data type in file. Either ASCII or BINARY character(len=FORMAT_LENGTH), public :: read_file_format = \"vtk\" Read file type. Either vtk or tecplot character(len=FILE_NAME_LENGTH), public :: outfile String to store name of output file character(len=FILE_NAME_LENGTH), public :: infile String to store the name of restart/load file character(len=FILE_NAME_LENGTH), public :: restartfile Sting to store the name of restart log file character(len=STATE_NAME_LENGTH), public, dimension(:), allocatable :: r_list Read variable list character(len=STATE_NAME_LENGTH), public, dimension(:), allocatable :: w_list Write variable list character(len=FLOW_TYPE_LENGTH), public :: previous_flow_type = \"none\" Type of flow:inviscid, laminar, etc, stored in the load file real, public :: CFL Courant–Friedrichs–Lewy (CFL) (Read from input) real, public :: tolerance Minimum value of resnorm after which simulation stop character(len=TOLERANCE_LENGTH), public :: tolerance_type = \"abs\" Type of tolerance to check:absolute or relative integer, public :: want_to_stop = 0 0: continue the solver; 1=Stop the solver logical, public :: Halt = .FALSE. Logical value used to stop the solver in main program file. character, public :: time_stepping_method Either local time stepping or global time stepping character(len=INTERPOLANT_NAME_LENGTH), public :: time_step_accuracy Type of time_integration scheme: RK4, none(firt order explicit) implicit, real, public :: global_time_step Value of global time step to march the solution with real, public, dimension(:, :, :), allocatable :: delta_t Local time increment value at each cell center real, public :: sim_clock Simluation clock time character(len=SCHEME_NAME_LENGTH), public :: scheme_name Flux Scheme to use: ausm, ldfss0, vanleer, ausmup, ausmp, slau character(len=INTERPOLANT_NAME_LENGTH), public :: interpolant Face state reconstruction  method to user: muscl, ppm, none, weno, and wenoNM real, public, dimension(:, :, :, :), allocatable :: qp_n real, public, dimension(:, :, :, :), allocatable :: dEdx_1 real, public, dimension(:, :, :, :), allocatable :: dEdx_2 real, public, dimension(:, :, :, :), allocatable :: dEdx_3 integer, public :: n_var = 5 Number of variable to solve for real, public, dimension(:, :, :, :), allocatable, target :: qp Store primitive variable at cell center real, public, dimension(:), allocatable, target :: qp_inf Store primitive variable at infinity real, public, dimension(:, :, :), pointer :: density Rho pointer, point to slice of qp (:,:,:,1) real, public, dimension(:, :, :), pointer :: x_speed U pointer, point to slice of qp (:,:,:,2) real, public, dimension(:, :, :), pointer :: y_speed V pointer, point to slice of qp (:,:,:,3) real, public, dimension(:, :, :), pointer :: z_speed W pointer, point to slice of qp (:,:,:,4) real, public, dimension(:, :, :), pointer :: pressure P pointer, point to slice of qp (:,:,:,5) real, public, pointer :: density_inf Rho pointer, point to slice of qp_inf (1) real, public, pointer :: x_speed_inf U pointer, point to slice of qp_inf (2) real, public, pointer :: y_speed_inf V pointer, point to slice of qp_inf (3) real, public, pointer :: z_speed_inf W pointer, point to slice of qp_inf (4) real, public, pointer :: pressure_inf P pointer, point to slice of qp_inf (5) real, public :: MInf Free-stream Mach number real, public, dimension(:, :, :), allocatable, target :: intermittency Intermiitency pointer real, public, dimension(:, :, :), allocatable, target :: ExtraVar1 Extravar1 used only for debuging or store some sepcial kind of compination of other varialbes real, public, dimension(:, :, :), allocatable, target :: ExtraVar2 Extravar2 used only for debuging or store some sepcial kind of compination of other varialbes real, public, dimension(:, :, :), allocatable, target :: ExtraVar3 Extravar3 used only for debuging or store some sepcial kind of compination of other varialbes real, public, dimension(:, :, :), allocatable, target :: ExtraVar4 Extravar4 used only for debuging or store some sepcial kind of compination of other varialbes real, public, dimension(:, :, :), allocatable, target :: ExtraVar5 Extravar5 used only for debuging or store some sepcial kind of compination of other varialbes real, public :: free_stream_density Read freestream Density from control file real, public :: free_stream_x_speed Read freestream U from control file real, public :: free_stream_y_speed Read freestream V from control file real, public :: free_stream_z_speed Read freestream W from control file real, public :: free_stream_pressure Read freestream Pressure from control file real, public :: free_stream_tk Read freestream turbulent kinetic energy rate from control file real, public :: free_stream_tw Read freestream turbulent dissipation rate from control file real, public :: free_stream_te Read freestream turbulent dissipation from control file real, public :: free_stream_tv Read freestream turbulent viscosity(SA) from control file real, public :: free_stream_tkl Read freestream kL variable from control file real, public :: free_stream_tu Read freestream turbulence intensity (percentage) from control file real, public :: free_stream_tgm Read freestream turbulence intermittency from control file real, public :: vel_mag Calulated freestream Velocity Magnitude from control file real, public :: Reynolds_number Calculated free_stream Reynolds_number real, public :: mu_ratio_inf Read freestream turbulent viscosity to molecular viscosity ratio real, public :: Turb_intensity_inf Calculate free_stream turbulence intensity real, public, dimension(:, :, :), allocatable :: dist Store wall distance for each cell center real, public, dimension(:, :, :), allocatable :: CCnormalX Cell-Center normal nx with respect to wall; used for transition model (pressure gradient calcualtion) real, public, dimension(:, :, :), allocatable :: CCnormalY Cell-Center normal ny with respect to wall; used for transiton model (pressure gradient calculation) real, public, dimension(:, :, :), allocatable :: CCnormalZ Cell-Center normal nz with respect to wall; used for transiton model (pressure gradient calculation) real, public, dimension(:, :, :), allocatable :: CCVn Store value at Cell-Center of dot product between velocity vector and cell-center normal. {vec(Velocity).normal} real, public, dimension(:, :, :), allocatable :: DCCVnX Store Derivative of Cell-Center CCVn with respect to x real, public, dimension(:, :, :), allocatable :: DCCVnY Store Derivative of Cell-Center CCVn with respect to y real, public, dimension(:, :, :), allocatable :: DCCVnZ Store Derivative of Cell-Center CCVn with respect to z integer, public :: sst_n_var = 2 integer, public :: sst_n_grad = 2 real, public, dimension(:, :, :), pointer :: tk TKE/mass real, public, dimension(:, :, :), pointer :: tw Omega real, public, dimension(:, :, :), pointer :: te Dissipation real, public, dimension(:, :, :), pointer :: tv SA visocity real, public, dimension(:, :, :), pointer :: tkl KL K-KL method real, public, dimension(:, :, :), pointer :: tgm Intermittency of LCTM2015 real, public, pointer :: tk_inf TKE/mass at inf real, public, pointer :: tw_inf Omega at inf real, public, pointer :: te_inf Dissipation at inf real, public, pointer :: tv_inf SA viscosity at inf real, public, pointer :: tkl_inf kl at inf real, public, pointer :: tgm_inf Intermittency at inf real, public, dimension(:, :, :, :), pointer :: F_p Flux pointer for face in the I direction real, public, dimension(:, :, :, :), pointer :: G_p Flux pointer for face in the G direction real, public, dimension(:, :, :, :), pointer :: H_p Flux pointer for face in the K direction real, public, dimension(:, :, :, :), pointer :: residue Store residue at each cell-center real, public, dimension(:, :, :), pointer :: mass_residue Store continuity equation residual at each cell-center real, public, dimension(:, :, :), pointer :: x_mom_residue Store x-momentum equation residual at each cell-center real, public, dimension(:, :, :), pointer :: y_mom_residue Store y-momentum equation residual at each cell-center real, public, dimension(:, :, :), pointer :: z_mom_residue Store z-momentum equation residual at each cell-center real, public, dimension(:, :, :), pointer :: energy_residue Store energy equation residual at each cell-center real, public, dimension(:, :, :), pointer :: TKE_residue Store TKE equation residual at each cell-center real, public, dimension(:, :, :), pointer :: omega_residue Store Omega equation residual at each cell-center real, public, dimension(:, :, :), pointer :: KL_residue Store KL equation residual at each cell-center real, public, dimension(:, :, :), pointer :: dissipation_residue Store Disspaiton equation residual at each cell-center real, public, dimension(:, :, :), pointer :: tv_residue Store nut equation(SA model) residual at each cell-center real, public :: gm Gamma commonly 1.4 real, public :: R_gas Univarsal gas constant real, public :: mu_ref Molecular viscoity reference character(len=FILE_NAME_LENGTH), public :: mu_variation Type of viscosity variaiton: Sutherland or constant real, public :: T_ref Reference Temperature of flow for viscosity calculation real, public :: Sutherland_temp Sutherland temperature for viscosity calculation real, public :: Pr = 0.7 prandtl number real, public :: tPr = 0.9 turbulent Prandtl number logical, public :: supersonic_flag Switch for boundary condition. No longer in use integer, public :: ilimiter_switch Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for I direction faces. integer, public :: jlimiter_switch Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for J direction faces. integer, public :: klimiter_switch Turn on/off application of limiter for MUSCL (higer order face state reconstiion) for K direction faces. integer, public :: itlimiter_switch Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for I direction faces. integer, public :: jtlimiter_switch Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for J direction faces. integer, public :: ktlimiter_switch Turn on/off application of limiter for MUSCL (higer order face turbulent variable state reconstiion) for K direction faces. integer, public :: iPB_switch Turn on/off application of pressure based switching for higher order methods for I direction faces. integer, public :: jPB_switch Turn on/off application of pressure based switching for higher order methods for J direction faces. integer, public :: kPB_switch Turn on/off application of pressure based switching for higher order methods for K direction faces. character(len=8), public :: turbulence Store Turbulence model name character(len=8), public :: transition Store Transition model name real, public, dimension(:, :, :), allocatable, target :: mu Cell-center molecular viscosity real, public, dimension(:, :, :), allocatable, target :: mu_t Cell-center turbulent viscosity real, public, dimension(:, :, :), pointer :: sst_mu Pointer to  turbulent viscosity for SST turbulence model real, public, dimension(:, :, :), pointer :: kkl_mu Pointer to  turbulent viscosity for KKL turbulence model real, public, dimension(:, :, :), pointer :: sa_mu Pointer to  turbulent viscosity for SA turbulence model character(len=STATE_NAME_LENGTH), public, dimension(:), allocatable :: Res_list integer, public :: Res_count No of variable to save integer, public :: Res_itr = 3 Iteration to save real, public, dimension(:), allocatable :: Res_abs Absolute value real, public, dimension(:), allocatable :: Res_rel Relative value real, public, dimension(:), allocatable :: Res_save Saved iteration for relative real, public, dimension(:), allocatable :: Res_scale Scaling factor real, public, pointer :: resnorm Residual normalized real, public, pointer :: vis_resnorm {rho+V+P} equation residual normalized real, public, pointer :: turb_resnorm Turbulent residual normalized real, public, pointer :: cont_resnorm Mass residual normalized real, public, pointer :: x_mom_resnorm X momentum residual normalized real, public, pointer :: y_mom_resnorm Y momentum residual normalized real, public, pointer :: z_mom_resnorm Z momentum residual normalized real, public, pointer :: energy_resnorm Energy residual normalized real, public, pointer :: TKE_resnorm TKE residual normalized real, public, pointer :: omega_resnorm Omega residual normalized real, public, pointer :: resnorm_d1 Residual normalized/same at iter 1 real, public, pointer :: vis_resnorm_d1 {rho+V+P}  residual normalized/same at iter 1 real, public, pointer :: turb_resnorm_d1 Turbulent residual normalized/same at iter 1 real, public, pointer :: cont_resnorm_d1 Mass residual normalized/same at iter 1 real, public, pointer :: x_mom_resnorm_d1 X momentum residual normalized/same at iter 1 real, public, pointer :: y_mom_resnorm_d1 Y momentum residual normalized/same at iter 1 real, public, pointer :: z_mom_resnorm_d1 Z momentum residual normalized/same at iter 1 real, public, pointer :: energy_resnorm_d1 Energy residual normalized/same at iter 1 real, public, pointer :: TKE_resnorm_d1 TKE residual normalized/same at iter 1 real, public, pointer :: omega_resnorm_d1 Omega residual normalized/same at iter 1 real, public :: resnorm_0 Residual normalized at iter 1 real, public :: vis_resnorm_0 {rho+V+P}  residual normalized at iter 1 real, public :: turb_resnorm_0 Turbulent residual normalized at iter 1 real, public :: cont_resnorm_0 Mass residual normalized at iter 1 real, public :: x_mom_resnorm_0 X momentum residual normalized at iter 1 real, public :: y_mom_resnorm_0 Y momentum residual normalized at iter 1 real, public :: z_mom_resnorm_0 Z momentum residual normalized at iter 1 real, public :: energy_resnorm_0 Energy residual normalized at iter 1 real, public :: TKE_resnorm_0 TKE residual normalized at iter 1 real, public :: omega_resnorm_0 Omega residual normalized at iter 1 real, public :: resnorm_0s Residual normalized at iter 1 real, public :: vis_resnorm_0s {rho+V+P}  residual normalized at iter 1 real, public :: turb_resnorm_0s Turbulent residual normalized at iter 1 real, public :: cont_resnorm_0s Mass residual normalized at iter 1 real, public :: x_mom_resnorm_0s X momentum residual normalized at iter 1 real, public :: y_mom_resnorm_0s Y momentum residual normalized at iter 1 real, public :: z_mom_resnorm_0s Z momentum residual normalized at iter 1 real, public :: energy_resnorm_0s Energy residual normalized at iter 1 real, public :: TKE_resnorm_0s TKE residual normalized at iter 1 real, public :: omega_resnorm_0s Omega residual normalized at iter 1 integer, public :: imx Maximum number of grid points in the I direction integer, public :: jmx Maximum number of grid points in the K direction integer, public :: kmx Maximum number of grid points in the K direction integer, public :: imn integer, public :: jmn integer, public :: kmn real, public, dimension(:, :, :), allocatable :: grid_x X corrdinate of the grid point real, public, dimension(:, :, :), allocatable :: grid_y Y corrdinate of the grid point real, public, dimension(:, :, :), allocatable :: grid_z Z corrdinate of the grid point real, public, dimension(:, :, :,:), allocatable, target :: xn Store unit face normal vector for all I faces real, public, dimension(:, :, :,:), allocatable, target :: yn Store unit face normal vector for all J faces real, public, dimension(:, :, :,:), allocatable, target :: zn Store unit face normal vector for all K faces real, public, dimension(:, :, :), pointer :: xnx Pointer to x component of face unit normal of I faces real, public, dimension(:, :, :), pointer :: xny Pointer to y component of face unit normal of I faces real, public, dimension(:, :, :), pointer :: xnz Pointer to z component of face unit normal of I faces real, public, dimension(:, :, :), pointer :: ynx Pointer to x component of face unit normal of J faces real, public, dimension(:, :, :), pointer :: yny Pointer to y component of face unit normal of J faces real, public, dimension(:, :, :), pointer :: ynz Pointer to z component of face unit normal of J faces real, public, dimension(:, :, :), pointer :: znx Pointer to x component of face unit normal of K faces real, public, dimension(:, :, :), pointer :: zny Pointer to y component of face unit normal of K faces real, public, dimension(:, :, :), pointer :: znz Pointer to z component of face unit normal of K faces real, public, dimension(:, :, :), allocatable, target :: xA Store magnitude of face area vector of I direction faces real, public, dimension(:, :, :), allocatable, target :: yA Store magnitude of face area vector of J direction faces real, public, dimension(:, :, :), allocatable, target :: zA Store magnitude of face area vector of K direction faces real, public, dimension(:, :, :), allocatable, target :: volume Store cell volume real, public, dimension(:, :, :), allocatable, target :: left_ghost_centroid Store the cell center of the ghost cell on 1 face real, public, dimension(:, :, :), allocatable, target :: right_ghost_centroid Store the cell center of the ghost cell on 2 face real, public, dimension(:, :, :), allocatable, target :: front_ghost_centroid Store the cell center of the ghost cell on 3 face real, public, dimension(:, :, :), allocatable, target :: back_ghost_centroid Store the cell center of the ghost cell on 4 face real, public, dimension(:, :, :), allocatable, target :: top_ghost_centroid Store the cell center of the ghost cell on 5 face real, public, dimension(:, :, :), allocatable, target :: bottom_ghost_centroid Store the cell center of the ghost cell on 6 face integer, public :: n_grad = 4 Number of variable to store gradient for real, public, dimension(:, :, :, :), allocatable, target :: gradqp_x Store gradient of n_grad variables with respect to direction x real, public, dimension(:, :, :, :), allocatable, target :: gradqp_y Store gradient of n_grad variables with respect to direction y real, public, dimension(:, :, :, :), allocatable, target :: gradqp_z Store gradient of n_grad variables with respect to direction z real, public, dimension(:, :, :), pointer :: gradu_x Gradient of variable U with respect to direction x real, public, dimension(:, :, :), pointer :: gradu_y Gradient of variable U with respect to direction y real, public, dimension(:, :, :), pointer :: gradu_z Gradient of variable U with respect to direction z real, public, dimension(:, :, :), pointer :: gradv_x Gradient of variable V with respect to direction x real, public, dimension(:, :, :), pointer :: gradv_y Gradient of variable V with respect to direction y real, public, dimension(:, :, :), pointer :: gradv_z Gradient of variable V with respect to direction z real, public, dimension(:, :, :), pointer :: gradw_x Gradient of variable W with respect to direction x real, public, dimension(:, :, :), pointer :: gradw_y Gradient of variable W with respect to direction y real, public, dimension(:, :, :), pointer :: gradw_z Gradient of variable W with respect to direction z real, public, dimension(:, :, :), pointer :: gradT_x Gradient of variable Temperature with respect to direction x real, public, dimension(:, :, :), pointer :: gradT_y Gradient of variable Temperature with respect to direction y real, public, dimension(:, :, :), pointer :: gradT_z Gradient of variable Temperature with respect to direction z real, public, dimension(:, :, :), pointer :: gradtk_x Gradient of variable turbulent kinetic energy with respect to direction x real, public, dimension(:, :, :), pointer :: gradtk_y Gradient of variable turbulent kinetic energy with respect to direction y real, public, dimension(:, :, :), pointer :: gradtk_z Gradient of variable turbulent kinetic energy with respect to direction z real, public, dimension(:, :, :), pointer :: gradtw_x Gradient of variable dissipation rate with respect to direction x real, public, dimension(:, :, :), pointer :: gradtw_y Gradient of variable dissipation rate with respect to direction y real, public, dimension(:, :, :), pointer :: gradtw_z Gradient of variable dissipation rate with respect to direction z real, public, dimension(:, :, :), pointer :: gradtkl_x Gradient of variable kL with respect to direction x real, public, dimension(:, :, :), pointer :: gradtkl_y Gradient of variable kL with respect to direction y real, public, dimension(:, :, :), pointer :: gradtkl_z Gradient of variable kL with respect to direction z real, public, dimension(:, :, :), pointer :: gradte_x Gradient of variable turbulent energy dissiaption with respect to direction x real, public, dimension(:, :, :), pointer :: gradte_y Gradient of variable turbulent energy dissiaption with respect to direction y real, public, dimension(:, :, :), pointer :: gradte_z Gradient of variable turbulent energy dissiaption with respect to direction z real, public, dimension(:, :, :), pointer :: gradtv_x Gradient of variable turbulenct visocity(SA mode) with respect to direction x real, public, dimension(:, :, :), pointer :: gradtv_y Gradient of variable turbulenct visocity(SA mode) with respect to direction y real, public, dimension(:, :, :), pointer :: gradtv_z Gradient of variable turbulenct visocity(SA mode) with respect to direction z real, public, dimension(:, :, :), pointer :: gradtgm_x Gradient of variable intermittency with respect to direction x real, public, dimension(:, :, :), pointer :: gradtgm_y Gradient of variable intermittency with respect to direction y real, public, dimension(:, :, :), pointer :: gradtgm_z Gradient of variable intermittency with respect to direction z integer, public :: accur = 1 Switch for higher order boundary condition character(len=4), public, dimension(6) :: face_names Store name of all six boundary faces integer, public, dimension(6) :: id Store the boundary condition ID of all six faces real, public :: c1 First coefficient user for higher order boundary condition real, public :: c2 Second coefficient user for higher order boundary condition real, public :: c3 Third coefficient user for higher order boundary condition real, public, dimension(6) :: fixed_density = 0. Density value to fix at particular boundary real, public, dimension(6) :: fixed_pressure = 0. Pressure value to fix at particular boundary real, public, dimension(6) :: fixed_x_speed = 0. X component of velocity to fix at particular boundary condition real, public, dimension(6) :: fixed_y_speed = 0. Y component of velocity to fix at particular boundary condition real, public, dimension(6) :: fixed_z_speed = 0. Z component of velocity to fix at particular boundary condition real, public, dimension(6) :: fixed_tk = 0. Turbulent kinetic energy value to fix at particular boundary condition real, public, dimension(6) :: fixed_tw = 0. Turbulent kinetic energy dissiaption rate value to fix at particular boundary condition(k-omega and SST model) real, public, dimension(6) :: fixed_te = 0. Turbulent kinetic energy dissiaption value to fix at particular boundary condition (K-eplision model) real, public, dimension(6) :: fixed_tv = 0. Turbulent viscosity varialble value to fix at particular boundary condition (for SA turbulence model) real, public, dimension(6) :: fixed_tkl = 0. (Turbulent kinetic energy x length) varialble value to fix at particular boundary condition (for k-kL turbulence model) real, public, dimension(6) :: fixed_tgm = 0. Fixed intermittency value to apply at particular boundary condition (for SST2003-gamma transition model) real, public, dimension(6) :: fixed_wall_temperature = 0. Fixed wall temperature value to apply at isothermal wall boundary condition. real, public, dimension(6) :: fixed_Tpressure = 0. Fixed Total Pressure value to apply at particular boundary condition real, public, dimension(6) :: fixed_Ttemperature = 0. Fixed Total Temperature value to apply at particular boundary condition integer, public :: N_blocks Total number of blocks integer, public :: I_blocks Total number of blocks  in I direction integer, public :: J_blocks Total number of blocks  in J direction integer, public :: K_blocks Total number of blocks  in K direction integer, public, dimension(:), allocatable :: imin integer, public, dimension(:), allocatable :: imax integer, public, dimension(:), allocatable :: jmin integer, public, dimension(:), allocatable :: jmax integer, public, dimension(:), allocatable :: kmin integer, public, dimension(:), allocatable :: kmax integer, public, dimension(6) :: ilo Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: ihi Store the lower and upper bound of the indecies of I loop for the interface mapping integer, public, dimension(6) :: jlo Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: jhi Store the lower and upper bound of the indecies of J loop for the interface mapping integer, public, dimension(6) :: klo Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: khi Store the lower and upper bound of the indecies of K loop for the interface mapping integer, public, dimension(6) :: dir_switch = 0 Switch for each boundary face. Activated only if ( for eg I-direction in the mapping is mapped with J-direction) integer, public, dimension(6) :: otherface Store the face number with which the current interface is connected. integer, public, dimension(:), allocatable :: make_F_flux_zero Store zero to boundary face, which has wall ID, to make F flux zero integer, public, dimension(:), allocatable :: make_G_flux_zero Store zero to boundary face, which has wall ID, to make G flux zero integer, public, dimension(:), allocatable :: make_H_flux_zero Store zero to boundary face, which has wall ID, to make H flux zero integer, public, dimension(6) :: PbcId = -1 Block ID for Periodic boundary condition","tags":"","loc":"module/global_vars.html","title":"global_vars – FEST-3D"},{"text":"Common constant/parameters variables used by most other modules Used by module~~global~~UsedByGraph module~global global module~mapping mapping module~mapping->module~global module~grid grid module~grid->module~global module~write_output_vtk write_output_vtk module~write_output_vtk->module~global module~global_vars global_vars module~global_vars->module~global module~wall wall module~wall->module~global module~write_output write_output module~write_output->module~global module~read_output_vtk read_output_vtk module~read_output_vtk->module~global module~read read module~read->module~global module~str_case str_case module~str_case->module~global module~wall_dist wall_dist module~wall_dist->module~global module~resnorm resnorm module~resnorm->module~global module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~global module~create_and_erase create_and_erase module~create_and_erase->module~global module~fclose fclose module~fclose->module~global module~state state module~state->module~global module~layout layout module~layout->module~global module~write_output_tec write_output_tec module~write_output_tec->module~global module~solver solver module~solver->module~global module~fopen fopen module~fopen->module~global module~read_bc read_bc module~read_bc->module~global module~dump_solution dump_solution module~dump_solution->module~global module~read_output read_output module~read_output->module~global module~viscous viscous module~viscous->module~global module~read_output_tec read_output_tec module~read_output_tec->module~global Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables FILE_NAME_LENGTH SCHEME_NAME_LENGTH INTERPOLANT_NAME_LENGTH DESCRIPTION_STRING_LENGTH STRING_BUFFER_LENGTH ERROR_MESSAGE_LENGTH LONG_BUFFER_LENGTH FORMAT_LENGTH STATE_NAME_LENGTH FLOW_TYPE_LENGTH TOLERANCE_LENGTH CONFIG_FILE_UNIT GRID_FILE_UNIT BOUNDARY_CONDITIONS_FILE_UNIT STATE_FILE_UNIT IN_FILE_UNIT OUT_FILE_UNIT RESNORM_FILE_UNIT TEMP_NODE_FILE_UNIT LAYOUT_FILE_UNIT NODESURF_FILE_UNIT WALL_DIST_FILE_UNIT RES_CONTROL_FILE_UNIT INFO_FILE_UNIT CONTROL_FILE_UNIT SCHEME_FILE_UNIT FLOW_FILE_UNIT RESTART_FILE_UNIT OUTIN_FILE_UNIT MAP_FILE_UNIT PERIODIC_FILE_UNIT STOP_FILE_UNIT control_file scheme_file flow_file outin_file layout_file nodefile_temp surface_node_points wall_dist_file res_control_file resnorm_file stop_file mapfile periodicfile Variables Type Visibility Attributes Name Initial integer, public, parameter :: FILE_NAME_LENGTH = 64 Length of string used for defining any filename integer, public, parameter :: SCHEME_NAME_LENGTH = 16 Length of string used for storing Scheme integer, public, parameter :: INTERPOLANT_NAME_LENGTH = 10 Length of string used for storing  higher order method integer, public, parameter :: DESCRIPTION_STRING_LENGTH = 64 Length of string used for description in message call integer, public, parameter :: STRING_BUFFER_LENGTH = 128 User to define a string of medium length integer, public, parameter :: ERROR_MESSAGE_LENGTH = 256 Length of string used for passing error message during call integer, public, parameter :: LONG_BUFFER_LENGTH = 256 Used to define a string of large size integer, public, parameter :: FORMAT_LENGTH = 16 Length of string used for file format: tecplot or vtk integer, public, parameter :: STATE_NAME_LENGTH = 64 Length of string used in array user for sotring and reading Output/input variable list integer, public, parameter :: FLOW_TYPE_LENGTH = 64 Length of string used for storing type of flow: inviscid, laminar, etc. integer, public, parameter :: TOLERANCE_LENGTH = 32 Length of string used for resnorm types: abs or relative integer, public, parameter :: CONFIG_FILE_UNIT = 1 Handler unit for config.md file integer, public, parameter :: GRID_FILE_UNIT = 2 Handler for input Gridfile; eg: grid_00.txt integer, public, parameter :: BOUNDARY_CONDITIONS_FILE_UNIT = 3 Handler for Boundary condition file; eg: bc_00.md integer, public, parameter :: STATE_FILE_UNIT = 10 Handler no longer in use integer, public, parameter :: IN_FILE_UNIT = 19 Handler for restart file for block: eg: time_drectories/0001/process_00.dat integer, public, parameter :: OUT_FILE_UNIT = 20 Handler for output file for each block integer, public, parameter :: RESNORM_FILE_UNIT = 21 Handler for Residual output file. filename: time_directories/aux/resnorm integer, public, parameter :: TEMP_NODE_FILE_UNIT = 30 Handler no longer in use integer, public, parameter :: LAYOUT_FILE_UNIT = 31 Handler for input multi-block layout and boundary condition file. integer, public, parameter :: NODESURF_FILE_UNIT = 32 Handler for storing node point on the wall integer, public, parameter :: WALL_DIST_FILE_UNIT = 33 Handler no longer in use integer, public, parameter :: RES_CONTROL_FILE_UNIT = 34 Handler for residual control file. filename: system/res_control.md integer, public, parameter :: INFO_FILE_UNIT = 35 Handler NO longer in user ; info is handled using print*, command integer, public, parameter :: CONTROL_FILE_UNIT = 36 Handler for input system/control.md file integer, public, parameter :: SCHEME_FILE_UNIT = 37 Handler for input system/fvscheme.md file integer, public, parameter :: FLOW_FILE_UNIT = 38 Handler for input system/flow.md  file integer, public, parameter :: RESTART_FILE_UNIT = 39 Handler for Restart file in Restart folder. eg: time_directories/0001/Restart/process_00 integer, public, parameter :: OUTIN_FILE_UNIT = 40 Handler for file which controls what variables will be read or stored. system/output_control.md integer, public, parameter :: MAP_FILE_UNIT = 41 Handler for input multi-block mapping file with index and direction. integer, public, parameter :: PERIODIC_FILE_UNIT = 42 Handler for input periodic boundary condition file integer, public, parameter :: STOP_FILE_UNIT = 41 Handler for Stop file character(len=*), public, parameter :: control_file = \"system/control.md\" FILENAME string: Control file character(len=*), public, parameter :: scheme_file = \"system/fvscheme.md\" FILENAME string: Scheme file character(len=*), public, parameter :: flow_file = \"system/flow.md\" FILENAME string: FLow condition file character(len=*), public, parameter :: outin_file = \"system/output_control.md\" FILENAME string: Ouput/Input variable control file character(len=*), public, parameter :: layout_file = 'system/mesh/layout/layout.md' FILENAME string: Multiple layout/boundary condition file character(len=*), public, parameter :: nodefile_temp = \"scratch.dat\" FILENAME string: Temperory file for nodesurface points character(len=*), public, parameter :: surface_node_points = 'time_directories/aux/surfnode.dat' FILENAME string: Wall surface node points character(len=*), public, parameter :: wall_dist_file = 'distance.vtk' FILENAME string: Wall distance for debug-- not in use anymore character(len=*), public, parameter :: res_control_file = 'system/res_control.md' FILENAME string: Residual write control file character(len=*), public, parameter :: resnorm_file = 'time_directories/aux/resnorm' FILENAME string: Residual output file character(len=*), public, parameter :: stop_file = 'system/stopfile' FILENAME string: Halt/stop file character(len=*), public, parameter :: mapfile = 'system/mesh/layout/mapping.txt' FILENAME string: Detailed multiblock mapping file with indicies and direction information at interface character(len=*), public, parameter :: periodicfile = 'system/mesh/layout/periodic.txt' FILENAME string: Multiblock periodic boundary condition detials","tags":"","loc":"module/global.html","title":"global – FEST-3D"},{"text":"Declare all the constants used by SA turbulence model Used by module~~global_sa~~UsedByGraph module~global_sa global_sa module~source source module~source->module~global_sa module~plusgs plusgs module~plusgs->module~global_sa module~lusgs lusgs module~lusgs->module~global_sa module~viscosity viscosity module~viscosity->module~global_sa module~update update module~update->module~global_sa module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~viscous viscous module~update->module~viscous module~viscous->module~global_sa module~solver solver module~solver->module~source module~solver->module~viscosity module~solver->module~update module~solver->module~viscous module~create_and_erase create_and_erase module~create_and_erase->module~source program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables cb1 cb2 cw2 cw3 cv1 ct3 ct4 sigma_sa kappa_sa cw1 cv1_3 cw3_6 Variables Type Visibility Attributes Name Initial real, public, parameter :: cb1 = 0.1355 real, public, parameter :: cb2 = 0.6220 real, public, parameter :: cw2 = 0.3 real, public, parameter :: cw3 = 2.0 real, public, parameter :: cv1 = 7.1 real, public, parameter :: ct3 = 1.2 real, public, parameter :: ct4 = 0.5 real, public, parameter :: sigma_sa = 2./3. real, public, parameter :: kappa_sa = 0.41 real, public, parameter :: cw1 = (cb1/(kappa_sa**2))+((1+cb2)/sigma_sa) real, public, parameter :: cv1_3 = cv1**3 real, public, parameter :: cw3_6 = cw3**6","tags":"","loc":"module/global_sa.html","title":"global_sa – FEST-3D"},{"text":"Declare all the constants used by SST turbulence model Used by module~~global_sst~~UsedByGraph module~global_sst global_sst module~source source module~source->module~global_sst module~dump_solution dump_solution module~source->module~dump_solution module~plusgs plusgs module~plusgs->module~global_sst module~write_output_vtk write_output_vtk module~write_output_vtk->module~global_sst module~write_output_tec write_output_tec module~write_output_tec->module~global_sst module~read_output_tec read_output_tec module~read_output_tec->module~global_sst module~write_output_tec_node write_output_tec_node module~write_output_tec_node->module~global_sst module~viscosity viscosity module~viscosity->module~global_sst module~bc_primitive bc_primitive module~bc_primitive->module~global_sst module~update update module~update->module~global_sst module~update->module~source module~update->module~plusgs module~update->module~viscosity module~update->module~bc_primitive module~viscous viscous module~update->module~viscous module~lusgs lusgs module~update->module~lusgs module~viscous->module~global_sst module~lusgs->module~global_sst module~read_output read_output module~read_output->module~read_output_tec module~solver solver module~solver->module~source module~solver->module~viscosity module~solver->module~bc_primitive module~solver->module~update module~solver->module~viscous module~state state module~solver->module~state module~solver->module~dump_solution module~create_and_erase create_and_erase module~create_and_erase->module~source module~create_and_erase->module~state module~write_output write_output module~write_output->module~write_output_vtk module~write_output->module~write_output_tec module~write_output->module~write_output_tec_node module~state->module~read_output module~start_finish start_finish module~start_finish->module~solver module~dump_solution->module~write_output program~main main program~main->module~solver program~main->module~start_finish var panmoduleglobal_sstUsedByGraph = svgPanZoom('#moduleglobal_sstUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables sigma_k1 sigma_k2 sigma_w1 sigma_w2 beta1 beta2 bstar kappa a1 gama1 gama2 beta sigma_w sigma_k gama sst_F1 Variables Type Visibility Attributes Name Initial real, public, parameter :: sigma_k1 = 0.85 real, public, parameter :: sigma_k2 = 1.0 real, public, parameter :: sigma_w1 = 0.5 real, public, parameter :: sigma_w2 = 0.856 real, public, parameter :: beta1 = 0.075 real, public, parameter :: beta2 = 0.0828 real, public, parameter :: bstar = 0.09 real, public, parameter :: kappa = 0.41 real, public, parameter :: a1 = 0.31 real, public :: gama1 = (beta1/bstar)-((sigma_w1*(kappa**2))/sqrt(bstar)) real, public :: gama2 = (beta2/bstar)-((sigma_w2*(kappa**2))/sqrt(bstar)) real, public :: beta real, public :: sigma_w real, public :: sigma_k real, public :: gama real, public, dimension(:,:,:), allocatable, target :: sst_F1","tags":"","loc":"module/global_sst.html","title":"global_sst – FEST-3D"},{"text":"Declare all the constants used by k-kL turbulence model Used by module~~global_kkl~~UsedByGraph module~global_kkl global_kkl module~source source module~source->module~global_kkl module~plusgs plusgs module~plusgs->module~global_kkl module~lusgs lusgs module~lusgs->module~global_kkl module~viscosity viscosity module~viscosity->module~global_kkl module~update update module~update->module~global_kkl module~update->module~source module~update->module~plusgs module~update->module~lusgs module~update->module~viscosity module~viscous viscous module~update->module~viscous module~viscous->module~global_kkl module~solver solver module~solver->module~source module~solver->module~viscosity module~solver->module~update module~solver->module~viscous module~create_and_erase create_and_erase module~create_and_erase->module~source program~main main program~main->module~solver module~start_finish start_finish program~main->module~start_finish module~start_finish->module~solver Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Variables zeta1 zeta2 zeta3 sigma_k sigma_phi cmu kappa c11 c12 cd1 cphi1 cphi2 fphi eta Variables Type Visibility Attributes Name Initial real, public, parameter :: zeta1 = 1.2 real, public, parameter :: zeta2 = 0.97 real, public, parameter :: zeta3 = 0.13 real, public, parameter :: sigma_k = 1.0 real, public, parameter :: sigma_phi = 1.0 real, public, parameter :: cmu = 0.09 real, public, parameter :: kappa = 0.41 real, public, parameter :: c11 = 10.0 real, public, parameter :: c12 = 1.3 real, public, parameter :: cd1 = 4.7 real, public :: cphi1 real, public :: cphi2 real, public :: fphi real, public :: eta","tags":"","loc":"module/global_kkl.html","title":"global_kkl – FEST-3D"},{"text":"Uses global_vars solver start_finish convergence program~~main~~UsesGraph program~main main module~global_vars global_vars program~main->module~global_vars module~start_finish start_finish program~main->module~start_finish module~solver solver program~main->module~solver module~convergence convergence program~main->module~convergence module~global global module~global_vars->module~global module~start_finish->module~solver module~fclose fclose module~start_finish->module~fclose module~solver->module~global_vars module~mapping mapping module~solver->module~mapping module~read read module~solver->module~read module~viscosity viscosity module~solver->module~viscosity module~wall wall module~solver->module~wall module~bc_primitive bc_primitive module~solver->module~bc_primitive module~cc CC module~solver->module~cc module~bc bc module~solver->module~bc Scheme Scheme module~solver->Scheme module~geometry geometry module~solver->module~geometry module~wall_dist wall_dist module~solver->module~wall_dist module~source source module~solver->module~source module~utils utils module~solver->module~utils module~resnorm resnorm module~solver->module~resnorm module~update update module~solver->module~update module~interface1 interface1 module~solver->module~interface1 module~time time module~solver->module~time module~viscous viscous module~solver->module~viscous module~state state module~solver->module~state module~layout layout module~solver->module~layout module~summon_grad_evaluation summon_grad_evaluation module~solver->module~summon_grad_evaluation module~string string module~solver->module~string module~gradients gradients module~solver->module~gradients module~boundary_state_reconstruction boundary_state_reconstruction module~solver->module~boundary_state_reconstruction module~dump_solution dump_solution module~solver->module~dump_solution module~solver->module~global module~grid grid module~solver->module~grid module~convergence->module~global_vars Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Main program Calls program~~main~~CallsGraph program~main main proc~iterate_one_more_time_step iterate_one_more_time_step program~main->proc~iterate_one_more_time_step proc~finish_run finish_run program~main->proc~finish_run proc~converged converged program~main->proc~converged proc~start_run start_run program~main->proc~start_run proc~dmsg dmsg proc~iterate_one_more_time_step->proc~dmsg mpi_bcast mpi_bcast proc~iterate_one_more_time_step->mpi_bcast proc~checkpoint checkpoint proc~iterate_one_more_time_step->proc~checkpoint proc~find_resnorm find_resnorm proc~iterate_one_more_time_step->proc~find_resnorm proc~get_next_solution get_next_solution proc~iterate_one_more_time_step->proc~get_next_solution proc~close_all_files close_all_files proc~finish_run->proc~close_all_files proc~destroy_solver destroy_solver proc~finish_run->proc~destroy_solver mpi_finalize mpi_finalize proc~finish_run->mpi_finalize mpi_init mpi_init proc~start_run->mpi_init proc~setup_solver setup_solver proc~start_run->proc~setup_solver Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are given different colours to make them easier to distinguish in large graphs. Contents Source Code main Source Code program main !< Main program !------------------------------------------------- ! 170801 - Jatinder Pal Singh Sandhu ! change : - explicit call with use module instead of using whole module !          - include error and mpi file ! 170803 - jatinder Pal Singh Sandhu ! change : - new name to step -> iterate_one_more_time_step !------------------------------------------------ use global_vars , only : max_iters use global_vars , only : current_iter use global_vars , only : Halt use solver , only : iterate_one_more_time_step use convergence , only : converged use start_finish , only : start_run use start_finish , only : finish_run #include \"error.inc\" #include \"mpi.inc\" !--------Start---------! call start_run () do while (( current_iter <= max_iters ) . and . (. not . converged ()) . and . (. not . Halt )) call iterate_one_more_time_step () end do call finish_run () !--------Stop---------! end program main","tags":"","loc":"program/main.html","title":"main – FEST-3D"},{"text":"Introduction FEST-3D is a finite-volume solver build to compute incompressible/compressible, and inviscid/laminar/transitonal/turbulent fluid flow problems on structured grids. Highlights: The solver provides multiple choices to the user in terms of inviscid flux calculation\nscheme, higher-order face-state reconstruction scheme, time-integration scheme, and turbulence and transition models. Schemes Inviscid flux calculation AUSM Liou, M.-S. and Steffen, C., “A New Flux Splitting Scheme,” J. Comput. Phys., vol. 107, no. 1, pp. 23-39, 1993. LDFSS Edwards, J.R., A low-diffusion flux-splitting scheme for Navier-Stokes calculations. Computers & Fluids, vol. 26, no. 6, pp.635-659, 1997. AUSM+ Liou, M. S., “A sequel to AUSM: AUSM+,” Journal of Computational Physics, vol. 129, no. 2, pp. 364–382, 1996. AUSM+-UP Liou, M. S., “A sequel to AUSM, Part II: AUSM+-up for all speeds,” Journal of Computational Physics, vol. 214, no. 1, pp. 137–170, 2006. SLAU Shima, E., and Kitamura, K., “Parameter-Free Simple Low-Dissipation AUSM-Family Scheme for All Speeds,” AIAA Journal, vol. 49, no. 8, pp. 1693–1709, 2011. Higher-order spatial reconstruction None 1rst order accurate in space MUSCL 3rd order accurate in space van Leer, B., Towards the Ultimate Conservative Difference Scheme, V. A Second Order Sequel to Godunov's Method, J. Com. Phys., vol. 32, no. 1, pp. 101–136, 1979 PPM 4th order accurate in space Colella, P., and Woodward, P. R., “The Piecewise Parabolic Method (PPM) for gas-dynamical simulations,” Journal of Computational Physics, vol. 54, no. 1, pp. 174–201, 1984. WENO 5th order accurate in space Shu, C.-W., “High-order Finite Difference and Finite Volume WENO Schemes and Discontinuous Galerkin Methods for CFD,” International Journal of Computational Fluid Dynamics, vol. 17, no. 2, pp. 107–118, 2003. WENO-NM 5th order accurate in space (specifically for non-uniform grid) Huang, W.-F., Ren, Y.-X., and Jiang, X., “A simple algorithm to improve the performance of the WENO scheme on non-uniform grids,” Acta Mechanica Sinica, vol. 34, no. 1, pp. 37–47, 2018. Temporal integration Explicit Euler Explicit First order accurate in time RK2 2nd order accurate in time, Runge-Kutta method RK4 4th order accurate in time, Runge-Kutta method TVDRK2 Total variation diminishing RK2 method for Weno scheme TVDRK3 Total variation diminishing RK3 method for Weno scheme Hoffmann, Klaus A., and Steve T. Chiang. \"Computational fluid dynamics volume I.\" Engineering Education System, 2000. Implicit implicit Matrix free LU-SGS method, first order accurate in time. Chen, R. F., and Wang, Z. J., “Fast , Block Lower-Upper Symmetric Gauss – Seidel Scheme Introduction,” AIAA Journal, vol. 38, no. 12, pp. 2238–2245, 2000. PLUSGS Preconditioned Matrix free LU-SGS method for very low speed flow; first order accuate in time Kitamura, K., Shima, E., Fujimoto, K., and Wang, Z. J., “Performance of Low-Dissipation Euler Fluxes and Preconditioned LU-SGS at Low Speeds,” Communications in Computational Physics, vol. 10, no. 1, pp. 90–119, 2011. Turbulence model SA Allmaras, S. R., Johnson, F. T., and Spalart, P. R., “Modifications and Clarifications for the Implementation of the Spalart-Allmaras Turbulence Model,” Seventh International Conference on Computational Fluid Dynamics (ICCFD7), 2012. Spalart, P. R., and Allmaras, S., “A one-equation turbulence model for aerodynamic flows,” 30th Aerospace Sciences Meeting and Exhibit, 1992. SST Menter, F. R., \"Two-Equation Eddy-Viscosity Turbulence Models for Engineering Applications,\" AIAA Journal, vol. 32, no. 8, pp. 1598-1605, 1994. SST2003 Menter, F. R., Kuntz, M., and Langtry, R., \"Ten Years of Industrial Experience with the SST Turbulence Model,\" Turbulence, Heat and Mass Transfer 4, ed: K. Hanjalic, Y. Nagano, and M. Tummers, Begell House, Inc., pp. 625 - 632, 2003. k-kL Menter, F. R., and Egorov, Y., “The scale-adaptive simulation method for unsteady turbulent flow predictions. part 1: Theory and model description,” Flow, Turbulence and Combustion, vol. 85, no. 1, pp. 113–138, 2010. Transition model Gamma LCTM2015 Menter, F. R., Smirnov, P. E., Liu, T., and Avancha, R., “A One-Equation Local Correlation-Based Transition Model,” Flow, Turbulence and Combustion, vol. 95, no. 4, pp. 583–619, 2015. SA-BC Cakmakcioglu, S. C., Bas, O., and Kaynak, U., “A correlation-based algebraic transition model,” Proceedings of the Institution of Mechanical Engineers, Part C: Journal of Mechanical Engineering Science, vol. 232, no. 21, pp. 3915–3929, 2018. FEST-3D Team Over the last five years, many individuals have contributed to the development of FEST-3D. The team includes: Jatinder Pal Singh Sandhu Ph.D. Student (Current) Added turbulence and transition models:SST, SA, k-kL; implicit time-integration method: LU-SGS and PLU-SGS; approximate Reimann solver: SLAU, AUSM+-UP, AUSM+; and 5th order weno scheme R. D. Teja B.Tech Student (2016) Parallelized FEST-3D using MPI routines Raskesh Ramakrishnan Dual Degree Student (2016) Modified FEST-3D into a three-dimensional laminar flow solver_ Anant Girdhar B.Tech Student (2015) Developed the FEST-3D code as a modular two-dimensional inviscid flow solver for strutured grids All the above individuals were guided by Dr. Santanu Ghosh .","tags":"","loc":"page//index.html","title":"Documentation – FEST-3D"},{"text":"How to download FEST-3D The FEST-3D solver is available at GitHub to download.  The tutorials are provided in a separate GitHub repository and the same is used as a submodule in the main source code with folder name [RootFolder]/run . The grid files for the tutorials are provided in the respective test case folders. Note In case you do not have Git installed on you local machine, you can do so by using following command on ubuntu: sudo apt-get install git A similar command can be used for other Linux package platforms. Use the following command to clone the git repository without tutorials git clone https://github.com/FEST3D/FEST-3D.git Note The tutorials are submodule to main FEST-3D source code on  GitHub. Use the following command to get git repository with tutorials git clone --recursive https://github.com/FEST3D/FEST-3D.git If you already have source code without tutorials, then use following to downlaod tutorials git submodule update --init If you are downloading the FEST-3D package as a zip file from GitHub or Home page on Linux system, use the command \"unzip\", which can be  installed (if not available)  using the command: sudo apt-get install unzip and then use the following command to unzip the folder unzip FEST-3D-master.zip -d FEST3D The run folder is not part of the main zip folder.","tags":"","loc":"page/./00_download.html","title":"Download – FEST-3D"},{"text":"Installing FEST-3D The installation instructions are listed here for Linux platforms. Specifically, examples are given for UBUNTU distribution. Dependencies FEST-3D has the following dependencies: Fortran compiler MPI library CMAKE and MAKE Compiler To build the FEST-3D code written in FORTRAN 90 code, a FORTRAN compiler is required. Either open-source gfortran or commercial ifort FORTRAN compilers can be used.\nTo install gfortran on Ubuntu, use the following command: $sudo apt-get install gfortran Distributive MPI Library To have a faster computation, the FEST-3D code uses the MPICH library to distribute the computation load across different processors within one machine or across multiple machines. You can install MPICH on Ubuntu  using: $sudo apt-get install mpich CMAKE and Make CMake is required to generate a Makefile, which in turn generates the executable. The following command is useful to install cmake: $sudo apt-get install build-essential $sudo apt-get install cmake So, in summary, all the dependencies can be installed using  the  following commands: $sudo apt-get update\n$sudo apt-get install build-essential\n$sudo apt-get install cmake\n$sudo apt-get install gfortran\n$sudo apt-get install mpich Building To build the FEST-3D code, we first generate a new \"build\" directory/folder in the root directory of the FEST-3D code. Inside the build directory, we execute Cmake with specific FORTRAN compiler. $FC=mpif90 cmake .. $make -j 4 Here -j is a parallel building option that speeds up the building process. You can replace the number after \"-j\" with the number of processors you want to use for  building the code. Note if you have installed OPENMPI also along with MPICH, then  mpif90 may point to mpif90.openmpi instead of mpif90.mpich . In that case use the following command $FC=mpif90.mpich cmake .. So, in summary, the following list of commands are required to build the executable $mkdir build && cd build\n$FC=mpif90.mpich cmake ..\n$make -j 4 These commands will create a binary file named FEST3D in the bin folder; located in the root directory of the FEST-3D code.","tags":"","loc":"page/./01_install.html","title":"Installation – FEST-3D"},{"text":"How to run the code to solve a real problem To set up the run folder, for solving a problem, few \ninput files are needed by the FEST-3D solver. To facilitate the process of setting up\nall these input files, a Python code is provided at Github . Dependencies C++11 compiler Python 2.7 bash Inputs Note A python scipt is provided to ease the user interface with FEST-3D solver.\nIn order to run the script provide all the input variables described below\nand run the script  using: python automation.py Above command will create a new directory. This new directory host all the input files.\nBefore runing the solver, change directory to newly created directory with name provide in variable $RunDir eg: $python automaton.py $cd <New directory> If required, tweak the input files, and after that, run the solver using $nohup bash run.sh & To check the current run status $tail -f time_directories/aux/out To plot the residual using gnuplot script gnplt $gnuplot gnplt First, we need to create a directory to perform simulation and save all the input/output data. RunDir = 'Test' Give any name to the Run directory One of the important input is the grid/mesh files. FEST-3D code requires a separate file for each process.\nIf the domain is decomposed into 4 blocks, then 4 separate files are required. Although, you can give\nany unique name to the grid files, for simplicity the python code expect grid file name in grid_nn.txt , where\nthe nn is the block-number-1 . So, for 4 blocks, we will use the following: grid_00.txt, grid_01.txt, grid_02.txt, and\ngrid_03.txt. You should keep all the grid files in a separate folder and mention name of that folder \nat GridDir='Mesh' , here Mesh is the folder in which all the grid files are kept. For more details about the grid/mesh read the subsection Mesh NumberOfBlocks = 1 Total number of blocks In order to use the executable build in the binary folder of the FEST-3D code, a soft link is created\nbetween the FEST3D executable bin folder and FEST3D in bin folder of Run folder. AbsBinaryPath=\"/home/jatinder/solver/FEST3D/bin/FEST3D\" provide the absolute path to the binary. Now, you are required to fix different input parameter of the solver based on the problem you are simulating.\nMeaning of the most input is self-explanatory from the name. Variable Expected Input Description Control['CFL'] Real Number greater than zero Courant–Friedrichs–Lewy number. Low value (less than 1) for explicit scheme and high value for implicit scheme Control['LoadLevel'] Integer Restart folder number in the time_directories/ directory Control['MaxIterations'] Integer greater than SaveIterations Maximum number of iteration Control['SaveIterations'] Integer lesser than MaxIterations Save solution state after every these many iteration Control['OutputFileFormat'] 'vtk' or 'tecplot' Format of the solution output file Control['OutputDataFormat'] 'ASCII' Type of the data in the output folder. Only ASCII for now. BINARY will be added in later release Control['InputFileFormat'] 'vtk' or 'tecplot' Format of the solution file from which solution will be restarted Control['InputDataFormat'] 'ASCII' Type of the data in the restart file . Similar to output data type, only ASCII is supported for now. Control['Precision'] Integer, lesser than 14 and greater than 1 Data precision for residual output, not used for solution output. Control['Purge'] Integer Number of recent solution folder to keep and delete others. 0 input will keep all the folders Control['ResidualWriteInterval'] Integer greater than zero Number of iteration after which to save the residual output in the file Control['Tolerance'] Real number and [\"Mass_abs\", \"Viscous_abs\", \"Mass_abs\", \"Resnorm_abs\", \"Viscous_abs\", \"Turbulent_abs\", \"Continuity_abs\", \"X-mom_abs\", \"Y-mom_abs\", \"Z-mom_abs\", \"Energy_abs\", \"Mass_rel\", \"Resnorm_rel\", \"Viscous_rel\", \"Turublent_rel\", \"Continuity_abs\", \"X-mom_rel\", \"Y-mom_rel\", \"Z-mom_rel\", \"Energy_rel\", \"TKE_abs\", \"Tv_abs\", \"Dissipation_abs\", \"Omega_abs\", \"Kl_abs\", \"TKE_rel\", \"Tv_rel\", \"Dissipation_rel\", \"Omega_rel\", \"Kl_rel\"] Tolerance value and variable. The solver will stop once this value is achived. List of tolerace variables is given in expected input column. You can use only one input at a time. Control['DebugLevel'] 1, 2, 3, 4, or 5 Print the information about the function/subroutines called in the solver. This helps in debugging the code. 5-Only important information is logged, 1-All the information is logged which helps in debuging. Will be remove in later release Scheme['InviscidFlux'] 'ausm', 'slau', 'ausmUP', or 'ldfss0' Scheme to calcualte inviscid fluxes through cell faces Scheme['FaceState'] 'none', 'muscl', 'ppm', or 'weno' Scheme for higher-order face-state reconstuction Scheme['Limiter'] '1 1 1  0 0 0' or '0 0 0 0 0 0' Switch for limiters and pressure based switching when using higher order face-state reconstuction. Three value for i,j, and k direction 1->on  and 0-> off. Koren limiter is being used with MUSCL scheme. Scheme['TurbulenceLimiter'] '1 1 1' or '0 0 0' Switch for limiters when used for higher-order face-state reconstuctio of turbulent variables.  1->on  and 0-> off Scheme['TurbulenceModel'] 'none', 'sa', 'sst', or 'sst2003' Turbulence model Scheme['TransitionModel'] 'none', 'bc', 'lctm2015' Transition model Scheme['TimeStep'] 'l' or 'g [optional time step]' Time-step for time-integration. 'l' for local and 'g' for global. In case for global method you can provide exact value to time-step here. Scheme['TimeIntegration'] 'none', 'RK2', 'RK4', 'TVDRK2', 'TVDRK3', 'implicit', or 'plusgs' Method for time-integration Scheme['HigherOrderBC'] 0 or 1 Higher order boundary conditions.  1->on  and 0-> off. Flow[\"NumberOfVariables\"] 5 Total number of variables to solver. Reduntant and will be depricated in later release. Flow[\"DensityInf\"] Real Number Free-stream density Flow[\"UInf\"] Real Number Free-stream x-component of velocity Flow[\"VInf\"] Real Number Free-stream y-component of velocity Flow[\"WInf\"] Real Number Free-stream z-component of velocity Flow[\"PressureInf\"] Real Number Free-stream pressure Flow[\"TurbulenceIntensity\"] Real Number Free-stream trubulent intensity in (percentage) Flow[\"ViscosityRatio\"] Real Number Free-stream ratio of turbulence viscosity to molecular viscosity Flow[\"Intermitency\"] Real Number Free-stream turbulent intermittency Flow[\"ReferenceViscosity\"] Real Number Reference viscosity Flow[\"ViscosityLaw\"] 'sutherland_law' or 'constant' Law used for viscosity variation Flow[\"ReferenceTemp\"] Real Number Reference temperature for viscosity variation Flow[\"SutherlandTemp\"] Real Number Sutherland temperature Flow[\"PrandtlNumbers\"] Two real numbers Prandtl number and turbulent prandtl number Flow[\"SpecificHeatRatio\"] Real number Specific heat ratio Flow[\"GasConstant\"] Real Gas Constant OutputControl['Out'] [ \"Velocity\" , \"Density\" , \"Pressure\" , \"Mu\" , \"Mu_t\" , \"TKE\" , \"Omega\" , \"kL\" , \"tv\" , \"Wall_distance\" , \"resnorm\" , \"TKE_residue\" , \"Mass_residue\" , \"X_mom_residue\" , \"Y_mom_residue\" , \"Z_mom_residue\" , \"energy_residue\" , \"DuDx\",   \"Dudy\",   \"DuDz\" , \"DvDx\",   \"DvDy\",   \"DvDz\" , \"DwDx\",   \"DWDy\",   \"DwDz\" , \"DTDx\",   \"DTDy\",   \"DTDz\" , \"DtkDx\",  \"DtkDy\",  \"DtkDz\" , \"DtwDx\",  \"DtwDy\",  \"DtwDz\" , \"DtvDx\",  \"DtvDy\",  \"DtvDz\" , \"DtkLDx\", \"DtkLDy\", \"DtkLDz\"] Variables to write in the output file OutputControl['In'] [\"Velocity\" ,\"Density\" ,\"Pressure\" ,\"viscosity\" ,\"TKE\" ,\"Omega\" ,\"kL\" ,\"tv\"] Variables to read in case of restrart ResidualControl['Out'] [\"Mass_abs\", \"Viscous_abs\", \"Mass_abs\", \"Resnorm_abs\", \"Viscous_abs\", \"Turbulent_abs\", \"Continuity_abs\", \"X-mom_abs\", \"Y-mom_abs\", \"Z-mom_abs\", \"Energy_abs\", \"Mass_rel\", \"Resnorm_rel\", \"Viscous_rel\", \"Turublent_rel\", \"Continuity_abs\", \"X-mom_rel\", \"Y-mom_rel\", \"Z-mom_rel\", \"Energy_rel\", \"TKE_abs\", \"Tv_abs\", \"Dissipation_abs\", \"Omega_abs\", \"Kl_abs\", \"TKE_rel\", \"Tv_rel\", \"Dissipation_rel\", \"Omega_rel\", \"Kl_rel\"] Residual to write in the resnorm file BoundaryConditions [-3, -4, -5, -8, -6, -6]  where <-1:'SUPERSONIC INLET', -2:'SUPERSONIC OUTFLOW', -3:'SUBSONIC INFLOW', -4:'SUBSONIC OUTFLOW', -5:'WALL', -6:'SYMMETRY', -7:'Pole', -8:'Far-field', -11:'Total inlet'> Boundary conditions to used for the six face of the domain $python automaton.py Note Make sure to provide the absolute path of the FEST3D binary in the automaton.py script before executing. And also\nthe number of files in the GridDir folder should be equal to the number of blocks as input. Directory structure Executing automation.py will create a directory with usual directory structure: system :all the input files including the mesh files and boundary condition file is located in this directory time_directory : all the output files will be stored in this folder. bin : a soft link between original FEST-3D binary is stored here. run.sh : bash script to run the solver. This helps to remove log clutter on screen and save it in a log file named out in the time_directory/aux/ directory along with resnorm file which store the residual values. Check Layout file Although, automaton.py python script tries to handle the boundary condition by its own; it is still not full-proof. So, always the check the layout.md file in the system/mesh/layout directory. Make sure all the boundary condition number are as you expect. In the case of pole boundary condition, some random number will be mentioned and required to change manually to -007. The layout file in explained in the later section. Execute $mpiexec .hydra -np 16 bin/FEST3D On linux os you can use following command to run FEST-3D in the background: nohup bash run.sh & Check Status The screen output is directed to the text file: [RunDir]/time_directories/aux/out The residual are stored in the text file: [RunDir]/time_directories/aux/resnorm You can output the current status or Current iteration number of the run on screen using tail -f time_directories/aux/out or you can check the residual by using Gnuplot or other similar software: gnuplot gnplt gnplt is the script provided for the Gnuplot software. You can download Gnuplot using: sudo apt-get install gnuplot Use ctl-c to stop the Gnuplot. Post Processing Since FEST-3D output solution file in Tecplot and VTK format, you can use either commerical TECPLOT software or open-source softwares like: Visit , Paraview , Mayavi .","tags":"","loc":"page/02_run/index.html","title":"Run – FEST-3D"},{"text":"Fig.1 Domain of interest divide into 4 sub-domain. To solve a real-life problem, like flow over\nan airfoil, first, a domain of computation has to be defined. This \ndomain represents the system of interest which we\nlike to study. Now to apply a numerical method\nto solve the governing equation (Navier-Stokes) on this domain, it needed\nto be discretized. This process is not part of the FEST-3D\ncode and it assume a predefine discretized domain(grid) will\nbe provided as input. You can use softwares like Pointwise to generate the\ngood quality mesh. The FEST-3D expect structured grid in\n the following format Imax  Jmax  Kmax\nX(1,1,1)   Y(1,1,1)   Z(1,1,1)\nX(2,1,1)   Y(2,1,1)   Z(2,1,1)\nX(3,1,1)   Y(3,1,1)   Z(3,1,1)\n...\nX(Imax,1,1)   Y(Imax,1,1)   Z(Imax,1,1)\nX(1,2,1)   Y(1,2,1)   Z(1,2,1)\nX(2,2,1)   Y(2,2,1)   Z(2,2,1)\n...\n...\nX(Imax,Jmax,1)   Y(Imax,Jmax,1)   Z(Imax,Jmax,1)\nX(1,1,2)   Y(1,1,2)   Z(1,1,2)\nX(2,1,2)   Y(2,1,2)   Z(2,1,2)\nX(3,1,2)   Y(3,1,2)   Z(3,1,2)\n...\n...\n...\nX(Imax,Jmax,kmax)   Y(Imax,Jmax,kmax)   Z(Imax,Jmax,kmax) In the case of multi-block, as shown in Fig. 1, each process requires a separate grid file\nand block should be created such that every face of that\nblock employs only a single boundary condition. For now, two different types of boundary\nconditions at a single face  of a block is not supported by the FEST-3D. Fig.2 Example Mesh. A very simple example of grid file is given below for 2D-smooth bump test case, shown in Fig. 3: Blocks: 2 Number of blocks in I-direction are 2. So, two files will be written: grid_00.txt for first block and grid__01.txt for second block Imax: 3 Jmin: 2 Kmin: 2 Fig.2 Simple coarse grid for 2D smooth bump test case. grid_00.txt 2 2 2\n-1.5000e+00  2.3271e-26  0.0000e+00\n 0.0000e+00  6.2500e-02  0.0000e+00\n-1.5000e+00  8.0000e-01  0.0000e+00\n 0.0000e+00  8.0000e-01  0.0000e+00\n-1.5000e+00  2.3271e-26  1.0000e-01\n 0.0000e+00  6.2500e-02  1.0000e-01\n-1.5000e+00  8.0000e-01  1.0000e-01\n 0.0000e+00  8.0000e-01  1.0000e-01 grid_01.txt 2 2 2\n0.0000e+00  6.2500e-02  0.0000e+00\n1.5000e+00  2.3271e-26  0.0000e+00\n0.0000e+00  8.0000e-01  0.0000e+00\n1.5000e+00  8.0000e-01  0.0000e+00\n0.0000e+00  6.2500e-02  1.0000e-01\n1.5000e+00  2.3271e-26  1.0000e-01\n0.0000e+00  8.0000e-01  1.0000e-01\n1.5000e+00  8.0000e-01  1.0000e-01","tags":"","loc":"page/02_run/02_mesh.html","title":"Mesh – FEST-3D"},{"text":"Fig.1 Example for interface between blocks. When performing a multi-block simulation, some information has to communicate between adjacent\nblocks. For this process, a setup file is provide called layout.md in the system/mesh/layout folder. This file contains information about the adjacent blocks and physical boundary conditions.\nAll the non-negative numbers in this file represent the interface boundary condition, and negative\nnumbers represent the physical boundary conditions. For each block/process a row of information is \nwritten: Block number Grid file name in the system/mesh/gridfile/ directory Boundary condition file name in the system/mesh/bc/ directory Boundary condition at Imin face. Boundary condition at Imax face. Boundary condition at Jmin face. Boundary condition at Jmax face. Boundary condition at Kmin face. Boundary condition at Kmax face. Fig.2 Each block has six faces and hence six boundary conditions to set. So for four blocks the layout file looks like following. ## BLOCK LAYOUT FILE\n ## ==========================\n ## NUMBER OF PROCESSES\n 4\n ## NUMBER OF ENTRIES PER PROCESS\n 9\n ## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n ## ===================================\n ## PROCESS 0\n 00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n ## PROCESS 1\n 01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n ## PROCESS 2\n 02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n ## PROCESS 3\n 03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 Each line starting with # is a comment line and hence will be ignored while reading. \nThe first non-comment line\nstate for how many blocks the layout file is written for and second line state how many entries\nto read for each block. This number is same as the number of entries in the list above. After these two\nlines, every non-comment line represents a block. The positive boundary condition at any face represents \nthe interface boundary condition, and  the exact number represents the block number to which the current block \nis connected through that face. The physical boundary conditions are listed below: Boundary conditions -1: Supersonic Inlet -2: Supersonic Outflow -3: Subsonic Inflow -4: Subsonic Outflow -5: Wall -6: Symmetry or Slip-Wall -7: Pole -8: Far-field -9: Total inlet","tags":"","loc":"page/02_run/04_layout.html","title":"Layout file – FEST-3D"},{"text":"Although the boundary conditions are already defined in the layout.md file, it is not possible to define a particular value to the state variable on a boundary face.\nIn order to defined a fixed value at the boundary face you can use the boundary condition file. Once layout.md file is defined, the boundary condition file can be created using following command in the system/mesh/layout/ directory: $. compile.sh generate_bc.cpp\n$./a.out For each block a separate boundary condition files is written in system/mesh/bc/ . The sample boundary condition is as follows: BOUNDARY CONDITIONS CONFIGURATION \n================================= \n\n# imn\n- INTERFACE\n\n# imx\n- COPY_DENSITY\n- COPY_X_SPEED\n- COPY_Y_SPEED\n- COPY_Z_SPEED\n- FIX_PRESSURE\n\n# jmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- NO_SLIP\n- WALL_TEMPERATURE\n\n# jmx\n- INTERFACE\n\n# kmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\n# kmx\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\nFIN In order to fix the value of a particular variable, depending on the boundary condition type, just input the value in front of Fix_var line. For example, at imx boundary, the back pressure is fixed to 101325 Pa. So the boundary condition file is change to : BOUNDARY CONDITIONS CONFIGURATION \n================================= \n\n# imn\n- INTERFACE\n\n# imx\n- COPY_DENSITY\n- COPY_X_SPEED\n- COPY_Y_SPEED\n- COPY_Z_SPEED\n- FIX_PRESSURE 101325\n\n# jmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- NO_SLIP\n- WALL_TEMPERATURE\n\n# jmx\n- INTERFACE\n\n# kmn\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\n# kmx\n- COPY_DENSITY\n- COPY_PRESSURE\n- FLOW_TANGENCY\n\nFIN Input value only in SI units.","tags":"","loc":"page/02_run/05_bc.html","title":"Boundary condition file – FEST-3D"},{"text":"Since it is not possible to perform unit test with the current status of FEST-3D,\nwe have defined a few integrated test cases. Using this integrated method, \nyou can test the implementation of various flux-schemes, higher-order methods, and turbulence models.\nAny new scheme added to the FEST-3D can also be tested using the same framework.\nA python script, Test.py , provided in the test/ directory to run the integrated test\nwith a particular flux scheme, higher-order method, and turbulence model.\nUse the following command to run all tests in the test/ directory. How to run Test.py script $cd <FEST-3D/root/directory>/test/\n$python Test.py <arg1> <arg2> <arg3> <arg1> : Flux scheme allowed options: ausm ldfss0 ausmUP ausmP slau <arg2> : Higher order method allowed options: muscl ppm weno <arg3> : Turbulence model allowed options: sst sst2003 kkl sa Examples: $python Test.py ausm   muscl sst $python Test.py slau   weno  sa $python Test.py ausmUP ppm   kkl You will see following output on the screen: ----- Integrated Tests Started -----  \nTotal two processes will be used with MPICH library\nRunning Test number 1  --->  Subsonic flow over a smooth bump\nRunning Test number 2  --->  Laminar flow over a flat plate\nRunning Test number 3  --->  Turbulent flow over a flat plate\n ----- All tests completed -----\n\nTests passed:  3 out of 3\nCheck test summary in 'Report.txt' file. The integrated tests use two processes with MPICH library. Three different test cases are defined: Inviscid test case: Subsonic flow over a 2D smooth bump . Laminar test csae: Laminar flow over a flat plate . Turbulent test case: Fully turbulent flow over a flat plate . S.No. Test case Expected value Tolereance % 1 Inviscid Change in entropy = 0.0 0.1% 2. Laminar Cofficient of drag = 0.00133 1% 3. Turbulent Cofficient of drag = 0.00290 2% The change in entropy is calculated using following expression: For more details about domain, boundary conditions and flow conditions of these test cases, check the Tutorial section. The solver setup (domain, grid, flow and boundary conditions) is same as listed in the separate tutorials. Once the tests are complete, you can check the test summary in Report.txt file. Ran Test number 1  --->  Subsonic flow over a smooth bump\n __________Report__________  \n ---------- Inviscid Test case: Smooth Bump ---------- \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : none\n Expected Change in entropy           : 0.000E+00\n Calculated relative change in entropy: 1.046E-06\n Difference                           : 1.046E-04 %\n Allowed Tolerance                    : 0.1 %\n------------ >>> Test Passed  <<< --------------\n\n\nRan Test number 2  --->  Laminar flow over a flat plate\n  __________Report__________   \n ------ Laminar Test case: Flat plate ------ \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : none\n Expected drag coeffcient    : 1.330E-03\n Calculated drag coefficient : 1.329E-03\n Difference                  : 4.638E-02 %\n Allowed Tolerance           : 1 %\n------------ >>> Test Passed  <<< --------------\n\n\nRan Test number 3  --->  Turbulent flow over a flat plate\n  __________Report__________   \n ------ Turbulent Test case: Flat plate ------ \n Flux Scheme        : ausm\n Higher order method: muscl\n Turbulence model   : sst\n Expected drag coeffcient    : 2.900E-03\n Calculated drag coefficient : 2.873E-03\n Difference                  : 9.312E-01 %\n Allowed Tolerance           : 2 %\n------------ >>> Test Passed  <<< --------------","tags":"","loc":"page/./03_test.html","title":"Test – FEST-3D"},{"text":"Steps to run FEST-3D Once you have downloaded and installed the FEST-3D code, you are ready to use the FEST-3D solver. A step by step guide for the LiD-Driven cavity is given on this page. Run folder First, change the current directory to run/ directory. Now check if run/ directory is empty or it already has files in it. Use: $ls If run/ folder is empty, that means the submodule run has not been download. You should use the following command to get all the files: $git submodule update --init The $ls command in run/ directory should show the following file/folder name as output: automaton.py  README.md  Tutorials/ Sample automaton.py script The automaton.py in the run directory is a sample script file. This script file is not supposed to be executed as the inputs are randomly provided as an explanation for the variables. Users are supposed to copy this script and modify as according to need. In the Tutorial/ subfolder, different automation.py file is provided with specific inputs. README.md This markdown file contains information about: Software dependencies of run module Information about all the input variables in automaton.py Directory structure created for each test case. How to start the simulation once setup for the test case is done. Tutorial Few test cases are provided in Tutorials/ folder for learning and verification purpose. Generate Grid before executing automaton.py script For all the tutorial, a grid file is provided in CreateBlocks/ subfolder. You can generate the grid by just changing directory to CreateBlocks/ subfolder, and type following make command: $make It will create a grids/ subfolder in CreateBlocks . In the grid/ multiple grid files are written, one for each processor. For each tutorial, an input is provided for the number of processors to be used for the simulation. Except for 2D bump test case, the number of blocks in i,j,k direction can be changed in blocking_point.f90 file at: integer, parameter :: xblocks = 4\n  integer, parameter :: yblocks = 1\n  integer, parameter :: zblocks = 1 It should be noted that the grid generation process is not part of the FEST-3D solver and has to be handled separately. You can write your code for grid-generation of simple geometries. An example for such code is bump.py python script for 2D smooth bump grid generation. You can also use software like pointwise for complicated geometries. Modify and execute automaton.py automaton.py script is provided in each tutorial folder. Although most of the input in the automaton.py has been set according to the test case, you still need to change the first few lines of this file: RunDir = 'GiveAnyName'\nGridDir= 'PathToAllGridFiles'\nNumberOfBlocks = 4 #Make sure it is same as the number of grid-files\nAbsBinaryPath=\"/home/jatinder/solver/FEST-3D/bin/FEST3D\" If you are not able to run or set up the test case, then the above lines in the automaton.py may be the culprit. You can give any name for RunDir . A new folder will be created with the name you supply here. You can give a different name for a different version for the input you give in automaton.py . For GridDir variable provide folder name in which all the grid files are present. For all the tutorials, grid files created are situated at \" CreateBlocks/grids \". For NumberOfBlocks provide the number of processors you want to use for the simulation. Make sure the NumberOfBlocks and number of grid files in GridDir are the same. This will be asserted in the latter part of the script. If this is not the case following error will be thrown: ERROR: Traceback (most recent call last):\n  File \"automaton.py\", line 340, in <module>\n    CheckInput(ExpectedControl, ExpectedScheme, ExpectedFlow, ExpectedOutputControl, ExpectedResidualControl, Control, Scheme, Flow, OutputControl, ResidualControl)\n  File \"automaton.py\", line 183, in CheckInput\n    assert len(next(os.walk(GridDir))[2]) == NumberOfBlocks\nStopIteration Same error will be shown if the folder name provided for GridDir is invalid. For running the code, we create a soft link for the executable situated in the bin folder. So, to create a soft link, you should provide an AbsolutePath to the location fo executable to AbsBinaryPath . If the path provided is invalid, the soft link created will fail. Steps to run Lid-Driven Cavity tutorial Fig.1 Domain and boundary condition for Lid-driven cavity test case. Make sure the run directory has the Turtorial folder. Change directory to the FEST-3D/run/Tutorials/LidDrivenCavity/ . This folder contains automaton.py file and CreateBlocks/ subfolder Change directory to CreateBlocks/ subfolder and open blocking_point.f90. Change number of I-direction blocks and J-direction blocks to what you desire. Do not change the \nK-direction blocks as there is only one cell in the third direction. integer, parameter :: xblocks = 2\n  !< Number of block in I-directions\n  integer, parameter :: yblocks = 2\n  !< Number of block in J-directions\n  integer, parameter :: zblocks = 1\n  !< Number of block in Z-directions A makefile is provided to automate the grid generation and blocking process. Use the following command to generate the grid/ folder which contains all the grid files. $make An important point to note here is that the grid generation requires numpy version 1.10 or above for Python2.7 Once the grids are generated, go one-directory up to run/Tutorials/LidDrivenCavity/ . Open automaton.py and change first four variables: RunDir = 'LDC-Test1'\nGridDir= 'CreateBlocks/grid'\nNumberOfBlocks = 4 #Make sure it is same as the number of grid-files\nAbsBinaryPath=\"/home/<user>/solver/FEST-3D/bin/FEST3D\" #Make sure to provide the absoute path to FEST-3D binary If you provide incorrect path to the FEST-3D binary on you local computer, you will get following error while trying to run simulation: ERROR : HYDU_create_process ( utils /launch/launch.c:74): execvp error on file bin/ FEST3D ( No such file or directory ) Run the python script python automaton.py If you have provided a wrong path to grid files or incorrect number of blocks to use, you will get the following error: ERROR : Traceback ( most recent call last ): File \"automaton.py\" , line 340 , in < module > CheckInput ( ExpectedControl , ExpectedScheme , ExpectedFlow , ExpectedOutputControl , ExpectedResidualControl , Control , Scheme , Flow , OutputControl , ResidualControl ) File \"automaton.py\" , line 183 , in CheckInput assert len ( next ( os . walk ( GridDir ))[ 2 ]) == NumberOfBlocks StopIteration If not error occured, a new folder: LDC-Test1 will be generated. Change to newly created folder LDC-Test1 . You will find the following directory structure:\n        bin/  fill_vtk_name.sh  gnplt  pp/  pre/  run.sh  system/  time_directories/ bin/ soft link to FEST-3D binary resides in this folder. gnplt is GNUPLOT script to live plot the residual while a simulation is running in the background. pp/ and pre/ are the directories to keep you pre-processing and post-processing code. Currently, they should be empty. run.sh is the bash script which will be executed. It contains the instruction to pipe all the screen output to the time_directories/aux/out file. system/ contains the information about the grid, boundary condition, layout of blocks, and input and output configuration of current simulation. control.md contains information about all the control parameters like CFL, Maximum number of iteration, output file format, etc. fvscheme.md contains information about the numerical schemes to use for the current simulation. flow.md contains information about the flow: reference velocity, density, pressure, viscosity, etc. output_control.md contains the name of the variable to read or write to the solution file in the time_directories. res_control.md contains the name of the residual which you want to track. mesh/ Contains information about the grid and its layout. Fig.2 Domain and mesh decomposition in to 4 blocks. Gridfiles/ Contains all the grid file used for the simulation layout/ contains the information about the layout of the grid file and some script to most of the information about \n      the layout automatically from the grid file in the Gridfiles/ folder. Fig.3 Boundary faces of each block indicated with 'Imin', 'Imax', 'Jmin', and 'Jmax' labels. layout.md file contains layout information. For more information about layout file check this page .\n    The layout.md file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 here the boundary condition numbers are as follow: * -1: Supersonic Inlet\n  * -2: Supersonic Outflow\n  * -3: Subsonic Inflow\n  * -4: Subsonic Outflow\n  * -5: Wall\n  * -6: Symmetry or Slip-Wall\n  * -7: Pole\n  * -8: Far-field\n  * -9: Total inlet bc/ folder contains a separate boundary condition file for each block. In layout.md file you can fix the type of boundary but in bc_xx.md file you can give a particular value to the variable you want to fix. For Lid-Driven cavity test case, we need to fix velocity of the top lid. This can be done easily by opening the file of the block, which contains the lid, and set value of velocity to the boundary face, which represents the lid. Change # jmx\n    - FIX_DENSITY\n    - FIX_X_SPEED\n    - FIX_Y_SPEED\n    - FIX_Z_SPEED\n    - COPY_PRESSURE to # jmx\n    - FIX_DENSITY\n    - FIX_X_SPEED 100.0\n    - FIX_Y_SPEED 0.0\n    - FIX_Z_SPEED 0.0\n    - COPY_PRESSURE Fig.4. For lid-driven cavity a velocity vectory of (100,0,0) will be fixed at top boundary. time_direcories/ contains a folder for each save point. aux/ contains the auxiliary files like out output of all the print command in the solver resnorm residual which you can plot using gnplt script surfacenode.dat : In case of turbulence model being used, this file is written to calculate wall-distance. Finally, to run the simulation, use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal.\n if you get following error: ERROR : HYDU_create_process ( utils /launch/launch.c:74): execvp error on file bin/ FEST3D ( No such file or directory ) correct the AbsBinaryPath in the automaton.py and repeat step 7.\n If you do not get any error, but still simulation terminates as soon it begins, run following command: $mpiexec.hydra -np 4 bin/FEST3D it will provide output on the screen and help you debug. You can use GNUPLOT to plot the residual using $gnuplot gnplt Results Post-processing is not part of the FEST-3D solver. FEST-3D provides two output file formats: vtk and Tecplot, which you can specify in the automaton.py file. You can use software like visit , paraview , Tecplot to visualize the obtained solution data from FEST-3D. Fig.5 Contour of y-component of velocity vector.","tags":"","loc":"page/./04_Steps_to_run_FEST3D.html","title":"How to run FEST-3D solver? – FEST-3D"},{"text":"Fig.1 Pressure contour simlulated with FEST-3D for transonic flow over RAE2822 airfoil. Getting Started In order to understand better that how to use different options in FEST-3D,\nsome verification test cases are provided as tutorials. Summary of Testcases Supersonic inviscid flow over a ramp (2D) Subsonic inviscid flow over a smooth bump (2D) Lid-driven cavity (2D) Laminar flow over a plate (2D) Turbulent flow over a plate  (2D) Turbulent flow over a transonic airfoil RAE-2822 (2D) Transition flow over a flat plate (2D)","tags":"","loc":"page/05_tutorials/index.html","title":"Tutorials – FEST-3D"},{"text":"Supersonic inviscid flow of Mach 2.0 past a 15-degree ramp Fig.1 Mach contours simlulated with FEST-3D for supersonic flow over a 15-degree ramp. Problem Statement In this test case, a supersonic inviscid flow of Mach 2.0 past a 15-degree ramp will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from NPARC\nAlliance Validation Archive . Fig.2 Domain and boundary conditions for supersonic flow over a 15-degree ramp. Mesh A structured grid of size 153 × 91 × 2 will be used, as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/Ramp/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, only one block will\nbe used. integer, parameter :: xblocks = 1 integer, parameter :: yblocks = 1 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/Ramp/CreateBlocks/ directory. Fig.3 The Mesh for supersonic flow over a 15-degree ramp. Setup In order to setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. You can give any\nname for this directory. This new directory will contains all the required files. All following command expect python automaton.py will be executed in this directory. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 1 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 4000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 5 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '1 1 1  0 0 0' Switch on the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='l' Local time-stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.225 Free-stream density. Flow[\"UInf\"] = 680.588 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 0.0 Set reference viscosity to zero for inviscid flow. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-1, -2, -6, -6, -6, -6] Broad boundary condition.[supersonic inlet, supersonic outlet, rest are Slip-walls]. Rest of the variables should be left to thier default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n1\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -001  -002  -006  -006  -006  -006 The last line, in sequence, indicates the following: Block_Number    GridFile   Boundary_condition_file   Imin_boundary_condition_number    Imax_boundary_condition_number Jmin_boundary_condition_number Jmax_boundary_condition_number Kmin_boundary_condition_number  Kmax_boundary_condition_number Finally, to run the simulation use following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.5 Surface pressure comparasion with theory. Documentation Download Installation Run Mesh Layout file Boundary condition file Test How to run FEST-3D solver? Tutorials Supersonic flow over Wedge 2D Smooth Bump Lid-Driven Cavity Flat plate (laminar) Flat plate (Turbulent) RAE2822 airfoil Flat plate (Transition)","tags":"","loc":"page/05_tutorials/01_ramp.html","title":"Supersonic flow over Wedge – FEST-3D"},{"text":"Subsonic inviscid flow of Mach 0.5 past a smooth 2D-bump Fig.1 Pressure contour over smoooth bump. Problem Statement In this test case, a subsonic inviscid flow of Mach 0.5 past a smooth 2D-bump will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from 4th International Workshop on High-Order CFD Methods . Fig.2 Domain and boundary conditions for subsonic flow over 2D smooth bump. Mesh A structured grid of size 97 x 49 × 2 will be used, as shown in Fig. 3. \nThe grid is available in the tutorial folder |rootFolder|/run/Tutorial/2DBump/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the bump.py edit the number of blocks in the I-direction . In this test case, only two blocks will\nbe used. imax = 97 Maximum number of grid points in the I-direction jmax = 49 Maximum number of grid points in the J-direction kmax = 2 Maximum number of grid points in the K-direction blocks = 2 Number of blocks in the I-direction In order to execute the bump.py script with python, all commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/2DBump/CreateBlocks/ directory. Fig.3 The Mesh for subsonic flow over 2D smooth bump. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 2 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 5 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch on the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='l' Local time-stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.225 Free-stream density. Flow[\"UInf\"] = 170.14 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 0.0 Set reference viscosity to zero for inviscid flow. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -6, -6, -6, -6] Broad boundary condition.[Riemann-inlet, subsonic outlet, rest are Slip-walls]. Free-stream pressure is used to fix the pressure outlet value. Rest of the variables should be left to their default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n2\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -004  -006  -006  -006  -006 The last two uncommented line, in sequence, indicates following: Block_Number    GridFile   Boundary_condition_file   Imin_boundary_condition_number    Imax_boundary_condition_number Jmin_boundary_condition_number Jmax_boundary_condition_number Kmin_boundary_condition_number  Kmax_boundary_condition_number Since there are two blocks, there are two rows of entries, one for each block. All the lines with # as the first character are skipped while reading by the FEST-3D solver.\nAll the positive numbers define the interface boundary condition, and negative numbers define the physical boundary conditions.\nFinally, to run the simulation use following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Pressure contour for different higher order methods. Documentation Download Installation Run Mesh Layout file Boundary condition file Test How to run FEST-3D solver? Tutorials Supersonic flow over Wedge 2D Smooth Bump Lid-Driven Cavity Flat plate (laminar) Flat plate (Turbulent) RAE2822 airfoil Flat plate (Transition)","tags":"","loc":"page/05_tutorials/02_2dbump.html","title":"2D Smooth Bump – FEST-3D"},{"text":"Lid-driven cavity Fig.1 Contour of x-component of velocity vector. Problem Statement In this test case, we calculate the flow inside the cavity formed simulated due to the tangential velocity of the upper plate\n. The domain used, and boundary condition applied to the domain are illustrated in Fig. 2. \nThe case definition and grid used were obtained from NPARC Alliance Validation Archive . Fig.2 Domain and boundary conditions for lid-driven cavity. Mesh A uniform structured grid of size 129 x 129 × 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/LidDrivenCavity/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 2 integer, parameter :: yblocks = 2 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/LidDrivenCavity/CreateBlocks/ directory. Note Make sure you are using numpy version greater than 1.10 for python script to generate grid. Fig.3 The Mesh for lid-driven cavity test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'GiveAnyName' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 4 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 10.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'ppm' Higher-order  face-state reconstruction method. you can use: none , muscl , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TimeStep']='g 1e-5' Global time-stepping method and time-step. You can use local time-stepping method also l . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Note The domain is initialized with zero velocity vector and Lid velocity is defined\nlater in the boundary condition file. As the residual are normalized with \nfree-stream velocity, residual written in resnom file will be Nan. But solution\nis correct. Flow[\"UInf\"] = 0.0 Free-stream x-component of velcotiy vector. Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.2e-1 Reference viscosity is set to 0.12 so that the Reynolds number based on the lid-velocity (100m/s) is 1000 OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-5, -5, -5, -3, -6, -6] Broad boundary condition.[Noslip adiabatic side and lower wall, and upper wall with slip velocity of 100 m/s ]. The velocity at the upper wall is set manually, later, in the bc_02.md and bc_03.md boundary condition file. Rest of the variables should be left to their default value. In order to execute this script use following command: $python automaton.py Now you will see a new folder created with RunDir name. Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -005  0001  -005  0002  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  -005  -005  0003  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  -005  0003  0000  -003  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -005  0001  -003  -006  -006 If all the boundary conditions are defined in the layout.md file then fix the upper wall velocity in the \nbc_02.md and bc_03.md file in system/mesh/bc/ folder. Change the bc_02.md file from # jmx\n- FIX_DENSITY\n- FIX_X_SPEED\n- FIX_Y_SPEED\n- FIX_Z_SPEED\n- COPY_PRESSURE to # jmx\n- FIX_DENSITY\n- FIX_X_SPEED 100.0\n- FIX_Y_SPEED 0.0\n- FIX_Z_SPEED 0.0\n- COPY_PRESSURE and same for bc_03.md file. Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Contour of y-component of velocity vector. Fig.5 Comparision of x-component of velocity with experiment. Fig.6 Comparision of y-comoponent of velocity with experiment.","tags":"","loc":"page/05_tutorials/03_LDC.html","title":"Lid-Driven Cavity – FEST-3D"},{"text":"Subsonic laminar flow of Mach 0.5, Reynolds number 1 million over a flat plate Fig.1 Contour of v-component of velocity vector. Problem Statement In this test case, a subsonic laminar flow of Mach 0.5 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from 3rd International Workshop on High-Order CFD Methods . Fig.2 Domain and boundary conditions for laminar flow over flat plate test case. Mesh A structured grid of size 113 × 81 x 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/LaminarFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 In order to compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/LaminarFlatPlate/CreateBlocks/ directory. Fig.3 The Mesh for laminar flow over flat plate test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'FlatPlate_Lam' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 4 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'slau' Inviscid flux-reconstruction shceme. You can use: ausm , ldfss0 , ausmP , and ausmUP instead of __slau . Scheme['FaceState'] = 'ppm' Higher-order  face-state reconstruction method. you can use: none , muscl , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceModel']='none' since no turbulence is required, none is mentioned here. Scheme['TransitionModel']='none' Similar to turbulence model option, none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 173.59 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 2.083e-4 Reference viscosity is set to 0.0002083 kg/ms so that the Reynolds number (L_ref=1m) is 1 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -5, -6, -6, -6] Broad boundary condition.[Riemann inlet, subsonic outlet, no-slip wall and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 2, and the blocking provided here is such that first two of the four blocks\nhave inviscid region as a boundary condition at the bottom faces and other two have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face (Jmin) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. In order to execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Lam ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for first two blocks from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -006  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.4 Coefficient of friction along the surface of the plate.","tags":"","loc":"page/05_tutorials/04_LamFp.html","title":"Flat plate (laminar) – FEST-3D"},{"text":"Subsonic turbulent flow of Mach 0.2, Reynolds number 5 million over a flat plate Fig.1 Domain of computation for turbulent flow over flat plate test case. Problem Statement In this test case, a subsonic turbulent flow of Mach 0.2 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 1. The case definition and grid used were obtained from Turbulence Modeling Resource . Mesh A structured grid of size 113 × 81 x 2 will be used as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ directory. Fig.3 The Mesh for turbulent flow over flat plate test case. Setup To set up the case directory, a python automation script is provided: automaton.py . First, set up the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'FlatPlate_Turb' Name of the run directory to create for the current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains the grid files. NumberOfBlocks = 4 Total number of blocks. It should match with the number of grid files available in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausm' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausmUP instead of __ausm . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst' using SST turbulence model. Other models kkl , sa , and sst2003 can be user also. Scheme['TransitionModel']='none' none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.17659 Free-stream density. Flow[\"UInf\"] = 69.445 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 101325.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.63416586e-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 5 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-8, -4, -5, -6, -6, -6] Broad boundary condition.[Riemann inlet, subsonic outlet, no-slip wall and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 1, and the blocking provided here is such that first out the four blocks\nhave inviscid region as a boundary condition at the bottom face and other three have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face ( Jmin ) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Turb ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for the first block from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -008  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.3 Coefficient of friction along the surface of the plate for SST turbulence model. Fig.4 Coefficient of friction along the surface of the plate for k-kL turbulence model.","tags":"","loc":"page/05_tutorials/05_TurbFp.html","title":"Flat plate (Turbulent) – FEST-3D"},{"text":"Transonic turbulent flow of Mach 0.72, Reynolds number 6.5 million, and angle of attack 2.92 deg over the RAE2822 Fig.1 Contour of pressure for subsonic flow over RAE2822 airfoil. Problem Statement In this test case, a transonic turbulent flow of Mach 0.72 over the RAE2822 will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 2. The case definition and grid used were obtained from NPARC Alliance Validation Archive . Fig.2 Domain and boundary condition for RAE2822 airfoil test case. Mesh A structured C-grid of size 369 × 65 x 2 (with 305 grid points on the airfoil)\n will be used, as shown in Fig. 3. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/RAE2822/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 6 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate the grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/RAE2822/CreateBlocks/ directory. Fig.3 The Mesh for turbulent flow over flat plate test case. Setup To setup the case directory, a python automation script is provided: automaton.py . First, setup the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'RAE2822' Name of the run directory to create for current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains grid file. NumberOfBlocks = 6 Total number of blocks. It should match with number of gridfiles avaiable in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 100.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 10000 Maximum number of iteration to perform. Control['SaveIterations'] = 1000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'vtk' Type of solution file to write. If you have tecplot file viewer you can user tecplot instead of vtk Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausm' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausmUP instead of __ausm . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '1 1 1  0 0 0' Switch on the limiter for I,J,and K direction and switch off pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst' using SST turbulence model. Other models kkl , sa , and sst2003 can be user also. Scheme['TransitionModel']='none' none is metioned for no transition model. Scheme['TimeStep']='l' Local time stepping method. You can use global time-stepping method also g . Scheme['TimeIntegration']='implicit' LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 252.9 Free-stream x-component of velcotiy vector. (Mach = 0.5 at T_ref=300K) Flow[\"VInf\"] = 10.2 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103338.0 Free-stream pressure. Flow[\"TurbulenceIntensity\"] = 1.0 Free-stream turbulence intensity. Flow[\"ViscosityRatio\"] = 10.0 Free-stream viscosity ratio. Flow[\"Intermittency\"] = 1.0 Free-stream intermittency. Flow[\"ReferenceViscosity\"] = 1.4243-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 5 million Flow[\"ViscosityLaw\"] = \"sutherland_law\"``` Viscosity variation law. OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"Mu\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-4, -4, -5, -8, -6, -6] Broad boundary condition.[subsonic outlet, no-slip wall, far-field, and slip wall for rest ]. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now, you will see a new folder created with RunDir name ( RAE2822 ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n6\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -004  0001  0005  -008  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -008  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -008  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  0004  -005  -008  -006  -006\n## PROCESS 4\n04  grid_04.txt  bc_04.md  0003  0005  -005  -008  -006  -006\n## PROCESS 5\n05  grid_05.txt  bc_05.md  0004  -004  0000  -008  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal.","tags":"","loc":"page/05_tutorials/06_rae2822.html","title":"RAE2822 airfoil – FEST-3D"},{"text":"Subsonic transition flow of Mach 0.015, Reynolds number 0.36 million over a flat plate Fig.1 Domain of computation for transition flow over flat plate test case. Problem Statement In this test case, a subsonic transition flow of Mach 0.015 over a flat plate will be simulated. The domain used, and boundary\ncondition applied to the domain are illustrated in Fig. 1. The case definition and grid used were obtained from Turbulence Modeling Resource . Mesh A structured grid of size 285 × 161 x 2 will be used as shown in Fig. 2. The grid is available in the \ntutorial folder |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ . Note If run folder is empty, please download the content from Github direcotry or download the zip file here . In the blocking_point.f90 edit the number of blocks in the I-direction and J-direction. In this test case, four blocks will\nbe used. integer, parameter :: xblocks = 4 integer, parameter :: yblocks = 1 To compile the blocking_point.f90 code with gfortran and execute it, commands are written \nin the makefile. Just use the following command to generate grid files in the grid/ folder. $make Run the previous command in the |rootFolder|/run/Tutorial/TurbulentFlatPlate/CreateBlocks/ directory. Fig.2 The Mesh for turbulent flow over flat plate test case. Setup To set up the case directory, a python automation script is provided: automaton.py . First, set up the most important\nparameters, the paths to the grid files and main executable binary to FEST-3D RunDir = 'T3A' Name of the run directory to create for the current case. GridDir= 'CreateBlocks/grid/' Path to the folder which only contains the grid files. NumberOfBlocks = 4 Total number of blocks. It should match with the number of grid files available in the GridDir folder AbsBinaryPath=\"/home/usr/FEST3D/bin/FEST3D\" Absolute path to the FEST-3D binary. Should be in |rootfolder|/bin/FEST3D Now provide the common control parameters. Control['CFL'] = 30.0 High CFL since implicit time-integration method will be used. Control['LoadLevel'] = 0 Since simulation will be started from scratch, 0 is specified. Control['MaxIterations'] = 400000 Maximum number of iteration to perform. Control['SaveIterations'] = 10000 Solution folder will be written every 1000 iteration. Control['OutputFileFormat'] = 'tecplot' Type of solution file to write. If you have vtk file viewer you can user vtk instead of tecplot Control['Purge'] = 1 Only one latest solution folder will be kept in the time_directories and rest will be deleted. Control['ResidualWriteInterval'] = 20 Write residual in time_directories/aux/resnorm after every 5 iteration. Control['Tolerance'] = \"1e-13 Continuity_abs\" Stop the iteration if the absolute residual value of continuity equation is less than 1e-13. Few scheme parameters for inviscid flow: Scheme['InviscidFlux'] = 'ausmUP' Inviscid flux-reconstruction shceme. You can use: slau , ldfss0 , ausmP , and ausm instead of ausmUP . Scheme['FaceState'] = 'muscl' Higher-order  face-state reconstruction method. you can use: none , ppm , and weno . Scheme['Limiter'] = '0 0 0  0 0 0' Switch off the limiter for I,J,and K direction and switch of pressure based switching for all direction. Scheme['TurbulenceLimiter'] = '1 1 1' Using limiter only for turbulent variables face-state reconstruction improve convergence. Scheme['TurbulenceModel']='sst2003' using SST2003 turbulence model. Other models kkl , sa , and sst can be user also. Scheme['TransitionModel']='lctm2015' $\\gamma$ one-equation transition model is metioned as transition model. Scheme['TimeStep']='g' Global time stepping method. You can use local time-stepping method also l . Scheme['TimeIntegration']='plusgs' Preconditioned LU-SGS matrix-free time integration method. Now, lets define the flow feature of test case: Flow[\"DensityInf\"] = 1.2 Free-stream density. Flow[\"UInf\"] = 5.18 Free-stream x-component of velcotiy vector. (Mach = 0.015 at T_ref=300K) Flow[\"VInf\"] = 0.0 Free-stream y-component of velcotiy vector. Flow[\"WInf\"] = 0.0 Free-stream z-component of velcotiy vector. Flow[\"PressureInf\"] = 103320.0 Free-stream pressure. Flow[\"ReferenceViscosity\"] = 1.8e-5 Reference viscosity is set such that the Reynolds number (L_ref=1m) is 0.36 million OutputControl['Out'] = [\"Velocity\", \"Density\", \"Pressure\", \"TKE\", \"Omega\", \"Mu\", \"Mu_t\"] Variables to write in the output file. ResidualControl['Out'] = [\"Mass_abs\", \"Viscous_abs\", \"Continuity_abs\", \"TKE_abs\", \"Omega_abs\"] Residual to write in the resnorm file. BoundaryConditions = [-3, -4, -5, -8, -6, -6] Broad boundary condition.[Subsonic inlet, subsonic outlet, no-slip wall, far-field, and slip wall for rest ]. Since the bottom faces\nof the full domain have two different boundary conditions, as shown in Fig. 1, and the blocking provided here is such that first out the four blocks\nhave inviscid region as a boundary condition at the bottom face and other three have the no-slip adiabatic wall as a boundary condition at\nthe bottom faces. The boundary condition at the bottom face ( Jmin ) will be changed manually in the layout.md file after the automatic \ncase setup. Rest of the variables should be left to their default value. To execute this script, use the following command: $python automaton.py Now you will see a new folder created with RunDir name ( FlatPlate_Turb ). Switch to that directory to run the test case. To make sure setup is correct, check\nthe layout.md file located in system/mesh/layout/layout.md . The file should look like the following: ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -003  0001  -005  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Change the Jmin boundary condition for the first block from no-slip wall (-5) to slip wall (-6). ## BLOCK LAYOUT FILE\n## ==========================\n## NUMBER OF PROCESSES\n4\n## NUMBER OF ENTRIES PER PROCESS\n9\n## PROCESS_NO GRID BC_FILE IMIN IMAX JMIN JMAX KMIN KMAX\n## ===================================\n## PROCESS 0\n00  grid_00.txt  bc_00.md  -003  0001  -006  -006  -006  -006\n## PROCESS 1\n01  grid_01.txt  bc_01.md  0000  0002  -005  -006  -006  -006\n## PROCESS 2\n02  grid_02.txt  bc_02.md  0001  0003  -005  -006  -006  -006\n## PROCESS 3\n03  grid_03.txt  bc_03.md  0002  -004  -005  -006  -006  -006 Finally, to run the simulation use the following command: $nohup bash run.sh & nohup helps in avoiding any output on the screen, & execute the last command in the background, allowing you to keep using the terminal. Results Fig.3 Coefficient of friction along the surface of the plate for SST turbulence model. Fig.4 Coefficient of friction along the surface of the plate for k-kL turbulence model.","tags":"","loc":"page/05_tutorials/07_TransFp.html","title":"Flat plate (Transition) – FEST-3D"}]}